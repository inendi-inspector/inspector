//! \file PVUtils.cpp
//! $Id: PVUtils.cpp 2872 2011-05-19 03:30:31Z stricaud $
//! Copyright (C) SÃ©bastien Tricaud 2009-2011
//! Copyright (C) Philippe Saade 2009-2011
//! Copyright (C) Picviz Labs 2011

#include <iostream>
#include <string>
#include <sstream>
#include <cstdlib>
#include <cstdio>

#include <QtCore>
#include <QDir>
#include <QString>

#define GLEW_STATIC 1
#include <GL/glew.h>
#ifndef WIN32
#ifndef MACOS
#include <GL/glx.h>
#endif
#endif
#include <GL/gl.h>

#include <pvgl/PVUtils.h>

/******************************************************************************
 *
 * pvgl_get_share_path
 *
 *****************************************************************************/
std::string pvgl_get_share_path()
{
	const char *pluginsdir;

	pluginsdir = getenv("PVGL_SHARE_DIR");
	if (!pluginsdir) {
		pluginsdir = PVGL_SHARE_DIR; /* Variable generated by CMAKE */
	}

	return pluginsdir;
}

/******************************************************************************
 *
 * pvgl_share_path_exists
 *
 *****************************************************************************/
bool pvgl_share_path_exists()
{
	std::string share_path = pvgl_get_share_path();

	QDir share_dir(QString(share_path.c_str()));

	return share_dir.exists();
}

/******************************************************************************
 *
 * pvgl_get_next_utf8
 *
 *****************************************************************************/
int pvgl_get_next_utf8(const char *&text)
{
	unsigned char byte[4];

	byte[0] = *text++;

	if (byte[0] < 0x80) {
		return byte[0];
	}
	if ((byte[0] & 0xe0) == 0xc0) {
		byte[1] = *text++;
		return ((byte[0] & 0x1f) << 6) | (byte[1] & 0x3f);
	}
	if ((byte[0] & 0xf0) == 0xe0) {
		byte[1] = *text++;
		byte[2] = *text++;
		return ((byte[0] & 0xf) << 12) | ((byte[1] & 0x3f) << 6) | (byte[2] & 0x3f);
	}
	byte[1] = *text++;
	byte[2] = *text++;
	byte[3] = *text++;
	return ((byte[0] & 0xf) << 18) | ((byte[1] & 0x3f) << 12) | ((byte[2] & 0x3f) << 6) | (byte[3] & 0x3f);
}

/******************************************************************************
 *
 * print_opengl_error
 *
 *****************************************************************************/
bool print_opengl_error(const char *file, int line)
{
	/* Returns true if an OpenGL error occurred, false otherwise. */
	GLenum error;
	bool   ret_code = false;

	error = glGetError();
	while (error != GL_NO_ERROR)
		{
			const GLubyte* error_str = gluErrorString (error);
			if (error_str) {
				std::cerr << "glError in file " << file << ", line " << line << ": " <<
					         error_str  << std::endl;
			}
			ret_code = true;
			error = glGetError();
		}
	return ret_code;
}

/******************************************************************************
 *
 * check_framebuffer_status
 *
 *****************************************************************************/
void check_framebuffer_status(void)
{
	GLenum status;
	status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
	PRINT_OPENGL_ERROR ();
	switch(status) {
		case GL_FRAMEBUFFER_COMPLETE:
			PVLOG_DEBUG("Framebuffer complete!\n");
				break;
		case GL_FRAMEBUFFER_UNSUPPORTED:
			PVLOG_WARNING("Framebuffer GL_FRAMEBUFFER_UNSUPPORTED_EXT.\n");
				break;
		case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
			PVLOG_WARNING("Framebuffer INCOMPLETE_ATTACHMENT.\n");
				break;
		case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
			PVLOG_WARNING("Framebuffer FRAMEBUFFER_MISSING_ATTACHMENT.\n");
				break;
		case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT:
			PVLOG_WARNING("Framebuffer FRAMEBUFFER_DIMENSIONS.\n");
				break;
		case GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT:
			PVLOG_WARNING("Framebuffer INCOMPLETE_FORMATS.\n");
				break;
		case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:
			PVLOG_WARNING("Framebuffer INCOMPLETE_DRAW_BUFFER.\n");
				break;
		case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER:
			PVLOG_WARNING("Framebuffer INCOMPLETE_READ_BUFFER.\n");
				break;
		case GL_FRAMEBUFFER_BINDING:
			PVLOG_WARNING("Framebuffer BINDING_EXT.\n");
				break;
		default:
				/* programming error; will fail on all hardware */
				;
	}
}

/******************************************************************************
 *
 * get_gl_version
 *
 *****************************************************************************/
void get_gl_version(int *major, int *minor)
{
	const GLubyte *version = glGetString(GL_VERSION); PRINT_OPENGL_ERROR();

	if (!version || (sscanf (reinterpret_cast<const char*>(version), "%d.%d", major, minor) != 2))
		{
			*major = *minor = 0;
			PVLOG_ERROR("Invalid GL_VERSION format!!!\n");
		}
}

/******************************************************************************
 *
 * print_shader_info_log
 *
 *****************************************************************************/
void print_shader_info_log(GLuint shader)
{
	int     info_log_length = 0;
	int     chars_written  = 0;
	GLchar *info_log;

	glGetShaderiv (shader, GL_INFO_LOG_LENGTH, &info_log_length); PRINT_OPENGL_ERROR ();

	if (info_log_length > 1)
		{
			info_log = new GLchar[info_log_length];
			glGetShaderInfoLog (shader, info_log_length, &chars_written, info_log); PRINT_OPENGL_ERROR ();
			std::cout << "Shader InfoLog:" << std::endl << info_log << std::endl;
			delete[] info_log;
		}
}

/******************************************************************************
 *
 * print_program_info_log
 *
 *****************************************************************************/
void print_program_info_log (GLuint program)
{
	int     info_log_length = 0;
	int     chars_written  = 0;
	GLchar *info_log;

	glGetProgramiv (program, GL_INFO_LOG_LENGTH, &info_log_length); PRINT_OPENGL_ERROR ();

	if (info_log_length > 1)
		{
			info_log = new GLchar[info_log_length];
			glGetProgramInfoLog (program, info_log_length, &chars_written, info_log); PRINT_OPENGL_ERROR ();
			std::cout << "Program InfoLog:" << std::endl << info_log << std::endl;
			delete[] info_log;
		}
	PRINT_OPENGL_ERROR ();  // Check for OpenGL errors
}

/******************************************************************************
 *
 * get_uni_loc
 *
 *****************************************************************************/
GLint get_uni_loc (GLuint program, const GLchar *name)
{
	GLint loc;

	loc = glGetUniformLocation (program, name); PRINT_OPENGL_ERROR ();
	if (loc == -1)
		std::cerr << "No such uniform named \"" << name << "\"" << std::endl;

	return loc;
}

/******************************************************************************
 *
 * get_file_content
 *
 *****************************************************************************/
std::string get_file_content (const std::string &filename)
{
	std::string ret;
	if (FILE *fp = fopen((pvgl_get_share_path() + filename).c_str(), "r")) {
		char buf[1024];
		while(size_t len = fread(buf, 1, sizeof(buf), fp))
			ret += std::string(buf, buf + len);
		fclose(fp);
	}

	// Get values from pvconfig.ini
	size_t pos_window_r = ret.find("{{{window_r}}}");
	if (pos_window_r != std::string::npos) {
		std::string window_r = pvconfig.value("pvgl/window_r", "0.2").toString().toUtf8().data();
		ret.replace(pos_window_r, 14, window_r);
		// std::cout << ret;
	}
	size_t pos_window_g = ret.find("{{{window_g}}}");
	if (pos_window_g != std::string::npos) {
		std::string window_g = pvconfig.value("pvgl/window_g", "0.2").toString().toUtf8().data();
		ret.replace(pos_window_g, 14, window_g);
		// std::cout << ret;
	}
	size_t pos_window_b = ret.find("{{{window_b}}}");
	if (pos_window_b != std::string::npos) {
		std::string window_b = pvconfig.value("pvgl/window_b", "0.2").toString().toUtf8().data();
		ret.replace(pos_window_b, 14, window_b);
		// std::cout << ret;
	}
	size_t pos_window_a = ret.find("{{{window_a}}}");
	if (pos_window_a != std::string::npos) {
		std::string window_a = pvconfig.value("pvgl/window_a", "1.0").toString().toUtf8().data();
		ret.replace(pos_window_a, 14, window_a);
		// std::cout << ret;
	}



	return ret;
}

/******************************************************************************
 *
 * read_shader
 *
 *****************************************************************************/
GLuint read_shader(const std::string              &vertex_filename,
                   const std::string              &geometry_filename,
                   const std::string              &fragment_filename,
                   const std::string              &vertex_prefix,
                   const std::string              &geometry_prefix,
                   const std::string              &fragment_prefix,
                   const std::vector<std::string> &attributes)
{
	GLint        status;
	std::string  source;
	const char  *cstring;
	GLuint       program;

	program = glCreateProgram(); PRINT_OPENGL_ERROR();

	// Create the vertex shader.
	if (vertex_filename != "")
		{
			GLuint handle = glCreateShader(GL_VERTEX_SHADER); PRINT_OPENGL_ERROR();
			source = vertex_prefix + get_file_content("shaders/" + vertex_filename);
			cstring = source.c_str();
			glShaderSource(handle, 1, &cstring, 0); PRINT_OPENGL_ERROR();
			// Compile the vertex shader, and print out the compiler log file.
			glCompileShader(handle); PRINT_OPENGL_ERROR();
			glGetShaderiv(handle, GL_COMPILE_STATUS, &status); PRINT_OPENGL_ERROR();
			print_shader_info_log(handle);
			glAttachShader(program, handle); PRINT_OPENGL_ERROR();
			if (!status) return 0;
		}

	// Create the geometry shader
	if (geometry_filename != "")
		{
			GLuint handle = glCreateShader(GL_GEOMETRY_SHADER); PRINT_OPENGL_ERROR();
			source = geometry_prefix + get_file_content("shaders/" + geometry_filename);
			cstring = source.c_str();
			glShaderSource(handle, 1, &cstring, 0); PRINT_OPENGL_ERROR();
			// Compile the geometry shader, and print out the compiler log file.
			glCompileShader(handle); PRINT_OPENGL_ERROR();
			glGetShaderiv(handle, GL_COMPILE_STATUS, &status); PRINT_OPENGL_ERROR();
			print_shader_info_log(handle);
			glAttachShader(program, handle); PRINT_OPENGL_ERROR();
			if (!status) return 0;
		}

	// Create the fragment shader
	if (fragment_filename != "")
		{
			GLuint handle = glCreateShader(GL_FRAGMENT_SHADER); PRINT_OPENGL_ERROR();
			source = fragment_prefix + get_file_content("shaders/" + fragment_filename);
			cstring = source.c_str();
			glShaderSource(handle, 1, &cstring, 0); PRINT_OPENGL_ERROR();
			// Compile the fragment shader, and print out the compiler log file.
			glCompileShader(handle); PRINT_OPENGL_ERROR();
			glGetShaderiv(handle, GL_COMPILE_STATUS, &status); PRINT_OPENGL_ERROR();
			print_shader_info_log(handle);
			glAttachShader(program, handle); PRINT_OPENGL_ERROR();
			if (!status) return 0;
		}

	for (unsigned i = 0; i < attributes.size(); i++)
		glBindAttribLocation(program, i, attributes[i].c_str()); PRINT_OPENGL_ERROR();

	// Link the program object and print out the info log.
	glLinkProgram(program); PRINT_OPENGL_ERROR();
	glGetProgramiv(program, GL_LINK_STATUS, &status);PRINT_OPENGL_ERROR ();
	print_program_info_log(program);
	if (!status) {
		return 0;
	}

	// Install program object as part of current state.
	glUseProgram(program); PRINT_OPENGL_ERROR();

	return program;
}

/******************************************************************************
 *
 * gl_have_extension
 *
 *****************************************************************************/
static bool gl_have_extension(const std::string &name)
{
	GLint num;

	glGetIntegerv(GL_NUM_EXTENSIONS, &num);
	for (GLint i = 0; i < num; i++)
		if (std::string(reinterpret_cast<const char*>(glGetStringi(GL_EXTENSIONS, i))) == name)
			return true;
	return false;
}

/******************************************************************************
 *
 * fixing_glew_bugs
 *
 *****************************************************************************/
void fixing_glew_bugs (void)
{
#ifdef WIN32

#else
#ifdef MACOS

#else
	PVLOG_INFO("Fixing glew bugs\n");
	if (!GLEW_ARB_vertex_array_object)
		{
			PVLOG_ERROR("Glew didn't find the GL_ARB_vertex_array_object extension!\n");
			if (gl_have_extension ("GL_ARB_vertex_array_object"))
				{
					PVLOG_INFO("But we do!\n");
					glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC)glXGetProcAddress((const GLubyte*)"glBindVertexArray");
					glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC)glXGetProcAddress((const GLubyte*)"glDeleteVertexArrays");
					glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC)glXGetProcAddress((const GLubyte*)"glGenVertexArrays");
					glIsVertexArray = (PFNGLISVERTEXARRAYPROC)glXGetProcAddress((const GLubyte*)"glIsVertexArray");
				}
			else
				{
					std::cout << "And neither we do, exiting!" << std::endl;
					exit (-1);
				}
		}
	if (!GLEW_ARB_framebuffer_object)
		{
			PVLOG_ERROR("Glew didn't find the GL_ARB_framebuffer_object extension!\n");
			if (gl_have_extension ("GL_ARB_framebuffer_object"))
				{
					PVLOG_INFO("But we do!\n");
					glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC)glXGetProcAddress((const GLubyte*)"glBindFramebuffer");
					glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC)glXGetProcAddress((const GLubyte*)"glBindRenderbuffer");
					glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC)glXGetProcAddress((const GLubyte*)"glBlitFramebuffer");
					glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC)glXGetProcAddress((const GLubyte*)"glCheckFramebufferStatus");
					glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC)glXGetProcAddress((const GLubyte*)"glDeleteFramebuffers");
					glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC)glXGetProcAddress((const GLubyte*)"glDeleteRenderbuffers");
					glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC)glXGetProcAddress((const GLubyte*)"glFramebufferRenderbuffer");
					glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC)glXGetProcAddress((const GLubyte*)"glFramebufferTexture1D");
					glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC)glXGetProcAddress((const GLubyte*)"glFramebufferTexture2D");
					glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC)glXGetProcAddress((const GLubyte*)"glFramebufferTexture3D");
					glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC)glXGetProcAddress((const GLubyte*)"glFramebufferTextureLayer");
					glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC)glXGetProcAddress((const GLubyte*)"glGenFramebuffers");
					glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC)glXGetProcAddress((const GLubyte*)"glGenRenderbuffers");
					glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC)glXGetProcAddress((const GLubyte*)"glGenerateMipmap");
					glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)glXGetProcAddress((const GLubyte*)"glGetFramebufferAttachmentParameteriv");
					glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC)glXGetProcAddress((const GLubyte*)"glGetRenderbufferParameteriv");
					glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC)glXGetProcAddress((const GLubyte*)"glIsFramebuffer");
					glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC)glXGetProcAddress((const GLubyte*)"glIsRenderbuffer");
					glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC)glXGetProcAddress((const GLubyte*)"glRenderbufferStorage");
					glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)glXGetProcAddress((const GLubyte*)"glRenderbufferStorageMultisample");
				}
			else
				{
					PVLOG_INFO("And neither we do, exiting!\n");
					exit (-1);
				}
		}
#endif
#endif
}
