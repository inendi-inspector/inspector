diff --git a/src/gui/styles/qcleanlooksstyle.cpp b/src/gui/styles/qcleanlooksstyle.cpp
index 0e0d050..4fefd53 100644
--- a/src/gui/styles/qcleanlooksstyle.cpp
+++ b/src/gui/styles/qcleanlooksstyle.cpp
@@ -2407,6 +2407,514 @@ QPalette QCleanlooksStyle::standardPalette () const
     return palette;
 }
 
+template <class OptionSlider>
+static void drawSlider(const QStyleOptionComplex* option, const QWidget* widget, const QColor& darkOutline, const QColor& grooveColor, const QColor& dark, const QColor& gripShadow, QPainter* painter, const QStyle* proxy)
+{
+	if (const OptionSlider *slider = qstyleoption_cast<const OptionSlider *>(option)) {
+		QRect groove = proxy->subControlRect(QCleanlooksStyle::CC_Slider, option, QCleanlooksStyle::SC_SliderGroove, widget);
+		QRect handle = proxy->subControlRect(QCleanlooksStyle::CC_Slider, option, QCleanlooksStyle::SC_SliderHandle, widget);
+
+		bool horizontal = slider->orientation == Qt::Horizontal;
+		bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
+		bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
+		QColor activeHighlight = option->palette.color(QPalette::Normal, QPalette::Highlight);
+		QPixmap cache;
+
+		QBrush oldBrush = painter->brush();
+		QPen oldPen = painter->pen();
+
+		QColor shadowAlpha(Qt::black);
+		shadowAlpha.setAlpha(10);
+		QColor highlightAlpha(Qt::white);
+		highlightAlpha.setAlpha(80);
+
+		if ((option->subControls & QCleanlooksStyle::SC_SliderGroove) && groove.isValid()) {
+			QString groovePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_groove"), option, groove.size());
+			QRect pixmapRect(0, 0, groove.width(), groove.height());
+
+			// draw background groove
+			if (!QPixmapCache::find(groovePixmapName, cache)) {
+				cache = QPixmap(pixmapRect.size());
+				cache.fill(Qt::transparent);
+				QPainter groovePainter(&cache);
+
+				groovePainter.setPen(shadowAlpha);
+				groovePainter.drawLine(1, 0, groove.width(), 0);
+				groovePainter.drawLine(0, 0, 0, groove.height() - 1);
+
+				groovePainter.setPen(highlightAlpha);
+				groovePainter.drawLine(1, groove.height() - 1, groove.width() - 1, groove.height() - 1);
+				groovePainter.drawLine(groove.width() - 1, 1, groove.width() - 1, groove.height() - 1);
+				QLinearGradient gradient;
+				if (horizontal) {
+					gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
+					gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
+				}
+				else {
+					gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
+					gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
+				}
+				groovePainter.setPen(QPen(darkOutline.darker(110), 0));
+				gradient.setColorAt(0, grooveColor.darker(110));//dark.lighter(120));
+				gradient.setColorAt(1, grooveColor.lighter(110));//palette.button().color().darker(115));
+				groovePainter.setBrush(gradient);
+				groovePainter.drawRect(pixmapRect.adjusted(1, 1, -2, -2));
+				groovePainter.end();
+				QPixmapCache::insert(groovePixmapName, cache);
+			}
+			painter->drawPixmap(groove.topLeft(), cache);
+
+			// draw blue groove highlight
+			QRect clipRect;
+			groovePixmapName += QLatin1String("_blue");
+			if (!QPixmapCache::find(groovePixmapName, cache)) {
+				cache = QPixmap(pixmapRect.size());
+				cache.fill(Qt::transparent);
+				QPainter groovePainter(&cache);
+				QLinearGradient gradient;
+				if (horizontal) {
+					gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
+					gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
+				}
+				else {
+					gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
+					gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
+				}
+				groovePainter.setPen(QPen(activeHighlight.darker(150), 0));
+				gradient.setColorAt(0, activeHighlight.darker(120));
+				gradient.setColorAt(1, activeHighlight.lighter(160));
+				groovePainter.setBrush(gradient);
+				groovePainter.drawRect(pixmapRect.adjusted(1, 1, -2, -2));
+				groovePainter.end();
+				QPixmapCache::insert(groovePixmapName, cache);
+			}
+			if (horizontal) {
+				if (slider->upsideDown)
+					clipRect = QRect(handle.right(), groove.top(), groove.right() - handle.right(), groove.height());
+				else
+					clipRect = QRect(groove.left(), groove.top(), handle.left(), groove.height());
+			} else {
+				if (slider->upsideDown)
+					clipRect = QRect(groove.left(), handle.bottom(), groove.width(), groove.height() - handle.bottom());
+				else
+					clipRect = QRect(groove.left(), groove.top(), groove.width(), handle.top() - groove.top());
+			}
+			painter->save();
+			painter->setClipRect(clipRect.adjusted(0, 0, 1, 1));
+			painter->drawPixmap(groove.topLeft(), cache);
+			painter->restore();
+		}
+
+		// draw handle
+		if ((option->subControls & QCleanlooksStyle::SC_SliderHandle) ) {
+			QString handlePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_handle"), option, handle.size());
+			if (!QPixmapCache::find(handlePixmapName, cache)) {
+				cache = QPixmap(handle.size());
+				cache.fill(Qt::transparent);
+				QRect pixmapRect(0, 0, handle.width(), handle.height());
+				QPainter handlePainter(&cache);
+
+				QColor gradientStartColor = mergedColors(option->palette.button().color().lighter(155),
+														 dark.lighter(155), 50);
+				QColor gradientStopColor = gradientStartColor.darker(108);
+				QRect gradRect = pixmapRect.adjusted(2, 2, -2, -2);
+
+				QColor gradientBgStartColor = gradientStartColor;
+				QColor gradientBgStopColor = gradientStopColor;
+
+				QColor outline = option->state & QCleanlooksStyle::State_Enabled ? dark : dark.lighter(130);
+				if (option->state & QCleanlooksStyle::State_Enabled && option->activeSubControls & QCleanlooksStyle::SC_SliderHandle) {
+					gradientBgStartColor = option->palette.highlight().color().lighter(180);
+					gradientBgStopColor = option->palette.highlight().color().lighter(110);
+					outline = option->palette.highlight().color().darker(130);
+				}
+
+				// gradient fill
+				QRect r = pixmapRect.adjusted(1, 1, -1, -1);
+
+				qt_cleanlooks_draw_gradient(&handlePainter, gradRect,
+											gradientBgStartColor,
+											gradientBgStopColor,
+											horizontal ? TopDown : FromLeft, option->palette.button());
+
+				handlePainter.setPen(QPen(outline.darker(110), 1));
+				handlePainter.drawLine(QPoint(r.left(), r.top() + 3), QPoint(r.left(), r.bottom() - 3));
+				handlePainter.drawLine(QPoint(r.right(), r.top() + 3), QPoint(r.right(), r.bottom() - 3));
+				handlePainter.drawLine(QPoint(r.left() + 3, r.bottom()), QPoint(r.right() - 3, r.bottom()));
+
+				handlePainter.save();
+				handlePainter.setRenderHint(QPainter::Antialiasing);
+				handlePainter.translate(0.5, 0.5);
+				const QLine lines[4] = {
+					QLine(QPoint(r.left(), r.bottom() - 2), QPoint(r.left() + 2, r.bottom())),
+					QLine(QPoint(r.left(), r.top() + 2), QPoint(r.left() + 2, r.top())),
+					QLine(QPoint(r.right(), r.bottom() - 2), QPoint(r.right() - 2, r.bottom())),
+					QLine(QPoint(r.right(), r.top() + 2), QPoint(r.right() - 2, r.top()))
+				};
+				handlePainter.drawLines(lines, 4);
+				handlePainter.restore();;
+				handlePainter.setPen(QPen(outline.darker(130), 1));
+				handlePainter.drawLine(QPoint(r.left() + 3, r.top()), QPoint(r.right() - 3, r.top()));
+				QColor cornerAlpha = outline.darker(120);
+				cornerAlpha.setAlpha(80);
+
+				handlePainter.setPen(cornerAlpha);
+				if (horizontal) {
+					handlePainter.drawLine(QPoint(r.left() + 6, r.top()), QPoint(r.left() + 6, r.bottom()));
+					handlePainter.drawLine(QPoint(r.right() - 6, r.top()), QPoint(r.right() - 6, r.bottom()));
+				} else {
+					handlePainter.drawLine(QPoint(r.left(), r.top() + 6), QPoint(r.right(), r.top() + 6));
+					handlePainter.drawLine(QPoint(r.left(), r.bottom() - 6), QPoint(r.right(), r.bottom() - 6));
+				}
+
+				//handle shadow
+				handlePainter.setPen(shadowAlpha);
+				handlePainter.drawLine(QPoint(r.left() + 2, r.bottom() + 1), QPoint(r.right() - 2, r.bottom() + 1));
+				handlePainter.drawLine(QPoint(r.right() + 1, r.bottom() - 3), QPoint(r.right() + 1, r.top() + 4));
+				handlePainter.drawLine(QPoint(r.right() - 1, r.bottom()), QPoint(r.right() + 1, r.bottom() - 2));
+
+				qt_cleanlooks_draw_gradient(&handlePainter, horizontal ?
+					gradRect.adjusted(6, 0, -6, 0) : gradRect.adjusted(0, 6, 0, -6),
+					gradientStartColor,
+					gradientStopColor.darker(106),
+					horizontal ? TopDown : FromLeft,
+					option->palette.button());
+
+				//draw grips
+				for (int i = -3; i< 6 ; i += 3) {
+					for (int j = -3; j< 6 ; j += 3) {
+						handlePainter.fillRect(r.center().x() + i, r.center().y() + j, 2, 2, highlightAlpha);
+						handlePainter.setPen(gripShadow);
+						handlePainter.drawPoint(r.center().x() + i, r.center().y() + j );
+					}
+				}
+				handlePainter.end();
+				QPixmapCache::insert(handlePixmapName, cache);
+			}
+
+			painter->drawPixmap(handle.topLeft(), cache);
+
+			if (slider->state & QCleanlooksStyle::State_HasFocus) {
+				QStyleOptionFocusRect fropt;
+				fropt.QStyleOption::operator=(*slider);
+				fropt.rect = slider->rect;
+				proxy->drawPrimitive(QCleanlooksStyle::PE_FrameFocusRect, &fropt, painter, widget);
+			}
+		}
+		if (option->subControls & QCleanlooksStyle::SC_SliderTickmarks) {
+			painter->setPen(darkOutline);
+			int tickSize = proxy->pixelMetric(QCleanlooksStyle::PM_SliderTickmarkOffset, option, widget);
+			qint64 available = proxy->pixelMetric(QCleanlooksStyle::PM_SliderSpaceAvailable, slider, widget);
+			qint64 interval = slider->tickInterval;
+			if (interval <= 0) {
+				interval = slider->singleStep;
+				if (QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum, interval,
+													available)
+					- QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum,
+													(qint64) 0, available) < 3)
+					interval = slider->pageStep;
+			}
+			if (interval <= 0)
+				interval = 1;
+
+			qint64 v = slider->minimum;
+			qint64 len = proxy->pixelMetric(QCleanlooksStyle::PM_SliderLength, slider, widget);
+			while (v <= slider->maximum + 1) {
+				if (v == slider->maximum + 1 && interval == 1)
+					break;
+				const qint64 v_ = qMin(v, (qint64) slider->maximum);
+				qint64 pos = QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum,
+												v_, (qint64) (horizontal
+													? slider->rect.width()
+													: slider->rect.height()) - len,
+												slider->upsideDown) + len / 2;
+				int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
+
+				if (horizontal) {
+					if (ticksAbove) {
+						painter->drawLine(pos, slider->rect.top() + extra,
+							pos, slider->rect.top() + tickSize);
+					}
+					if (ticksBelow) {
+						painter->drawLine(pos, slider->rect.bottom() - extra,
+										pos, slider->rect.bottom() - tickSize);
+					}
+				} else {
+					if (ticksAbove) {
+						painter->drawLine(slider->rect.left() + extra, pos,
+										slider->rect.left() + tickSize, pos);
+					}
+					if (ticksBelow) {
+						painter->drawLine(slider->rect.right() - extra, pos,
+										slider->rect.right() - tickSize, pos);
+					}
+				}
+				// in the case where maximum is max int
+				qint64 nextInterval = v + interval;
+				if (nextInterval < v)
+					break;
+				v = nextInterval;
+			}
+		}
+		painter->setBrush(oldBrush);
+		painter->setPen(oldPen);
+	}
+}
+
+template <class OptionStyle>
+void drawScrollBar(const QStyleOptionComplex* option, QCleanlooksStyle::ComplexControl control, const QWidget* widget, const QColor& grooveColor, const QColor& darkOutline, const QColor& gradientStartColor, const QColor& gradientStopColor, const QColor& gripShadow, const QPalette& palette, const QColor& alphaCornerColor, QPainter* painter, QStyle const* proxy)
+{
+	painter->save();
+	if (const OptionStyle *scrollBar = qstyleoption_cast<const OptionStyle *>(option)) {
+		bool isEnabled = scrollBar->state & QCleanlooksStyle::State_Enabled;
+		bool reverse = scrollBar->direction == Qt::RightToLeft;
+		bool horizontal = scrollBar->orientation == Qt::Horizontal;
+		bool sunken = scrollBar->state & QCleanlooksStyle::State_Sunken;
+
+		painter->fillRect(option->rect, option->palette.background());
+
+		QRect scrollBarSubLine = proxy->subControlRect(control, scrollBar, QCleanlooksStyle::SC_ScrollBarSubLine, widget);
+		QRect scrollBarAddLine = proxy->subControlRect(control, scrollBar, QCleanlooksStyle::SC_ScrollBarAddLine, widget);
+		QRect scrollBarSlider = proxy->subControlRect(control, scrollBar, QCleanlooksStyle::SC_ScrollBarSlider, widget);
+		QRect grooveRect = proxy->subControlRect(control, scrollBar, QCleanlooksStyle::SC_ScrollBarGroove, widget);
+
+		// paint groove
+		if (scrollBar->subControls & QCleanlooksStyle::SC_ScrollBarGroove) {
+			painter->setBrush(grooveColor);
+			painter->setPen(Qt::NoPen);
+			if (horizontal) {
+				painter->drawRect(grooveRect);
+				painter->setPen(darkOutline);
+				painter->drawLine(grooveRect.topLeft(), grooveRect.topRight());
+				painter->drawLine(grooveRect.bottomLeft(), grooveRect.bottomRight());
+			} else {
+				painter->drawRect(grooveRect);
+				painter->setPen(darkOutline);
+				painter->drawLine(grooveRect.topLeft(), grooveRect.bottomLeft());
+				painter->drawLine(grooveRect.topRight(), grooveRect.bottomRight());
+			}
+		}
+		//paint slider
+		if (scrollBar->subControls & QCleanlooksStyle::SC_ScrollBarSlider) {
+			QRect pixmapRect = scrollBarSlider;
+			if (horizontal)
+				pixmapRect.adjust(-1, 0, 0, -1);
+			else
+				pixmapRect.adjust(0, -1, -1, 0);
+
+			if (isEnabled) {
+				QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
+										 pixmapRect.center().x(), pixmapRect.bottom());
+				if (!horizontal)
+					gradient = QLinearGradient(pixmapRect.left(), pixmapRect.center().y(),
+											   pixmapRect.right(), pixmapRect.center().y());
+
+				if (option->palette.button().gradient()) {
+					gradient.setStops(option->palette.button().gradient()->stops());
+				} else {
+					if (sunken || (option->state & QCleanlooksStyle::State_MouseOver &&
+						(scrollBar->activeSubControls & QCleanlooksStyle::SC_ScrollBarSlider))) {
+						gradient.setColorAt(0, gradientStartColor.lighter(110));
+						gradient.setColorAt(1, gradientStopColor.lighter(110));
+					} else {
+						gradient.setColorAt(0, gradientStartColor);
+						gradient.setColorAt(1, gradientStopColor);
+					}
+				}
+				painter->setPen(QPen(darkOutline, 0));
+				painter->setBrush(gradient);
+				painter->drawRect(pixmapRect);
+
+
+				//calculate offsets used by highlight and shadow
+				int yoffset, xoffset;
+				if (option->state & QCleanlooksStyle::State_Horizontal) {
+					xoffset = 0;
+					yoffset = 1;
+				} else {
+					xoffset = 1;
+					yoffset = 0;
+				}
+				//draw slider highlights
+				painter->setPen(QPen(gradientStopColor, 0));
+				painter->drawLine(scrollBarSlider.left() + xoffset,
+								  scrollBarSlider.bottom() - yoffset,
+								  scrollBarSlider.right() - xoffset,
+								  scrollBarSlider.bottom() - yoffset);
+				painter->drawLine(scrollBarSlider.right() - xoffset,
+								  scrollBarSlider.top() + yoffset,
+								  scrollBarSlider.right() - xoffset,
+								  scrollBarSlider.bottom() - yoffset);
+
+				//draw slider shadow
+				painter->setPen(QPen(gradientStartColor, 0));
+				painter->drawLine(scrollBarSlider.left() + xoffset,
+								  scrollBarSlider.top() + yoffset,
+								  scrollBarSlider.right() - xoffset,
+								  scrollBarSlider.top() + yoffset);
+				painter->drawLine(scrollBarSlider.left() + xoffset,
+								  scrollBarSlider.top() + yoffset,
+								  scrollBarSlider.left() + xoffset,
+								  scrollBarSlider.bottom() - yoffset);
+			} else {
+				QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
+										 pixmapRect.center().x(), pixmapRect.bottom());
+				if (!horizontal) {
+					gradient = QLinearGradient(pixmapRect.left(), pixmapRect.center().y(),
+											   pixmapRect.right(), pixmapRect.center().y());
+				}
+				if (sunken) {
+					gradient.setColorAt(0, gradientStartColor.lighter(110));
+					gradient.setColorAt(1, gradientStopColor.lighter(110));
+				} else {
+					gradient.setColorAt(0, gradientStartColor);
+					gradient.setColorAt(1, gradientStopColor);
+				}
+				painter->setPen(darkOutline);
+				painter->setBrush(gradient);
+				painter->drawRect(pixmapRect);
+			}
+			int gripMargin = 4;
+			//draw grips
+			if (horizontal) {
+				for (int i = -3; i< 6 ; i += 3) {
+					painter->setPen(QPen(gripShadow, 1));
+					painter->drawLine(
+						QPoint(scrollBarSlider.center().x() + i ,
+							   scrollBarSlider.top() + gripMargin),
+						QPoint(scrollBarSlider.center().x() + i,
+							   scrollBarSlider.bottom() - gripMargin));
+					painter->setPen(QPen(palette.light(), 1));
+					painter->drawLine(
+						QPoint(scrollBarSlider.center().x() + i + 1,
+							   scrollBarSlider.top() + gripMargin  ),
+						QPoint(scrollBarSlider.center().x() + i + 1,
+							   scrollBarSlider.bottom() - gripMargin));
+				}
+			} else {
+				for (int i = -3; i < 6 ; i += 3) {
+					painter->setPen(QPen(gripShadow, 1));
+					painter->drawLine(
+						QPoint(scrollBarSlider.left() + gripMargin ,
+							   scrollBarSlider.center().y()+ i),
+						QPoint(scrollBarSlider.right() - gripMargin,
+							   scrollBarSlider.center().y()+ i));
+					painter->setPen(QPen(palette.light(), 1));
+					painter->drawLine(
+						QPoint(scrollBarSlider.left() + gripMargin,
+							   scrollBarSlider.center().y() + 1 + i),
+						QPoint(scrollBarSlider.right() - gripMargin,
+							   scrollBarSlider.center().y() + 1 + i));
+				}
+			}
+		}
+
+		// The SubLine (up/left) buttons
+		if (scrollBar->subControls & QCleanlooksStyle::SC_ScrollBarSubLine) {
+			//int scrollBarExtent = proxy->pixelMetric(PM_ScrollBarExtent, option, widget);
+			QRect pixmapRect = scrollBarSubLine;
+			if (isEnabled ) {
+				QRect fillRect = pixmapRect.adjusted(1, 1, -1, -1);
+				// Gradients
+				if ((scrollBar->activeSubControls & QCleanlooksStyle::SC_ScrollBarSubLine) && sunken) {
+					qt_cleanlooks_draw_gradient(painter,
+												QRect(fillRect),
+												gradientStopColor.darker(120),
+												gradientStopColor.darker(120),
+												horizontal ? TopDown : FromLeft, option->palette.button());
+				} else {
+					qt_cleanlooks_draw_gradient(painter,
+												QRect(fillRect),
+												gradientStartColor.lighter(105),
+												gradientStopColor,
+												horizontal ? TopDown : FromLeft, option->palette.button());
+				}
+			}
+			// Details
+			QImage subButton;
+			if (horizontal) {
+				subButton = QImage(reverse ? qt_scrollbar_button_right : qt_scrollbar_button_left);
+			} else {
+				subButton = QImage(qt_scrollbar_button_up);
+			}
+			subButton.setColor(1, alphaCornerColor.rgba());
+			subButton.setColor(2, darkOutline.rgba());
+			if ((scrollBar->activeSubControls & QCleanlooksStyle::SC_ScrollBarSubLine) && sunken) {
+				subButton.setColor(3, gradientStopColor.darker(140).rgba());
+				subButton.setColor(4, gradientStopColor.darker(120).rgba());
+			} else {
+				subButton.setColor(3, gradientStartColor.lighter(105).rgba());
+				subButton.setColor(4, gradientStopColor.rgba());
+			}
+			subButton.setColor(5, scrollBar->palette.text().color().rgba());
+			painter->drawImage(pixmapRect, subButton);
+
+			// Arrows
+			QCleanlooksStyle::PrimitiveElement arrow;
+			if (option->state & QCleanlooksStyle::State_Horizontal)
+				arrow = option->direction == Qt::LeftToRight ? QCleanlooksStyle::PE_IndicatorArrowLeft: QCleanlooksStyle::PE_IndicatorArrowRight;
+			else
+				arrow = QCleanlooksStyle::PE_IndicatorArrowUp;
+			QStyleOption arrowOpt = *option;
+			arrowOpt.rect = scrollBarSubLine.adjusted(3, 3, -2, -2);
+			proxy->drawPrimitive(arrow, &arrowOpt, painter, widget);
+
+
+			// The AddLine (down/right) button
+			if (scrollBar->subControls & QCleanlooksStyle::SC_ScrollBarAddLine) {
+				QString addLinePixmapName = QStyleHelper::uniqueName(QLatin1String("scrollbar_addline"), option, QSize(16, 16));
+				QRect pixmapRect = scrollBarAddLine;
+				if (isEnabled) {
+					QRect fillRect = pixmapRect.adjusted(1, 1, -1, -1);
+					// Gradients
+					if ((scrollBar->activeSubControls & QCleanlooksStyle::SC_ScrollBarAddLine) && sunken) {
+						qt_cleanlooks_draw_gradient(painter,
+													fillRect,
+													gradientStopColor.darker(120),
+													gradientStopColor.darker(120),
+													horizontal ? TopDown: FromLeft, option->palette.button());
+					} else {
+						qt_cleanlooks_draw_gradient(painter,
+													fillRect,
+													gradientStartColor.lighter(105),
+													gradientStopColor,
+													horizontal ? TopDown : FromLeft, option->palette.button());
+					}
+				}
+				// Details
+				QImage addButton;
+				if (horizontal) {
+					addButton = QImage(reverse ? qt_scrollbar_button_left : qt_scrollbar_button_right);
+				} else {
+					addButton = QImage(qt_scrollbar_button_down);
+				}
+				addButton.setColor(1, alphaCornerColor.rgba());
+				addButton.setColor(2, darkOutline.rgba());
+				if ((scrollBar->activeSubControls & QCleanlooksStyle::SC_ScrollBarAddLine) && sunken) {
+					addButton.setColor(3, gradientStopColor.darker(140).rgba());
+					addButton.setColor(4, gradientStopColor.darker(120).rgba());
+				} else {
+					addButton.setColor(3, gradientStartColor.lighter(105).rgba());
+					addButton.setColor(4, gradientStopColor.rgba());
+				}
+				addButton.setColor(5, scrollBar->palette.text().color().rgba());
+				painter->drawImage(pixmapRect, addButton);
+
+				QCleanlooksStyle::PrimitiveElement arrow;
+				if (option->state & QCleanlooksStyle::State_Horizontal)
+					arrow = option->direction == Qt::LeftToRight ? QCleanlooksStyle::PE_IndicatorArrowRight : QCleanlooksStyle::PE_IndicatorArrowLeft;
+				else
+					arrow = QCleanlooksStyle::PE_IndicatorArrowDown;
+
+				QStyleOption arrowOpt = *option;
+				arrowOpt.rect = scrollBarAddLine.adjusted(3, 3, -2, -2);
+				proxy->drawPrimitive(arrow, &arrowOpt, painter, widget);
+			}
+		}
+	}
+	painter->restore();
+}
+
 /*!
   \reimp
 */
@@ -2960,255 +3468,10 @@ void QCleanlooksStyle::drawComplexControl(ComplexControl control, const QStyleOp
         break;
 #ifndef QT_NO_SCROLLBAR
     case CC_ScrollBar:
-        painter->save();
-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            bool isEnabled = scrollBar->state & State_Enabled;
-            bool reverse = scrollBar->direction == Qt::RightToLeft;
-            bool horizontal = scrollBar->orientation == Qt::Horizontal;
-            bool sunken = scrollBar->state & State_Sunken;
-
-            painter->fillRect(option->rect, option->palette.background());
-
-            QRect scrollBarSubLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSubLine, widget);
-            QRect scrollBarAddLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarAddLine, widget);
-            QRect scrollBarSlider = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSlider, widget);
-            QRect grooveRect = proxy()->subControlRect(control, scrollBar, SC_ScrollBarGroove, widget);
-
-            // paint groove
-            if (scrollBar->subControls & SC_ScrollBarGroove) {
-                painter->setBrush(grooveColor);
-                painter->setPen(Qt::NoPen);
-                if (horizontal) {
-                    painter->drawRect(grooveRect);
-                    painter->setPen(darkOutline);
-                    painter->drawLine(grooveRect.topLeft(), grooveRect.topRight());
-                    painter->drawLine(grooveRect.bottomLeft(), grooveRect.bottomRight());
-                } else {
-                    painter->drawRect(grooveRect);
-                    painter->setPen(darkOutline);
-                    painter->drawLine(grooveRect.topLeft(), grooveRect.bottomLeft());
-                    painter->drawLine(grooveRect.topRight(), grooveRect.bottomRight());
-                }
-            }
-            //paint slider
-            if (scrollBar->subControls & SC_ScrollBarSlider) {
-                QRect pixmapRect = scrollBarSlider;
-                if (horizontal)
-                    pixmapRect.adjust(-1, 0, 0, -1);
-                else
-                    pixmapRect.adjust(0, -1, -1, 0);
-
-                if (isEnabled) {
-                    QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
-                                             pixmapRect.center().x(), pixmapRect.bottom());
-                    if (!horizontal)
-                        gradient = QLinearGradient(pixmapRect.left(), pixmapRect.center().y(),
-                                                   pixmapRect.right(), pixmapRect.center().y());
-
-                    if (option->palette.button().gradient()) {
-                        gradient.setStops(option->palette.button().gradient()->stops());
-                    } else {
-                        if (sunken || (option->state & State_MouseOver &&
-                            (scrollBar->activeSubControls & SC_ScrollBarSlider))) {
-                            gradient.setColorAt(0, gradientStartColor.lighter(110));
-                            gradient.setColorAt(1, gradientStopColor.lighter(110));
-                        } else {
-                            gradient.setColorAt(0, gradientStartColor);
-                            gradient.setColorAt(1, gradientStopColor);
-                        }
-                    }
-                    painter->setPen(QPen(darkOutline, 0));
-                    painter->setBrush(gradient);
-                    painter->drawRect(pixmapRect);
-
-
-                    //calculate offsets used by highlight and shadow
-                    int yoffset, xoffset;
-                    if (option->state & State_Horizontal) {
-                        xoffset = 0;
-                        yoffset = 1;
-                    } else {
-                        xoffset = 1;
-                        yoffset = 0;
-                    }
-                    //draw slider highlights
-                    painter->setPen(QPen(gradientStopColor, 0));
-                    painter->drawLine(scrollBarSlider.left() + xoffset,
-                                      scrollBarSlider.bottom() - yoffset,
-                                      scrollBarSlider.right() - xoffset,
-                                      scrollBarSlider.bottom() - yoffset);
-                    painter->drawLine(scrollBarSlider.right() - xoffset,
-                                      scrollBarSlider.top() + yoffset,
-                                      scrollBarSlider.right() - xoffset,
-                                      scrollBarSlider.bottom() - yoffset);
-
-                    //draw slider shadow
-                    painter->setPen(QPen(gradientStartColor, 0));
-                    painter->drawLine(scrollBarSlider.left() + xoffset,
-                                      scrollBarSlider.top() + yoffset,
-                                      scrollBarSlider.right() - xoffset,
-                                      scrollBarSlider.top() + yoffset);
-                    painter->drawLine(scrollBarSlider.left() + xoffset,
-                                      scrollBarSlider.top() + yoffset,
-                                      scrollBarSlider.left() + xoffset,
-                                      scrollBarSlider.bottom() - yoffset);
-                } else {
-                    QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
-                                             pixmapRect.center().x(), pixmapRect.bottom());
-                    if (!horizontal) {
-                        gradient = QLinearGradient(pixmapRect.left(), pixmapRect.center().y(),
-                                                   pixmapRect.right(), pixmapRect.center().y());
-                    }
-                    if (sunken) {
-                        gradient.setColorAt(0, gradientStartColor.lighter(110));
-                        gradient.setColorAt(1, gradientStopColor.lighter(110));
-                    } else {
-                        gradient.setColorAt(0, gradientStartColor);
-                        gradient.setColorAt(1, gradientStopColor);
-                    }
-                    painter->setPen(darkOutline);
-                    painter->setBrush(gradient);
-                    painter->drawRect(pixmapRect);
-                }
-                int gripMargin = 4;
-                //draw grips
-                if (horizontal) {
-                    for (int i = -3; i< 6 ; i += 3) {
-                        painter->setPen(QPen(gripShadow, 1));
-                        painter->drawLine(
-                            QPoint(scrollBarSlider.center().x() + i ,
-                                   scrollBarSlider.top() + gripMargin),
-                            QPoint(scrollBarSlider.center().x() + i,
-                                   scrollBarSlider.bottom() - gripMargin));
-                        painter->setPen(QPen(palette.light(), 1));
-                        painter->drawLine(
-                            QPoint(scrollBarSlider.center().x() + i + 1,
-                                   scrollBarSlider.top() + gripMargin  ),
-                            QPoint(scrollBarSlider.center().x() + i + 1,
-                                   scrollBarSlider.bottom() - gripMargin));
-                    }
-                } else {
-                    for (int i = -3; i < 6 ; i += 3) {
-                        painter->setPen(QPen(gripShadow, 1));
-                        painter->drawLine(
-                            QPoint(scrollBarSlider.left() + gripMargin ,
-                                   scrollBarSlider.center().y()+ i),
-                            QPoint(scrollBarSlider.right() - gripMargin,
-                                   scrollBarSlider.center().y()+ i));
-                        painter->setPen(QPen(palette.light(), 1));
-                        painter->drawLine(
-                            QPoint(scrollBarSlider.left() + gripMargin,
-                                   scrollBarSlider.center().y() + 1 + i),
-                            QPoint(scrollBarSlider.right() - gripMargin,
-                                   scrollBarSlider.center().y() + 1 + i));
-                    }
-                }
-            }
-
-            // The SubLine (up/left) buttons
-            if (scrollBar->subControls & SC_ScrollBarSubLine) {
-                //int scrollBarExtent = proxy()->pixelMetric(PM_ScrollBarExtent, option, widget);
-                QRect pixmapRect = scrollBarSubLine;
-                if (isEnabled ) {
-                    QRect fillRect = pixmapRect.adjusted(1, 1, -1, -1);
-                    // Gradients
-                    if ((scrollBar->activeSubControls & SC_ScrollBarSubLine) && sunken) {
-                        qt_cleanlooks_draw_gradient(painter,
-                                                    QRect(fillRect),
-                                                    gradientStopColor.darker(120),
-                                                    gradientStopColor.darker(120),
-                                                    horizontal ? TopDown : FromLeft, option->palette.button());
-                    } else {
-                        qt_cleanlooks_draw_gradient(painter,
-                                                    QRect(fillRect),
-                                                    gradientStartColor.lighter(105),
-                                                    gradientStopColor,
-                                                    horizontal ? TopDown : FromLeft, option->palette.button());
-                    }
-                }
-                // Details
-                QImage subButton;
-                if (horizontal) {
-                    subButton = QImage(reverse ? qt_scrollbar_button_right : qt_scrollbar_button_left);
-                } else {
-                    subButton = QImage(qt_scrollbar_button_up);
-                }
-                subButton.setColor(1, alphaCornerColor.rgba());
-                subButton.setColor(2, darkOutline.rgba());
-                if ((scrollBar->activeSubControls & SC_ScrollBarSubLine) && sunken) {
-                    subButton.setColor(3, gradientStopColor.darker(140).rgba());
-                    subButton.setColor(4, gradientStopColor.darker(120).rgba());
-                } else {
-                    subButton.setColor(3, gradientStartColor.lighter(105).rgba());
-                    subButton.setColor(4, gradientStopColor.rgba());
-                }
-                subButton.setColor(5, scrollBar->palette.text().color().rgba());
-                painter->drawImage(pixmapRect, subButton);
-
-                // Arrows
-                PrimitiveElement arrow;
-                if (option->state & State_Horizontal)
-                    arrow = option->direction == Qt::LeftToRight ? PE_IndicatorArrowLeft: PE_IndicatorArrowRight;
-                else
-                    arrow = PE_IndicatorArrowUp;
-                QStyleOption arrowOpt = *option;
-                arrowOpt.rect = scrollBarSubLine.adjusted(3, 3, -2, -2);
-                proxy()->drawPrimitive(arrow, &arrowOpt, painter, widget);
-
-
-                // The AddLine (down/right) button
-                if (scrollBar->subControls & SC_ScrollBarAddLine) {
-                    QString addLinePixmapName = QStyleHelper::uniqueName(QLatin1String("scrollbar_addline"), option, QSize(16, 16));
-                    QRect pixmapRect = scrollBarAddLine;
-                    if (isEnabled) {
-                        QRect fillRect = pixmapRect.adjusted(1, 1, -1, -1);
-                        // Gradients
-                        if ((scrollBar->activeSubControls & SC_ScrollBarAddLine) && sunken) {
-                            qt_cleanlooks_draw_gradient(painter,
-                                                        fillRect,
-                                                        gradientStopColor.darker(120),
-                                                        gradientStopColor.darker(120),
-                                                        horizontal ? TopDown: FromLeft, option->palette.button());
-                        } else {
-                            qt_cleanlooks_draw_gradient(painter,
-                                                        fillRect,
-                                                        gradientStartColor.lighter(105),
-                                                        gradientStopColor,
-                                                        horizontal ? TopDown : FromLeft, option->palette.button());
-                        }
-                    }
-                    // Details
-                    QImage addButton;
-                    if (horizontal) {
-                        addButton = QImage(reverse ? qt_scrollbar_button_left : qt_scrollbar_button_right);
-                    } else {
-                        addButton = QImage(qt_scrollbar_button_down);
-                    }
-                    addButton.setColor(1, alphaCornerColor.rgba());
-                    addButton.setColor(2, darkOutline.rgba());
-                    if ((scrollBar->activeSubControls & SC_ScrollBarAddLine) && sunken) {
-                        addButton.setColor(3, gradientStopColor.darker(140).rgba());
-                        addButton.setColor(4, gradientStopColor.darker(120).rgba());
-                    } else {
-                        addButton.setColor(3, gradientStartColor.lighter(105).rgba());
-                        addButton.setColor(4, gradientStopColor.rgba());
-                    }
-                    addButton.setColor(5, scrollBar->palette.text().color().rgba());
-                    painter->drawImage(pixmapRect, addButton);
-
-                    PrimitiveElement arrow;
-                    if (option->state & State_Horizontal)
-                        arrow = option->direction == Qt::LeftToRight ? PE_IndicatorArrowRight : PE_IndicatorArrowLeft;
-                    else
-                        arrow = PE_IndicatorArrowDown;
-
-                    QStyleOption arrowOpt = *option;
-                    arrowOpt.rect = scrollBarAddLine.adjusted(3, 3, -2, -2);
-                    proxy()->drawPrimitive(arrow, &arrowOpt, painter, widget);
-                }
-            }
-        }
-        painter->restore();
+		drawScrollBar<QStyleOptionSlider>(option, control, widget, grooveColor, darkOutline, gradientStartColor, gradientStopColor, gripShadow, palette, alphaCornerColor, painter, proxy());
+        break;;
+    case CC_ScrollBar64:
+		drawScrollBar<QStyleOptionSlider64>(option, control, widget, grooveColor, darkOutline, gradientStartColor, gradientStopColor, gripShadow, palette, alphaCornerColor, painter, proxy());
         break;;
 #endif // QT_NO_SCROLLBAR
 #ifndef QT_NO_COMBOBOX
@@ -3422,255 +3685,10 @@ void QCleanlooksStyle::drawComplexControl(ComplexControl control, const QStyleOp
 #endif // QT_NO_GROUPBOX
 #ifndef QT_NO_SLIDER
     case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            QRect groove = proxy()->subControlRect(CC_Slider, option, SC_SliderGroove, widget);
-            QRect handle = proxy()->subControlRect(CC_Slider, option, SC_SliderHandle, widget);
-
-            bool horizontal = slider->orientation == Qt::Horizontal;
-            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
-            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
-            QColor activeHighlight = option->palette.color(QPalette::Normal, QPalette::Highlight);
-            QPixmap cache;
-
-            QBrush oldBrush = painter->brush();
-            QPen oldPen = painter->pen();
-
-            QColor shadowAlpha(Qt::black);
-            shadowAlpha.setAlpha(10);
-            QColor highlightAlpha(Qt::white);
-            highlightAlpha.setAlpha(80);
-
-            if ((option->subControls & SC_SliderGroove) && groove.isValid()) {
-                QString groovePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_groove"), option, groove.size());
-                QRect pixmapRect(0, 0, groove.width(), groove.height());
-
-                // draw background groove
-                if (!QPixmapCache::find(groovePixmapName, cache)) {
-                    cache = QPixmap(pixmapRect.size());
-                    cache.fill(Qt::transparent);
-                    QPainter groovePainter(&cache);
-
-                    groovePainter.setPen(shadowAlpha);
-                    groovePainter.drawLine(1, 0, groove.width(), 0);
-                    groovePainter.drawLine(0, 0, 0, groove.height() - 1);
-
-                    groovePainter.setPen(highlightAlpha);
-                    groovePainter.drawLine(1, groove.height() - 1, groove.width() - 1, groove.height() - 1);
-                    groovePainter.drawLine(groove.width() - 1, 1, groove.width() - 1, groove.height() - 1);
-                    QLinearGradient gradient;
-                    if (horizontal) {
-                        gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
-                        gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
-                    }
-                    else {
-                        gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
-                        gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
-                    }
-                    groovePainter.setPen(QPen(darkOutline.darker(110), 0));
-                    gradient.setColorAt(0, grooveColor.darker(110));//dark.lighter(120));
-                    gradient.setColorAt(1, grooveColor.lighter(110));//palette.button().color().darker(115));
-                    groovePainter.setBrush(gradient);
-                    groovePainter.drawRect(pixmapRect.adjusted(1, 1, -2, -2));
-                    groovePainter.end();
-                    QPixmapCache::insert(groovePixmapName, cache);
-                }
-                painter->drawPixmap(groove.topLeft(), cache);
-
-                // draw blue groove highlight
-                QRect clipRect;
-                groovePixmapName += QLatin1String("_blue");
-                if (!QPixmapCache::find(groovePixmapName, cache)) {
-                    cache = QPixmap(pixmapRect.size());
-                    cache.fill(Qt::transparent);
-                    QPainter groovePainter(&cache);
-                    QLinearGradient gradient;
-                    if (horizontal) {
-                        gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
-                        gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
-                    }
-                    else {
-                        gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
-                        gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
-                    }
-                    groovePainter.setPen(QPen(activeHighlight.darker(150), 0));
-                    gradient.setColorAt(0, activeHighlight.darker(120));
-                    gradient.setColorAt(1, activeHighlight.lighter(160));
-                    groovePainter.setBrush(gradient);
-                    groovePainter.drawRect(pixmapRect.adjusted(1, 1, -2, -2));
-                    groovePainter.end();
-                    QPixmapCache::insert(groovePixmapName, cache);
-                }
-                if (horizontal) {
-                    if (slider->upsideDown)
-                        clipRect = QRect(handle.right(), groove.top(), groove.right() - handle.right(), groove.height());
-                    else
-                        clipRect = QRect(groove.left(), groove.top(), handle.left(), groove.height());
-                } else {
-                    if (slider->upsideDown)
-                        clipRect = QRect(groove.left(), handle.bottom(), groove.width(), groove.height() - handle.bottom());
-                    else
-                        clipRect = QRect(groove.left(), groove.top(), groove.width(), handle.top() - groove.top());
-                }
-                painter->save();
-                painter->setClipRect(clipRect.adjusted(0, 0, 1, 1));
-                painter->drawPixmap(groove.topLeft(), cache);
-                painter->restore();
-            }
-
-            // draw handle
-            if ((option->subControls & SC_SliderHandle) ) {
-                QString handlePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_handle"), option, handle.size());
-                if (!QPixmapCache::find(handlePixmapName, cache)) {
-                    cache = QPixmap(handle.size());
-                    cache.fill(Qt::transparent);
-                    QRect pixmapRect(0, 0, handle.width(), handle.height());
-                    QPainter handlePainter(&cache);
-
-                    QColor gradientStartColor = mergedColors(option->palette.button().color().lighter(155),
-                                                             dark.lighter(155), 50);
-                    QColor gradientStopColor = gradientStartColor.darker(108);
-                    QRect gradRect = pixmapRect.adjusted(2, 2, -2, -2);
-
-                    QColor gradientBgStartColor = gradientStartColor;
-                    QColor gradientBgStopColor = gradientStopColor;
-
-                    QColor outline = option->state & State_Enabled ? dark : dark.lighter(130);
-                    if (option->state & State_Enabled && option->activeSubControls & SC_SliderHandle) {
-                        gradientBgStartColor = option->palette.highlight().color().lighter(180);
-                        gradientBgStopColor = option->palette.highlight().color().lighter(110);
-                        outline = option->palette.highlight().color().darker(130);
-                    }
-
-                    // gradient fill
-                    QRect r = pixmapRect.adjusted(1, 1, -1, -1);
-
-                    qt_cleanlooks_draw_gradient(&handlePainter, gradRect,
-                                                gradientBgStartColor,
-                                                gradientBgStopColor,
-                                                horizontal ? TopDown : FromLeft, option->palette.button());
-
-                    handlePainter.setPen(QPen(outline.darker(110), 1));
-                    handlePainter.drawLine(QPoint(r.left(), r.top() + 3), QPoint(r.left(), r.bottom() - 3));
-                    handlePainter.drawLine(QPoint(r.right(), r.top() + 3), QPoint(r.right(), r.bottom() - 3));
-                    handlePainter.drawLine(QPoint(r.left() + 3, r.bottom()), QPoint(r.right() - 3, r.bottom()));
-
-                    handlePainter.save();
-                    handlePainter.setRenderHint(QPainter::Antialiasing);
-                    handlePainter.translate(0.5, 0.5);
-                    const QLine lines[4] = {
-                        QLine(QPoint(r.left(), r.bottom() - 2), QPoint(r.left() + 2, r.bottom())),
-                        QLine(QPoint(r.left(), r.top() + 2), QPoint(r.left() + 2, r.top())),
-                        QLine(QPoint(r.right(), r.bottom() - 2), QPoint(r.right() - 2, r.bottom())),
-                        QLine(QPoint(r.right(), r.top() + 2), QPoint(r.right() - 2, r.top()))
-                    };
-                    handlePainter.drawLines(lines, 4);
-                    handlePainter.restore();;
-                    handlePainter.setPen(QPen(outline.darker(130), 1));
-                    handlePainter.drawLine(QPoint(r.left() + 3, r.top()), QPoint(r.right() - 3, r.top()));
-                    QColor cornerAlpha = outline.darker(120);
-                    cornerAlpha.setAlpha(80);
-
-                    handlePainter.setPen(cornerAlpha);
-                    if (horizontal) {
-                        handlePainter.drawLine(QPoint(r.left() + 6, r.top()), QPoint(r.left() + 6, r.bottom()));
-                        handlePainter.drawLine(QPoint(r.right() - 6, r.top()), QPoint(r.right() - 6, r.bottom()));
-                    } else {
-                        handlePainter.drawLine(QPoint(r.left(), r.top() + 6), QPoint(r.right(), r.top() + 6));
-                        handlePainter.drawLine(QPoint(r.left(), r.bottom() - 6), QPoint(r.right(), r.bottom() - 6));
-                    }
-
-                    //handle shadow
-                    handlePainter.setPen(shadowAlpha);
-                    handlePainter.drawLine(QPoint(r.left() + 2, r.bottom() + 1), QPoint(r.right() - 2, r.bottom() + 1));
-                    handlePainter.drawLine(QPoint(r.right() + 1, r.bottom() - 3), QPoint(r.right() + 1, r.top() + 4));
-                    handlePainter.drawLine(QPoint(r.right() - 1, r.bottom()), QPoint(r.right() + 1, r.bottom() - 2));
-
-                    qt_cleanlooks_draw_gradient(&handlePainter, horizontal ?
-                        gradRect.adjusted(6, 0, -6, 0) : gradRect.adjusted(0, 6, 0, -6),
-                        gradientStartColor,
-                        gradientStopColor.darker(106),
-                        horizontal ? TopDown : FromLeft,
-                        option->palette.button());
-
-                    //draw grips
-                    for (int i = -3; i< 6 ; i += 3) {
-                        for (int j = -3; j< 6 ; j += 3) {
-                            handlePainter.fillRect(r.center().x() + i, r.center().y() + j, 2, 2, highlightAlpha);
-                            handlePainter.setPen(gripShadow);
-                            handlePainter.drawPoint(r.center().x() + i, r.center().y() + j );
-                        }
-                    }
-                    handlePainter.end();
-                    QPixmapCache::insert(handlePixmapName, cache);
-                }
-
-                painter->drawPixmap(handle.topLeft(), cache);
-
-                if (slider->state & State_HasFocus) {
-                    QStyleOptionFocusRect fropt;
-                    fropt.QStyleOption::operator=(*slider);
-                    fropt.rect = slider->rect;
-                    proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
-                }
-            }
-            if (option->subControls & SC_SliderTickmarks) {
-                painter->setPen(darkOutline);
-                int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
-                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
-                int interval = slider->tickInterval;
-                if (interval <= 0) {
-                    interval = slider->singleStep;
-                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
-                                                        available)
-                        - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                        0, available) < 3)
-                        interval = slider->pageStep;
-                }
-                if (interval <= 0)
-                    interval = 1;
-
-                int v = slider->minimum;
-                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
-                while (v <= slider->maximum + 1) {
-                    if (v == slider->maximum + 1 && interval == 1)
-                        break;
-                    const int v_ = qMin(v, slider->maximum);
-                    int pos = sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                    v_, (horizontal
-                                                        ? slider->rect.width()
-                                                        : slider->rect.height()) - len,
-                                                    slider->upsideDown) + len / 2;
-                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
-
-                    if (horizontal) {
-                        if (ticksAbove) {
-                            painter->drawLine(pos, slider->rect.top() + extra,
-                                pos, slider->rect.top() + tickSize);
-                        }
-                        if (ticksBelow) {
-                            painter->drawLine(pos, slider->rect.bottom() - extra,
-                                            pos, slider->rect.bottom() - tickSize);
-                        }
-                    } else {
-                        if (ticksAbove) {
-                            painter->drawLine(slider->rect.left() + extra, pos,
-                                            slider->rect.left() + tickSize, pos);
-                        }
-                        if (ticksBelow) {
-                            painter->drawLine(slider->rect.right() - extra, pos,
-                                            slider->rect.right() - tickSize, pos);
-                        }
-                    }
-                    // in the case where maximum is max int
-                    int nextInterval = v + interval;
-                    if (nextInterval < v)
-                        break;
-                    v = nextInterval;
-                }
-            }
-            painter->setBrush(oldBrush);
-            painter->setPen(oldPen);
-        }
+		drawSlider<QStyleOptionSlider>(option, widget, darkOutline, grooveColor, dark, gripShadow, painter, proxy());
+        break;
+    case CC_Slider64:
+		drawSlider<QStyleOptionSlider64>(option, widget, darkOutline, grooveColor, dark, gripShadow, painter, proxy());
         break;
 #endif // QT_NO_SLIDER
 #ifndef QT_NO_DIAL
@@ -3980,6 +3998,58 @@ void QCleanlooksStyle::unpolish(QApplication *app)
     QWindowsStyle::unpolish(app);
 }
 
+template <class OptionSlider>
+static void subControlRectSlider(const QStyleOptionComplex* option, const QWidget* widget, QCleanlooksStyle::SubControl subControl, QRect& rect, const QStyle* proxy)
+{
+	if (const OptionSlider *slider = qstyleoption_cast<const OptionSlider*>(option)) {
+		int tickSize = proxy->pixelMetric(QCleanlooksStyle::PM_SliderTickmarkOffset, option, widget);
+		switch (subControl) {
+		case QCleanlooksStyle::SC_SliderHandle: {
+			if (slider->orientation == Qt::Horizontal) {
+				rect.setHeight(proxy->pixelMetric(QCleanlooksStyle::PM_SliderThickness));
+				rect.setWidth(proxy->pixelMetric(QCleanlooksStyle::PM_SliderLength));
+				int centerY = slider->rect.center().y() - rect.height() / 2;
+				if (slider->tickPosition & QSlider::TicksAbove)
+					centerY += tickSize;
+				if (slider->tickPosition & QSlider::TicksBelow)
+					centerY -= tickSize;
+				rect.moveTop(centerY);
+			} else {
+				rect.setWidth(proxy->pixelMetric(QCleanlooksStyle::PM_SliderThickness));
+				rect.setHeight(proxy->pixelMetric(QCleanlooksStyle::PM_SliderLength));
+				int centerX = slider->rect.center().x() - rect.width() / 2;
+				if (slider->tickPosition & QSlider::TicksAbove)
+					centerX += tickSize;
+				if (slider->tickPosition & QSlider::TicksBelow)
+					centerX -= tickSize;
+				rect.moveLeft(centerX);
+			}
+		}
+			break;
+		case QCleanlooksStyle::SC_SliderGroove: {
+			QPoint grooveCenter = slider->rect.center();
+			if (slider->orientation == Qt::Horizontal) {
+				rect.setHeight(7);
+				if (slider->tickPosition & QSlider::TicksAbove)
+					grooveCenter.ry() += tickSize;
+				if (slider->tickPosition & QSlider::TicksBelow)
+					grooveCenter.ry() -= tickSize;
+			} else {
+				rect.setWidth(7);
+				if (slider->tickPosition & QSlider::TicksAbove)
+					grooveCenter.rx() += tickSize;
+				if (slider->tickPosition & QSlider::TicksBelow)
+					grooveCenter.rx() -= tickSize;
+			}
+			rect.moveCenter(grooveCenter);
+			break;
+		}
+		default:
+			break;
+		}
+	}
+}
+
 /*!
   \reimp
 */
@@ -3991,56 +4061,14 @@ QRect QCleanlooksStyle::subControlRect(ComplexControl control, const QStyleOptio
     switch (control) {
 #ifndef QT_NO_SLIDER
     case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
-            switch (subControl) {
-            case SC_SliderHandle: {
-                if (slider->orientation == Qt::Horizontal) {
-                    rect.setHeight(proxy()->pixelMetric(PM_SliderThickness));
-                    rect.setWidth(proxy()->pixelMetric(PM_SliderLength));
-                    int centerY = slider->rect.center().y() - rect.height() / 2;
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        centerY += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        centerY -= tickSize;
-                    rect.moveTop(centerY);
-                } else {
-                    rect.setWidth(proxy()->pixelMetric(PM_SliderThickness));
-                    rect.setHeight(proxy()->pixelMetric(PM_SliderLength));
-                    int centerX = slider->rect.center().x() - rect.width() / 2;
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        centerX += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        centerX -= tickSize;
-                    rect.moveLeft(centerX);
-                }
-            }
-                break;
-            case SC_SliderGroove: {
-                QPoint grooveCenter = slider->rect.center();
-                if (slider->orientation == Qt::Horizontal) {
-                    rect.setHeight(7);
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        grooveCenter.ry() += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        grooveCenter.ry() -= tickSize;
-                } else {
-                    rect.setWidth(7);
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        grooveCenter.rx() += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        grooveCenter.rx() -= tickSize;
-                }
-                rect.moveCenter(grooveCenter);
-                break;
-            }
-            default:
-                break;
-            }
-        }
+		subControlRectSlider<QStyleOptionSlider>(option, widget, subControl, rect, proxy());
+        break;
+    case CC_Slider64:
+		subControlRectSlider<QStyleOptionSlider64>(option, widget, subControl, rect, proxy());
         break;
 #endif // QT_NO_SLIDER
     case CC_ScrollBar:
+    case CC_ScrollBar64:
         break;
 #ifndef QT_NO_SPINBOX
     case CC_SpinBox:
diff --git a/src/gui/styles/qcommonstyle.cpp b/src/gui/styles/qcommonstyle.cpp
index 1e5b7a9..c406dfd 100644
--- a/src/gui/styles/qcommonstyle.cpp
+++ b/src/gui/styles/qcommonstyle.cpp
@@ -3092,6 +3092,153 @@ static QPolygonF calcArrow(const QStyleOptionSlider *dial, qreal &a)
 
 #endif // QT_NO_DIAL
 
+template <class OptionSlider>
+static void drawSlider(const QStyleOptionComplex* opt, const QWidget* widget, QPainter* p, const QStyle* proxy)
+{
+	if (const OptionSlider *slider = qstyleoption_cast<const OptionSlider*>(opt)) {
+		if (slider->subControls == QCommonStyle::SC_SliderTickmarks) {
+			int tickOffset = proxy->pixelMetric(QCommonStyle::PM_SliderTickmarkOffset, slider, widget);
+			int ticks = slider->tickPosition;
+			int thickness = proxy->pixelMetric(QCommonStyle::PM_SliderControlThickness, slider, widget);
+			int len = proxy->pixelMetric(QCommonStyle::PM_SliderLength, slider, widget);
+			qint64 available = proxy->pixelMetric(QCommonStyle::PM_SliderSpaceAvailable, slider, widget);
+			qint64 interval = slider->tickInterval;
+			if (interval <= 0) {
+				interval = slider->singleStep;
+				if (QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum, interval,
+													available)
+					- QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum,
+													  (qint64) 0, available) < 3)
+					interval = slider->pageStep;
+			}
+			if (!interval)
+				interval = 1;
+			int fudge = len / 2;
+			qint64 pos;
+			// Since there is no subrect for tickmarks do a translation here.
+			p->save();
+			p->translate(slider->rect.x(), slider->rect.y());
+			p->setPen(slider->palette.foreground().color());
+			qint64 v = slider->minimum;
+			while (v <= slider->maximum + 1) {
+				if (v == slider->maximum + 1 && interval == 1)
+					break;
+				const qint64 v_ = qMin(v, (qint64) slider->maximum);
+				pos = QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum,
+													  v_, available) + fudge;
+				if (slider->orientation == Qt::Horizontal) {
+					if (ticks & QSlider::TicksAbove)
+						p->drawLine(pos, 0, pos, tickOffset - 2);
+					if (ticks & QSlider::TicksBelow)
+						p->drawLine(pos, tickOffset + thickness + 1, pos,
+									slider->rect.height()-1);
+				} else {
+					if (ticks & QSlider::TicksAbove)
+						p->drawLine(0, pos, tickOffset - 2, pos);
+					if (ticks & QSlider::TicksBelow)
+						p->drawLine(tickOffset + thickness + 1, pos,
+									slider->rect.width()-1, pos);
+				}
+				// in the case where maximum is max int
+				qint64 nextInterval = v + interval;
+				if (nextInterval < v)
+					break;
+				v = nextInterval;
+			}
+			p->restore();
+		}
+	}
+}
+
+template <class OptionStyle>
+static void drawScrollBar(const QStyleOptionComplex* opt, QCommonStyle::ComplexControl cc, const QWidget* widget, QPainter* p, QStyle const* proxy)
+{
+	if (const OptionStyle *scrollbar = qstyleoption_cast<const OptionStyle *>(opt)) {
+		// Make a copy here and reset it for each primitive.
+		OptionStyle newScrollbar = *scrollbar;
+		QCommonStyle::State saveFlags = scrollbar->state;
+
+		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarSubLine) {
+			newScrollbar.state = saveFlags;
+			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarSubLine, widget);
+			if (newScrollbar.rect.isValid()) {
+				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarSubLine))
+					newScrollbar.state &= ~(QCommonStyle::QCommonStyle::State_Sunken | QCommonStyle::QCommonStyle::State_MouseOver);
+				proxy->drawControl(QCommonStyle::QCommonStyle::CE_ScrollBarSubLine, &newScrollbar, p, widget);
+			}
+		}
+		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarAddLine) {
+			newScrollbar.rect = scrollbar->rect;
+			newScrollbar.state = saveFlags;
+			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarAddLine, widget);
+			if (newScrollbar.rect.isValid()) {
+				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarAddLine))
+					newScrollbar.state &= ~(QCommonStyle::QCommonStyle::State_Sunken | QCommonStyle::QCommonStyle::State_MouseOver);
+				proxy->drawControl(QCommonStyle::QCommonStyle::CE_ScrollBarAddLine, &newScrollbar, p, widget);
+			}
+		}
+		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarSubPage) {
+			newScrollbar.rect = scrollbar->rect;
+			newScrollbar.state = saveFlags;
+			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarSubPage, widget);
+			if (newScrollbar.rect.isValid()) {
+				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarSubPage))
+					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
+				proxy->drawControl(QCommonStyle::CE_ScrollBarSubPage, &newScrollbar, p, widget);
+			}
+		}
+		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarAddPage) {
+			newScrollbar.rect = scrollbar->rect;
+			newScrollbar.state = saveFlags;
+			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarAddPage, widget);
+			if (newScrollbar.rect.isValid()) {
+				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarAddPage))
+					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
+				proxy->drawControl(QCommonStyle::CE_ScrollBarAddPage, &newScrollbar, p, widget);
+			}
+		}
+		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarFirst) {
+			newScrollbar.rect = scrollbar->rect;
+			newScrollbar.state = saveFlags;
+			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarFirst, widget);
+			if (newScrollbar.rect.isValid()) {
+				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarFirst))
+					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
+				proxy->drawControl(QCommonStyle::CE_ScrollBarFirst, &newScrollbar, p, widget);
+			}
+		}
+		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarLast) {
+			newScrollbar.rect = scrollbar->rect;
+			newScrollbar.state = saveFlags;
+			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarLast, widget);
+			if (newScrollbar.rect.isValid()) {
+				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarLast))
+					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
+				proxy->drawControl(QCommonStyle::CE_ScrollBarLast, &newScrollbar, p, widget);
+			}
+		}
+		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarSlider) {
+			newScrollbar.rect = scrollbar->rect;
+			newScrollbar.state = saveFlags;
+			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarSlider, widget);
+			if (newScrollbar.rect.isValid()) {
+				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarSlider))
+					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
+				proxy->drawControl(QCommonStyle::CE_ScrollBarSlider, &newScrollbar, p, widget);
+
+				if (scrollbar->state & QCommonStyle::State_HasFocus) {
+					QStyleOptionFocusRect fropt;
+					fropt.QStyleOption::operator=(newScrollbar);
+					fropt.rect.setRect(newScrollbar.rect.x() + 2, newScrollbar.rect.y() + 2,
+									   newScrollbar.rect.width() - 5,
+									   newScrollbar.rect.height() - 5);
+					proxy->drawPrimitive(QCommonStyle::PE_FrameFocusRect, &fropt, p, widget);
+				}
+			}
+		}
+	}
+}
+
 /*!
   \reimp
 */
@@ -3101,147 +3248,18 @@ void QCommonStyle::drawComplexControl(ComplexControl cc, const QStyleOptionCompl
     switch (cc) {
 #ifndef QT_NO_SLIDER
     case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
-            if (slider->subControls == SC_SliderTickmarks) {
-                int tickOffset = proxy()->pixelMetric(PM_SliderTickmarkOffset, slider, widget);
-                int ticks = slider->tickPosition;
-                int thickness = proxy()->pixelMetric(PM_SliderControlThickness, slider, widget);
-                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
-                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
-                int interval = slider->tickInterval;
-                if (interval <= 0) {
-                    interval = slider->singleStep;
-                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
-                                                        available)
-                        - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                          0, available) < 3)
-                        interval = slider->pageStep;
-                }
-                if (!interval)
-                    interval = 1;
-                int fudge = len / 2;
-                int pos;
-                // Since there is no subrect for tickmarks do a translation here.
-                p->save();
-                p->translate(slider->rect.x(), slider->rect.y());
-                p->setPen(slider->palette.foreground().color());
-                int v = slider->minimum;
-                while (v <= slider->maximum + 1) {
-                    if (v == slider->maximum + 1 && interval == 1)
-                        break;
-                    const int v_ = qMin(v, slider->maximum);
-                    pos = QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                          v_, available) + fudge;
-                    if (slider->orientation == Qt::Horizontal) {
-                        if (ticks & QSlider::TicksAbove)
-                            p->drawLine(pos, 0, pos, tickOffset - 2);
-                        if (ticks & QSlider::TicksBelow)
-                            p->drawLine(pos, tickOffset + thickness + 1, pos,
-                                        slider->rect.height()-1);
-                    } else {
-                        if (ticks & QSlider::TicksAbove)
-                            p->drawLine(0, pos, tickOffset - 2, pos);
-                        if (ticks & QSlider::TicksBelow)
-                            p->drawLine(tickOffset + thickness + 1, pos,
-                                        slider->rect.width()-1, pos);
-                    }
-                    // in the case where maximum is max int
-                    int nextInterval = v + interval;
-                    if (nextInterval < v)
-                        break;
-                    v = nextInterval;
-                }
-                p->restore();
-            }
-        }
+		drawSlider<QStyleOptionSlider>(opt, widget, p, proxy());
+        break;
+    case CC_Slider64:
+		drawSlider<QStyleOptionSlider64>(opt, widget, p, proxy());
         break;
 #endif // QT_NO_SLIDER
 #ifndef QT_NO_SCROLLBAR
     case CC_ScrollBar:
-        if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
-            // Make a copy here and reset it for each primitive.
-            QStyleOptionSlider newScrollbar = *scrollbar;
-            State saveFlags = scrollbar->state;
-
-            if (scrollbar->subControls & SC_ScrollBarSubLine) {
-                newScrollbar.state = saveFlags;
-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarSubLine, widget);
-                if (newScrollbar.rect.isValid()) {
-                    if (!(scrollbar->activeSubControls & SC_ScrollBarSubLine))
-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
-                    proxy()->drawControl(CE_ScrollBarSubLine, &newScrollbar, p, widget);
-                }
-            }
-            if (scrollbar->subControls & SC_ScrollBarAddLine) {
-                newScrollbar.rect = scrollbar->rect;
-                newScrollbar.state = saveFlags;
-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarAddLine, widget);
-                if (newScrollbar.rect.isValid()) {
-                    if (!(scrollbar->activeSubControls & SC_ScrollBarAddLine))
-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
-                    proxy()->drawControl(CE_ScrollBarAddLine, &newScrollbar, p, widget);
-                }
-            }
-            if (scrollbar->subControls & SC_ScrollBarSubPage) {
-                newScrollbar.rect = scrollbar->rect;
-                newScrollbar.state = saveFlags;
-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarSubPage, widget);
-                if (newScrollbar.rect.isValid()) {
-                    if (!(scrollbar->activeSubControls & SC_ScrollBarSubPage))
-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
-                    proxy()->drawControl(CE_ScrollBarSubPage, &newScrollbar, p, widget);
-                }
-            }
-            if (scrollbar->subControls & SC_ScrollBarAddPage) {
-                newScrollbar.rect = scrollbar->rect;
-                newScrollbar.state = saveFlags;
-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarAddPage, widget);
-                if (newScrollbar.rect.isValid()) {
-                    if (!(scrollbar->activeSubControls & SC_ScrollBarAddPage))
-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
-                    proxy()->drawControl(CE_ScrollBarAddPage, &newScrollbar, p, widget);
-                }
-            }
-            if (scrollbar->subControls & SC_ScrollBarFirst) {
-                newScrollbar.rect = scrollbar->rect;
-                newScrollbar.state = saveFlags;
-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarFirst, widget);
-                if (newScrollbar.rect.isValid()) {
-                    if (!(scrollbar->activeSubControls & SC_ScrollBarFirst))
-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
-                    proxy()->drawControl(CE_ScrollBarFirst, &newScrollbar, p, widget);
-                }
-            }
-            if (scrollbar->subControls & SC_ScrollBarLast) {
-                newScrollbar.rect = scrollbar->rect;
-                newScrollbar.state = saveFlags;
-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarLast, widget);
-                if (newScrollbar.rect.isValid()) {
-                    if (!(scrollbar->activeSubControls & SC_ScrollBarLast))
-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
-                    proxy()->drawControl(CE_ScrollBarLast, &newScrollbar, p, widget);
-                }
-            }
-            if (scrollbar->subControls & SC_ScrollBarSlider) {
-                newScrollbar.rect = scrollbar->rect;
-                newScrollbar.state = saveFlags;
-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarSlider, widget);
-                if (newScrollbar.rect.isValid()) {
-                    if (!(scrollbar->activeSubControls & SC_ScrollBarSlider))
-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
-                    proxy()->drawControl(CE_ScrollBarSlider, &newScrollbar, p, widget);
-
-                    if (scrollbar->state & State_HasFocus) {
-                        QStyleOptionFocusRect fropt;
-                        fropt.QStyleOption::operator=(newScrollbar);
-                        fropt.rect.setRect(newScrollbar.rect.x() + 2, newScrollbar.rect.y() + 2,
-                                           newScrollbar.rect.width() - 5,
-                                           newScrollbar.rect.height() - 5);
-                        proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, p, widget);
-                    }
-                }
-            }
-        }
+		drawScrollBar<QStyleOptionSlider>(opt, cc, widget, p, proxy());
+        break;
+    case CC_ScrollBar64:
+		drawScrollBar<QStyleOptionSlider64>(opt, cc, widget, p, proxy());
         break;
 #endif // QT_NO_SCROLLBAR
 #ifdef QT3_SUPPORT
@@ -3781,6 +3799,90 @@ void QCommonStyle::drawComplexControl(ComplexControl cc, const QStyleOptionCompl
     }
 }
 
+template <class OptionStyle>
+void hitTestComplexControlScrollbar(const QStyleOptionComplex* opt, const QWidget* widget, QCommonStyle::SubControl sc, QRect& ret, QStyle const* proxy)
+{
+	if (const OptionStyle *scrollbar = qstyleoption_cast<const OptionStyle *>(opt)) {
+		const QRect scrollBarRect = scrollbar->rect;
+		int sbextent = proxy->pixelMetric(QCommonStyle::PM_ScrollBarExtent, scrollbar, widget);
+		qint64 maxlen = ((scrollbar->orientation == Qt::Horizontal) ?
+					  scrollBarRect.width() : scrollBarRect.height()) - (sbextent * 2);
+		qint64 sliderlen;
+
+		// calculate slider length
+		if (scrollbar->maximum != scrollbar->minimum) {
+			quint64 range = scrollbar->maximum - scrollbar->minimum;
+			sliderlen = (qint64(scrollbar->pageStep) * maxlen) / (range + scrollbar->pageStep);
+
+			qint64 slidermin = proxy->pixelMetric(QCommonStyle::PM_ScrollBarSliderMin, scrollbar, widget);
+			if (sliderlen < slidermin || range > INT_MAX / 2)
+				sliderlen = slidermin;
+			if (sliderlen > maxlen)
+				sliderlen = maxlen;
+		} else {
+			sliderlen = maxlen;
+		}
+
+		qint64 sliderstart = sbextent + QStyle::sliderPositionFromValue((qint64) scrollbar->minimum,
+															 (qint64) scrollbar->maximum,
+															 (qint64) scrollbar->sliderPosition,
+															 maxlen - sliderlen,
+															 scrollbar->upsideDown);
+
+		switch (sc) {
+		case QCommonStyle::SC_ScrollBarSubLine:            // top/left button
+			if (scrollbar->orientation == Qt::Horizontal) {
+				int buttonWidth = qMin(scrollBarRect.width() / 2, sbextent);
+				ret.setRect(0, 0, buttonWidth, scrollBarRect.height());
+			} else {
+				int buttonHeight = qMin(scrollBarRect.height() / 2, sbextent);
+				ret.setRect(0, 0, scrollBarRect.width(), buttonHeight);
+			}
+			break;
+		case QCommonStyle::SC_ScrollBarAddLine:            // bottom/right button
+			if (scrollbar->orientation == Qt::Horizontal) {
+				int buttonWidth = qMin(scrollBarRect.width()/2, sbextent);
+				ret.setRect(scrollBarRect.width() - buttonWidth, 0, buttonWidth, scrollBarRect.height());
+			} else {
+				int buttonHeight = qMin(scrollBarRect.height()/2, sbextent);
+				ret.setRect(0, scrollBarRect.height() - buttonHeight, scrollBarRect.width(), buttonHeight);
+			}
+			break;
+		case QCommonStyle::SC_ScrollBarSubPage:            // between top/left button and slider
+			if (scrollbar->orientation == Qt::Horizontal)
+				ret.setRect(sbextent, 0, sliderstart - sbextent, scrollBarRect.height());
+			else
+				ret.setRect(0, sbextent, scrollBarRect.width(), sliderstart - sbextent);
+			break;
+		case QCommonStyle::SC_ScrollBarAddPage:            // between bottom/right button and slider
+			if (scrollbar->orientation == Qt::Horizontal)
+				ret.setRect(sliderstart + sliderlen, 0,
+							maxlen - sliderstart - sliderlen + sbextent, scrollBarRect.height());
+			else
+				ret.setRect(0, sliderstart + sliderlen, scrollBarRect.width(),
+							maxlen - sliderstart - sliderlen + sbextent);
+			break;
+		case QCommonStyle::SC_ScrollBarGroove:
+			if (scrollbar->orientation == Qt::Horizontal)
+				ret.setRect(sbextent, 0, scrollBarRect.width() - sbextent * 2,
+							scrollBarRect.height());
+			else
+				ret.setRect(0, sbextent, scrollBarRect.width(),
+							scrollBarRect.height() - sbextent * 2);
+			break;
+		case QCommonStyle::SC_ScrollBarSlider:
+			if (scrollbar->orientation == Qt::Horizontal)
+				ret.setRect(sliderstart, 0, sliderlen, scrollBarRect.height());
+			else
+				ret.setRect(0, sliderstart, scrollBarRect.width(), sliderlen);
+			break;
+		default:
+			break;
+		}
+		ret = QStyle::visualRect(scrollbar->direction, scrollBarRect, ret);
+	}
+}
+
 /*!
     \reimp
 */
@@ -3805,11 +3907,12 @@ QStyle::SubControl QCommonStyle::hitTestComplexControl(ComplexControl cc, const
 #endif // QT_NO_SLIDER
 #ifndef QT_NO_SCROLLBAR
     case CC_ScrollBar:
-        if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+    case CC_ScrollBar64:
+        if (qstyleoption_cast<const QStyleOptionSlider *>(opt) || qstyleoption_cast<const QStyleOptionSlider64 *>(opt)) {
             QRect r;
             uint ctrl = SC_ScrollBarAddLine;
             while (ctrl <= SC_ScrollBarGroove) {
-                r = proxy()->subControlRect(cc, scrollbar, QStyle::SubControl(ctrl), widget);
+                r = proxy()->subControlRect(cc, opt, QStyle::SubControl(ctrl), widget);
                 if (r.isValid() && r.contains(pt)) {
                     sc = QStyle::SubControl(ctrl);
                     break;
@@ -3972,85 +4075,10 @@ QRect QCommonStyle::subControlRect(ComplexControl cc, const QStyleOptionComplex
 #endif // QT_NO_SLIDER
 #ifndef QT_NO_SCROLLBAR
     case CC_ScrollBar:
-        if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
-            const QRect scrollBarRect = scrollbar->rect;
-            int sbextent = proxy()->pixelMetric(PM_ScrollBarExtent, scrollbar, widget);
-            int maxlen = ((scrollbar->orientation == Qt::Horizontal) ?
-                          scrollBarRect.width() : scrollBarRect.height()) - (sbextent * 2);
-            int sliderlen;
-
-            // calculate slider length
-            if (scrollbar->maximum != scrollbar->minimum) {
-                uint range = scrollbar->maximum - scrollbar->minimum;
-                sliderlen = (qint64(scrollbar->pageStep) * maxlen) / (range + scrollbar->pageStep);
-
-                int slidermin = proxy()->pixelMetric(PM_ScrollBarSliderMin, scrollbar, widget);
-                if (sliderlen < slidermin || range > INT_MAX / 2)
-                    sliderlen = slidermin;
-                if (sliderlen > maxlen)
-                    sliderlen = maxlen;
-            } else {
-                sliderlen = maxlen;
-            }
-
-            int sliderstart = sbextent + sliderPositionFromValue(scrollbar->minimum,
-                                                                 scrollbar->maximum,
-                                                                 scrollbar->sliderPosition,
-                                                                 maxlen - sliderlen,
-                                                                 scrollbar->upsideDown);
-
-            switch (sc) {
-            case SC_ScrollBarSubLine:            // top/left button
-                if (scrollbar->orientation == Qt::Horizontal) {
-                    int buttonWidth = qMin(scrollBarRect.width() / 2, sbextent);
-                    ret.setRect(0, 0, buttonWidth, scrollBarRect.height());
-                } else {
-                    int buttonHeight = qMin(scrollBarRect.height() / 2, sbextent);
-                    ret.setRect(0, 0, scrollBarRect.width(), buttonHeight);
-                }
-                break;
-            case SC_ScrollBarAddLine:            // bottom/right button
-                if (scrollbar->orientation == Qt::Horizontal) {
-                    int buttonWidth = qMin(scrollBarRect.width()/2, sbextent);
-                    ret.setRect(scrollBarRect.width() - buttonWidth, 0, buttonWidth, scrollBarRect.height());
-                } else {
-                    int buttonHeight = qMin(scrollBarRect.height()/2, sbextent);
-                    ret.setRect(0, scrollBarRect.height() - buttonHeight, scrollBarRect.width(), buttonHeight);
-                }
-                break;
-            case SC_ScrollBarSubPage:            // between top/left button and slider
-                if (scrollbar->orientation == Qt::Horizontal)
-                    ret.setRect(sbextent, 0, sliderstart - sbextent, scrollBarRect.height());
-                else
-                    ret.setRect(0, sbextent, scrollBarRect.width(), sliderstart - sbextent);
-                break;
-            case SC_ScrollBarAddPage:            // between bottom/right button and slider
-                if (scrollbar->orientation == Qt::Horizontal)
-                    ret.setRect(sliderstart + sliderlen, 0,
-                                maxlen - sliderstart - sliderlen + sbextent, scrollBarRect.height());
-                else
-                    ret.setRect(0, sliderstart + sliderlen, scrollBarRect.width(),
-                                maxlen - sliderstart - sliderlen + sbextent);
-                break;
-            case SC_ScrollBarGroove:
-                if (scrollbar->orientation == Qt::Horizontal)
-                    ret.setRect(sbextent, 0, scrollBarRect.width() - sbextent * 2,
-                                scrollBarRect.height());
-                else
-                    ret.setRect(0, sbextent, scrollBarRect.width(),
-                                scrollBarRect.height() - sbextent * 2);
-                break;
-            case SC_ScrollBarSlider:
-                if (scrollbar->orientation == Qt::Horizontal)
-                    ret.setRect(sliderstart, 0, sliderlen, scrollBarRect.height());
-                else
-                    ret.setRect(0, sliderstart, scrollBarRect.width(), sliderlen);
-                break;
-            default:
-                break;
-            }
-            ret = visualRect(scrollbar->direction, scrollBarRect, ret);
-        }
+		hitTestComplexControlScrollbar<QStyleOptionSlider>(opt, widget, sc, ret, proxy());
+        break;
+    case CC_ScrollBar64:
+		hitTestComplexControlScrollbar<QStyleOptionSlider64>(opt, widget, sc, ret, proxy());
         break;
 #endif // QT_NO_SCROLLBAR
 #ifndef QT_NO_SPINBOX
diff --git a/src/gui/styles/qgtkstyle.cpp b/src/gui/styles/qgtkstyle.cpp
index 97756ca..300a149 100644
--- a/src/gui/styles/qgtkstyle.cpp
+++ b/src/gui/styles/qgtkstyle.cpp
@@ -1253,6 +1253,316 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
     }
 }
 
+template <class OptionStyle>
+static void drawSlider(QGtkStyle::ComplexControl control, const QStyleOptionComplex* option, const QGtkStylePrivate* const d, const QWidget* widget, QGtkPainter gtkPainter, QPainter* painter, GtkStyle* style, QStyle const* proxy)
+{
+	if (const OptionStyle *scrollBar = qstyleoption_cast<const OptionStyle *>(option)) {
+		GtkWidget *gtkHScrollBar = d->gtkWidget("GtkHScrollbar");
+		GtkWidget *gtkVScrollBar = d->gtkWidget("GtkVScrollbar");
+
+		// Fill background in case the scrollbar is partially transparent
+		painter->fillRect(option->rect, option->palette.background());
+
+		QRect rect = scrollBar->rect;
+		QRect scrollBarSubLine = proxy->subControlRect(control, scrollBar, QGtkStyle::SC_ScrollBarSubLine, widget);
+		QRect scrollBarAddLine = proxy->subControlRect(control, scrollBar, QGtkStyle::SC_ScrollBarAddLine, widget);
+		QRect scrollBarSlider = proxy->subControlRect(control, scrollBar, QGtkStyle::SC_ScrollBarSlider, widget);
+		QRect grooveRect = proxy->subControlRect(control, scrollBar, QGtkStyle::SC_ScrollBarGroove, widget);
+		bool horizontal = scrollBar->orientation == Qt::Horizontal;
+		GtkWidget * scrollbarWidget = horizontal ? gtkHScrollBar : gtkVScrollBar;
+		style = scrollbarWidget->style;
+		gboolean trough_under_steppers = true;
+		gboolean trough_side_details = false;
+		gboolean activate_slider = false;
+		gboolean stepper_size = 14;
+		gint trough_border = 1;
+		if (!d->gtk_check_version(2, 10, 0)) {
+			d->gtk_widget_style_get((GtkWidget*)(scrollbarWidget),
+									   "trough-border",   &trough_border,
+									   "trough-side-details",   &trough_side_details,
+									   "trough-under-steppers", &trough_under_steppers,
+									   "activate-slider",       &activate_slider,
+									   "stepper-size",          &stepper_size, NULL);
+		}
+		if (trough_under_steppers) {
+			scrollBarAddLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
+			scrollBarSubLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
+			scrollBarSlider.adjust(horizontal ? -trough_border : 0, horizontal ? 0 : -trough_border,
+								   horizontal ? trough_border : 0, horizontal ? 0 : trough_border);
+		}
+
+		// Some styles check the position of scrollbars in order to determine
+		// if lines should be painted when the scrollbar is in max or min positions.
+		qint64 maximum = 2;
+		qint64 fakePos = 0;
+		bool reverse = (option->direction == Qt::RightToLeft);
+		if (scrollBar->minimum == scrollBar->maximum)
+			maximum = 0;
+		if (scrollBar->sliderPosition == scrollBar->maximum)
+			fakePos = maximum;
+		else if (scrollBar->sliderPosition > scrollBar->minimum)
+			fakePos = maximum - 1;
+
+
+		GtkRange *range = (GtkRange*)(horizontal ? gtkHScrollBar : gtkVScrollBar);
+		GtkAdjustment *adjustment = d->gtk_range_get_adjustment(range);
+
+		if (adjustment) {
+			d->gtk_adjustment_configure(adjustment, fakePos, 0, maximum, 0, 0, 0);
+		} else {
+			adjustment = (GtkAdjustment*)d->gtk_adjustment_new(fakePos, 0, maximum, 0, 0, 0);
+			d->gtk_range_set_adjustment(range, adjustment);
+		}
+
+		if (scrollBar->subControls & QGtkStyle::SC_ScrollBarGroove) {
+			GtkStateType state = GTK_STATE_ACTIVE;
+
+			if (!(option->state & QGtkStyle::State_Enabled))
+				state = GTK_STATE_INSENSITIVE;
+
+			if (trough_under_steppers)
+				grooveRect = option->rect;
+
+			gtkPainter.paintBox( scrollbarWidget, "trough", grooveRect, state, GTK_SHADOW_IN, style);
+		}
+
+		//paint slider
+		if (scrollBar->subControls & QGtkStyle::SC_ScrollBarSlider) {
+			GtkStateType state = GTK_STATE_NORMAL;
+
+			if (!(option->state & QGtkStyle::State_Enabled))
+				state = GTK_STATE_INSENSITIVE;
+			else if (activate_slider &&
+					 option->state & QGtkStyle::State_Sunken && (scrollBar->activeSubControls & QGtkStyle::SC_ScrollBarSlider))
+				state = GTK_STATE_ACTIVE;
+			else if (option->state & QGtkStyle::State_MouseOver && (scrollBar->activeSubControls & QGtkStyle::SC_ScrollBarSlider))
+				state = GTK_STATE_PRELIGHT;
+
+			GtkShadowType shadow = GTK_SHADOW_OUT;
+
+			if (trough_under_steppers) {
+				if (!horizontal)
+					scrollBarSlider.adjust(trough_border, 0, -trough_border, 0);
+				else
+					scrollBarSlider.adjust(0, trough_border, 0, -trough_border);
+			}
+
+			gtkPainter.paintSlider( scrollbarWidget, "slider", scrollBarSlider, state, shadow, style,
+
+									horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL, QString(QLS("%0%1")).arg(fakePos).arg(maximum));
+		}
+
+		if (scrollBar->subControls & QGtkStyle::SC_ScrollBarAddLine) {
+			gtkVScrollBar->allocation.y = scrollBarAddLine.top();
+			gtkVScrollBar->allocation.height = scrollBarAddLine.height() - rect.height() + 6;
+			gtkHScrollBar->allocation.x = scrollBarAddLine.right();
+			gtkHScrollBar->allocation.width = scrollBarAddLine.width() - rect.width();
+
+			GtkShadowType shadow = GTK_SHADOW_OUT;
+			GtkStateType state = GTK_STATE_NORMAL;
+
+			if (!(option->state & QGtkStyle::State_Enabled) || (fakePos == maximum))
+				state = GTK_STATE_INSENSITIVE;
+			else if (option->state & QGtkStyle::State_Sunken && (scrollBar->activeSubControls & QGtkStyle::SC_ScrollBarAddLine)) {
+				state = GTK_STATE_ACTIVE;
+				shadow = GTK_SHADOW_IN;
+
+			} else if (option->state & QGtkStyle::State_MouseOver && (scrollBar->activeSubControls & QGtkStyle::SC_ScrollBarAddLine))
+				state = GTK_STATE_PRELIGHT;
+
+			gtkPainter.paintBox( scrollbarWidget,
+								 horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine,
+								 state, shadow, style, QLS("add"));
+
+			gtkPainter.paintArrow( scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine.adjusted(4, 4, -4, -4),
+								   horizontal ? (reverse ? GTK_ARROW_LEFT : GTK_ARROW_RIGHT) :
+								   GTK_ARROW_DOWN, state, GTK_SHADOW_NONE, FALSE, style);
+		}
+
+		if (scrollBar->subControls & QGtkStyle::SC_ScrollBarSubLine) {
+			gtkVScrollBar->allocation.y = 0;
+			gtkVScrollBar->allocation.height = scrollBarSubLine.height();
+			gtkHScrollBar->allocation.x = 0;
+			gtkHScrollBar->allocation.width = scrollBarSubLine.width();
+
+			GtkShadowType shadow = GTK_SHADOW_OUT;
+			GtkStateType state = GTK_STATE_NORMAL;
+
+			if (!(option->state & QGtkStyle::State_Enabled) || (fakePos == 0))
+				state = GTK_STATE_INSENSITIVE;
+			else if (option->state & QGtkStyle::State_Sunken && (scrollBar->activeSubControls & QGtkStyle::SC_ScrollBarSubLine)) {
+				shadow = GTK_SHADOW_IN;
+				state = GTK_STATE_ACTIVE;
+
+			} else if (option->state & QGtkStyle::State_MouseOver && (scrollBar->activeSubControls & QGtkStyle::SC_ScrollBarSubLine))
+				state = GTK_STATE_PRELIGHT;
+
+			gtkPainter.paintBox(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine,
+								state, shadow, style, QLS("sub"));
+
+			gtkPainter.paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine.adjusted(4, 4, -4, -4),
+								  horizontal ? (reverse ? GTK_ARROW_RIGHT : GTK_ARROW_LEFT) :
+								  GTK_ARROW_UP, state, GTK_SHADOW_NONE, FALSE, style);
+		}
+	}
+}
+
+template <class OptionStyle>
+void drawScrollBar(const QStyleOptionComplex* option, QGtkStyle::ComplexControl control, const QGtkStylePrivate* const d, const QWidget* widget, QGtkPainter gtkPainter, QPainter* painter, GtkStyle* style, QStyle const* proxy)
+{
+	if (const OptionStyle *scrollBar = qstyleoption_cast<const OptionStyle *>(option)) {
+		GtkWidget *gtkHScrollBar = d->gtkWidget("GtkHScrollbar");
+		GtkWidget *gtkVScrollBar = d->gtkWidget("GtkVScrollbar");
+
+		// Fill background in case the scrollbar is partially transparent
+		painter->fillRect(option->rect, option->palette.background());
+
+		QRect rect = scrollBar->rect;
+		QRect scrollBarSubLine = proxy->subControlRect(control, scrollBar, QGtkStyle::SC_ScrollBarSubLine, widget);
+		QRect scrollBarAddLine = proxy->subControlRect(control, scrollBar, QGtkStyle::SC_ScrollBarAddLine, widget);
+		QRect scrollBarSlider = proxy->subControlRect(control, scrollBar, QGtkStyle::SC_ScrollBarSlider, widget);
+		QRect grooveRect = proxy->subControlRect(control, scrollBar, QGtkStyle::SC_ScrollBarGroove, widget);
+		bool horizontal = scrollBar->orientation == Qt::Horizontal;
+		GtkWidget * scrollbarWidget = horizontal ? gtkHScrollBar : gtkVScrollBar;
+		style = scrollbarWidget->style;
+		gboolean trough_under_steppers = true;
+		gboolean trough_side_details = false;
+		gboolean activate_slider = false;
+		gboolean stepper_size = 14;
+		gint trough_border = 1;
+		if (!d->gtk_check_version(2, 10, 0)) {
+			d->gtk_widget_style_get((GtkWidget*)(scrollbarWidget),
+									   "trough-border",   &trough_border,
+									   "trough-side-details",   &trough_side_details,
+									   "trough-under-steppers", &trough_under_steppers,
+									   "activate-slider",       &activate_slider,
+									   "stepper-size",          &stepper_size, NULL);
+		}
+		if (trough_under_steppers) {
+			scrollBarAddLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
+			scrollBarSubLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
+			scrollBarSlider.adjust(horizontal ? -trough_border : 0, horizontal ? 0 : -trough_border,
+								   horizontal ? trough_border : 0, horizontal ? 0 : trough_border);
+		}
+
+		// Some styles check the position of scrollbars in order to determine
+		// if lines should be painted when the scrollbar is in max or min positions.
+		int maximum = 2;
+		int fakePos = 0;
+		bool reverse = (option->direction == Qt::RightToLeft);
+		if (scrollBar->minimum == scrollBar->maximum)
+			maximum = 0;
+		if (scrollBar->sliderPosition == scrollBar->maximum)
+			fakePos = maximum;
+		else if (scrollBar->sliderPosition > scrollBar->minimum)
+			fakePos = maximum - 1;
+
+
+		GtkRange *range = (GtkRange*)(horizontal ? gtkHScrollBar : gtkVScrollBar);
+		GtkAdjustment *adjustment = 0;
+
+		if (d->gtk_adjustment_configure)
+			adjustment = d->gtk_range_get_adjustment(range);
+		if (adjustment) {
+			d->gtk_adjustment_configure(adjustment, fakePos, 0, maximum, 0, 0, 0);
+		} else {
+			adjustment = (GtkAdjustment*)d->gtk_adjustment_new(fakePos, 0, maximum, 0, 0, 0);
+			d->gtk_range_set_adjustment(range, adjustment);
+		}
+
+		if (scrollBar->subControls & QGtkStyle::SC_ScrollBarGroove) {
+			GtkStateType state = GTK_STATE_ACTIVE;
+
+			if (!(option->state & QGtkStyle::State_Enabled))
+				state = GTK_STATE_INSENSITIVE;
+
+			if (trough_under_steppers)
+				grooveRect = option->rect;
+
+			gtkPainter.paintBox( scrollbarWidget, "trough", grooveRect, state, GTK_SHADOW_IN, style);
+		}
+
+		//paint slider
+		if (scrollBar->subControls & QGtkStyle::SC_ScrollBarSlider) {
+			GtkStateType state = GTK_STATE_NORMAL;
+
+			if (!(option->state & QGtkStyle::State_Enabled))
+				state = GTK_STATE_INSENSITIVE;
+			else if (activate_slider &&
+					 option->state & QGtkStyle::State_Sunken && (scrollBar->activeSubControls & QGtkStyle::SC_ScrollBarSlider))
+				state = GTK_STATE_ACTIVE;
+			else if (option->state & QGtkStyle::State_MouseOver && (scrollBar->activeSubControls & QGtkStyle::SC_ScrollBarSlider))
+				state = GTK_STATE_PRELIGHT;
+
+			GtkShadowType shadow = GTK_SHADOW_OUT;
+
+			if (trough_under_steppers) {
+				if (!horizontal)
+					scrollBarSlider.adjust(trough_border, 0, -trough_border, 0);
+				else
+					scrollBarSlider.adjust(0, trough_border, 0, -trough_border);
+			}
+
+			gtkPainter.paintSlider( scrollbarWidget, "slider", scrollBarSlider, state, shadow, style,
+
+									horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL, QString(QLS("%0%1")).arg(fakePos).arg(maximum));
+		}
+
+		if (scrollBar->subControls & QGtkStyle::SC_ScrollBarAddLine) {
+			gtkVScrollBar->allocation.y = scrollBarAddLine.top();
+			gtkVScrollBar->allocation.height = scrollBarAddLine.height() - rect.height() + 6;
+			gtkHScrollBar->allocation.x = scrollBarAddLine.right();
+			gtkHScrollBar->allocation.width = scrollBarAddLine.width() - rect.width();
+
+			GtkShadowType shadow = GTK_SHADOW_OUT;
+			GtkStateType state = GTK_STATE_NORMAL;
+
+			if (!(option->state & QGtkStyle::State_Enabled) || (fakePos == maximum))
+				state = GTK_STATE_INSENSITIVE;
+			else if (option->state & QGtkStyle::State_Sunken && (scrollBar->activeSubControls & QGtkStyle::SC_ScrollBarAddLine)) {
+				state = GTK_STATE_ACTIVE;
+				shadow = GTK_SHADOW_IN;
+
+			} else if (option->state & QGtkStyle::State_MouseOver && (scrollBar->activeSubControls & QGtkStyle::SC_ScrollBarAddLine))
+				state = GTK_STATE_PRELIGHT;
+
+			gtkPainter.paintBox( scrollbarWidget,
+								 horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine,
+								 state, shadow, style, QLS("add"));
+
+			gtkPainter.paintArrow( scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine.adjusted(4, 4, -4, -4),
+								   horizontal ? (reverse ? GTK_ARROW_LEFT : GTK_ARROW_RIGHT) :
+								   GTK_ARROW_DOWN, state, GTK_SHADOW_NONE, FALSE, style);
+		}
+
+		if (scrollBar->subControls & QGtkStyle::SC_ScrollBarSubLine) {
+			gtkVScrollBar->allocation.y = 0;
+			gtkVScrollBar->allocation.height = scrollBarSubLine.height();
+			gtkHScrollBar->allocation.x = 0;
+			gtkHScrollBar->allocation.width = scrollBarSubLine.width();
+
+			GtkShadowType shadow = GTK_SHADOW_OUT;
+			GtkStateType state = GTK_STATE_NORMAL;
+
+			if (!(option->state & QGtkStyle::State_Enabled) || (fakePos == 0))
+				state = GTK_STATE_INSENSITIVE;
+			else if (option->state & QGtkStyle::State_Sunken && (scrollBar->activeSubControls & QGtkStyle::SC_ScrollBarSubLine)) {
+				shadow = GTK_SHADOW_IN;
+				state = GTK_STATE_ACTIVE;
+
+			} else if (option->state & QGtkStyle::State_MouseOver && (scrollBar->activeSubControls & QGtkStyle::SC_ScrollBarSubLine))
+				state = GTK_STATE_PRELIGHT;
+
+			gtkPainter.paintBox(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine,
+								state, shadow, style, QLS("sub"));
+
+			gtkPainter.paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine.adjusted(4, 4, -4, -4),
+								  horizontal ? (reverse ? GTK_ARROW_RIGHT : GTK_ARROW_LEFT) :
+								  GTK_ARROW_UP, state, GTK_SHADOW_NONE, FALSE, style);
+		}
+	}
+}
+
 /*!
     \reimp
 */
@@ -1659,157 +1969,10 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
 #ifndef QT_NO_SCROLLBAR
 
     case CC_ScrollBar:
-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            GtkWidget *gtkHScrollBar = d->gtkWidget("GtkHScrollbar");
-            GtkWidget *gtkVScrollBar = d->gtkWidget("GtkVScrollbar");
-
-            // Fill background in case the scrollbar is partially transparent
-            painter->fillRect(option->rect, option->palette.background());
-
-            QRect rect = scrollBar->rect;
-            QRect scrollBarSubLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSubLine, widget);
-            QRect scrollBarAddLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarAddLine, widget);
-            QRect scrollBarSlider = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSlider, widget);
-            QRect grooveRect = proxy()->subControlRect(control, scrollBar, SC_ScrollBarGroove, widget);
-            bool horizontal = scrollBar->orientation == Qt::Horizontal;
-            GtkWidget * scrollbarWidget = horizontal ? gtkHScrollBar : gtkVScrollBar;
-            style = scrollbarWidget->style;
-            gboolean trough_under_steppers = true;
-            gboolean trough_side_details = false;
-            gboolean activate_slider = false;
-            gboolean stepper_size = 14;
-            gint trough_border = 1;
-            if (!d->gtk_check_version(2, 10, 0)) {
-                d->gtk_widget_style_get((GtkWidget*)(scrollbarWidget),
-                                           "trough-border",   &trough_border,
-                                           "trough-side-details",   &trough_side_details,
-                                           "trough-under-steppers", &trough_under_steppers,
-                                           "activate-slider",       &activate_slider,
-                                           "stepper-size",          &stepper_size, NULL);
-            }
-            if (trough_under_steppers) {
-                scrollBarAddLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
-                scrollBarSubLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
-                scrollBarSlider.adjust(horizontal ? -trough_border : 0, horizontal ? 0 : -trough_border,
-                                       horizontal ? trough_border : 0, horizontal ? 0 : trough_border);
-            }
-
-            // Some styles check the position of scrollbars in order to determine
-            // if lines should be painted when the scrollbar is in max or min positions.
-            int maximum = 2;
-            int fakePos = 0;
-            bool reverse = (option->direction == Qt::RightToLeft);
-            if (scrollBar->minimum == scrollBar->maximum)
-                maximum = 0;
-            if (scrollBar->sliderPosition == scrollBar->maximum)
-                fakePos = maximum;
-            else if (scrollBar->sliderPosition > scrollBar->minimum)
-                fakePos = maximum - 1;
-
-
-            GtkRange *range = (GtkRange*)(horizontal ? gtkHScrollBar : gtkVScrollBar);
-            GtkAdjustment *adjustment = 0;
-
-            if (d->gtk_adjustment_configure)
-                adjustment = d->gtk_range_get_adjustment(range);
-            if (adjustment) {
-                d->gtk_adjustment_configure(adjustment, fakePos, 0, maximum, 0, 0, 0);
-            } else {
-                adjustment = (GtkAdjustment*)d->gtk_adjustment_new(fakePos, 0, maximum, 0, 0, 0);
-                d->gtk_range_set_adjustment(range, adjustment);
-            }
-
-            if (scrollBar->subControls & SC_ScrollBarGroove) {
-                GtkStateType state = GTK_STATE_ACTIVE;
-
-                if (!(option->state & State_Enabled))
-                    state = GTK_STATE_INSENSITIVE;
-
-                if (trough_under_steppers)
-                    grooveRect = option->rect;
-
-                gtkPainter.paintBox( scrollbarWidget, "trough", grooveRect, state, GTK_SHADOW_IN, style);
-            }
-
-            //paint slider
-            if (scrollBar->subControls & SC_ScrollBarSlider) {
-                GtkStateType state = GTK_STATE_NORMAL;
-
-                if (!(option->state & State_Enabled))
-                    state = GTK_STATE_INSENSITIVE;
-                else if (activate_slider &&
-                         option->state & State_Sunken && (scrollBar->activeSubControls & SC_ScrollBarSlider))
-                    state = GTK_STATE_ACTIVE;
-                else if (option->state & State_MouseOver && (scrollBar->activeSubControls & SC_ScrollBarSlider))
-                    state = GTK_STATE_PRELIGHT;
-
-                GtkShadowType shadow = GTK_SHADOW_OUT;
-
-                if (trough_under_steppers) {
-                    if (!horizontal)
-                        scrollBarSlider.adjust(trough_border, 0, -trough_border, 0);
-                    else
-                        scrollBarSlider.adjust(0, trough_border, 0, -trough_border);
-                }
-
-                gtkPainter.paintSlider( scrollbarWidget, "slider", scrollBarSlider, state, shadow, style,
-
-                                        horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL, QString(QLS("%0%1")).arg(fakePos).arg(maximum));
-            }
-
-            if (scrollBar->subControls & SC_ScrollBarAddLine) {
-                gtkVScrollBar->allocation.y = scrollBarAddLine.top();
-                gtkVScrollBar->allocation.height = scrollBarAddLine.height() - rect.height() + 6;
-                gtkHScrollBar->allocation.x = scrollBarAddLine.right();
-                gtkHScrollBar->allocation.width = scrollBarAddLine.width() - rect.width();
-
-                GtkShadowType shadow = GTK_SHADOW_OUT;
-                GtkStateType state = GTK_STATE_NORMAL;
-
-                if (!(option->state & State_Enabled) || (fakePos == maximum))
-                    state = GTK_STATE_INSENSITIVE;
-                else if (option->state & State_Sunken && (scrollBar->activeSubControls & SC_ScrollBarAddLine)) {
-                    state = GTK_STATE_ACTIVE;
-                    shadow = GTK_SHADOW_IN;
-
-                } else if (option->state & State_MouseOver && (scrollBar->activeSubControls & SC_ScrollBarAddLine))
-                    state = GTK_STATE_PRELIGHT;
-
-                gtkPainter.paintBox( scrollbarWidget,
-                                     horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine,
-                                     state, shadow, style, QLS("add"));
-
-                gtkPainter.paintArrow( scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine.adjusted(4, 4, -4, -4),
-                                       horizontal ? (reverse ? GTK_ARROW_LEFT : GTK_ARROW_RIGHT) :
-                                       GTK_ARROW_DOWN, state, GTK_SHADOW_NONE, FALSE, style);
-            }
-
-            if (scrollBar->subControls & SC_ScrollBarSubLine) {
-                gtkVScrollBar->allocation.y = 0;
-                gtkVScrollBar->allocation.height = scrollBarSubLine.height();
-                gtkHScrollBar->allocation.x = 0;
-                gtkHScrollBar->allocation.width = scrollBarSubLine.width();
-
-                GtkShadowType shadow = GTK_SHADOW_OUT;
-                GtkStateType state = GTK_STATE_NORMAL;
-
-                if (!(option->state & State_Enabled) || (fakePos == 0))
-                    state = GTK_STATE_INSENSITIVE;
-                else if (option->state & State_Sunken && (scrollBar->activeSubControls & SC_ScrollBarSubLine)) {
-                    shadow = GTK_SHADOW_IN;
-                    state = GTK_STATE_ACTIVE;
-
-                } else if (option->state & State_MouseOver && (scrollBar->activeSubControls & SC_ScrollBarSubLine))
-                    state = GTK_STATE_PRELIGHT;
-
-                gtkPainter.paintBox(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine,
-                                    state, shadow, style, QLS("sub"));
-
-                gtkPainter.paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine.adjusted(4, 4, -4, -4),
-                                      horizontal ? (reverse ? GTK_ARROW_RIGHT : GTK_ARROW_LEFT) :
-                                      GTK_ARROW_UP, state, GTK_SHADOW_NONE, FALSE, style);
-            }
-        }
+        drawScrollBar<QStyleOptionSlider>(option, control, d, widget, gtkPainter, painter, style, proxy());
+        break;
+    case CC_ScrollBar64:
+        drawScrollBar<QStyleOptionSlider64>(option, control, d, widget, gtkPainter, painter, style, proxy());
         break;
 
 #endif //QT_NO_SCROLLBAR
@@ -1969,188 +2132,10 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
 #ifndef QT_NO_SLIDER
 
     case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            GtkWidget *hScaleWidget = d->gtkWidget("GtkHScale");
-            GtkWidget *vScaleWidget = d->gtkWidget("GtkVScale");
-
-            QRect groove = proxy()->subControlRect(CC_Slider, option, SC_SliderGroove, widget);
-            QRect handle = proxy()->subControlRect(CC_Slider, option, SC_SliderHandle, widget);
-
-            bool horizontal = slider->orientation == Qt::Horizontal;
-            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
-            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
-
-            QBrush oldBrush = painter->brush();
-            QPen oldPen = painter->pen();
-
-            QColor shadowAlpha(Qt::black);
-            shadowAlpha.setAlpha(10);
-            QColor highlightAlpha(Qt::white);
-            highlightAlpha.setAlpha(80);
-
-            QGtkStylePrivate::gtk_widget_set_direction(hScaleWidget, slider->upsideDown ?
-                                                       GTK_TEXT_DIR_RTL : GTK_TEXT_DIR_LTR);
-            GtkWidget *scaleWidget = horizontal ? hScaleWidget : vScaleWidget;
-            style = scaleWidget->style;
-
-            if ((option->subControls & SC_SliderGroove) && groove.isValid()) {
-
-                GtkRange *range = (GtkRange*)scaleWidget;
-                GtkAdjustment *adjustment = d->gtk_range_get_adjustment(range);
-                if (adjustment) {
-                    d->gtk_adjustment_configure(adjustment,
-                                                slider->sliderPosition,
-                                                slider->minimum,
-                                                slider->maximum,
-                                                slider->singleStep,
-                                                slider->singleStep,
-                                                slider->pageStep);
-                } else {
-                    adjustment = (GtkAdjustment*)d->gtk_adjustment_new(slider->sliderPosition,
-                                                                       slider->minimum,
-                                                                       slider->maximum,
-                                                                       slider->singleStep,
-                                                                       slider->singleStep,
-                                                                       slider->pageStep);
-                    d->gtk_range_set_adjustment(range, adjustment);
-                }
-
-                int outerSize;
-                d->gtk_range_set_inverted(range, !horizontal);
-                d->gtk_widget_style_get(scaleWidget, "trough-border", &outerSize, NULL);
-                outerSize++;
-
-                GtkStateType state = gtkPainter.gtkState(option);
-                int focusFrameMargin = 2;
-                QRect grooveRect = option->rect.adjusted(focusFrameMargin, outerSize + focusFrameMargin,
-                                   -focusFrameMargin, -outerSize - focusFrameMargin);
-
-                gboolean trough_side_details = false; // Indicates if the upper or lower scale background differs
-                if (!d->gtk_check_version(2, 10, 0))
-                    d->gtk_widget_style_get((GtkWidget*)(scaleWidget), "trough-side-details",   &trough_side_details, NULL);
-
-                if (!trough_side_details) {
-                    gtkPainter.paintBox( scaleWidget, "trough", grooveRect, state,
-                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
-                } else {
-                    QRect upperGroove = grooveRect;
-                    QRect lowerGroove = grooveRect;
-
-                    if (horizontal) {
-                        if (slider->upsideDown) {
-                            lowerGroove.setLeft(handle.center().x());
-                            upperGroove.setRight(handle.center().x());
-                        } else {
-                            upperGroove.setLeft(handle.center().x());
-                            lowerGroove.setRight(handle.center().x());
-                        }
-                    } else {
-                        if (!slider->upsideDown) {
-                            lowerGroove.setBottom(handle.center().y());
-                            upperGroove.setTop(handle.center().y());
-                        } else {
-                            upperGroove.setBottom(handle.center().y());
-                            lowerGroove.setTop(handle.center().y());
-                        }
-                    }
-
-                    gtkPainter.paintBox( scaleWidget, "trough-upper", upperGroove, state,
-                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
-                    gtkPainter.paintBox( scaleWidget, "trough-lower", lowerGroove, state,
-                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
-                }
-            }
-
-            if (option->subControls & SC_SliderTickmarks) {
-                painter->setPen(darkOutline);
-                int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
-                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
-                int interval = slider->tickInterval;
-
-                if (interval <= 0) {
-                    interval = slider->singleStep;
-
-                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
-                                                        available)
-                            - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                              0, available) < 3)
-                        interval = slider->pageStep;
-                }
-
-                if (interval <= 0)
-                    interval = 1;
-
-                int v = slider->minimum;
-                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
-                while (v <= slider->maximum + 1) {
-                    if (v == slider->maximum + 1 && interval == 1)
-                        break;
-                    const int v_ = qMin(v, slider->maximum);
-                    int pos = sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                      v_, (horizontal
-                                                           ? slider->rect.width()
-                                                           : slider->rect.height()) - len,
-                                                      slider->upsideDown) + len / 2;
-                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
-                    if (horizontal) {
-                        if (ticksAbove)
-                            painter->drawLine(pos, slider->rect.top() + extra,
-                                              pos, slider->rect.top() + tickSize);
-                        if (ticksBelow)
-                            painter->drawLine(pos, slider->rect.bottom() - extra,
-                                              pos, slider->rect.bottom() - tickSize);
-
-                    } else {
-                        if (ticksAbove)
-                            painter->drawLine(slider->rect.left() + extra, pos,
-                                              slider->rect.left() + tickSize, pos);
-                        if (ticksBelow)
-                            painter->drawLine(slider->rect.right() - extra, pos,
-                                              slider->rect.right() - tickSize, pos);
-                    }
-
-                    // In the case where maximum is max int
-                    int nextInterval = v + interval;
-                    if (nextInterval < v)
-                        break;
-                    v = nextInterval;
-                }
-            }
-
-            // Draw slider handle
-            if (option->subControls & SC_SliderHandle) {
-                GtkShadowType shadow =  GTK_SHADOW_OUT;
-                GtkStateType state = GTK_STATE_NORMAL;
-
-                if (!(option->state & State_Enabled))
-                    state = GTK_STATE_INSENSITIVE;
-                else if (option->state & State_MouseOver && option->activeSubControls & SC_SliderHandle)
-                    state = GTK_STATE_PRELIGHT;
-
-                bool horizontal = option->state & State_Horizontal;
-
-                if (slider->state & State_HasFocus) {
-                    QStyleOptionFocusRect fropt;
-                    fropt.QStyleOption::operator=(*slider);
-                    fropt.rect = slider->rect.adjusted(-1, -1 ,1, 1);
-
-                    if (horizontal) {
-                        fropt.rect.setTop(handle.top() - 3);
-                        fropt.rect.setBottom(handle.bottom() + 4);
-
-                    } else {
-                        fropt.rect.setLeft(handle.left() - 3);
-                        fropt.rect.setRight(handle.right() + 3);
-                    }
-                    proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
-                }
-                gtkPainter.paintSlider( scaleWidget, horizontal ? "hscale" : "vscale", handle, state, shadow, style,
-
-                                        horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL);
-            }
-            painter->setBrush(oldBrush);
-            painter->setPen(oldPen);
-        }
+		drawSlider<QStyleOptionSlider>(control, option, d, widget, gtkPainter, painter, style, proxy());
+        break;
+    case CC_Slider64:
+		drawSlider<QStyleOptionSlider64>(control, option, d, widget, gtkPainter, painter, style, proxy());
         break;
 
 #endif // QT_NO_SLIDER
@@ -3076,6 +3061,16 @@ QRect QGtkStyle::subControlRect(ComplexControl control, const QStyleOptionComple
 
         break;
 
+    case CC_Slider64:
+        if (const QStyleOptionSlider64 *slider = qstyleoption_cast<const QStyleOptionSlider64 *>(option)) {
+            // Reserve space for outside focus rect
+            QStyleOptionSlider64 sliderCopy = *slider;
+            sliderCopy.rect = option->rect.adjusted(2, 2, -2, -2);
+            return QCleanlooksStyle::subControlRect(control, &sliderCopy, subControl, widget);
+        }
+
+        break;
+
 #ifndef QT_NO_GROUPBOX
 
     case CC_GroupBox:
diff --git a/src/gui/styles/qplastiquestyle.cpp b/src/gui/styles/qplastiquestyle.cpp
index 40e408b..0715cdf 100644
--- a/src/gui/styles/qplastiquestyle.cpp
+++ b/src/gui/styles/qplastiquestyle.cpp
@@ -3764,6 +3764,240 @@ void QPlastiqueStyle::drawControl(ControlElement element, const QStyleOption *op
     }
 }
 
+template <class OptionSlider>
+static void drawSlider(const QStyleOptionComplex* option, const QWidget* widget, const QColor& borderColor, const QColor& alphaCornerColor, const QColor& gradientStartColor, const QColor& gradientStopColor, QPainter* painter, const QStyle* proxy, const QPlastiqueStyle* style)
+{
+	if (const OptionSlider *slider = qstyleoption_cast<const OptionSlider*>(option)) {
+		QRect grooveRegion = proxy->subControlRect(QPlastiqueStyle::CC_Slider, option, QPlastiqueStyle::SC_SliderGroove, widget);
+		QRect handle = proxy->subControlRect(QPlastiqueStyle::CC_Slider, option, QPlastiqueStyle::SC_SliderHandle, widget);
+		bool horizontal = slider->orientation == Qt::Horizontal;
+		bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
+		bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
+
+		QRect groove;
+		//The clickable region is 5 px wider than the visible groove for improved usability
+		if (grooveRegion.isValid())
+			groove = horizontal ? grooveRegion.adjusted(0, 5, 0, -5) : grooveRegion.adjusted(5, 0, -5, 0);
+
+
+		QPixmap cache;
+
+		if ((option->subControls & QPlastiqueStyle::SC_SliderGroove) && groove.isValid()) {
+			BEGIN_STYLE_PIXMAPCACHE(QString::fromLatin1("slider_groove-%0-%1").arg(ticksAbove).arg(ticksBelow))
+			p->fillRect(groove, option->palette.background());
+
+			// draw groove
+			if (horizontal) {
+				p->setPen(borderColor);
+				const QLine lines[4] = {
+					QLine(groove.left() + 1, groove.top(),
+						  groove.right() - 1, groove.top()),
+					QLine(groove.left() + 1, groove.bottom(),
+						  groove.right() - 1, groove.bottom()),
+					QLine(groove.left(), groove.top() + 1,
+						  groove.left(), groove.bottom() - 1),
+					QLine(groove.right(), groove.top() + 1,
+						  groove.right(), groove.bottom() - 1) };
+				p->drawLines(lines, 4);
+
+				p->setPen(alphaCornerColor);
+				const QPoint points[4] = {
+					QPoint(groove.left(), groove.top()),
+					QPoint(groove.left(), groove.bottom()),
+					QPoint(groove.right(), groove.top()),
+					QPoint(groove.right(), groove.bottom()) };
+				p->drawPoints(points, 4);
+			} else {
+				p->setPen(borderColor);
+				const QLine lines[4] = {
+					QLine(groove.left() + 1, groove.top(),
+						  groove.right() - 1, groove.top()),
+					QLine(groove.left() + 1, groove.bottom(),
+						  groove.right() - 1, groove.bottom()),
+					QLine(groove.left(), groove.top() + 1,
+						  groove.left(), groove.bottom() - 1),
+					QLine(groove.right(), groove.top() + 1,
+						  groove.right(), groove.bottom() - 1) };
+				p->drawLines(lines, 4);
+
+				p->setPen(alphaCornerColor);
+				const QPoint points[4] = {
+					QPoint(groove.left(), groove.top()),
+					QPoint(groove.right(), groove.top()),
+					QPoint(groove.left(), groove.bottom()),
+					QPoint(groove.right(), groove.bottom()) };
+				p->drawPoints(points, 4);
+			}
+			END_STYLE_PIXMAPCACHE
+		}
+
+		if ((option->subControls & QPlastiqueStyle::SC_SliderHandle) && handle.isValid()) {
+			QString handlePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_handle"), option, handle.size());
+			if (ticksAbove && !ticksBelow)
+				handlePixmapName += QLatin1String("-flipped");
+			if ((option->activeSubControls & QPlastiqueStyle::SC_SliderHandle) && (option->state & QPlastiqueStyle::State_Sunken))
+				handlePixmapName += QLatin1String("-sunken");
+
+			if (!QPixmapCache::find(handlePixmapName, cache)) {
+				cache = QPixmap(handle.size());
+				cache.fill(Qt::white);
+				QRect pixmapRect(0, 0, handle.width(), handle.height());
+				QPainter handlePainter(&cache);
+				handlePainter.fillRect(pixmapRect, option->palette.background());
+
+				// draw handle
+				if (horizontal) {
+					QPainterPath path;
+					if (ticksAbove && !ticksBelow) {
+						path.moveTo(QPoint(pixmapRect.right(), pixmapRect.bottom()));
+						path.lineTo(QPoint(pixmapRect.right(), pixmapRect.bottom() - 10));
+						path.lineTo(QPoint(pixmapRect.right() - 5, pixmapRect.bottom() - 14));
+						path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.bottom() - 10));
+						path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.bottom()));
+						path.lineTo(QPoint(pixmapRect.right(), pixmapRect.bottom()));
+					} else {
+						path.moveTo(QPoint(pixmapRect.right(), pixmapRect.top() + 1));
+						path.lineTo(QPoint(pixmapRect.right(), pixmapRect.top() + 10));
+						path.lineTo(QPoint(pixmapRect.right() - 5, pixmapRect.top() + 14));
+						path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.top() + 10));
+						path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.top() + 1));
+						path.lineTo(QPoint(pixmapRect.right(), pixmapRect.top() + 1));
+					}
+					if (slider->state & QPlastiqueStyle::State_Enabled) {
+						QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
+												 pixmapRect.center().x(), pixmapRect.bottom());
+						if ((option->activeSubControls & QPlastiqueStyle::SC_SliderHandle) && (option->state & QPlastiqueStyle::State_Sunken)) {
+							gradient.setColorAt(0, gradientStartColor.lighter(110));
+							gradient.setColorAt(1, gradientStopColor.lighter(110));
+						} else {
+							gradient.setColorAt(0, gradientStartColor);
+							gradient.setColorAt(1, gradientStopColor);
+						}
+						handlePainter.fillPath(path, gradient);
+					} else {
+						handlePainter.fillPath(path, slider->palette.background());
+					}
+				} else {
+					QPainterPath path;
+					if (ticksAbove && !ticksBelow) {
+						path.moveTo(QPoint(pixmapRect.right(), pixmapRect.top() + 1));
+						path.lineTo(QPoint(pixmapRect.right() - 10, pixmapRect.top() + 1));
+						path.lineTo(QPoint(pixmapRect.right() - 14, pixmapRect.top() + 5));
+						path.lineTo(QPoint(pixmapRect.right() - 10, pixmapRect.bottom()));
+						path.lineTo(QPoint(pixmapRect.right(), pixmapRect.bottom()));
+						path.lineTo(QPoint(pixmapRect.right(), pixmapRect.top() + 1));
+					} else {
+						path.moveTo(QPoint(pixmapRect.left() + 1, pixmapRect.top() + 1));
+						path.lineTo(QPoint(pixmapRect.left() + 10, pixmapRect.top() + 1));
+						path.lineTo(QPoint(pixmapRect.left() + 14, pixmapRect.top() + 5));
+						path.lineTo(QPoint(pixmapRect.left() + 10, pixmapRect.bottom()));
+						path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.bottom()));
+						path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.top() + 1));
+					}
+					if (slider->state & QPlastiqueStyle::State_Enabled) {
+						QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
+												 pixmapRect.center().x(), pixmapRect.bottom());
+						gradient.setColorAt(0, gradientStartColor);
+						gradient.setColorAt(1, gradientStopColor);
+						handlePainter.fillPath(path, gradient);
+					} else {
+						handlePainter.fillPath(path, slider->palette.background());
+					}
+				}
+
+				QImage image;
+				if (horizontal) {
+					image = QImage((ticksAbove && !ticksBelow) ? qt_plastique_slider_horizontalhandle_up : qt_plastique_slider_horizontalhandle);
+				} else {
+					image = QImage((ticksAbove && !ticksBelow) ? qt_plastique_slider_verticalhandle_left : qt_plastique_slider_verticalhandle);
+				}
+
+				image.setColor(1, borderColor.rgba());
+				image.setColor(2, gradientStartColor.rgba());
+				image.setColor(3, alphaCornerColor.rgba());
+				if (option->state & QPlastiqueStyle::State_Enabled) {
+					image.setColor(4, 0x80ffffff);
+					image.setColor(5, 0x25000000);
+				}
+				handlePainter.drawImage(pixmapRect, image);
+				handlePainter.end();
+				QPixmapCache::insert(handlePixmapName, cache);
+			}
+
+			painter->drawPixmap(handle.topLeft(), cache);
+
+			if (slider->state & QPlastiqueStyle::State_HasFocus) {
+				QStyleOptionFocusRect fropt;
+				fropt.QStyleOption::operator=(*slider);
+				fropt.rect = style->subElementRect(QPlastiqueStyle::SE_SliderFocusRect, slider, widget);
+				proxy->drawPrimitive(QPlastiqueStyle::PE_FrameFocusRect, &fropt, painter, widget);
+			}
+		}
+
+		if (option->subControls & QPlastiqueStyle::SC_SliderTickmarks) {
+			QPen oldPen = painter->pen();
+			painter->setPen(borderColor);
+			int tickSize = proxy->pixelMetric(QPlastiqueStyle::PM_SliderTickmarkOffset, option, widget);
+			qint64 available = proxy->pixelMetric(QPlastiqueStyle::PM_SliderSpaceAvailable, slider, widget);
+			qint64 interval = slider->tickInterval;
+			if (interval <= 0) {
+				interval = slider->singleStep;
+				if (QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum, interval,
+													available)
+					- QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum,
+													  (qint64) 0, available) < 3)
+					interval = slider->pageStep;
+			}
+			if (interval <= 0)
+				interval = 1;
+
+			qint64 v = slider->minimum;
+			qint64 len = proxy->pixelMetric(QPlastiqueStyle::PM_SliderLength, slider, widget);
+			QVarLengthArray<QLine, 32> lines;
+			while (v <= slider->maximum + 1) {
+				if (v == slider->maximum + 1 && interval == 1)
+					break;
+				const qint64 v_ = qMin(v, (qint64) slider->maximum);
+				qint64 pos = QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum,
+												  v_, (qint64) (horizontal
+													  ? slider->rect.width()
+													  : slider->rect.height()) - len,
+												  slider->upsideDown) + len / 2;
+
+				int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
+
+				if (horizontal) {
+					if (ticksAbove) {
+						lines.append(QLine(pos, slider->rect.top() + extra,
+										   pos, slider->rect.top() + tickSize));
+					}
+					if (ticksBelow) {
+						lines.append(QLine(pos, slider->rect.bottom() - extra,
+										   pos, slider->rect.bottom() - tickSize));
+					}
+				} else {
+					if (ticksAbove) {
+						lines.append(QLine(slider->rect.left() + extra, pos,
+										   slider->rect.left() + tickSize, pos));
+					}
+					if (ticksBelow) {
+						lines.append(QLine(slider->rect.right() - extra, pos,
+										   slider->rect.right() - tickSize, pos));
+					}
+				}
+
+				// in the case where maximum is max int
+				qint64 nextInterval = v + interval;
+				if (nextInterval < v)
+					break;
+				v = nextInterval;
+			}
+			painter->drawLines(lines.constData(), lines.size());
+			painter->setPen(oldPen);
+		}
+	}
+}
+
 /*!
   \reimp
 */
@@ -3784,235 +4018,10 @@ void QPlastiqueStyle::drawComplexControl(ComplexControl control, const QStyleOpt
     switch (control) {
 #ifndef QT_NO_SLIDER
     case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            QRect grooveRegion = proxy()->subControlRect(CC_Slider, option, SC_SliderGroove, widget);
-            QRect handle = proxy()->subControlRect(CC_Slider, option, SC_SliderHandle, widget);
-            bool horizontal = slider->orientation == Qt::Horizontal;
-            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
-            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
-
-            QRect groove;
-            //The clickable region is 5 px wider than the visible groove for improved usability
-            if (grooveRegion.isValid())
-                groove = horizontal ? grooveRegion.adjusted(0, 5, 0, -5) : grooveRegion.adjusted(5, 0, -5, 0);
-
-
-            QPixmap cache;
-
-            if ((option->subControls & SC_SliderGroove) && groove.isValid()) {
-                BEGIN_STYLE_PIXMAPCACHE(QString::fromLatin1("slider_groove-%0-%1").arg(ticksAbove).arg(ticksBelow))
-                p->fillRect(groove, option->palette.background());
-
-                // draw groove
-                if (horizontal) {
-                    p->setPen(borderColor);
-                    const QLine lines[4] = {
-                        QLine(groove.left() + 1, groove.top(),
-                              groove.right() - 1, groove.top()),
-                        QLine(groove.left() + 1, groove.bottom(),
-                              groove.right() - 1, groove.bottom()),
-                        QLine(groove.left(), groove.top() + 1,
-                              groove.left(), groove.bottom() - 1),
-                        QLine(groove.right(), groove.top() + 1,
-                              groove.right(), groove.bottom() - 1) };
-                    p->drawLines(lines, 4);
-
-                    p->setPen(alphaCornerColor);
-                    const QPoint points[4] = {
-                        QPoint(groove.left(), groove.top()),
-                        QPoint(groove.left(), groove.bottom()),
-                        QPoint(groove.right(), groove.top()),
-                        QPoint(groove.right(), groove.bottom()) };
-                    p->drawPoints(points, 4);
-                } else {
-                    p->setPen(borderColor);
-                    const QLine lines[4] = {
-                        QLine(groove.left() + 1, groove.top(),
-                              groove.right() - 1, groove.top()),
-                        QLine(groove.left() + 1, groove.bottom(),
-                              groove.right() - 1, groove.bottom()),
-                        QLine(groove.left(), groove.top() + 1,
-                              groove.left(), groove.bottom() - 1),
-                        QLine(groove.right(), groove.top() + 1,
-                              groove.right(), groove.bottom() - 1) };
-                    p->drawLines(lines, 4);
-
-                    p->setPen(alphaCornerColor);
-                    const QPoint points[4] = {
-                        QPoint(groove.left(), groove.top()),
-                        QPoint(groove.right(), groove.top()),
-                        QPoint(groove.left(), groove.bottom()),
-                        QPoint(groove.right(), groove.bottom()) };
-                    p->drawPoints(points, 4);
-                }
-                END_STYLE_PIXMAPCACHE
-            }
-
-            if ((option->subControls & SC_SliderHandle) && handle.isValid()) {
-                QString handlePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_handle"), option, handle.size());
-                if (ticksAbove && !ticksBelow)
-                    handlePixmapName += QLatin1String("-flipped");
-                if ((option->activeSubControls & SC_SliderHandle) && (option->state & State_Sunken))
-                    handlePixmapName += QLatin1String("-sunken");
-
-                if (!QPixmapCache::find(handlePixmapName, cache)) {
-                    cache = QPixmap(handle.size());
-                    cache.fill(Qt::white);
-                    QRect pixmapRect(0, 0, handle.width(), handle.height());
-                    QPainter handlePainter(&cache);
-                    handlePainter.fillRect(pixmapRect, option->palette.background());
-
-                    // draw handle
-                    if (horizontal) {
-                        QPainterPath path;
-                        if (ticksAbove && !ticksBelow) {
-                            path.moveTo(QPoint(pixmapRect.right(), pixmapRect.bottom()));
-                            path.lineTo(QPoint(pixmapRect.right(), pixmapRect.bottom() - 10));
-                            path.lineTo(QPoint(pixmapRect.right() - 5, pixmapRect.bottom() - 14));
-                            path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.bottom() - 10));
-                            path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.bottom()));
-                            path.lineTo(QPoint(pixmapRect.right(), pixmapRect.bottom()));
-                        } else {
-                            path.moveTo(QPoint(pixmapRect.right(), pixmapRect.top() + 1));
-                            path.lineTo(QPoint(pixmapRect.right(), pixmapRect.top() + 10));
-                            path.lineTo(QPoint(pixmapRect.right() - 5, pixmapRect.top() + 14));
-                            path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.top() + 10));
-                            path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.top() + 1));
-                            path.lineTo(QPoint(pixmapRect.right(), pixmapRect.top() + 1));
-                        }
-                        if (slider->state & State_Enabled) {
-                            QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
-                                                     pixmapRect.center().x(), pixmapRect.bottom());
-                            if ((option->activeSubControls & SC_SliderHandle) && (option->state & State_Sunken)) {
-                                gradient.setColorAt(0, gradientStartColor.lighter(110));
-                                gradient.setColorAt(1, gradientStopColor.lighter(110));
-                            } else {
-                                gradient.setColorAt(0, gradientStartColor);
-                                gradient.setColorAt(1, gradientStopColor);
-                            }
-                            handlePainter.fillPath(path, gradient);
-                        } else {
-                            handlePainter.fillPath(path, slider->palette.background());
-                        }
-                    } else {
-                        QPainterPath path;
-                        if (ticksAbove && !ticksBelow) {
-                            path.moveTo(QPoint(pixmapRect.right(), pixmapRect.top() + 1));
-                            path.lineTo(QPoint(pixmapRect.right() - 10, pixmapRect.top() + 1));
-                            path.lineTo(QPoint(pixmapRect.right() - 14, pixmapRect.top() + 5));
-                            path.lineTo(QPoint(pixmapRect.right() - 10, pixmapRect.bottom()));
-                            path.lineTo(QPoint(pixmapRect.right(), pixmapRect.bottom()));
-                            path.lineTo(QPoint(pixmapRect.right(), pixmapRect.top() + 1));
-                        } else {
-                            path.moveTo(QPoint(pixmapRect.left() + 1, pixmapRect.top() + 1));
-                            path.lineTo(QPoint(pixmapRect.left() + 10, pixmapRect.top() + 1));
-                            path.lineTo(QPoint(pixmapRect.left() + 14, pixmapRect.top() + 5));
-                            path.lineTo(QPoint(pixmapRect.left() + 10, pixmapRect.bottom()));
-                            path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.bottom()));
-                            path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.top() + 1));
-                        }
-                        if (slider->state & State_Enabled) {
-                            QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
-                                                     pixmapRect.center().x(), pixmapRect.bottom());
-                            gradient.setColorAt(0, gradientStartColor);
-                            gradient.setColorAt(1, gradientStopColor);
-                            handlePainter.fillPath(path, gradient);
-                        } else {
-                            handlePainter.fillPath(path, slider->palette.background());
-                        }
-                    }
-
-                    QImage image;
-                    if (horizontal) {
-                        image = QImage((ticksAbove && !ticksBelow) ? qt_plastique_slider_horizontalhandle_up : qt_plastique_slider_horizontalhandle);
-                    } else {
-                        image = QImage((ticksAbove && !ticksBelow) ? qt_plastique_slider_verticalhandle_left : qt_plastique_slider_verticalhandle);
-                    }
-
-                    image.setColor(1, borderColor.rgba());
-                    image.setColor(2, gradientStartColor.rgba());
-                    image.setColor(3, alphaCornerColor.rgba());
-                    if (option->state & State_Enabled) {
-                        image.setColor(4, 0x80ffffff);
-                        image.setColor(5, 0x25000000);
-                    }
-                    handlePainter.drawImage(pixmapRect, image);
-                    handlePainter.end();
-                    QPixmapCache::insert(handlePixmapName, cache);
-                }
-
-                painter->drawPixmap(handle.topLeft(), cache);
-
-                if (slider->state & State_HasFocus) {
-                    QStyleOptionFocusRect fropt;
-                    fropt.QStyleOption::operator=(*slider);
-                    fropt.rect = subElementRect(SE_SliderFocusRect, slider, widget);
-                    proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
-                }
-            }
-
-            if (option->subControls & SC_SliderTickmarks) {
-                QPen oldPen = painter->pen();
-                painter->setPen(borderColor);
-                int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
-                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
-                int interval = slider->tickInterval;
-                if (interval <= 0) {
-                    interval = slider->singleStep;
-                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
-                                                        available)
-                        - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                          0, available) < 3)
-                        interval = slider->pageStep;
-                }
-                if (interval <= 0)
-                    interval = 1;
-
-                int v = slider->minimum;
-                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
-                QVarLengthArray<QLine, 32> lines;
-                while (v <= slider->maximum + 1) {
-                    if (v == slider->maximum + 1 && interval == 1)
-                        break;
-                    const int v_ = qMin(v, slider->maximum);
-                    int pos = sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                      v_, (horizontal
-                                                          ? slider->rect.width()
-                                                          : slider->rect.height()) - len,
-                                                      slider->upsideDown) + len / 2;
-
-                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
-
-                    if (horizontal) {
-                        if (ticksAbove) {
-                            lines.append(QLine(pos, slider->rect.top() + extra,
-                                               pos, slider->rect.top() + tickSize));
-                        }
-                        if (ticksBelow) {
-                            lines.append(QLine(pos, slider->rect.bottom() - extra,
-                                               pos, slider->rect.bottom() - tickSize));
-                        }
-                    } else {
-                        if (ticksAbove) {
-                            lines.append(QLine(slider->rect.left() + extra, pos,
-                                               slider->rect.left() + tickSize, pos));
-                        }
-                        if (ticksBelow) {
-                            lines.append(QLine(slider->rect.right() - extra, pos,
-                                               slider->rect.right() - tickSize, pos));
-                        }
-                    }
-
-                    // in the case where maximum is max int
-                    int nextInterval = v + interval;
-                    if (nextInterval < v)
-                        break;
-                    v = nextInterval;
-                }
-                painter->drawLines(lines.constData(), lines.size());
-                painter->setPen(oldPen);
-            }
-        }
+		drawSlider<QStyleOptionSlider>(option, widget, borderColor, alphaCornerColor, gradientStartColor, gradientStopColor, painter, proxy(), this);
+        break;
+    case CC_Slider64:
+		drawSlider<QStyleOptionSlider64>(option, widget, borderColor, alphaCornerColor, gradientStartColor, gradientStopColor, painter, proxy(), this);
         break;
 #endif // QT_NO_SLIDER
 #ifndef QT_NO_SPINBOX
@@ -5051,6 +5060,144 @@ QRect QPlastiqueStyle::subElementRect(SubElement element, const QStyleOption *op
     return visualRect(option->direction, option->rect, rect);
 }
 
+template <class OptionStyle>
+static void subControlRectSlider(const QStyleOptionComplex* option, const QWidget* widget, QPlastiqueStyle::SubControl subControl, QRect& rect, QStyle const* proxy)
+{
+	if (const OptionStyle *slider = qstyleoption_cast<const OptionStyle *>(option)) {
+		int tickSize = proxy->pixelMetric(QPlastiqueStyle::PM_SliderTickmarkOffset, option, widget);
+
+		switch (subControl) {
+		case QPlastiqueStyle::SC_SliderHandle:
+			if (slider->orientation == Qt::Horizontal) {
+				rect.setWidth(11);
+				rect.setHeight(15);
+				int centerY = slider->rect.center().y() - rect.height() / 2;
+				if (slider->tickPosition & QSlider::TicksAbove)
+					centerY += tickSize;
+				if (slider->tickPosition & QSlider::TicksBelow)
+					centerY -= tickSize;
+				rect.moveTop(centerY);
+			} else {
+				rect.setWidth(15);
+				rect.setHeight(11);
+				int centerX = slider->rect.center().x() - rect.width() / 2;
+				if (slider->tickPosition & QSlider::TicksAbove)
+					centerX += tickSize;
+				if (slider->tickPosition & QSlider::TicksBelow)
+					centerX -= tickSize;
+				rect.moveLeft(centerX);
+			}
+			break;
+		case QPlastiqueStyle::SC_SliderGroove: {
+			QPoint grooveCenter = slider->rect.center();
+			if (slider->orientation == Qt::Horizontal) {
+				rect.setHeight(14);
+				--grooveCenter.ry();
+				if (slider->tickPosition & QSlider::TicksAbove)
+					grooveCenter.ry() += tickSize;
+				if (slider->tickPosition & QSlider::TicksBelow)
+					grooveCenter.ry() -= tickSize;
+			} else {
+				rect.setWidth(14);
+				--grooveCenter.rx();
+				if (slider->tickPosition & QSlider::TicksAbove)
+					grooveCenter.rx() += tickSize;
+				if (slider->tickPosition & QSlider::TicksBelow)
+					grooveCenter.rx() -= tickSize;
+			}
+			rect.moveCenter(grooveCenter);
+			break;
+		}
+		default:
+			break;
+		}
+	}
+}
+
+template <class OptionStyle>
+static void subControlRectScrollbar(const QStyleOptionComplex* option, const QWidget* widget, QPlastiqueStyle::SubControl subControl, QRect& rect, QStyle const* proxy)
+{
+	if (const OptionStyle *scrollBar = qstyleoption_cast<const OptionStyle *>(option)) {
+		qint64 scrollBarExtent = proxy->pixelMetric(QPlastiqueStyle::PM_ScrollBarExtent, scrollBar, widget);
+		qint64 sliderMaxLength = ((scrollBar->orientation == Qt::Horizontal) ?
+							   scrollBar->rect.width() : scrollBar->rect.height()) - (scrollBarExtent * 3);
+		qint64 sliderMinLength = proxy->pixelMetric(QPlastiqueStyle::PM_ScrollBarSliderMin, scrollBar, widget);
+		qint64 sliderLength;
+
+		// calculate slider length
+		if (scrollBar->maximum != scrollBar->minimum) {
+			uint valueRange = scrollBar->maximum - scrollBar->minimum;
+			sliderLength = (scrollBar->pageStep * sliderMaxLength) / (valueRange + scrollBar->pageStep);
+
+			if (sliderLength < sliderMinLength || valueRange > INT_MAX / 2)
+				sliderLength = sliderMinLength;
+			if (sliderLength > sliderMaxLength)
+				sliderLength = sliderMaxLength;
+		} else {
+			sliderLength = sliderMaxLength;
+		}
+
+		qint64 sliderStart = scrollBarExtent + QStyle::sliderPositionFromValue((qint64) scrollBar->minimum,
+													   (qint64) scrollBar->maximum,
+													   (qint64) scrollBar->sliderPosition,
+													   sliderMaxLength - sliderLength,
+													   scrollBar->upsideDown);
+
+		QRect scrollBarRect = scrollBar->rect;
+
+		switch (subControl) {
+		case QPlastiqueStyle::SC_ScrollBarSubLine: // top/left button
+			if (scrollBar->orientation == Qt::Horizontal) {
+				rect.setRect(scrollBarRect.left(), scrollBarRect.top(), scrollBarRect.width() - scrollBarExtent, scrollBarRect.height());
+			} else {
+				rect.setRect(scrollBarRect.left(), scrollBarRect.top(), scrollBarRect.width(), scrollBarRect.height() - scrollBarExtent);
+			}
+			break;
+		case QPlastiqueStyle::SC_ScrollBarAddLine: // bottom/right button
+			if (scrollBar->orientation == Qt::Horizontal) {
+				rect.setRect(scrollBarRect.right() - (scrollBarExtent - 1), scrollBarRect.top(), scrollBarExtent, scrollBarRect.height());
+			} else {
+				rect.setRect(scrollBarRect.left(), scrollBarRect.bottom() - (scrollBarExtent - 1), scrollBarRect.width(), scrollBarExtent);
+			}
+			break;
+		case QPlastiqueStyle::SC_ScrollBarSubPage:
+			if (scrollBar->orientation == Qt::Horizontal) {
+				rect.setRect(scrollBarRect.left() + scrollBarExtent, scrollBarRect.top(),
+							 sliderStart - (scrollBarRect.left() + scrollBarExtent), scrollBarRect.height());
+			} else {
+				rect.setRect(scrollBarRect.left(), scrollBarRect.top() + scrollBarExtent,
+							 scrollBarRect.width(), sliderStart - (scrollBarRect.left() + scrollBarExtent));
+			}
+			break;
+		case QPlastiqueStyle::SC_ScrollBarAddPage:
+			if (scrollBar->orientation == Qt::Horizontal)
+				rect.setRect(sliderStart + sliderLength, 0,
+							 sliderMaxLength - sliderStart - sliderLength + scrollBarExtent, scrollBarRect.height());
+			else
+				rect.setRect(0, sliderStart + sliderLength,
+							 scrollBarRect.width(), sliderMaxLength - sliderStart - sliderLength + scrollBarExtent);
+			break;
+		case QPlastiqueStyle::SC_ScrollBarGroove:
+			if (scrollBar->orientation == Qt::Horizontal) {
+				rect = scrollBarRect.adjusted(scrollBarExtent, 0, -2 * scrollBarExtent, 0);
+			} else {
+				rect = scrollBarRect.adjusted(0, scrollBarExtent, 0, -2 * scrollBarExtent);
+			}
+			break;
+		case QPlastiqueStyle::SC_ScrollBarSlider:
+			if (scrollBar->orientation == Qt::Horizontal) {
+				rect.setRect(sliderStart, 0, sliderLength, scrollBarRect.height());
+			} else {
+				rect.setRect(0, sliderStart, scrollBarRect.width(), sliderLength);
+			}
+			break;
+		default:
+			break;
+		}
+		rect = QStyle::visualRect(scrollBar->direction, scrollBarRect, rect);
+	}
+}
+
 /*!
   \reimp
 */
@@ -5062,138 +5209,18 @@ QRect QPlastiqueStyle::subControlRect(ComplexControl control, const QStyleOption
     switch (control) {
 #ifndef QT_NO_SLIDER
     case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
-
-            switch (subControl) {
-            case SC_SliderHandle:
-                if (slider->orientation == Qt::Horizontal) {
-                    rect.setWidth(11);
-                    rect.setHeight(15);
-                    int centerY = slider->rect.center().y() - rect.height() / 2;
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        centerY += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        centerY -= tickSize;
-                    rect.moveTop(centerY);
-                } else {
-                    rect.setWidth(15);
-                    rect.setHeight(11);
-                    int centerX = slider->rect.center().x() - rect.width() / 2;
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        centerX += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        centerX -= tickSize;
-                    rect.moveLeft(centerX);
-                }
-                break;
-            case SC_SliderGroove: {
-                QPoint grooveCenter = slider->rect.center();
-                if (slider->orientation == Qt::Horizontal) {
-                    rect.setHeight(14);
-                    --grooveCenter.ry();
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        grooveCenter.ry() += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        grooveCenter.ry() -= tickSize;
-                } else {
-                    rect.setWidth(14);
-                    --grooveCenter.rx();
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        grooveCenter.rx() += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        grooveCenter.rx() -= tickSize;
-                }
-                rect.moveCenter(grooveCenter);
-                break;
-            }
-            default:
-                break;
-            }
-        }
+		subControlRectSlider<QStyleOptionSlider>(option, widget, subControl, rect, proxy());
+        break;
+    case CC_Slider64:
+		subControlRectSlider<QStyleOptionSlider64>(option, widget, subControl, rect, proxy());
         break;
 #endif // QT_NO_SLIDER
 #ifndef QT_NO_SCROLLBAR
     case CC_ScrollBar:
-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            int scrollBarExtent = proxy()->pixelMetric(PM_ScrollBarExtent, scrollBar, widget);
-            int sliderMaxLength = ((scrollBar->orientation == Qt::Horizontal) ?
-                                   scrollBar->rect.width() : scrollBar->rect.height()) - (scrollBarExtent * 3);
-            int sliderMinLength = proxy()->pixelMetric(PM_ScrollBarSliderMin, scrollBar, widget);
-            int sliderLength;
-
-            // calculate slider length
-            if (scrollBar->maximum != scrollBar->minimum) {
-                uint valueRange = scrollBar->maximum - scrollBar->minimum;
-                sliderLength = (scrollBar->pageStep * sliderMaxLength) / (valueRange + scrollBar->pageStep);
-
-                if (sliderLength < sliderMinLength || valueRange > INT_MAX / 2)
-                    sliderLength = sliderMinLength;
-                if (sliderLength > sliderMaxLength)
-                    sliderLength = sliderMaxLength;
-            } else {
-                sliderLength = sliderMaxLength;
-            }
-
-            int sliderStart = scrollBarExtent + sliderPositionFromValue(scrollBar->minimum,
-                                                           scrollBar->maximum,
-                                                           scrollBar->sliderPosition,
-                                                           sliderMaxLength - sliderLength,
-                                                           scrollBar->upsideDown);
-
-            QRect scrollBarRect = scrollBar->rect;
-
-            switch (subControl) {
-            case SC_ScrollBarSubLine: // top/left button
-                if (scrollBar->orientation == Qt::Horizontal) {
-                    rect.setRect(scrollBarRect.left(), scrollBarRect.top(), scrollBarRect.width() - scrollBarExtent, scrollBarRect.height());
-                } else {
-                    rect.setRect(scrollBarRect.left(), scrollBarRect.top(), scrollBarRect.width(), scrollBarRect.height() - scrollBarExtent);
-                }
-                break;
-            case SC_ScrollBarAddLine: // bottom/right button
-                if (scrollBar->orientation == Qt::Horizontal) {
-                    rect.setRect(scrollBarRect.right() - (scrollBarExtent - 1), scrollBarRect.top(), scrollBarExtent, scrollBarRect.height());
-                } else {
-                    rect.setRect(scrollBarRect.left(), scrollBarRect.bottom() - (scrollBarExtent - 1), scrollBarRect.width(), scrollBarExtent);
-                }
-                break;
-            case SC_ScrollBarSubPage:
-                if (scrollBar->orientation == Qt::Horizontal) {
-                    rect.setRect(scrollBarRect.left() + scrollBarExtent, scrollBarRect.top(),
-                                 sliderStart - (scrollBarRect.left() + scrollBarExtent), scrollBarRect.height());
-                } else {
-                    rect.setRect(scrollBarRect.left(), scrollBarRect.top() + scrollBarExtent,
-                                 scrollBarRect.width(), sliderStart - (scrollBarRect.left() + scrollBarExtent));
-                }
-                break;
-            case SC_ScrollBarAddPage:
-                if (scrollBar->orientation == Qt::Horizontal)
-                    rect.setRect(sliderStart + sliderLength, 0,
-                                 sliderMaxLength - sliderStart - sliderLength + scrollBarExtent, scrollBarRect.height());
-                else
-                    rect.setRect(0, sliderStart + sliderLength,
-                                 scrollBarRect.width(), sliderMaxLength - sliderStart - sliderLength + scrollBarExtent);
-                break;
-            case SC_ScrollBarGroove:
-                if (scrollBar->orientation == Qt::Horizontal) {
-                    rect = scrollBarRect.adjusted(scrollBarExtent, 0, -2 * scrollBarExtent, 0);
-                } else {
-                    rect = scrollBarRect.adjusted(0, scrollBarExtent, 0, -2 * scrollBarExtent);
-                }
-                break;
-            case SC_ScrollBarSlider:
-                if (scrollBar->orientation == Qt::Horizontal) {
-                    rect.setRect(sliderStart, 0, sliderLength, scrollBarRect.height());
-                } else {
-                    rect.setRect(0, sliderStart, scrollBarRect.width(), sliderLength);
-                }
-                break;
-            default:
-                break;
-            }
-            rect = visualRect(scrollBar->direction, scrollBarRect, rect);
-        }
+		subControlRectScrollbar<QStyleOptionSlider>(option, widget, subControl, rect, proxy());
+        break;
+    case CC_ScrollBar64:
+		subControlRectScrollbar<QStyleOptionSlider64>(option, widget, subControl, rect, proxy());
         break;
 #endif // QT_NO_SCROLLBAR
 #ifndef QT_NO_SPINBOX
@@ -5450,32 +5477,33 @@ QStyle::SubControl QPlastiqueStyle::hitTestComplexControl(ComplexControl control
     switch (control) {
 #ifndef QT_NO_SCROLLBAR
     case CC_ScrollBar:
-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            QRect slider = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSlider, widget);
+    case CC_ScrollBar64:
+        if (qstyleoption_cast<const QStyleOptionSlider *>(option) || qstyleoption_cast<const QStyleOptionSlider64 *>(option)) {
+            QRect slider = proxy()->subControlRect(control, option, SC_ScrollBarSlider, widget);
             if (slider.contains(pos)) {
                 ret = SC_ScrollBarSlider;
                 break;
             }
 
-            QRect scrollBarAddLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarAddLine, widget);
+            QRect scrollBarAddLine = proxy()->subControlRect(control, option, SC_ScrollBarAddLine, widget);
             if (scrollBarAddLine.contains(pos)) {
                 ret = SC_ScrollBarAddLine;
                 break;
             }
 
-            QRect scrollBarSubPage = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSubPage, widget);
+            QRect scrollBarSubPage = proxy()->subControlRect(control, option, SC_ScrollBarSubPage, widget);
             if (scrollBarSubPage.contains(pos)) {
                 ret = SC_ScrollBarSubPage;
                 break;
             }
 
-            QRect scrollBarAddPage = proxy()->subControlRect(control, scrollBar, SC_ScrollBarAddPage, widget);
+            QRect scrollBarAddPage = proxy()->subControlRect(control, option, SC_ScrollBarAddPage, widget);
             if (scrollBarAddPage.contains(pos)) {
                 ret = SC_ScrollBarAddPage;
                 break;
             }
 
-            QRect scrollBarSubLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSubLine, widget);
+            QRect scrollBarSubLine = proxy()->subControlRect(control, option, SC_ScrollBarSubLine, widget);
             if (scrollBarSubLine.contains(pos)) {
                 ret = SC_ScrollBarSubLine;
                 break;
diff --git a/src/gui/styles/qstyle.cpp b/src/gui/styles/qstyle.cpp
index 8a5b1a9..0bf9cb3 100644
--- a/src/gui/styles/qstyle.cpp
+++ b/src/gui/styles/qstyle.cpp
@@ -2107,6 +2107,16 @@ Qt::Alignment QStyle::visualAlignment(Qt::LayoutDirection direction, Qt::Alignme
 }
 
 /*!
+    Implemented for ABI compatibility.
+*/
+
+int QStyle::sliderPositionFromValue(int min, int max, int logicalValue, int span, bool upsideDown)
+{
+	return sliderPositionFromValue((qint64) min, (qint64) max, (qint64) logicalValue, (qint64) span, upsideDown);
+}
+
+
+/*!
     Converts the given \a logicalValue to a pixel position. The \a min
     parameter maps to 0, \a max maps to \a span and other values are
     distributed evenly in-between.
@@ -2121,24 +2131,24 @@ Qt::Alignment QStyle::visualAlignment(Qt::LayoutDirection direction, Qt::Alignme
     \sa sliderValueFromPosition()
 */
 
-int QStyle::sliderPositionFromValue(int min, int max, int logicalValue, int span, bool upsideDown)
+int QStyle::sliderPositionFromValue(qint64 min, qint64 max, qint64 logicalValue, qint64 span, bool upsideDown)
 {
     if (span <= 0 || logicalValue < min || max <= min)
         return 0;
     if (logicalValue > max)
         return upsideDown ? span : min;
 
-    uint range = max - min;
-    uint p = upsideDown ? max - logicalValue : logicalValue - min;
+    quint64 range = max - min;
+    quint64 p = upsideDown ? max - logicalValue : logicalValue - min;
 
     if (range > (uint)INT_MAX/4096) {
         double dpos = (double(p))/(double(range)/span);
-        return int(dpos);
+        return qint64(dpos);
     } else if (range > (uint)span) {
         return (2 * p * span + range) / (2*range);
     } else {
-        uint div = span / range;
-        uint mod = span % range;
+        quint64 div = span / range;
+        quint64 mod = span % range;
         return p * div + (2 * p * mod + range) / (2 * range);
     }
     // equiv. to (p * span) / range + 0.5
@@ -2147,6 +2157,14 @@ int QStyle::sliderPositionFromValue(int min, int max, int logicalValue, int span
 }
 
 /*!
+    Implemented for ABI compatibility.
+*/
+int QStyle::sliderValueFromPosition(int min, int max, int pos, int span, bool upsideDown)
+{
+	return sliderValueFromPosition((qint64) min, (qint64) max, pos, (qint64) span, upsideDown);
+}
+
+/*!
     \fn int QStyle::sliderValueFromPosition(int min, int max, int position, int span, bool upsideDown)
 
     Converts the given pixel \a position to a logical value. 0 maps to
@@ -2164,22 +2182,22 @@ int QStyle::sliderPositionFromValue(int min, int max, int logicalValue, int span
     \sa sliderPositionFromValue()
 */
 
-int QStyle::sliderValueFromPosition(int min, int max, int pos, int span, bool upsideDown)
+qint64 QStyle::sliderValueFromPosition(qint64 min, qint64 max, int pos, qint64 span, bool upsideDown)
 {
     if (span <= 0 || pos <= 0)
         return upsideDown ? max : min;
     if (pos >= span)
         return upsideDown ? min : max;
 
-    uint range = max - min;
+    quint64 range = max - min;
 
     if ((uint)span > range) {
-        int tmp = (2 * pos * range + span) / (2 * span);
+        qint64 tmp = (2 * pos * range + span) / (2 * span);
         return upsideDown ? max - tmp : tmp + min;
     } else {
-        uint div = range / span;
-        uint mod = range % span;
-        int tmp = pos * div + (2 * pos * mod + span) / (2 * span);
+        quint64 div = range / span;
+        quint64 mod = range % span;
+        qint64 tmp = pos * div + (2 * pos * mod + span) / (2 * span);
         return upsideDown ? max - tmp : tmp + min;
     }
     // equiv. to min + (pos*range)/span + 0.5
diff --git a/src/gui/styles/qstyle.h b/src/gui/styles/qstyle.h
index 33f0e39..3337977 100644
--- a/src/gui/styles/qstyle.h
+++ b/src/gui/styles/qstyle.h
@@ -394,6 +394,8 @@ public:
         CC_Dial,
         CC_GroupBox,
         CC_MdiControls,
+        CC_ScrollBar64,
+        CC_Slider64,
 
         // do not add any values below/greater than this
         CC_CustomBase = 0xf0000000
@@ -843,6 +845,10 @@ public:
                                        bool upsideDown = false);
     static int sliderValueFromPosition(int min, int max, int pos, int space,
                                        bool upsideDown = false);
+	static int sliderPositionFromValue(qint64 min, qint64 max, qint64 val, qint64 space,
+                                       bool upsideDown = false);
+	static qint64 sliderValueFromPosition(qint64 min, qint64 max, int pos, qint64 space,
+                                       bool upsideDown = false);
     static Qt::Alignment visualAlignment(Qt::LayoutDirection direction, Qt::Alignment alignment);
     static QRect alignedRect(Qt::LayoutDirection direction, Qt::Alignment alignment,
                              const QSize &size, const QRect &rectangle);
diff --git a/src/gui/styles/qstyleoption.cpp b/src/gui/styles/qstyleoption.cpp
index 9d72c0b..8c4e5d4 100644
--- a/src/gui/styles/qstyleoption.cpp
+++ b/src/gui/styles/qstyleoption.cpp
@@ -3041,6 +3041,25 @@ QStyleOptionSlider::QStyleOptionSlider(int version)
 
     \sa QAbstractSlider::pageStep
 */
+
+QStyleOptionSlider64::QStyleOptionSlider64()
+    : QStyleOptionComplex(Version, SO_Slider64), orientation(Qt::Horizontal), minimum(0), maximum(0),
+      tickPosition(QSlider::NoTicks), tickInterval(0), upsideDown(false),
+      sliderPosition(0), sliderValue(0), singleStep(0), pageStep(0), notchTarget(0.0),
+      dialWrapping(false)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionSlider64::QStyleOptionSlider64(int version)
+    : QStyleOptionComplex(version, SO_Slider64), orientation(Qt::Horizontal), minimum(0), maximum(0),
+      tickPosition(QSlider::NoTicks), tickInterval(0), upsideDown(false),
+      sliderPosition(0), sliderValue(0), singleStep(0), pageStep(0), notchTarget(0.0),
+      dialWrapping(false)
+{
+}
 #endif // QT_NO_SLIDER
 
 #ifndef QT_NO_SPINBOX
diff --git a/src/gui/styles/qstyleoption.h b/src/gui/styles/qstyleoption.h
index 2869564..7136270 100644
--- a/src/gui/styles/qstyleoption.h
+++ b/src/gui/styles/qstyleoption.h
@@ -74,7 +74,7 @@ public:
                       SO_TabBarBase, SO_RubberBand, SO_ToolBar, SO_GraphicsItem,
 
                       SO_Complex = 0xf0000, SO_Slider, SO_SpinBox, SO_ToolButton, SO_ComboBox,
-                      SO_Q3ListView, SO_TitleBar, SO_GroupBox, SO_SizeGrip,
+                      SO_Q3ListView, SO_TitleBar, SO_GroupBox, SO_SizeGrip, SO_Slider64,
 
                       SO_CustomBase = 0xf00,
                       SO_ComplexCustomBase = 0xf000000
@@ -723,6 +723,33 @@ public:
 protected:
     QStyleOptionSlider(int version);
 };
+
+class Q_GUI_EXPORT QStyleOptionSlider64: public QStyleOptionComplex
+{
+public:
+    enum StyleOptionType { Type = SO_Slider64 };
+    enum StyleOptionVersion { Version = 1 };
+
+    Qt::Orientation orientation;
+    qint64 minimum;
+    qint64 maximum;
+    QSlider::TickPosition tickPosition;
+    int tickInterval;
+    bool upsideDown;
+    qint64 sliderPosition;
+    qint64 sliderValue;
+    qint64 singleStep;
+    qint64 pageStep;
+    qreal notchTarget;
+    bool dialWrapping;
+
+    QStyleOptionSlider64();
+    QStyleOptionSlider64(const QStyleOptionSlider64 &other) : QStyleOptionComplex(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionSlider64(int version);
+};
+
 #endif // QT_NO_SLIDER
 
 #ifndef QT_NO_SPINBOX
diff --git a/src/gui/widgets/qabstractslider64.cpp b/src/gui/widgets/qabstractslider64.cpp
new file mode 100644
index 0000000..2903f90
--- /dev/null
+++ b/src/gui/widgets/qabstractslider64.cpp
@@ -0,0 +1,1013 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qapplication.h>
+#include "qabstractslider64.h"
+#include "qevent.h"
+#include "qabstractslider64_p.h"
+#include "qdebug.h"
+#ifndef QT_NO_ACCESSIBILITY
+#include "qaccessible.h"
+#endif
+#include <limits.h>
+#define __STDC_LIMIT_MACROS
+#include <stdint.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QAbstractSlider64
+    \brief The QAbstractSlider64 class provides an integer value within a range.
+
+    \ingroup abstractwidgets
+
+    The class is designed as a common super class for widgets like
+    QScrollBar, QSlider and QDial.
+
+    Here are the main properties of the class:
+
+    \list 1
+
+    \i \l value: The bounded integer that QAbstractSlider64 maintains.
+
+    \i \l minimum: The lowest possible value.
+
+    \i \l maximum: The highest possible value.
+
+    \i \l singleStep: The smaller of two natural steps that an
+    abstract sliders provides and typically corresponds to the user
+    pressing an arrow key.
+
+    \i \l pageStep: The larger of two natural steps that an abstract
+    slider provides and typically corresponds to the user pressing
+    PageUp or PageDown.
+
+    \i \l tracking: Whether slider tracking is enabled.
+
+    \i \l sliderPosition: The current position of the slider. If \l
+    tracking is enabled (the default), this is identical to \l value.
+
+    \endlist
+
+    Unity (1) may be viewed as a third step size. setValue() lets you
+    set the current value to any integer in the allowed range, not
+    just minimum() + \e n * singleStep() for integer values of \e n.
+    Some widgets may allow the user to set any value at all; others
+    may just provide multiples of singleStep() or pageStep().
+
+    QAbstractSlider64 emits a comprehensive set of signals:
+
+    \table
+    \header \i Signal \i Emitted when
+    \row \i \l valueChanged()
+         \i the value has changed. The \l tracking
+            determines whether this signal is emitted during user
+            interaction.
+    \row \i \l sliderPressed()
+         \i the user starts to drag the slider.
+    \row \i \l sliderMoved()
+         \i the user drags the slider.
+    \row \i \l sliderReleased()
+         \i the user releases the slider.
+    \row \i \l actionTriggered()
+         \i a slider action was triggerd.
+    \row \i \l rangeChanged()
+         \i a the range has changed.
+    \endtable
+
+    QAbstractSlider64 provides a virtual sliderChange() function that is
+    well suited for updating the on-screen representation of
+    sliders. By calling triggerAction(), subclasses trigger slider
+    actions. Two helper functions QStyle::sliderPositionFromValue() and
+    QStyle::sliderValueFromPosition() help subclasses and styles to map
+    screen coordinates to logical range values.
+
+    \sa QAbstractSpinBox, QSlider, QDial, QScrollBar, {Sliders Example}
+*/
+
+/*!
+    \enum QAbstractSlider64::SliderAction
+
+    \value SliderNoAction
+    \value SliderSingleStepAdd
+    \value SliderSingleStepSub
+    \value SliderPageStepAdd
+    \value SliderPageStepSub
+    \value SliderToMinimum
+    \value SliderToMaximum
+    \value SliderMove
+
+*/
+
+/*!
+    \fn void QAbstractSlider64::valueChanged(int value)
+
+    This signal is emitted when the slider value has changed, with the
+    new slider \a value as argument.
+*/
+
+/*!
+    \fn void QAbstractSlider64::sliderPressed()
+
+    This signal is emitted when the user presses the slider with the
+    mouse, or programmatically when setSliderDown(true) is called.
+
+    \sa sliderReleased(), sliderMoved(), isSliderDown()
+*/
+
+/*!
+    \fn void QAbstractSlider64::sliderMoved(int value)
+
+    This signal is emitted when sliderDown is true and the slider moves. This
+    usually happens when the user is dragging the slider. The \a value
+    is the new slider position.
+
+    This signal is emitted even when tracking is turned off.
+
+    \sa setTracking(), valueChanged(), isSliderDown(),
+    sliderPressed(), sliderReleased()
+*/
+
+/*!
+    \fn void QAbstractSlider64::sliderReleased()
+
+    This signal is emitted when the user releases the slider with the
+    mouse, or programmatically when setSliderDown(false) is called.
+
+    \sa sliderPressed() sliderMoved() sliderDown
+*/
+
+/*!
+    \fn void QAbstractSlider64::rangeChanged(int min, int max)
+
+    This signal is emitted when the slider range has changed, with \a
+    min being the new minimum, and \a max being the new maximum.
+
+    \sa minimum, maximum
+*/
+
+/*!
+    \fn void QAbstractSlider64::actionTriggered(int action)
+
+    This signal is emitted when the slider action \a action is
+    triggered. Actions are \l SliderSingleStepAdd, \l
+    SliderSingleStepSub, \l SliderPageStepAdd, \l SliderPageStepSub,
+    \l SliderToMinimum, \l SliderToMaximum, and \l SliderMove.
+
+    When the signal is emitted, the \l sliderPosition has been
+    adjusted according to the action, but the \l value has not yet
+    been propagated (meaning the valueChanged() signal was not yet
+    emitted), and the visual display has not been updated. In slots
+    connected to this signal you can thus safely adjust any action by
+    calling setSliderPosition() yourself, based on both the action and
+    the slider's value.
+
+    \sa triggerAction()
+*/
+
+/*!
+    \enum QAbstractSlider64::SliderChange
+
+    \value SliderRangeChange
+    \value SliderOrientationChange
+    \value SliderStepsChange
+    \value SliderValueChange
+*/
+
+QAbstractSlider64Private::QAbstractSlider64Private()
+    : minimum(0), maximum(99), pageStep(10), value(0), position(0), pressValue(-1),
+      singleStep(1), offset_accumulated(0), tracking(true),
+      blocktracking(false), pressed(false),
+      invertedAppearance(false), invertedControls(false),
+      orientation(Qt::Horizontal), repeatAction(QAbstractSlider64::SliderNoAction)
+#ifdef QT_KEYPAD_NAVIGATION
+      , isAutoRepeating(false)
+      , repeatMultiplier(1)
+{
+    firstRepeat.invalidate();
+#else
+{
+#endif
+
+}
+
+QAbstractSlider64Private::~QAbstractSlider64Private()
+{
+}
+
+/*!
+    Sets the slider's minimum to \a min and its maximum to \a max.
+
+    If \a max is smaller than \a min, \a min becomes the only legal
+    value.
+
+    \sa minimum maximum
+*/
+void QAbstractSlider64::setRange(qint64 min, qint64 max)
+{
+    Q_D(QAbstractSlider64);
+    qint64 oldMin = d->minimum;
+    qint64 oldMax = d->maximum;
+    d->minimum = min;
+    d->maximum = qMax(min, max);
+    if (oldMin != d->minimum || oldMax != d->maximum) {
+        sliderChange(SliderRangeChange);
+        emit rangeChanged(d->minimum, d->maximum);
+        setValue(d->value); // re-bound
+    }
+}
+
+
+void QAbstractSlider64Private::setSteps(qint64 single, qint64 page)
+{
+    Q_Q(QAbstractSlider64);
+    singleStep = qAbs(single);
+    pageStep = qAbs(page);
+    q->sliderChange(QAbstractSlider64::SliderStepsChange);
+}
+
+/*!
+    Constructs an abstract slider.
+
+    The \a parent argument is sent to the QWidget constructor.
+
+    The \l minimum defaults to 0, the \l maximum to 99, with a \l
+    singleStep size of 1 and a \l pageStep size of 10, and an initial
+    \l value of 0.
+*/
+QAbstractSlider64::QAbstractSlider64(QWidget *parent)
+    :QWidget(*new QAbstractSlider64Private, parent, 0)
+{
+}
+
+/*! \internal */
+QAbstractSlider64::QAbstractSlider64(QAbstractSlider64Private &dd, QWidget *parent)
+    :QWidget(dd, parent, 0)
+{
+}
+
+/*!
+    Destroys the slider.
+*/
+QAbstractSlider64::~QAbstractSlider64()
+{
+}
+
+/*!
+    \property QAbstractSlider64::orientation
+    \brief the orientation of the slider
+
+    The orientation must be \l Qt::Vertical (the default) or \l
+    Qt::Horizontal.
+*/
+void QAbstractSlider64::setOrientation(Qt::Orientation orientation)
+{
+    Q_D(QAbstractSlider64);
+    if (d->orientation == orientation)
+        return;
+
+    d->orientation = orientation;
+    if (!testAttribute(Qt::WA_WState_OwnSizePolicy)) {
+        QSizePolicy sp = sizePolicy();
+        sp.transpose();
+        setSizePolicy(sp);
+        setAttribute(Qt::WA_WState_OwnSizePolicy, false);
+    }
+    update();
+    updateGeometry();
+}
+
+Qt::Orientation QAbstractSlider64::orientation() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->orientation;
+}
+
+
+/*!
+    \property QAbstractSlider64::minimum
+    \brief the sliders's minimum value
+
+    When setting this property, the \l maximum is adjusted if
+    necessary to ensure that the range remains valid. Also the
+    slider's current value is adjusted to be within the new range.
+
+*/
+
+void QAbstractSlider64::setMinimum(qint64 min)
+{
+    Q_D(QAbstractSlider64);
+    setRange(min, qMax(d->maximum, min));
+}
+
+qint64 QAbstractSlider64::minimum() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->minimum;
+}
+
+
+/*!
+    \property QAbstractSlider64::maximum
+    \brief the slider's maximum value
+
+    When setting this property, the \l minimum is adjusted if
+    necessary to ensure that the range remains valid.  Also the
+    slider's current value is adjusted to be within the new range.
+
+
+*/
+
+void QAbstractSlider64::setMaximum(qint64 max)
+{
+    Q_D(QAbstractSlider64);
+    setRange(qMin(d->minimum, max), max);
+}
+
+qint64 QAbstractSlider64::maximum() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->maximum;
+}
+
+
+
+/*!
+    \property QAbstractSlider64::singleStep
+    \brief the single step.
+
+    The smaller of two natural steps that an
+    abstract sliders provides and typically corresponds to the user
+    pressing an arrow key.
+
+    If the property is modified during an auto repeating key event, behavior
+    is undefined.
+
+    \sa pageStep
+*/
+
+void QAbstractSlider64::setSingleStep(qint64 step)
+{
+    Q_D(QAbstractSlider64);
+    if (step != d->singleStep)
+        d->setSteps(step, d->pageStep);
+}
+
+qint64 QAbstractSlider64::singleStep() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->singleStep;
+}
+
+
+/*!
+    \property QAbstractSlider64::pageStep
+    \brief the page step.
+
+    The larger of two natural steps that an abstract slider provides
+    and typically corresponds to the user pressing PageUp or PageDown.
+
+    \sa singleStep
+*/
+
+void QAbstractSlider64::setPageStep(qint64 step)
+{
+    Q_D(QAbstractSlider64);
+    if (step != d->pageStep)
+        d->setSteps(d->singleStep, step);
+}
+
+qint64 QAbstractSlider64::pageStep() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->pageStep;
+}
+
+/*!
+    \property QAbstractSlider64::tracking
+    \brief whether slider tracking is enabled
+
+    If tracking is enabled (the default), the slider emits the
+    valueChanged() signal while the slider is being dragged. If
+    tracking is disabled, the slider emits the valueChanged() signal
+    only when the user releases the slider.
+
+    \sa sliderDown
+*/
+void QAbstractSlider64::setTracking(bool enable)
+{
+    Q_D(QAbstractSlider64);
+    d->tracking = enable;
+}
+
+bool QAbstractSlider64::hasTracking() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->tracking;
+}
+
+
+/*!
+    \property QAbstractSlider64::sliderDown
+    \brief whether the slider is pressed down.
+
+    The property is set by subclasses in order to let the abstract
+    slider know whether or not \l tracking has any effect.
+
+    Changing the slider down property emits the sliderPressed() and
+    sliderReleased() signals.
+
+*/
+void QAbstractSlider64::setSliderDown(bool down)
+{
+    Q_D(QAbstractSlider64);
+    bool doEmit = d->pressed != down;
+
+    d->pressed = down;
+
+    if (doEmit) {
+        if (down)
+            emit sliderPressed();
+        else
+            emit sliderReleased();
+    }
+
+    if (!down && d->position != d->value)
+        triggerAction(SliderMove);
+}
+
+bool QAbstractSlider64::isSliderDown() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->pressed;
+}
+
+
+/*!
+    \property QAbstractSlider64::sliderPosition
+    \brief the current slider position
+
+    If \l tracking is enabled (the default), this is identical to \l value.
+*/
+void QAbstractSlider64::setSliderPosition(qint64 position)
+{
+    Q_D(QAbstractSlider64);
+    position = d->bound(position);
+    if (position == d->position)
+        return;
+    d->position = position;
+    if (!d->tracking)
+        update();
+    if (d->pressed)
+        emit sliderMoved(position);
+    if (d->tracking && !d->blocktracking)
+        triggerAction(SliderMove);
+}
+
+qint64 QAbstractSlider64::sliderPosition() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->position;
+}
+
+
+/*!
+    \property QAbstractSlider64::value
+    \brief the slider's current value
+
+    The slider forces the value to be within the legal range: \l
+    minimum <= \c value <= \l maximum.
+
+    Changing the value also changes the \l sliderPosition.
+*/
+
+
+qint64 QAbstractSlider64::value() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->value;
+}
+
+void QAbstractSlider64::setValue(qint64 value)
+{
+    Q_D(QAbstractSlider64);
+    value = d->bound(value);
+    if (d->value == value && d->position == value)
+        return;
+    d->value = value;
+    if (d->position != value) {
+        d->position = value;
+        if (d->pressed)
+            emit sliderMoved((d->position = value));
+    }
+#ifndef QT_NO_ACCESSIBILITY
+    QAccessible::updateAccessibility(this, 0, QAccessible::ValueChanged);
+#endif
+    sliderChange(SliderValueChange);
+    emit valueChanged(value);
+}
+
+/*!
+    \property QAbstractSlider64::invertedAppearance
+    \brief whether or not a slider shows its values inverted.
+
+    If this property is false (the default), the minimum and maximum will
+    be shown in its classic position for the inherited widget. If the
+    value is true, the minimum and maximum appear at their opposite location.
+
+    Note: This property makes most sense for sliders and dials. For
+    scroll bars, the visual effect of the scroll bar subcontrols depends on
+    whether or not the styles understand inverted appearance; most styles
+    ignore this property for scroll bars.
+*/
+
+bool QAbstractSlider64::invertedAppearance() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->invertedAppearance;
+}
+
+void QAbstractSlider64::setInvertedAppearance(bool invert)
+{
+    Q_D(QAbstractSlider64);
+    d->invertedAppearance = invert;
+    update();
+}
+
+
+/*!
+    \property QAbstractSlider64::invertedControls
+    \brief whether or not the slider inverts its wheel and key events.
+
+    If this property is false, scrolling the mouse wheel "up" and using keys
+    like page up will increase the slider's value towards its maximum. Otherwise
+    pressing page up will move value towards the slider's minimum.
+*/
+
+
+bool QAbstractSlider64::invertedControls() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->invertedControls;
+}
+
+void QAbstractSlider64::setInvertedControls(bool invert)
+{
+    Q_D(QAbstractSlider64);
+    d->invertedControls = invert;
+}
+
+/*!  Triggers a slider \a action.  Possible actions are \l
+  SliderSingleStepAdd, \l SliderSingleStepSub, \l SliderPageStepAdd,
+  \l SliderPageStepSub, \l SliderToMinimum, \l SliderToMaximum, and \l
+  SliderMove.
+
+  \sa actionTriggered()
+ */
+void QAbstractSlider64::triggerAction(SliderAction action)
+{
+    Q_D(QAbstractSlider64);
+    d->blocktracking = true;
+    switch (action) {
+    case SliderSingleStepAdd:
+        setSliderPosition(d->overflowSafeAdd(d->effectiveSingleStep()));
+        break;
+    case SliderSingleStepSub:
+        setSliderPosition(d->overflowSafeAdd(-d->effectiveSingleStep()));
+        break;
+    case SliderPageStepAdd:
+        setSliderPosition(d->overflowSafeAdd(d->pageStep));
+        break;
+    case SliderPageStepSub:
+        setSliderPosition(d->overflowSafeAdd(-d->pageStep));
+        break;
+    case SliderToMinimum:
+        setSliderPosition(d->minimum);
+        break;
+    case SliderToMaximum:
+        setSliderPosition(d->maximum);
+        break;
+    case SliderMove:
+    case SliderNoAction:
+        break;
+    };
+    emit actionTriggered(action);
+    d->blocktracking = false;
+    setValue(d->position);
+}
+
+/*!  Sets action \a action to be triggered repetitively in intervals
+of \a repeatTime, after an initial delay of \a thresholdTime.
+
+\sa triggerAction() repeatAction()
+ */
+void QAbstractSlider64::setRepeatAction(SliderAction action, int thresholdTime, int repeatTime)
+{
+    Q_D(QAbstractSlider64);
+    if ((d->repeatAction = action) == SliderNoAction) {
+        d->repeatActionTimer.stop();
+    } else {
+        d->repeatActionTime = repeatTime;
+        d->repeatActionTimer.start(thresholdTime, this);
+    }
+}
+
+/*!
+  Returns the current repeat action.
+  \sa setRepeatAction()
+ */
+QAbstractSlider64::SliderAction QAbstractSlider64::repeatAction() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->repeatAction;
+}
+
+/*!\reimp
+ */
+void QAbstractSlider64::timerEvent(QTimerEvent *e)
+{
+    Q_D(QAbstractSlider64);
+    if (e->timerId() == d->repeatActionTimer.timerId()) {
+        if (d->repeatActionTime) { // was threshold time, use repeat time next time
+            d->repeatActionTimer.start(d->repeatActionTime, this);
+            d->repeatActionTime = 0;
+        }
+        if (d->repeatAction == SliderPageStepAdd)
+            d->setAdjustedSliderPosition(d->overflowSafeAdd(d->pageStep));
+        else if (d->repeatAction == SliderPageStepSub)
+            d->setAdjustedSliderPosition(d->overflowSafeAdd(-d->pageStep));
+        else
+            triggerAction(d->repeatAction);
+    }
+}
+
+/*!
+    Reimplement this virtual function to track slider changes such as
+    \l SliderRangeChange, \l SliderOrientationChange, \l
+    SliderStepsChange, or \l SliderValueChange. The default
+    implementation only updates the display and ignores the \a change
+    parameter.
+ */
+void QAbstractSlider64::sliderChange(SliderChange)
+{
+    update();
+}
+
+/*!
+    \internal
+
+    Truncate qreal to int without flipping on overflow.
+*/
+static inline qint64 clampScrollStep(qreal x)
+{
+    return qint64(qBound(qreal(INT64_MIN), x, qreal(INT64_MAX)));
+}
+
+bool QAbstractSlider64Private::scrollByDelta(Qt::Orientation orientation, Qt::KeyboardModifiers modifiers, qint64 delta)
+{
+    Q_Q(QAbstractSlider64);
+    qint64 stepsToScroll = 0;
+    // in Qt scrolling to the right gives negative values.
+    if (orientation == Qt::Horizontal)
+        delta = -delta;
+    qreal offset = qreal(delta) / 120;
+
+    if ((modifiers & Qt::ControlModifier) || (modifiers & Qt::ShiftModifier)) {
+        // Scroll one page regardless of delta:
+        stepsToScroll = qBound(-pageStep, clampScrollStep(offset * pageStep), pageStep);
+        offset_accumulated = 0;
+    } else {
+        // Calculate how many lines to scroll. Depending on what delta is (and
+        // offset), we might end up with a fraction (e.g. scroll 1.3 lines). We can
+        // only scroll whole lines, so we keep the reminder until next event.
+        qreal stepsToScrollF =
+#ifndef QT_NO_WHEELEVENT
+                QApplication::wheelScrollLines() *
+#endif
+                offset * effectiveSingleStep();
+        // Check if wheel changed direction since last event:
+        if (offset_accumulated != 0 && (offset / offset_accumulated) < 0)
+            offset_accumulated = 0;
+
+        offset_accumulated += stepsToScrollF;
+#ifndef Q_WS_MAC
+        // Don't scroll more than one page in any case:
+        stepsToScroll = qBound(-pageStep, clampScrollStep(offset_accumulated), pageStep);
+#else
+        // Native UI-elements on Mac can scroll hundreds of lines at a time as
+        // a result of acceleration. So keep the same behaviour in Qt, and
+        // don't restrict stepsToScroll to certain maximum (pageStep):
+        stepsToScroll = clampScrollStep(offset_accumulated);
+#endif
+        offset_accumulated -= clampScrollStep(offset_accumulated);
+        if (stepsToScroll == 0)
+            return false;
+    }
+
+    if (invertedControls)
+        stepsToScroll = -stepsToScroll;
+
+    qint64 prevValue = value;
+    position = overflowSafeAdd(stepsToScroll); // value will be updated by triggerAction()
+    q->triggerAction(QAbstractSlider64::SliderMove);
+
+    if (prevValue == value) {
+        offset_accumulated = 0;
+        return false;
+    }
+    return true;
+}
+
+/*!
+    \reimp
+*/
+#ifndef QT_NO_WHEELEVENT
+void QAbstractSlider64::wheelEvent(QWheelEvent * e)
+{
+    Q_D(QAbstractSlider64);
+    e->ignore();
+    int delta = e->delta();
+    if (d->scrollByDelta(e->orientation(), e->modifiers(), delta))
+        e->accept();
+}
+
+#endif
+
+/*!
+    \reimp
+*/
+void QAbstractSlider64::keyPressEvent(QKeyEvent *ev)
+{
+    Q_D(QAbstractSlider64);
+    SliderAction action = SliderNoAction;
+#ifdef QT_KEYPAD_NAVIGATION
+    if (ev->isAutoRepeat()) {
+        if (!d->firstRepeat.isValid())
+            d->firstRepeat.start();
+        else if (1 == d->repeatMultiplier) {
+            // This is the interval in milli seconds which one key repetition
+            // takes.
+            const int repeatMSecs = d->firstRepeat.elapsed();
+
+            /**
+             * The time it takes to currently navigate the whole slider.
+             */
+            const qreal currentTimeElapse = (qreal(maximum()) / singleStep()) * repeatMSecs;
+
+            /**
+             * This is an arbitrarily determined constant in msecs that
+             * specifies how long time it should take to navigate from the
+             * start to the end(excluding starting key auto repeat).
+             */
+            const int SliderRepeatElapse = 2500;
+
+            d->repeatMultiplier = currentTimeElapse / SliderRepeatElapse;
+        }
+
+    }
+    else if (d->firstRepeat.isValid()) {
+        d->firstRepeat.invalidate();
+        d->repeatMultiplier = 1;
+    }
+
+#endif
+
+    switch (ev->key()) {
+#ifdef QT_KEYPAD_NAVIGATION
+        case Qt::Key_Select:
+            if (QApplication::keypadNavigationEnabled())
+                setEditFocus(!hasEditFocus());
+            else
+                ev->ignore();
+            break;
+        case Qt::Key_Back:
+            if (QApplication::keypadNavigationEnabled() && hasEditFocus()) {
+                setValue(d->origValue);
+                setEditFocus(false);
+            } else
+                ev->ignore();
+            break;
+#endif
+
+        // It seems we need to use invertedAppearance for Left and right, otherwise, things look weird.
+        case Qt::Key_Left:
+#ifdef QT_KEYPAD_NAVIGATION
+            // In QApplication::KeypadNavigationDirectional, we want to change the slider
+            // value if there is no left/right navigation possible and if this slider is not
+            // inside a tab widget.
+            if (QApplication::keypadNavigationEnabled()
+                    && (!hasEditFocus() && QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
+                    || d->orientation == Qt::Vertical
+                    || !hasEditFocus()
+                    && (QWidgetPrivate::canKeypadNavigate(Qt::Horizontal) || QWidgetPrivate::inTabWidget(this)))) {
+                ev->ignore();
+                return;
+            }
+            if (QApplication::keypadNavigationEnabled() && d->orientation == Qt::Vertical)
+                action = d->invertedControls ? SliderSingleStepSub : SliderSingleStepAdd;
+            else
+#endif
+            if (isRightToLeft())
+                action = d->invertedAppearance ? SliderSingleStepSub : SliderSingleStepAdd;
+            else
+                action = !d->invertedAppearance ? SliderSingleStepSub : SliderSingleStepAdd;
+            break;
+        case Qt::Key_Right:
+#ifdef QT_KEYPAD_NAVIGATION
+            // Same logic as in Qt::Key_Left
+            if (QApplication::keypadNavigationEnabled()
+                    && (!hasEditFocus() && QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
+                    || d->orientation == Qt::Vertical
+                    || !hasEditFocus()
+                    && (QWidgetPrivate::canKeypadNavigate(Qt::Horizontal) || QWidgetPrivate::inTabWidget(this)))) {
+                ev->ignore();
+                return;
+            }
+            if (QApplication::keypadNavigationEnabled() && d->orientation == Qt::Vertical)
+                action = d->invertedControls ? SliderSingleStepAdd : SliderSingleStepSub;
+            else
+#endif
+            if (isRightToLeft())
+                action = d->invertedAppearance ? SliderSingleStepAdd : SliderSingleStepSub;
+            else
+                action = !d->invertedAppearance ? SliderSingleStepAdd : SliderSingleStepSub;
+            break;
+        case Qt::Key_Up:
+#ifdef QT_KEYPAD_NAVIGATION
+            // In QApplication::KeypadNavigationDirectional, we want to change the slider
+            // value if there is no up/down navigation possible.
+            if (QApplication::keypadNavigationEnabled()
+                    && (QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
+                    || d->orientation == Qt::Horizontal
+                    || !hasEditFocus() && QWidgetPrivate::canKeypadNavigate(Qt::Vertical))) {
+                ev->ignore();
+                break;
+            }
+#endif
+            action = d->invertedControls ? SliderSingleStepSub : SliderSingleStepAdd;
+            break;
+        case Qt::Key_Down:
+#ifdef QT_KEYPAD_NAVIGATION
+            // Same logic as in Qt::Key_Up
+            if (QApplication::keypadNavigationEnabled()
+                    && (QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
+                    || d->orientation == Qt::Horizontal
+                    || !hasEditFocus() && QWidgetPrivate::canKeypadNavigate(Qt::Vertical))) {
+                ev->ignore();
+                break;
+            }
+#endif
+            action = d->invertedControls ? SliderSingleStepAdd : SliderSingleStepSub;
+            break;
+        case Qt::Key_PageUp:
+            action = d->invertedControls ? SliderPageStepSub : SliderPageStepAdd;
+            break;
+        case Qt::Key_PageDown:
+            action = d->invertedControls ? SliderPageStepAdd : SliderPageStepSub;
+            break;
+        case Qt::Key_Home:
+            action = SliderToMinimum;
+            break;
+        case Qt::Key_End:
+            action = SliderToMaximum;
+            break;
+        default:
+            ev->ignore();
+            break;
+    }
+    if (action)
+        triggerAction(action);
+}
+
+/*!
+    \reimp
+*/
+void QAbstractSlider64::changeEvent(QEvent *ev)
+{
+    Q_D(QAbstractSlider64);
+    switch (ev->type()) {
+    case QEvent::EnabledChange:
+        if (!isEnabled()) {
+            d->repeatActionTimer.stop();
+            setSliderDown(false);
+        }
+        // fall through...
+    default:
+        QWidget::changeEvent(ev);
+    }
+}
+
+/*!
+    \reimp
+*/
+bool QAbstractSlider64::event(QEvent *e)
+{
+#ifdef QT_KEYPAD_NAVIGATION
+    Q_D(QAbstractSlider64);
+    switch (e->type()) {
+    case QEvent::FocusIn:
+        d->origValue = d->value;
+        break;
+    default:
+        break;
+    }
+#endif
+
+    return QWidget::event(e);
+}
+
+/*! \fn int QAbstractSlider64::minValue() const
+
+    Use minimum() instead.
+*/
+
+/*! \fn int QAbstractSlider64::maxValue() const
+
+    Use maximum() instead.
+*/
+
+/*! \fn int QAbstractSlider64::lineStep() const
+
+    Use singleStep() instead.
+*/
+
+/*! \fn void QAbstractSlider64::setMinValue(int v)
+
+    Use setMinimum() instead.
+*/
+
+/*! \fn void QAbstractSlider64::setMaxValue(int v)
+
+    Use setMaximum() instead.
+*/
+
+/*! \fn void QAbstractSlider64::setLineStep(int v)
+
+    Use setSingleStep() instead.
+*/
+
+/*! \fn void QAbstractSlider64::addPage()
+
+    Use triggerAction(QAbstractSlider64::SliderPageStepAdd) instead.
+*/
+
+/*! \fn void QAbstractSlider64::subtractPage()
+
+    Use triggerAction(QAbstractSlider64::SliderPageStepSub) instead.
+*/
+
+/*! \fn void QAbstractSlider64::addLine()
+
+    Use triggerAction(QAbstractSlider64::SliderSingleStepAdd) instead.
+*/
+
+/*! \fn void QAbstractSlider64::subtractLine()
+
+    Use triggerAction(QAbstractSlider64::SliderSingleStepSub) instead.
+*/
+
+/*! \fn void QAbstractSlider64::setSteps(int single, int page)
+
+    Use setSingleStep(\a single) followed by setPageStep(\a page)
+    instead.
+*/
+
+QT_END_NAMESPACE
diff --git a/src/gui/widgets/qabstractslider64.h b/src/gui/widgets/qabstractslider64.h
new file mode 100644
index 0000000..30acdfe
--- /dev/null
+++ b/src/gui/widgets/qabstractslider64.h
@@ -0,0 +1,143 @@
+#ifndef QABSTRACTSLIDER64_H
+#define QABSTRACTSLIDER64_H
+
+#include <QtGui/qwidget.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Gui)
+
+class QAbstractSlider64Private;
+
+class Q_GUI_EXPORT QAbstractSlider64 : public QWidget
+{
+    Q_OBJECT
+
+    Q_PROPERTY(qint64 minimum READ minimum WRITE setMinimum)
+    Q_PROPERTY(qint64 maximum READ maximum WRITE setMaximum)
+    Q_PROPERTY(qint64 singleStep READ singleStep WRITE setSingleStep)
+    Q_PROPERTY(qint64 pageStep READ pageStep WRITE setPageStep)
+    Q_PROPERTY(qint64 value READ value WRITE setValue NOTIFY valueChanged USER true)
+    Q_PROPERTY(qint64 sliderPosition READ sliderPosition WRITE setSliderPosition NOTIFY sliderMoved)
+    Q_PROPERTY(bool tracking READ hasTracking WRITE setTracking)
+    Q_PROPERTY(Qt::Orientation orientation READ orientation WRITE setOrientation)
+    Q_PROPERTY(bool invertedAppearance READ invertedAppearance WRITE setInvertedAppearance)
+    Q_PROPERTY(bool invertedControls READ invertedControls WRITE setInvertedControls)
+    Q_PROPERTY(bool sliderDown READ isSliderDown WRITE setSliderDown DESIGNABLE false)
+
+public:
+    explicit QAbstractSlider64(QWidget *parent=0);
+    ~QAbstractSlider64();
+
+    Qt::Orientation orientation() const;
+
+    void setMinimum(qint64);
+    qint64 minimum() const;
+
+    void setMaximum(qint64);
+    qint64 maximum() const;
+
+    void setRange(qint64 min, qint64 max);
+
+    void setSingleStep(qint64);
+    qint64 singleStep() const;
+
+    void setPageStep(qint64);
+    qint64 pageStep() const;
+
+    void setTracking(bool enable);
+    bool hasTracking() const;
+
+    void setSliderDown(bool);
+    bool isSliderDown() const;
+
+    void setSliderPosition(qint64);
+    qint64 sliderPosition() const;
+
+    void setInvertedAppearance(bool);
+    bool invertedAppearance() const;
+
+    void setInvertedControls(bool);
+    bool invertedControls() const;
+
+    enum SliderAction {
+        SliderNoAction,
+        SliderSingleStepAdd,
+        SliderSingleStepSub,
+        SliderPageStepAdd,
+        SliderPageStepSub,
+        SliderToMinimum,
+        SliderToMaximum,
+        SliderMove
+    };
+
+    qint64 value() const;
+
+    void triggerAction(SliderAction action);
+
+public Q_SLOTS:
+    void setValue(qint64);
+    void setOrientation(Qt::Orientation);
+
+Q_SIGNALS:
+    void valueChanged(qint64 value);
+
+    void sliderPressed();
+    void sliderMoved(qint64 position);
+    void sliderReleased();
+
+    void rangeChanged(qint64 min, qint64 max);
+
+    void actionTriggered(int action);
+
+protected:
+    bool event(QEvent *e);
+
+    void setRepeatAction(SliderAction action, int thresholdTime = 500, int repeatTime = 50);
+    SliderAction repeatAction() const;
+
+    enum SliderChange {
+        SliderRangeChange,
+        SliderOrientationChange,
+        SliderStepsChange,
+        SliderValueChange
+    };
+    virtual void sliderChange(SliderChange change);
+
+    void keyPressEvent(QKeyEvent *ev);
+    void timerEvent(QTimerEvent *);
+#ifndef QT_NO_WHEELEVENT
+    void wheelEvent(QWheelEvent *e);
+#endif
+    void changeEvent(QEvent *e);
+
+#ifdef QT3_SUPPORT
+public:
+    inline QT3_SUPPORT qint64 minValue() const { return minimum(); }
+    inline QT3_SUPPORT qint64 maxValue() const { return maximum(); }
+    inline QT3_SUPPORT qint64 lineStep() const { return singleStep(); }
+    inline QT3_SUPPORT void setMinValue(qint64 v) { setMinimum(v); }
+    inline QT3_SUPPORT void setMaxValue(qint64 v) { setMaximum(v); }
+    inline QT3_SUPPORT void setLineStep(qint64 v) { setSingleStep(v); }
+    inline QT3_SUPPORT void setSteps(qint64 single, qint64 page) { setSingleStep(single); setPageStep(page); }
+    inline QT3_SUPPORT void addPage() { triggerAction(SliderPageStepAdd); }
+    inline QT3_SUPPORT void subtractPage() { triggerAction(SliderPageStepSub); }
+    inline QT3_SUPPORT void addLine() { triggerAction(SliderSingleStepAdd); }
+    inline QT3_SUPPORT void subtractLine() { triggerAction(SliderSingleStepSub); }
+#endif
+
+protected:
+    QAbstractSlider64(QAbstractSlider64Private &dd, QWidget *parent=0);
+
+private:
+    Q_DISABLE_COPY(QAbstractSlider64)
+    Q_DECLARE_PRIVATE(QAbstractSlider64)
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QABSTRACTSLIDER64_H
diff --git a/src/gui/widgets/qabstractslider64_p.h b/src/gui/widgets/qabstractslider64_p.h
new file mode 100644
index 0000000..681d9ea
--- /dev/null
+++ b/src/gui/widgets/qabstractslider64_p.h
@@ -0,0 +1,106 @@
+#ifndef QABSTRACTSLIDER64_P_H
+#define QABSTRACTSLIDER64_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "QtCore/qbasictimer.h"
+#include "QtCore/qelapsedtimer.h"
+#include "private/qwidget_p.h"
+#include "qstyle.h"
+
+QT_BEGIN_NAMESPACE
+
+class QAbstractSlider64Private : public QWidgetPrivate
+{
+    Q_DECLARE_PUBLIC(QAbstractSlider64)
+public:
+    QAbstractSlider64Private();
+    ~QAbstractSlider64Private();
+
+    void setSteps(qint64 single, qint64 page);
+
+    qint64 minimum, maximum, pageStep, value, position, pressValue;
+
+    /**
+     * Call effectiveSingleStep() when changing the slider value.
+     */
+    qint64 singleStep;
+
+    float offset_accumulated;
+    uint tracking : 1;
+    uint blocktracking :1;
+    uint pressed : 1;
+    uint invertedAppearance : 1;
+    uint invertedControls : 1;
+    Qt::Orientation orientation;
+
+    QBasicTimer repeatActionTimer;
+    int repeatActionTime;
+    QAbstractSlider64::SliderAction repeatAction;
+
+#ifdef QT_KEYPAD_NAVIGATION
+    qint64 origValue;
+
+    /**
+     */
+    bool isAutoRepeating;
+
+    /**
+     * When we're auto repeating, we multiply singleStep with this value to
+     * get our effective step.
+     */
+    qreal repeatMultiplier;
+
+    /**
+     * The time of when the first auto repeating key press event occurs.
+     */
+    QElapsedTimer firstRepeat;
+
+#endif
+
+    inline qint64 effectiveSingleStep() const
+    {
+        return singleStep
+#ifdef QT_KEYPAD_NAVIGATION
+        * repeatMultiplier
+#endif
+        ;
+    }
+
+    virtual qint64 bound(qint64 val) const { return qMax(minimum, qMin(maximum, val)); }
+    inline qint64 overflowSafeAdd(qint64 add) const
+    {
+        qint64 newValue = value + add;
+        if (add > 0 && newValue < value)
+            newValue = maximum;
+        else if (add < 0 && newValue > value)
+            newValue = minimum;
+        return newValue;
+    }
+    inline void setAdjustedSliderPosition(qint64 position)
+    {
+        Q_Q(QAbstractSlider64);
+        if (q->style()->styleHint(QStyle::SH_Slider_StopMouseOverSlider, 0, q)) {
+            if ((position > pressValue - 2 * pageStep) && (position < pressValue + 2 * pageStep)) {
+                repeatAction = QAbstractSlider64::SliderNoAction;
+                q->setSliderPosition(pressValue);
+                return;
+            }
+        }
+        q->triggerAction(repeatAction);
+    }
+    bool scrollByDelta(Qt::Orientation orientation, Qt::KeyboardModifiers modifiers, qint64 delta);
+};
+
+QT_END_NAMESPACE
+
+#endif // QABSTRACTSLIDER64_P_H
diff --git a/src/gui/widgets/qscrollbar64.cpp b/src/gui/widgets/qscrollbar64.cpp
new file mode 100644
index 0000000..3316f5f
--- /dev/null
+++ b/src/gui/widgets/qscrollbar64.cpp
@@ -0,0 +1,764 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qapplication.h"
+#include "qcursor.h"
+#include "qevent.h"
+#include "qpainter.h"
+#include "qscrollbar64.h"
+#include "qstyle.h"
+#include "qstyleoption.h"
+#include "qmenu.h"
+#include <QtCore/qelapsedtimer.h>
+
+#ifndef QT_NO_SCROLLBAR
+
+#ifndef QT_NO_ACCESSIBILITY
+#include "qaccessible.h"
+#endif
+#include <limits.h>
+#include "qabstractslider64_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QScrollBar64
+    \brief The QScrollBar64 widget provides a vertical or horizontal scroll bar.
+
+    \ingroup basicwidgets
+
+    A scroll bar is a control that enables the user to access parts of a
+    document that is larger than the widget used to display it. It provides
+    a visual indication of the user's current position within the document
+    and the amount of the document that is visible. Scroll bars are usually
+    equipped with other controls that enable more accurate navigation.
+    Qt displays scroll bars in a way that is appropriate for each platform.
+
+    If you need to provide a scrolling view onto another widget, it may be
+    more convenient to use the QScrollArea class because this provides a
+    viewport widget and scroll bars. QScrollBar64 is useful if you need to
+    implement similar functionality for specialized widgets using QAbstractScrollArea;
+    for example, if you decide to subclass QAbstractItemView.
+    For most other situations where a slider control is used to obtain a value
+    within a given range, the QSlider class may be more appropriate for your
+    needs.
+
+    \table
+    \row \o \image qscrollbar-picture.png
+    \o Scroll bars typically include four separate controls: a slider,
+    scroll arrows, and a page control.
+
+    \list
+    \o a. The slider provides a way to quickly go to any part of the
+    document, but does not support accurate navigation within large
+    documents.
+    \o b. The scroll arrows are push buttons which can be used to accurately
+    navigate to a particular place in a document. For a vertical scroll bar
+    connected to a text editor, these typically move the current position one
+    "line" up or down, and adjust the position of the slider by a small
+    amount. In editors and list boxes a "line" might mean one line of text;
+    in an image viewer it might mean 20 pixels.
+    \o c. The page control is the area over which the slider is dragged (the
+    scroll bar's background). Clicking here moves the scroll bar towards
+    the click by one "page". This value is usually the same as the length of
+    the slider.
+    \endlist
+    \endtable
+
+    Each scroll bar has a value that indicates how far the slider is from
+    the start of the scroll bar; this is obtained with value() and set
+    with setValue(). This value always lies within the range of values
+    defined for the scroll bar, from \l{QAbstractSlider64::minimum()}{minimum()}
+    to \l{QAbstractSlider64::minimum()}{maximum()} inclusive. The range of
+    acceptable values can be set with setMinimum() and setMaximum().
+    At the minimum value, the top edge of the slider (for a vertical scroll
+    bar) or left edge (for a horizontal scroll bar) will be at the top (or
+    left) end of the scroll bar. At the maximum value, the bottom (or right)
+    edge of the slider will be at the bottom (or right) end of the scroll bar.
+
+    The length of the slider is usually related to the value of the page step,
+    and typically represents the proportion of the document area shown in a
+    scrolling view. The page step is the amount that the value changes by
+    when the user presses the \key{Page Up} and \key{Page Down} keys, and is
+    set with setPageStep(). Smaller changes to the value defined by the
+    line step are made using the cursor keys, and this quantity is set with
+    \l{QAbstractSlider64::}{setSingleStep()}.
+
+    Note that the range of values used is independent of the actual size
+    of the scroll bar widget. You do not need to take this into account when
+    you choose values for the range and the page step.
+
+    The range of values specified for the scroll bar are often determined
+    differently to those for a QSlider because the length of the slider
+    needs to be taken into account. If we have a document with 100 lines,
+    and we can only show 20 lines in a widget, we may wish to construct a
+    scroll bar with a page step of 20, a minimum value of 0, and a maximum
+    value of 80. This would give us a scroll bar with five "pages".
+
+    \table
+    \row \o \inlineimage qscrollbar-values.png
+    \o The relationship between a document length, the range of values used
+    in a scroll bar, and the page step is simple in many common situations.
+    The scroll bar's range of values is determined by subtracting a
+    chosen page step from some value representing the length of the document.
+    In such cases, the following equation is useful:
+    \e{document length} = maximum() - minimum() + pageStep().
+    \endtable
+
+    QScrollBar64 only provides integer ranges. Note that although
+    QScrollBar64 handles very large numbers, scroll bars on current
+    screens cannot usefully represent ranges above about 100,000 pixels.
+    Beyond that, it becomes difficult for the user to control the
+    slider using either the keyboard or the mouse, and the scroll
+    arrows will have limited use.
+
+    ScrollBar inherits a comprehensive set of signals from QAbstractSlider64:
+    \list
+    \o \l{QAbstractSlider64::valueChanged()}{valueChanged()} is emitted when the
+       scroll bar's value has changed. The tracking() determines whether this
+       signal is emitted during user interaction.
+    \o \l{QAbstractSlider64::rangeChanged()}{rangeChanged()} is emitted when the
+       scroll bar's range of values has changed.
+    \o \l{QAbstractSlider64::sliderPressed()}{sliderPressed()} is emitted when
+       the user starts to drag the slider.
+    \o \l{QAbstractSlider64::sliderMoved()}{sliderMoved()} is emitted when the user
+       drags the slider.
+    \o \l{QAbstractSlider64::sliderReleased()}{sliderReleased()} is emitted when
+       the user releases the slider.
+    \o \l{QAbstractSlider64::actionTriggered()}{actionTriggered()} is emitted
+       when the scroll bar is changed by user interaction or via the
+       \l{QAbstractSlider64::triggerAction()}{triggerAction()} function.
+    \endlist
+
+    A scroll bar can be controlled by the keyboard, but it has a
+    default focusPolicy() of Qt::NoFocus. Use setFocusPolicy() to
+    enable keyboard interaction with the scroll bar:
+    \list
+         \o Left/Right move a horizontal scroll bar by one single step.
+         \o Up/Down move a vertical scroll bar by one single step.
+         \o PageUp moves up one page.
+         \o PageDown moves down one page.
+         \o Home moves to the start (mininum).
+         \o End moves to the end (maximum).
+     \endlist
+
+    The slider itself can be controlled by using the
+    \l{QAbstractSlider64::triggerAction()}{triggerAction()} function to simulate
+    user interaction with the scroll bar controls. This is useful if you have
+    many different widgets that use a common range of values.
+
+    Most GUI styles use the pageStep() value to calculate the size of the
+    slider.
+
+    \table 100%
+    \row \o \inlineimage macintosh-horizontalscrollbar.png Screenshot of a Macintosh style scroll bar
+         \o A scroll bar shown in the \l{Macintosh Style Widget Gallery}{Macintosh widget style}.
+    \row \o \inlineimage windowsxp-horizontalscrollbar.png Screenshot of a Windows XP style scroll bar
+         \o A scroll bar shown in the \l{Windows XP Style Widget Gallery}{Windows XP widget style}.
+    \row \o \inlineimage plastique-horizontalscrollbar.png Screenshot of a Plastique style scroll bar
+         \o A scroll bar shown in the \l{Plastique Style Widget Gallery}{Plastique widget style}.
+    \endtable
+
+    \sa QScrollArea, QSlider, QDial, QSpinBox, {fowler}{GUI Design Handbook: Scroll Bar}, {Sliders Example}
+*/
+
+class QScrollBar64Private : public QAbstractSlider64Private
+{
+    Q_DECLARE_PUBLIC(QScrollBar64)
+public:
+    QStyle::SubControl pressedControl;
+    bool pointerOutsidePressedControl;
+
+    qint64 clickOffset, snapBackPosition;
+
+    void activateControl(uint control, int threshold = 500);
+    void stopRepeatAction();
+    qint64 pixelPosToRangeValue(int pos) const;
+    void init();
+    bool updateHoverControl(const QPoint &pos);
+    QStyle::SubControl newHoverControl(const QPoint &pos);
+
+    QStyle::SubControl hoverControl;
+    QRect hoverRect;
+};
+
+bool QScrollBar64Private::updateHoverControl(const QPoint &pos)
+{
+    Q_Q(QScrollBar64);
+    QRect lastHoverRect = hoverRect;
+    QStyle::SubControl lastHoverControl = hoverControl;
+    bool doesHover = q->testAttribute(Qt::WA_Hover);
+    if (lastHoverControl != newHoverControl(pos) && doesHover) {
+        q->update(lastHoverRect);
+        q->update(hoverRect);
+        return true;
+    }
+    return !doesHover;
+}
+
+QStyle::SubControl QScrollBar64Private::newHoverControl(const QPoint &pos)
+{
+    Q_Q(QScrollBar64);
+    QStyleOptionSlider64 opt;
+    q->initStyleOption(&opt);
+    opt.subControls = QStyle::SC_All;
+    hoverControl = q->style()->hitTestComplexControl(QStyle::CC_ScrollBar64, &opt, pos, q);
+    if (hoverControl == QStyle::SC_None)
+        hoverRect = QRect();
+    else
+        hoverRect = q->style()->subControlRect(QStyle::CC_ScrollBar64, &opt, hoverControl, q);
+    return hoverControl;
+}
+
+void QScrollBar64Private::activateControl(uint control, int threshold)
+{
+    QAbstractSlider64::SliderAction action = QAbstractSlider64::SliderNoAction;
+    switch (control) {
+    case QStyle::SC_ScrollBarAddPage:
+        action = QAbstractSlider64::SliderPageStepAdd;
+        break;
+    case QStyle::SC_ScrollBarSubPage:
+        action = QAbstractSlider64::SliderPageStepSub;
+        break;
+    case QStyle::SC_ScrollBarAddLine:
+        action = QAbstractSlider64::SliderSingleStepAdd;
+        break;
+    case QStyle::SC_ScrollBarSubLine:
+        action = QAbstractSlider64::SliderSingleStepSub;
+        break;
+    case QStyle::SC_ScrollBarFirst:
+        action = QAbstractSlider64::SliderToMinimum;
+        break;
+    case QStyle::SC_ScrollBarLast:
+        action = QAbstractSlider64::SliderToMaximum;
+        break;
+    default:
+        break;
+    }
+
+    if (action) {
+        q_func()->setRepeatAction(action, threshold);
+        q_func()->triggerAction(action);
+    }
+}
+
+void QScrollBar64Private::stopRepeatAction()
+{
+    Q_Q(QScrollBar64);
+    QStyle::SubControl tmp = pressedControl;
+    q->setRepeatAction(QAbstractSlider64::SliderNoAction);
+    pressedControl = QStyle::SC_None;
+
+    if (tmp == QStyle::SC_ScrollBarSlider)
+        q->setSliderDown(false);
+
+    QStyleOptionSlider64 opt;
+    q->initStyleOption(&opt);
+    q->repaint(q->style()->subControlRect(QStyle::CC_ScrollBar64, &opt, tmp, q));
+}
+
+/*!
+    Initialize \a option with the values from this QScrollBar64. This method
+    is useful for subclasses when they need a QStyleOptionSlider64, but don't want
+    to fill in all the information themselves.
+
+    \sa QStyleOption::initFrom()
+*/
+void QScrollBar64::initStyleOption(QStyleOptionSlider64 *option) const
+{
+    if (!option)
+        return;
+
+    Q_D(const QScrollBar64);
+    option->initFrom(this);
+    option->subControls = QStyle::SC_None;
+    option->activeSubControls = QStyle::SC_None;
+    option->orientation = d->orientation;
+    option->minimum = d->minimum;
+    option->maximum = d->maximum;
+    option->sliderPosition = d->position;
+    option->sliderValue = d->value;
+    option->singleStep = d->singleStep;
+    option->pageStep = d->pageStep;
+    option->upsideDown = d->invertedAppearance;
+    if (d->orientation == Qt::Horizontal)
+        option->state |= QStyle::State_Horizontal;
+}
+
+
+#define HORIZONTAL (d_func()->orientation == Qt::Horizontal)
+#define VERTICAL !HORIZONTAL
+
+/*!
+    Constructs a vertical scroll bar.
+
+    The \a parent argument is sent to the QWidget constructor.
+
+    The \l {QAbstractSlider64::minimum} {minimum} defaults to 0, the
+    \l {QAbstractSlider64::maximum} {maximum} to 99, with a
+    \l {QAbstractSlider64::singleStep} {singleStep} size of 1 and a
+    \l {QAbstractSlider64::pageStep} {pageStep} size of 10, and an
+    initial \l {QAbstractSlider64::value} {value} of 0.
+*/
+QScrollBar64::QScrollBar64(QWidget *parent)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    d_func()->orientation = Qt::Vertical;
+    d_func()->init();
+}
+
+/*!
+    Constructs a scroll bar with the given \a orientation.
+
+    The \a parent argument is passed to the QWidget constructor.
+
+    The \l {QAbstractSlider64::minimum} {minimum} defaults to 0, the
+    \l {QAbstractSlider64::maximum} {maximum} to 99, with a
+    \l {QAbstractSlider64::singleStep} {singleStep} size of 1 and a
+    \l {QAbstractSlider64::pageStep} {pageStep} size of 10, and an
+    initial \l {QAbstractSlider64::value} {value} of 0.
+*/
+QScrollBar64::QScrollBar64(Qt::Orientation orientation, QWidget *parent)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    d_func()->orientation = orientation;
+    d_func()->init();
+}
+
+
+#ifdef QT3_SUPPORT
+/*!
+    Use one of the constructors that doesn't take the \a name
+    argument and then use setObjectName() instead.
+*/
+QScrollBar64::QScrollBar64(QWidget *parent, const char *name)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    setObjectName(QString::fromAscii(name));
+    d_func()->orientation = Qt::Vertical;
+    d_func()->init();
+}
+
+/*!
+    Use one of the constructors that doesn't take the \a name
+    argument and then use setObjectName() instead.
+*/
+QScrollBar64::QScrollBar64(Qt::Orientation orientation, QWidget *parent, const char *name)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    setObjectName(QString::fromAscii(name));
+    d_func()->orientation = orientation;
+    d_func()->init();
+}
+
+/*!
+    Use one of the constructors that doesn't take the \a name
+    argument and then use setObjectName() instead.
+*/
+QScrollBar64::QScrollBar64(qint64 minimum, qint64 maximum, qint64 lineStep, qint64 pageStep,
+                        qint64 value, Qt::Orientation orientation,
+                        QWidget *parent, const char *name)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    Q_D(QScrollBar64);
+    setObjectName(QString::fromAscii(name));
+    d->minimum = minimum;
+    d->maximum = maximum;
+    d->singleStep = lineStep;
+    d->pageStep = pageStep;
+    d->value = value;
+    d->orientation = orientation;
+    d->init();
+}
+#endif // QT3_SUPPORT
+
+/*!
+    Destroys the scroll bar.
+*/
+QScrollBar64::~QScrollBar64()
+{
+}
+
+void QScrollBar64Private::init()
+{
+    Q_Q(QScrollBar64);
+    invertedControls = true;
+    pressedControl = hoverControl = QStyle::SC_None;
+    pointerOutsidePressedControl = false;
+    q->setFocusPolicy(Qt::NoFocus);
+    QSizePolicy sp(QSizePolicy::Minimum, QSizePolicy::Fixed, QSizePolicy::Slider);
+    if (orientation == Qt::Vertical)
+        sp.transpose();
+    q->setSizePolicy(sp);
+    q->setAttribute(Qt::WA_WState_OwnSizePolicy, false);
+    q->setAttribute(Qt::WA_OpaquePaintEvent);
+
+#if !defined(QT_NO_CONTEXTMENU) && defined(Q_WS_WINCE)
+    if (!q->style()->styleHint(QStyle::SH_ScrollBar_ContextMenu, 0, q)) {
+        q->setContextMenuPolicy(Qt::PreventContextMenu);
+    }
+#endif
+}
+
+#ifndef QT_NO_CONTEXTMENU
+/*! \reimp */
+void QScrollBar64::contextMenuEvent(QContextMenuEvent *event)
+{
+    if (!style()->styleHint(QStyle::SH_ScrollBar_ContextMenu, 0, this)) {
+        QAbstractSlider64::contextMenuEvent(event);
+        return ;
+    }
+
+#ifndef QT_NO_MENU
+    bool horiz = HORIZONTAL;
+    QPointer<QMenu> menu = new QMenu(this);
+    QAction *actScrollHere = menu->addAction(tr("Scroll here"));
+    menu->addSeparator();
+    QAction *actScrollTop =  menu->addAction(horiz ? tr("Left edge") : tr("Top"));
+    QAction *actScrollBottom = menu->addAction(horiz ? tr("Right edge") : tr("Bottom"));
+    menu->addSeparator();
+    QAction *actPageUp = menu->addAction(horiz ? tr("Page left") : tr("Page up"));
+    QAction *actPageDn = menu->addAction(horiz ? tr("Page right") : tr("Page down"));
+    menu->addSeparator();
+    QAction *actScrollUp = menu->addAction(horiz ? tr("Scroll left") : tr("Scroll up"));
+    QAction *actScrollDn = menu->addAction(horiz ? tr("Scroll right") : tr("Scroll down"));
+    QAction *actionSelected = menu->exec(event->globalPos());
+    delete menu;
+    if (actionSelected == 0)
+        /* do nothing */ ;
+    else if (actionSelected == actScrollHere)
+        setValue(d_func()->pixelPosToRangeValue(horiz ? event->pos().x() : event->pos().y()));
+    else if (actionSelected == actScrollTop)
+        triggerAction(QAbstractSlider64::SliderToMinimum);
+    else if (actionSelected == actScrollBottom)
+        triggerAction(QAbstractSlider64::SliderToMaximum);
+    else if (actionSelected == actPageUp)
+        triggerAction(QAbstractSlider64::SliderPageStepSub);
+    else if (actionSelected == actPageDn)
+        triggerAction(QAbstractSlider64::SliderPageStepAdd);
+    else if (actionSelected == actScrollUp)
+        triggerAction(QAbstractSlider64::SliderSingleStepSub);
+    else if (actionSelected == actScrollDn)
+        triggerAction(QAbstractSlider64::SliderSingleStepAdd);
+#endif // QT_NO_MENU
+}
+#endif // QT_NO_CONTEXTMENU
+
+
+/*! \reimp */
+QSize QScrollBar64::sizeHint() const
+{
+    ensurePolished();
+    QStyleOptionSlider64 opt;
+    initStyleOption(&opt);
+
+    int scrollBarExtent = style()->pixelMetric(QStyle::PM_ScrollBarExtent, &opt, this);
+    int scrollBarSliderMin = style()->pixelMetric(QStyle::PM_ScrollBarSliderMin, &opt, this);
+    QSize size;
+    if (opt.orientation == Qt::Horizontal)
+        size = QSize(scrollBarExtent * 2 + scrollBarSliderMin, scrollBarExtent);
+    else
+        size = QSize(scrollBarExtent, scrollBarExtent * 2 + scrollBarSliderMin);
+
+    return style()->sizeFromContents(QStyle::CT_ScrollBar, &opt, size, this)
+        .expandedTo(QApplication::globalStrut());
+ }
+
+/*!\reimp */
+void QScrollBar64::sliderChange(SliderChange change)
+{
+    QAbstractSlider64::sliderChange(change);
+}
+
+/*!
+    \reimp
+*/
+bool QScrollBar64::event(QEvent *event)
+{
+    switch(event->type()) {
+    case QEvent::HoverEnter:
+    case QEvent::HoverLeave:
+    case QEvent::HoverMove:
+    if (const QHoverEvent *he = static_cast<const QHoverEvent *>(event))
+        d_func()->updateHoverControl(he->pos());
+        break;
+#ifndef QT_NO_WHEELEVENT
+    case QEvent::Wheel: {
+        event->ignore();
+        // override wheel event without adding virtual function override
+        QWheelEvent *ev = static_cast<QWheelEvent *>(event);
+        int delta = ev->delta();
+        // scrollbar is a special case - in vertical mode it reaches minimum
+        // value in the upper position, however QSlider's minimum value is on
+        // the bottom. So we need to invert a value, but since the scrollbar is
+        // inverted by default, we need to inverse the delta value for the
+        // horizontal orientation.
+        if (ev->orientation() == Qt::Horizontal)
+            delta = -delta;
+        Q_D(QScrollBar64);
+        if (d->scrollByDelta(ev->orientation(), ev->modifiers(), delta))
+            event->accept();
+        return true;
+    }
+#endif
+    default:
+        break;
+    }
+    return QAbstractSlider64::event(event);
+}
+
+/*!
+    \reimp
+*/
+void QScrollBar64::paintEvent(QPaintEvent *)
+{
+    Q_D(QScrollBar64);
+    QPainter p(this);
+    QStyleOptionSlider64 opt;
+    initStyleOption(&opt);
+    opt.subControls = QStyle::SC_All;
+    if (d->pressedControl) {
+        opt.activeSubControls = (QStyle::SubControl)d->pressedControl;
+        if (!d->pointerOutsidePressedControl)
+            opt.state |= QStyle::State_Sunken;
+    } else {
+        opt.activeSubControls = (QStyle::SubControl)d->hoverControl;
+    }
+    style()->drawComplexControl(QStyle::CC_ScrollBar64, &opt, &p, this);
+}
+
+/*!
+    \reimp
+*/
+void QScrollBar64::mousePressEvent(QMouseEvent *e)
+{
+    Q_D(QScrollBar64);
+
+    if (d->repeatActionTimer.isActive())
+        d->stopRepeatAction();
+
+    bool midButtonAbsPos = style()->styleHint(QStyle::SH_ScrollBar_MiddleClickAbsolutePosition,
+                                             0, this);
+    QStyleOptionSlider64 opt;
+    initStyleOption(&opt);
+
+    if (d->maximum == d->minimum // no range
+        || (e->buttons() & (~e->button())) // another button was clicked before
+        || !(e->button() == Qt::LeftButton || (midButtonAbsPos && e->button() == Qt::MidButton)))
+        return;
+
+    d->pressedControl = style()->hitTestComplexControl(QStyle::CC_ScrollBar64, &opt, e->pos(), this);
+    d->pointerOutsidePressedControl = false;
+
+    QRect sr = style()->subControlRect(QStyle::CC_ScrollBar64, &opt,
+                                       QStyle::SC_ScrollBarSlider, this);
+    QPoint click = e->pos();
+    QPoint pressValue = click - sr.center() + sr.topLeft();
+    d->pressValue = d->orientation == Qt::Horizontal ? d->pixelPosToRangeValue(pressValue.x()) :
+        d->pixelPosToRangeValue(pressValue.y());
+    if (d->pressedControl == QStyle::SC_ScrollBarSlider) {
+        d->clickOffset = HORIZONTAL ? (click.x()-sr.x()) : (click.y()-sr.y());
+        d->snapBackPosition = d->position;
+    }
+
+    if ((d->pressedControl == QStyle::SC_ScrollBarAddPage
+          || d->pressedControl == QStyle::SC_ScrollBarSubPage)
+        && ((midButtonAbsPos && e->button() == Qt::MidButton)
+            || (style()->styleHint(QStyle::SH_ScrollBar_LeftClickAbsolutePosition, &opt, this)
+                && e->button() == Qt::LeftButton))) {
+        qint64 sliderLength = HORIZONTAL ? sr.width() : sr.height();
+        setSliderPosition(d->pixelPosToRangeValue((HORIZONTAL ? e->pos().x()
+                                                              : e->pos().y()) - sliderLength / 2));
+        d->pressedControl = QStyle::SC_ScrollBarSlider;
+        d->clickOffset = sliderLength / 2;
+    }
+    const int initialDelay = 500; // default threshold
+    d->activateControl(d->pressedControl, initialDelay);
+    QElapsedTimer time;
+    time.start();
+    repaint(style()->subControlRect(QStyle::CC_ScrollBar64, &opt, d->pressedControl, this));
+    if (time.elapsed() >= initialDelay && d->repeatActionTimer.isActive()) {
+        // It took more than 500ms (the initial timer delay) to process the repaint(), we
+        // therefore need to restart the timer in case we have a pending mouse release event;
+        // otherwise we'll get a timer event right before the release event,
+        // causing the repeat action to be invoked twice on a single mouse click.
+        // 50ms is the default repeat time (see activateControl/setRepeatAction).
+        d->repeatActionTimer.start(50, this);
+    }
+    if (d->pressedControl == QStyle::SC_ScrollBarSlider)
+        setSliderDown(true);
+}
+
+
+/*!
+    \reimp
+*/
+void QScrollBar64::mouseReleaseEvent(QMouseEvent *e)
+{
+    Q_D(QScrollBar64);
+    if (!d->pressedControl)
+        return;
+
+    if (e->buttons() & (~e->button())) // some other button is still pressed
+        return;
+
+    d->stopRepeatAction();
+}
+
+
+/*!
+    \reimp
+*/
+void QScrollBar64::mouseMoveEvent(QMouseEvent *e)
+{
+    Q_D(QScrollBar64);
+    if (!d->pressedControl)
+        return;
+
+    QStyleOptionSlider64 opt;
+    initStyleOption(&opt);
+    if (!(e->buttons() & Qt::LeftButton
+          ||  ((e->buttons() & Qt::MidButton)
+               && style()->styleHint(QStyle::SH_ScrollBar_MiddleClickAbsolutePosition, &opt, this))))
+        return;
+
+    if (d->pressedControl == QStyle::SC_ScrollBarSlider) {
+        QPoint click = e->pos();
+        qint64 newPosition = d->pixelPosToRangeValue((HORIZONTAL ? click.x() : click.y()) -d->clickOffset);
+        int m = style()->pixelMetric(QStyle::PM_MaximumDragDistance, &opt, this);
+        if (m >= 0) {
+            QRect r = rect();
+            r.adjust(-m, -m, m, m);
+            if (! r.contains(e->pos()))
+                newPosition = d->snapBackPosition;
+        }
+        setSliderPosition(newPosition);
+    } else if (!style()->styleHint(QStyle::SH_ScrollBar_ScrollWhenPointerLeavesControl, &opt, this)) {
+
+        if (style()->styleHint(QStyle::SH_ScrollBar_RollBetweenButtons, &opt, this)
+                && d->pressedControl & (QStyle::SC_ScrollBarAddLine | QStyle::SC_ScrollBarSubLine)) {
+            QStyle::SubControl newSc = style()->hitTestComplexControl(QStyle::CC_ScrollBar64, &opt, e->pos(), this);
+            if (newSc == d->pressedControl && !d->pointerOutsidePressedControl)
+                return; // nothing to do
+            if (newSc & (QStyle::SC_ScrollBarAddLine | QStyle::SC_ScrollBarSubLine)) {
+                d->pointerOutsidePressedControl = false;
+                QRect scRect = style()->subControlRect(QStyle::CC_ScrollBar64, &opt, newSc, this);
+                scRect |= style()->subControlRect(QStyle::CC_ScrollBar64, &opt, d->pressedControl, this);
+                d->pressedControl = newSc;
+                d->activateControl(d->pressedControl, 0);
+                update(scRect);
+                return;
+            }
+        }
+
+        // stop scrolling when the mouse pointer leaves a control
+        // similar to push buttons
+        QRect pr = style()->subControlRect(QStyle::CC_ScrollBar64, &opt, d->pressedControl, this);
+        if (pr.contains(e->pos()) == d->pointerOutsidePressedControl) {
+            if ((d->pointerOutsidePressedControl = !d->pointerOutsidePressedControl)) {
+                d->pointerOutsidePressedControl = true;
+                setRepeatAction(SliderNoAction);
+                repaint(pr);
+            } else  {
+                d->activateControl(d->pressedControl);
+            }
+        }
+    }
+}
+
+
+qint64 QScrollBar64Private::pixelPosToRangeValue(int pos) const
+{
+    Q_Q(const QScrollBar64);
+    QStyleOptionSlider64 opt;
+    q->initStyleOption(&opt);
+    QRect gr = q->style()->subControlRect(QStyle::CC_ScrollBar64, &opt,
+                                          QStyle::SC_ScrollBarGroove, q);
+    QRect sr = q->style()->subControlRect(QStyle::CC_ScrollBar64, &opt,
+                                          QStyle::SC_ScrollBarSlider, q);
+    qint64 sliderMin, sliderMax, sliderLength;
+
+    if (orientation == Qt::Horizontal) {
+        sliderLength = sr.width();
+        sliderMin = gr.x();
+        sliderMax = gr.right() - sliderLength + 1;
+        if (q->layoutDirection() == Qt::RightToLeft)
+            opt.upsideDown = !opt.upsideDown;
+    } else {
+        sliderLength = sr.height();
+        sliderMin = gr.y();
+        sliderMax = gr.bottom() - sliderLength + 1;
+    }
+
+    return  QStyle::sliderValueFromPosition(minimum, maximum, pos - sliderMin,
+                                            sliderMax - sliderMin, opt.upsideDown);
+}
+
+/*! \reimp
+*/
+void QScrollBar64::hideEvent(QHideEvent *)
+{
+    Q_D(QScrollBar64);
+    if (d->pressedControl) {
+        d->pressedControl = QStyle::SC_None;
+        setRepeatAction(SliderNoAction);
+    }
+}
+
+/*!
+    \fn bool QScrollBar64::draggingSlider()
+
+    Use isSliderDown() instead.
+*/
+
+/*! \internal
+    Returns the style option for scroll bar.
+*/
+Q_GUI_EXPORT QStyleOptionSlider64 qt_qscrollbarStyleOption(QScrollBar64 *scrollbar)
+{
+    QStyleOptionSlider64 opt;
+    scrollbar->initStyleOption(&opt);
+    return opt;
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_SCROLLBAR
diff --git a/src/gui/widgets/qscrollbar64.h b/src/gui/widgets/qscrollbar64.h
new file mode 100644
index 0000000..d0293c9
--- /dev/null
+++ b/src/gui/widgets/qscrollbar64.h
@@ -0,0 +1,63 @@
+#ifndef QSCROLLBAR64_H
+#define QSCROLLBAR64_H
+
+#include <QtGui/qwidget.h>
+#include <QtGui/qabstractslider64.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Gui)
+
+#ifndef QT_NO_SCROLLBAR
+
+class QScrollBar64Private;
+class QStyleOptionSlider64;
+
+class Q_GUI_EXPORT QScrollBar64 : public QAbstractSlider64
+{
+    Q_OBJECT
+public:
+    explicit QScrollBar64(QWidget *parent=0);
+    explicit QScrollBar64(Qt::Orientation, QWidget *parent=0);
+    ~QScrollBar64();
+
+    QSize sizeHint() const;
+    bool event(QEvent *event);
+
+protected:
+    void paintEvent(QPaintEvent *);
+    void mousePressEvent(QMouseEvent *);
+    void mouseReleaseEvent(QMouseEvent *);
+    void mouseMoveEvent(QMouseEvent *);
+    void hideEvent(QHideEvent*);
+    void sliderChange(SliderChange change);
+#ifndef QT_NO_CONTEXTMENU
+    void contextMenuEvent(QContextMenuEvent *);
+#endif
+    void initStyleOption(QStyleOptionSlider64 *option) const;
+
+#ifdef QT3_SUPPORT
+public:
+    QT3_SUPPORT_CONSTRUCTOR QScrollBar64(QWidget *parent, const char* name);
+    QT3_SUPPORT_CONSTRUCTOR QScrollBar64(Qt::Orientation, QWidget *parent, const char* name);
+    QT3_SUPPORT_CONSTRUCTOR QScrollBar64(qint64 minValue, qint64 maxValue, qint64 lineStep, qint64 pageStep,
+                qint64 value, Qt::Orientation, QWidget *parent=0, const char* name = 0);
+    inline QT3_SUPPORT bool draggingSlider() { return isSliderDown(); }
+#endif
+
+private:
+    friend Q_GUI_EXPORT QStyleOptionSlider64 qt_qscrollbarStyleOption(QScrollBar64 *scrollBar);
+
+    Q_DISABLE_COPY(QScrollBar64)
+    Q_DECLARE_PRIVATE(QScrollBar64)
+};
+
+#endif // QT_NO_SCROLLBAR
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QSCROLLBAR64_H
diff --git a/src/gui/widgets/widgets.pri b/src/gui/widgets/widgets.pri
index 6b3d6a9..2c0d4f5 100644
--- a/src/gui/widgets/widgets.pri
+++ b/src/gui/widgets/widgets.pri
@@ -6,6 +6,8 @@ HEADERS += \
         widgets/qabstractbutton_p.h \
         widgets/qabstractslider.h \
         widgets/qabstractslider_p.h \
+        widgets/qabstractslider64.h \
+        widgets/qabstractslider64_p.h \
         widgets/qabstractspinbox.h \
         widgets/qabstractspinbox_p.h \
         widgets/qcalendartextnavigator_p.h \
@@ -48,6 +50,7 @@ HEADERS += \
         widgets/qradiobutton.h \
         widgets/qrubberband.h \
         widgets/qscrollbar.h \
+        widgets/qscrollbar64.h \
         widgets/qscrollarea_p.h \
         widgets/qsizegrip.h \
         widgets/qslider.h \
@@ -85,6 +88,7 @@ HEADERS += \
 SOURCES += \
         widgets/qabstractbutton.cpp \
         widgets/qabstractslider.cpp \
+        widgets/qabstractslider64.cpp \
         widgets/qabstractspinbox.cpp \
         widgets/qcalendarwidget.cpp \
         widgets/qcheckbox.cpp \
@@ -116,6 +120,7 @@ SOURCES += \
         widgets/qradiobutton.cpp \
         widgets/qrubberband.cpp \
         widgets/qscrollbar.cpp \
+        widgets/qscrollbar64.cpp \
         widgets/qsizegrip.cpp \
         widgets/qslider.cpp \
         widgets/qspinbox.cpp \
