diff -N -u qt4-x11-4.8.2+dfsg-org/src/gui/widgets/qabstractslider64.cpp qt4-x11-4.8.2+dfsg/src/gui/widgets/qabstractslider64.cpp
--- qt4-x11-4.8.2+dfsg-org/src/gui/widgets/qabstractslider64.cpp	1970-01-01 01:00:00.000000000 +0100
+++ qt4-x11-4.8.2+dfsg/src/gui/widgets/qabstractslider64.cpp	2013-01-16 16:10:46.290252266 +0100
@@ -0,0 +1,1013 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qapplication.h>
+#include "qabstractslider64.h"
+#include "qevent.h"
+#include "qabstractslider64_p.h"
+#include "qdebug.h"
+#ifndef QT_NO_ACCESSIBILITY
+#include "qaccessible.h"
+#endif
+#include <limits.h>
+#define __STDC_LIMIT_MACROS
+#include <stdint.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QAbstractSlider64
+    \brief The QAbstractSlider64 class provides an integer value within a range.
+
+    \ingroup abstractwidgets
+
+    The class is designed as a common super class for widgets like
+    QScrollBar, QSlider and QDial.
+
+    Here are the main properties of the class:
+
+    \list 1
+
+    \i \l value: The bounded integer that QAbstractSlider64 maintains.
+
+    \i \l minimum: The lowest possible value.
+
+    \i \l maximum: The highest possible value.
+
+    \i \l singleStep: The smaller of two natural steps that an
+    abstract sliders provides and typically corresponds to the user
+    pressing an arrow key.
+
+    \i \l pageStep: The larger of two natural steps that an abstract
+    slider provides and typically corresponds to the user pressing
+    PageUp or PageDown.
+
+    \i \l tracking: Whether slider tracking is enabled.
+
+    \i \l sliderPosition: The current position of the slider. If \l
+    tracking is enabled (the default), this is identical to \l value.
+
+    \endlist
+
+    Unity (1) may be viewed as a third step size. setValue() lets you
+    set the current value to any integer in the allowed range, not
+    just minimum() + \e n * singleStep() for integer values of \e n.
+    Some widgets may allow the user to set any value at all; others
+    may just provide multiples of singleStep() or pageStep().
+
+    QAbstractSlider64 emits a comprehensive set of signals:
+
+    \table
+    \header \i Signal \i Emitted when
+    \row \i \l valueChanged()
+         \i the value has changed. The \l tracking
+            determines whether this signal is emitted during user
+            interaction.
+    \row \i \l sliderPressed()
+         \i the user starts to drag the slider.
+    \row \i \l sliderMoved()
+         \i the user drags the slider.
+    \row \i \l sliderReleased()
+         \i the user releases the slider.
+    \row \i \l actionTriggered()
+         \i a slider action was triggerd.
+    \row \i \l rangeChanged()
+         \i a the range has changed.
+    \endtable
+
+    QAbstractSlider64 provides a virtual sliderChange() function that is
+    well suited for updating the on-screen representation of
+    sliders. By calling triggerAction(), subclasses trigger slider
+    actions. Two helper functions QStyle::sliderPositionFromValue() and
+    QStyle::sliderValueFromPosition() help subclasses and styles to map
+    screen coordinates to logical range values.
+
+    \sa QAbstractSpinBox, QSlider, QDial, QScrollBar, {Sliders Example}
+*/
+
+/*!
+    \enum QAbstractSlider64::SliderAction
+
+    \value SliderNoAction
+    \value SliderSingleStepAdd
+    \value SliderSingleStepSub
+    \value SliderPageStepAdd
+    \value SliderPageStepSub
+    \value SliderToMinimum
+    \value SliderToMaximum
+    \value SliderMove
+
+*/
+
+/*!
+    \fn void QAbstractSlider64::valueChanged(int value)
+
+    This signal is emitted when the slider value has changed, with the
+    new slider \a value as argument.
+*/
+
+/*!
+    \fn void QAbstractSlider64::sliderPressed()
+
+    This signal is emitted when the user presses the slider with the
+    mouse, or programmatically when setSliderDown(true) is called.
+
+    \sa sliderReleased(), sliderMoved(), isSliderDown()
+*/
+
+/*!
+    \fn void QAbstractSlider64::sliderMoved(int value)
+
+    This signal is emitted when sliderDown is true and the slider moves. This
+    usually happens when the user is dragging the slider. The \a value
+    is the new slider position.
+
+    This signal is emitted even when tracking is turned off.
+
+    \sa setTracking(), valueChanged(), isSliderDown(),
+    sliderPressed(), sliderReleased()
+*/
+
+/*!
+    \fn void QAbstractSlider64::sliderReleased()
+
+    This signal is emitted when the user releases the slider with the
+    mouse, or programmatically when setSliderDown(false) is called.
+
+    \sa sliderPressed() sliderMoved() sliderDown
+*/
+
+/*!
+    \fn void QAbstractSlider64::rangeChanged(int min, int max)
+
+    This signal is emitted when the slider range has changed, with \a
+    min being the new minimum, and \a max being the new maximum.
+
+    \sa minimum, maximum
+*/
+
+/*!
+    \fn void QAbstractSlider64::actionTriggered(int action)
+
+    This signal is emitted when the slider action \a action is
+    triggered. Actions are \l SliderSingleStepAdd, \l
+    SliderSingleStepSub, \l SliderPageStepAdd, \l SliderPageStepSub,
+    \l SliderToMinimum, \l SliderToMaximum, and \l SliderMove.
+
+    When the signal is emitted, the \l sliderPosition has been
+    adjusted according to the action, but the \l value has not yet
+    been propagated (meaning the valueChanged() signal was not yet
+    emitted), and the visual display has not been updated. In slots
+    connected to this signal you can thus safely adjust any action by
+    calling setSliderPosition() yourself, based on both the action and
+    the slider's value.
+
+    \sa triggerAction()
+*/
+
+/*!
+    \enum QAbstractSlider64::SliderChange
+
+    \value SliderRangeChange
+    \value SliderOrientationChange
+    \value SliderStepsChange
+    \value SliderValueChange
+*/
+
+QAbstractSlider64Private::QAbstractSlider64Private()
+    : minimum(0), maximum(99), pageStep(10), value(0), position(0), pressValue(-1),
+      singleStep(1), offset_accumulated(0), tracking(true),
+      blocktracking(false), pressed(false),
+      invertedAppearance(false), invertedControls(false),
+      orientation(Qt::Horizontal), repeatAction(QAbstractSlider64::SliderNoAction)
+#ifdef QT_KEYPAD_NAVIGATION
+      , isAutoRepeating(false)
+      , repeatMultiplier(1)
+{
+    firstRepeat.invalidate();
+#else
+{
+#endif
+
+}
+
+QAbstractSlider64Private::~QAbstractSlider64Private()
+{
+}
+
+/*!
+    Sets the slider's minimum to \a min and its maximum to \a max.
+
+    If \a max is smaller than \a min, \a min becomes the only legal
+    value.
+
+    \sa minimum maximum
+*/
+void QAbstractSlider64::setRange(qint64 min, qint64 max)
+{
+    Q_D(QAbstractSlider64);
+    qint64 oldMin = d->minimum;
+    qint64 oldMax = d->maximum;
+    d->minimum = min;
+    d->maximum = qMax(min, max);
+    if (oldMin != d->minimum || oldMax != d->maximum) {
+        sliderChange(SliderRangeChange);
+        emit rangeChanged(d->minimum, d->maximum);
+        setValue(d->value); // re-bound
+    }
+}
+
+
+void QAbstractSlider64Private::setSteps(qint64 single, qint64 page)
+{
+    Q_Q(QAbstractSlider64);
+    singleStep = qAbs(single);
+    pageStep = qAbs(page);
+    q->sliderChange(QAbstractSlider64::SliderStepsChange);
+}
+
+/*!
+    Constructs an abstract slider.
+
+    The \a parent argument is sent to the QWidget constructor.
+
+    The \l minimum defaults to 0, the \l maximum to 99, with a \l
+    singleStep size of 1 and a \l pageStep size of 10, and an initial
+    \l value of 0.
+*/
+QAbstractSlider64::QAbstractSlider64(QWidget *parent)
+    :QWidget(*new QAbstractSlider64Private, parent, 0)
+{
+}
+
+/*! \internal */
+QAbstractSlider64::QAbstractSlider64(QAbstractSlider64Private &dd, QWidget *parent)
+    :QWidget(dd, parent, 0)
+{
+}
+
+/*!
+    Destroys the slider.
+*/
+QAbstractSlider64::~QAbstractSlider64()
+{
+}
+
+/*!
+    \property QAbstractSlider64::orientation
+    \brief the orientation of the slider
+
+    The orientation must be \l Qt::Vertical (the default) or \l
+    Qt::Horizontal.
+*/
+void QAbstractSlider64::setOrientation(Qt::Orientation orientation)
+{
+    Q_D(QAbstractSlider64);
+    if (d->orientation == orientation)
+        return;
+
+    d->orientation = orientation;
+    if (!testAttribute(Qt::WA_WState_OwnSizePolicy)) {
+        QSizePolicy sp = sizePolicy();
+        sp.transpose();
+        setSizePolicy(sp);
+        setAttribute(Qt::WA_WState_OwnSizePolicy, false);
+    }
+    update();
+    updateGeometry();
+}
+
+Qt::Orientation QAbstractSlider64::orientation() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->orientation;
+}
+
+
+/*!
+    \property QAbstractSlider64::minimum
+    \brief the sliders's minimum value
+
+    When setting this property, the \l maximum is adjusted if
+    necessary to ensure that the range remains valid. Also the
+    slider's current value is adjusted to be within the new range.
+
+*/
+
+void QAbstractSlider64::setMinimum(qint64 min)
+{
+    Q_D(QAbstractSlider64);
+    setRange(min, qMax(d->maximum, min));
+}
+
+qint64 QAbstractSlider64::minimum() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->minimum;
+}
+
+
+/*!
+    \property QAbstractSlider64::maximum
+    \brief the slider's maximum value
+
+    When setting this property, the \l minimum is adjusted if
+    necessary to ensure that the range remains valid.  Also the
+    slider's current value is adjusted to be within the new range.
+
+
+*/
+
+void QAbstractSlider64::setMaximum(qint64 max)
+{
+    Q_D(QAbstractSlider64);
+    setRange(qMin(d->minimum, max), max);
+}
+
+qint64 QAbstractSlider64::maximum() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->maximum;
+}
+
+
+
+/*!
+    \property QAbstractSlider64::singleStep
+    \brief the single step.
+
+    The smaller of two natural steps that an
+    abstract sliders provides and typically corresponds to the user
+    pressing an arrow key.
+
+    If the property is modified during an auto repeating key event, behavior
+    is undefined.
+
+    \sa pageStep
+*/
+
+void QAbstractSlider64::setSingleStep(qint64 step)
+{
+    Q_D(QAbstractSlider64);
+    if (step != d->singleStep)
+        d->setSteps(step, d->pageStep);
+}
+
+qint64 QAbstractSlider64::singleStep() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->singleStep;
+}
+
+
+/*!
+    \property QAbstractSlider64::pageStep
+    \brief the page step.
+
+    The larger of two natural steps that an abstract slider provides
+    and typically corresponds to the user pressing PageUp or PageDown.
+
+    \sa singleStep
+*/
+
+void QAbstractSlider64::setPageStep(qint64 step)
+{
+    Q_D(QAbstractSlider64);
+    if (step != d->pageStep)
+        d->setSteps(d->singleStep, step);
+}
+
+qint64 QAbstractSlider64::pageStep() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->pageStep;
+}
+
+/*!
+    \property QAbstractSlider64::tracking
+    \brief whether slider tracking is enabled
+
+    If tracking is enabled (the default), the slider emits the
+    valueChanged() signal while the slider is being dragged. If
+    tracking is disabled, the slider emits the valueChanged() signal
+    only when the user releases the slider.
+
+    \sa sliderDown
+*/
+void QAbstractSlider64::setTracking(bool enable)
+{
+    Q_D(QAbstractSlider64);
+    d->tracking = enable;
+}
+
+bool QAbstractSlider64::hasTracking() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->tracking;
+}
+
+
+/*!
+    \property QAbstractSlider64::sliderDown
+    \brief whether the slider is pressed down.
+
+    The property is set by subclasses in order to let the abstract
+    slider know whether or not \l tracking has any effect.
+
+    Changing the slider down property emits the sliderPressed() and
+    sliderReleased() signals.
+
+*/
+void QAbstractSlider64::setSliderDown(bool down)
+{
+    Q_D(QAbstractSlider64);
+    bool doEmit = d->pressed != down;
+
+    d->pressed = down;
+
+    if (doEmit) {
+        if (down)
+            emit sliderPressed();
+        else
+            emit sliderReleased();
+    }
+
+    if (!down && d->position != d->value)
+        triggerAction(SliderMove);
+}
+
+bool QAbstractSlider64::isSliderDown() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->pressed;
+}
+
+
+/*!
+    \property QAbstractSlider64::sliderPosition
+    \brief the current slider position
+
+    If \l tracking is enabled (the default), this is identical to \l value.
+*/
+void QAbstractSlider64::setSliderPosition(qint64 position)
+{
+    Q_D(QAbstractSlider64);
+    position = d->bound(position);
+    if (position == d->position)
+        return;
+    d->position = position;
+    if (!d->tracking)
+        update();
+    if (d->pressed)
+        emit sliderMoved(position);
+    if (d->tracking && !d->blocktracking)
+        triggerAction(SliderMove);
+}
+
+qint64 QAbstractSlider64::sliderPosition() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->position;
+}
+
+
+/*!
+    \property QAbstractSlider64::value
+    \brief the slider's current value
+
+    The slider forces the value to be within the legal range: \l
+    minimum <= \c value <= \l maximum.
+
+    Changing the value also changes the \l sliderPosition.
+*/
+
+
+qint64 QAbstractSlider64::value() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->value;
+}
+
+void QAbstractSlider64::setValue(qint64 value)
+{
+    Q_D(QAbstractSlider64);
+    value = d->bound(value);
+    if (d->value == value && d->position == value)
+        return;
+    d->value = value;
+    if (d->position != value) {
+        d->position = value;
+        if (d->pressed)
+            emit sliderMoved((d->position = value));
+    }
+#ifndef QT_NO_ACCESSIBILITY
+    QAccessible::updateAccessibility(this, 0, QAccessible::ValueChanged);
+#endif
+    sliderChange(SliderValueChange);
+    emit valueChanged(value);
+}
+
+/*!
+    \property QAbstractSlider64::invertedAppearance
+    \brief whether or not a slider shows its values inverted.
+
+    If this property is false (the default), the minimum and maximum will
+    be shown in its classic position for the inherited widget. If the
+    value is true, the minimum and maximum appear at their opposite location.
+
+    Note: This property makes most sense for sliders and dials. For
+    scroll bars, the visual effect of the scroll bar subcontrols depends on
+    whether or not the styles understand inverted appearance; most styles
+    ignore this property for scroll bars.
+*/
+
+bool QAbstractSlider64::invertedAppearance() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->invertedAppearance;
+}
+
+void QAbstractSlider64::setInvertedAppearance(bool invert)
+{
+    Q_D(QAbstractSlider64);
+    d->invertedAppearance = invert;
+    update();
+}
+
+
+/*!
+    \property QAbstractSlider64::invertedControls
+    \brief whether or not the slider inverts its wheel and key events.
+
+    If this property is false, scrolling the mouse wheel "up" and using keys
+    like page up will increase the slider's value towards its maximum. Otherwise
+    pressing page up will move value towards the slider's minimum.
+*/
+
+
+bool QAbstractSlider64::invertedControls() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->invertedControls;
+}
+
+void QAbstractSlider64::setInvertedControls(bool invert)
+{
+    Q_D(QAbstractSlider64);
+    d->invertedControls = invert;
+}
+
+/*!  Triggers a slider \a action.  Possible actions are \l
+  SliderSingleStepAdd, \l SliderSingleStepSub, \l SliderPageStepAdd,
+  \l SliderPageStepSub, \l SliderToMinimum, \l SliderToMaximum, and \l
+  SliderMove.
+
+  \sa actionTriggered()
+ */
+void QAbstractSlider64::triggerAction(SliderAction action)
+{
+    Q_D(QAbstractSlider64);
+    d->blocktracking = true;
+    switch (action) {
+    case SliderSingleStepAdd:
+        setSliderPosition(d->overflowSafeAdd(d->effectiveSingleStep()));
+        break;
+    case SliderSingleStepSub:
+        setSliderPosition(d->overflowSafeAdd(-d->effectiveSingleStep()));
+        break;
+    case SliderPageStepAdd:
+        setSliderPosition(d->overflowSafeAdd(d->pageStep));
+        break;
+    case SliderPageStepSub:
+        setSliderPosition(d->overflowSafeAdd(-d->pageStep));
+        break;
+    case SliderToMinimum:
+        setSliderPosition(d->minimum);
+        break;
+    case SliderToMaximum:
+        setSliderPosition(d->maximum);
+        break;
+    case SliderMove:
+    case SliderNoAction:
+        break;
+    };
+    emit actionTriggered(action);
+    d->blocktracking = false;
+    setValue(d->position);
+}
+
+/*!  Sets action \a action to be triggered repetitively in intervals
+of \a repeatTime, after an initial delay of \a thresholdTime.
+
+\sa triggerAction() repeatAction()
+ */
+void QAbstractSlider64::setRepeatAction(SliderAction action, int thresholdTime, int repeatTime)
+{
+    Q_D(QAbstractSlider64);
+    if ((d->repeatAction = action) == SliderNoAction) {
+        d->repeatActionTimer.stop();
+    } else {
+        d->repeatActionTime = repeatTime;
+        d->repeatActionTimer.start(thresholdTime, this);
+    }
+}
+
+/*!
+  Returns the current repeat action.
+  \sa setRepeatAction()
+ */
+QAbstractSlider64::SliderAction QAbstractSlider64::repeatAction() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->repeatAction;
+}
+
+/*!\reimp
+ */
+void QAbstractSlider64::timerEvent(QTimerEvent *e)
+{
+    Q_D(QAbstractSlider64);
+    if (e->timerId() == d->repeatActionTimer.timerId()) {
+        if (d->repeatActionTime) { // was threshold time, use repeat time next time
+            d->repeatActionTimer.start(d->repeatActionTime, this);
+            d->repeatActionTime = 0;
+        }
+        if (d->repeatAction == SliderPageStepAdd)
+            d->setAdjustedSliderPosition(d->overflowSafeAdd(d->pageStep));
+        else if (d->repeatAction == SliderPageStepSub)
+            d->setAdjustedSliderPosition(d->overflowSafeAdd(-d->pageStep));
+        else
+            triggerAction(d->repeatAction);
+    }
+}
+
+/*!
+    Reimplement this virtual function to track slider changes such as
+    \l SliderRangeChange, \l SliderOrientationChange, \l
+    SliderStepsChange, or \l SliderValueChange. The default
+    implementation only updates the display and ignores the \a change
+    parameter.
+ */
+void QAbstractSlider64::sliderChange(SliderChange)
+{
+    update();
+}
+
+/*!
+    \internal
+
+    Truncate qreal to int without flipping on overflow.
+*/
+static inline qint64 clampScrollStep(qreal x)
+{
+    return qint64(qBound(qreal(INT64_MIN), x, qreal(INT64_MAX)));
+}
+
+bool QAbstractSlider64Private::scrollByDelta(Qt::Orientation orientation, Qt::KeyboardModifiers modifiers, qint64 delta)
+{
+    Q_Q(QAbstractSlider64);
+    qint64 stepsToScroll = 0;
+    // in Qt scrolling to the right gives negative values.
+    if (orientation == Qt::Horizontal)
+        delta = -delta;
+    qreal offset = qreal(delta) / 120;
+
+    if ((modifiers & Qt::ControlModifier) || (modifiers & Qt::ShiftModifier)) {
+        // Scroll one page regardless of delta:
+        stepsToScroll = qBound(-pageStep, clampScrollStep(offset * pageStep), pageStep);
+        offset_accumulated = 0;
+    } else {
+        // Calculate how many lines to scroll. Depending on what delta is (and
+        // offset), we might end up with a fraction (e.g. scroll 1.3 lines). We can
+        // only scroll whole lines, so we keep the reminder until next event.
+        qreal stepsToScrollF =
+#ifndef QT_NO_WHEELEVENT
+                QApplication::wheelScrollLines() *
+#endif
+                offset * effectiveSingleStep();
+        // Check if wheel changed direction since last event:
+        if (offset_accumulated != 0 && (offset / offset_accumulated) < 0)
+            offset_accumulated = 0;
+
+        offset_accumulated += stepsToScrollF;
+#ifndef Q_WS_MAC
+        // Don't scroll more than one page in any case:
+        stepsToScroll = qBound(-pageStep, clampScrollStep(offset_accumulated), pageStep);
+#else
+        // Native UI-elements on Mac can scroll hundreds of lines at a time as
+        // a result of acceleration. So keep the same behaviour in Qt, and
+        // don't restrict stepsToScroll to certain maximum (pageStep): 
+        stepsToScroll = clampScrollStep(offset_accumulated);
+#endif
+        offset_accumulated -= clampScrollStep(offset_accumulated);
+        if (stepsToScroll == 0)
+            return false;
+    }
+
+    if (invertedControls)
+        stepsToScroll = -stepsToScroll;
+
+    qint64 prevValue = value;
+    position = overflowSafeAdd(stepsToScroll); // value will be updated by triggerAction()
+    q->triggerAction(QAbstractSlider64::SliderMove);
+
+    if (prevValue == value) {
+        offset_accumulated = 0;
+        return false;
+    }
+    return true;
+}
+
+/*!
+    \reimp
+*/
+#ifndef QT_NO_WHEELEVENT
+void QAbstractSlider64::wheelEvent(QWheelEvent * e)
+{
+    Q_D(QAbstractSlider64);
+    e->ignore();
+    int delta = e->delta();
+    if (d->scrollByDelta(e->orientation(), e->modifiers(), delta))
+        e->accept();
+}
+
+#endif
+
+/*!
+    \reimp
+*/
+void QAbstractSlider64::keyPressEvent(QKeyEvent *ev)
+{
+    Q_D(QAbstractSlider64);
+    SliderAction action = SliderNoAction;
+#ifdef QT_KEYPAD_NAVIGATION
+    if (ev->isAutoRepeat()) {
+        if (!d->firstRepeat.isValid())
+            d->firstRepeat.start();
+        else if (1 == d->repeatMultiplier) {
+            // This is the interval in milli seconds which one key repetition
+            // takes.
+            const int repeatMSecs = d->firstRepeat.elapsed();
+
+            /**
+             * The time it takes to currently navigate the whole slider.
+             */
+            const qreal currentTimeElapse = (qreal(maximum()) / singleStep()) * repeatMSecs;
+
+            /**
+             * This is an arbitrarily determined constant in msecs that
+             * specifies how long time it should take to navigate from the
+             * start to the end(excluding starting key auto repeat).
+             */
+            const int SliderRepeatElapse = 2500;
+
+            d->repeatMultiplier = currentTimeElapse / SliderRepeatElapse;
+        }
+
+    }
+    else if (d->firstRepeat.isValid()) {
+        d->firstRepeat.invalidate();
+        d->repeatMultiplier = 1;
+    }
+
+#endif
+
+    switch (ev->key()) {
+#ifdef QT_KEYPAD_NAVIGATION
+        case Qt::Key_Select:
+            if (QApplication::keypadNavigationEnabled())
+                setEditFocus(!hasEditFocus());
+            else
+                ev->ignore();
+            break;
+        case Qt::Key_Back:
+            if (QApplication::keypadNavigationEnabled() && hasEditFocus()) {
+                setValue(d->origValue);
+                setEditFocus(false);
+            } else
+                ev->ignore();
+            break;
+#endif
+
+        // It seems we need to use invertedAppearance for Left and right, otherwise, things look weird.
+        case Qt::Key_Left:
+#ifdef QT_KEYPAD_NAVIGATION
+            // In QApplication::KeypadNavigationDirectional, we want to change the slider
+            // value if there is no left/right navigation possible and if this slider is not
+            // inside a tab widget.
+            if (QApplication::keypadNavigationEnabled()
+                    && (!hasEditFocus() && QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
+                    || d->orientation == Qt::Vertical
+                    || !hasEditFocus()
+                    && (QWidgetPrivate::canKeypadNavigate(Qt::Horizontal) || QWidgetPrivate::inTabWidget(this)))) {
+                ev->ignore();
+                return;
+            }
+            if (QApplication::keypadNavigationEnabled() && d->orientation == Qt::Vertical)
+                action = d->invertedControls ? SliderSingleStepSub : SliderSingleStepAdd;
+            else
+#endif
+            if (isRightToLeft())
+                action = d->invertedAppearance ? SliderSingleStepSub : SliderSingleStepAdd;
+            else
+                action = !d->invertedAppearance ? SliderSingleStepSub : SliderSingleStepAdd;
+            break;
+        case Qt::Key_Right:
+#ifdef QT_KEYPAD_NAVIGATION
+            // Same logic as in Qt::Key_Left
+            if (QApplication::keypadNavigationEnabled()
+                    && (!hasEditFocus() && QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
+                    || d->orientation == Qt::Vertical
+                    || !hasEditFocus()
+                    && (QWidgetPrivate::canKeypadNavigate(Qt::Horizontal) || QWidgetPrivate::inTabWidget(this)))) {
+                ev->ignore();
+                return;
+            }
+            if (QApplication::keypadNavigationEnabled() && d->orientation == Qt::Vertical)
+                action = d->invertedControls ? SliderSingleStepAdd : SliderSingleStepSub;
+            else
+#endif
+            if (isRightToLeft())
+                action = d->invertedAppearance ? SliderSingleStepAdd : SliderSingleStepSub;
+            else
+                action = !d->invertedAppearance ? SliderSingleStepAdd : SliderSingleStepSub;
+            break;
+        case Qt::Key_Up:
+#ifdef QT_KEYPAD_NAVIGATION
+            // In QApplication::KeypadNavigationDirectional, we want to change the slider
+            // value if there is no up/down navigation possible.
+            if (QApplication::keypadNavigationEnabled()
+                    && (QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
+                    || d->orientation == Qt::Horizontal
+                    || !hasEditFocus() && QWidgetPrivate::canKeypadNavigate(Qt::Vertical))) {
+                ev->ignore();
+                break;
+            }
+#endif
+            action = d->invertedControls ? SliderSingleStepSub : SliderSingleStepAdd;
+            break;
+        case Qt::Key_Down:
+#ifdef QT_KEYPAD_NAVIGATION
+            // Same logic as in Qt::Key_Up
+            if (QApplication::keypadNavigationEnabled()
+                    && (QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
+                    || d->orientation == Qt::Horizontal
+                    || !hasEditFocus() && QWidgetPrivate::canKeypadNavigate(Qt::Vertical))) {
+                ev->ignore();
+                break;
+            }
+#endif
+            action = d->invertedControls ? SliderSingleStepAdd : SliderSingleStepSub;
+            break;
+        case Qt::Key_PageUp:
+            action = d->invertedControls ? SliderPageStepSub : SliderPageStepAdd;
+            break;
+        case Qt::Key_PageDown:
+            action = d->invertedControls ? SliderPageStepAdd : SliderPageStepSub;
+            break;
+        case Qt::Key_Home:
+            action = SliderToMinimum;
+            break;
+        case Qt::Key_End:
+            action = SliderToMaximum;
+            break;
+        default:
+            ev->ignore();
+            break;
+    }
+    if (action)
+        triggerAction(action);
+}
+
+/*!
+    \reimp
+*/
+void QAbstractSlider64::changeEvent(QEvent *ev)
+{
+    Q_D(QAbstractSlider64);
+    switch (ev->type()) {
+    case QEvent::EnabledChange:
+        if (!isEnabled()) {
+            d->repeatActionTimer.stop();
+            setSliderDown(false);
+        }
+        // fall through...
+    default:
+        QWidget::changeEvent(ev);
+    }
+}
+
+/*!
+    \reimp
+*/
+bool QAbstractSlider64::event(QEvent *e)
+{
+#ifdef QT_KEYPAD_NAVIGATION
+    Q_D(QAbstractSlider64);
+    switch (e->type()) {
+    case QEvent::FocusIn:
+        d->origValue = d->value;
+        break;
+    default:
+        break;
+    }
+#endif
+
+    return QWidget::event(e);
+}
+
+/*! \fn int QAbstractSlider64::minValue() const
+
+    Use minimum() instead.
+*/
+
+/*! \fn int QAbstractSlider64::maxValue() const
+
+    Use maximum() instead.
+*/
+
+/*! \fn int QAbstractSlider64::lineStep() const
+
+    Use singleStep() instead.
+*/
+
+/*! \fn void QAbstractSlider64::setMinValue(int v)
+
+    Use setMinimum() instead.
+*/
+
+/*! \fn void QAbstractSlider64::setMaxValue(int v)
+
+    Use setMaximum() instead.
+*/
+
+/*! \fn void QAbstractSlider64::setLineStep(int v)
+
+    Use setSingleStep() instead.
+*/
+
+/*! \fn void QAbstractSlider64::addPage()
+
+    Use triggerAction(QAbstractSlider64::SliderPageStepAdd) instead.
+*/
+
+/*! \fn void QAbstractSlider64::subtractPage()
+
+    Use triggerAction(QAbstractSlider64::SliderPageStepSub) instead.
+*/
+
+/*! \fn void QAbstractSlider64::addLine()
+
+    Use triggerAction(QAbstractSlider64::SliderSingleStepAdd) instead.
+*/
+
+/*! \fn void QAbstractSlider64::subtractLine()
+
+    Use triggerAction(QAbstractSlider64::SliderSingleStepSub) instead.
+*/
+
+/*! \fn void QAbstractSlider64::setSteps(int single, int page)
+
+    Use setSingleStep(\a single) followed by setPageStep(\a page)
+    instead.
+*/
+
+QT_END_NAMESPACE
diff -N -u qt4-x11-4.8.2+dfsg-org/src/gui/widgets/qabstractslider64.h qt4-x11-4.8.2+dfsg/src/gui/widgets/qabstractslider64.h
--- qt4-x11-4.8.2+dfsg-org/src/gui/widgets/qabstractslider64.h	1970-01-01 01:00:00.000000000 +0100
+++ qt4-x11-4.8.2+dfsg/src/gui/widgets/qabstractslider64.h	2013-01-16 16:06:49.716100275 +0100
@@ -0,0 +1,143 @@
+#ifndef QABSTRACTSLIDER64_H
+#define QABSTRACTSLIDER64_H
+
+#include <QtGui/qwidget.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Gui)
+
+class QAbstractSlider64Private;
+
+class Q_GUI_EXPORT QAbstractSlider64 : public QWidget
+{
+    Q_OBJECT
+
+    Q_PROPERTY(qint64 minimum READ minimum WRITE setMinimum)
+    Q_PROPERTY(qint64 maximum READ maximum WRITE setMaximum)
+    Q_PROPERTY(qint64 singleStep READ singleStep WRITE setSingleStep)
+    Q_PROPERTY(qint64 pageStep READ pageStep WRITE setPageStep)
+    Q_PROPERTY(qint64 value READ value WRITE setValue NOTIFY valueChanged USER true)
+    Q_PROPERTY(qint64 sliderPosition READ sliderPosition WRITE setSliderPosition NOTIFY sliderMoved)
+    Q_PROPERTY(bool tracking READ hasTracking WRITE setTracking)
+    Q_PROPERTY(Qt::Orientation orientation READ orientation WRITE setOrientation)
+    Q_PROPERTY(bool invertedAppearance READ invertedAppearance WRITE setInvertedAppearance)
+    Q_PROPERTY(bool invertedControls READ invertedControls WRITE setInvertedControls)
+    Q_PROPERTY(bool sliderDown READ isSliderDown WRITE setSliderDown DESIGNABLE false)
+
+public:
+    explicit QAbstractSlider64(QWidget *parent=0);
+    ~QAbstractSlider64();
+
+    Qt::Orientation orientation() const;
+
+    void setMinimum(qint64);
+    qint64 minimum() const;
+
+    void setMaximum(qint64);
+    qint64 maximum() const;
+
+    void setRange(qint64 min, qint64 max);
+
+    void setSingleStep(qint64);
+    qint64 singleStep() const;
+
+    void setPageStep(qint64);
+    qint64 pageStep() const;
+
+    void setTracking(bool enable);
+    bool hasTracking() const;
+
+    void setSliderDown(bool);
+    bool isSliderDown() const;
+
+    void setSliderPosition(qint64);
+    qint64 sliderPosition() const;
+
+    void setInvertedAppearance(bool);
+    bool invertedAppearance() const;
+
+    void setInvertedControls(bool);
+    bool invertedControls() const;
+
+    enum SliderAction {
+        SliderNoAction,
+        SliderSingleStepAdd,
+        SliderSingleStepSub,
+        SliderPageStepAdd,
+        SliderPageStepSub,
+        SliderToMinimum,
+        SliderToMaximum,
+        SliderMove
+    };
+
+    qint64 value() const;
+
+    void triggerAction(SliderAction action);
+
+public Q_SLOTS:
+    void setValue(qint64);
+    void setOrientation(Qt::Orientation);
+
+Q_SIGNALS:
+    void valueChanged(qint64 value);
+
+    void sliderPressed();
+    void sliderMoved(qint64 position);
+    void sliderReleased();
+
+    void rangeChanged(qint64 min, qint64 max);
+
+    void actionTriggered(int action);
+
+protected:
+    bool event(QEvent *e);
+
+    void setRepeatAction(SliderAction action, int thresholdTime = 500, int repeatTime = 50);
+    SliderAction repeatAction() const;
+
+    enum SliderChange {
+        SliderRangeChange,
+        SliderOrientationChange,
+        SliderStepsChange,
+        SliderValueChange
+    };
+    virtual void sliderChange(SliderChange change);
+
+    void keyPressEvent(QKeyEvent *ev);
+    void timerEvent(QTimerEvent *);
+#ifndef QT_NO_WHEELEVENT
+    void wheelEvent(QWheelEvent *e);
+#endif
+    void changeEvent(QEvent *e);
+
+#ifdef QT3_SUPPORT
+public:
+    inline QT3_SUPPORT qint64 minValue() const { return minimum(); }
+    inline QT3_SUPPORT qint64 maxValue() const { return maximum(); }
+    inline QT3_SUPPORT qint64 lineStep() const { return singleStep(); }
+    inline QT3_SUPPORT void setMinValue(qint64 v) { setMinimum(v); }
+    inline QT3_SUPPORT void setMaxValue(qint64 v) { setMaximum(v); }
+    inline QT3_SUPPORT void setLineStep(qint64 v) { setSingleStep(v); }
+    inline QT3_SUPPORT void setSteps(qint64 single, qint64 page) { setSingleStep(single); setPageStep(page); }
+    inline QT3_SUPPORT void addPage() { triggerAction(SliderPageStepAdd); }
+    inline QT3_SUPPORT void subtractPage() { triggerAction(SliderPageStepSub); }
+    inline QT3_SUPPORT void addLine() { triggerAction(SliderSingleStepAdd); }
+    inline QT3_SUPPORT void subtractLine() { triggerAction(SliderSingleStepSub); }
+#endif
+
+protected:
+    QAbstractSlider64(QAbstractSlider64Private &dd, QWidget *parent=0);
+
+private:
+    Q_DISABLE_COPY(QAbstractSlider64)
+    Q_DECLARE_PRIVATE(QAbstractSlider64)
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QABSTRACTSLIDER64_H
diff -N -u qt4-x11-4.8.2+dfsg-org/src/gui/widgets/qabstractslider64_p.h qt4-x11-4.8.2+dfsg/src/gui/widgets/qabstractslider64_p.h
--- qt4-x11-4.8.2+dfsg-org/src/gui/widgets/qabstractslider64_p.h	1970-01-01 01:00:00.000000000 +0100
+++ qt4-x11-4.8.2+dfsg/src/gui/widgets/qabstractslider64_p.h	2013-01-17 11:04:03.111963920 +0100
@@ -0,0 +1,106 @@
+#ifndef QABSTRACTSLIDER64_P_H
+#define QABSTRACTSLIDER64_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "QtCore/qbasictimer.h"
+#include "QtCore/qelapsedtimer.h"
+#include "private/qwidget_p.h"
+#include "qstyle.h"
+
+QT_BEGIN_NAMESPACE
+
+class QAbstractSlider64Private : public QWidgetPrivate
+{
+    Q_DECLARE_PUBLIC(QAbstractSlider64)
+public:
+    QAbstractSlider64Private();
+    ~QAbstractSlider64Private();
+
+    void setSteps(qint64 single, qint64 page);
+
+    qint64 minimum, maximum, pageStep, value, position, pressValue;
+
+    /**
+     * Call effectiveSingleStep() when changing the slider value.
+     */
+    qint64 singleStep;
+
+    float offset_accumulated;
+    uint tracking : 1;
+    uint blocktracking :1;
+    uint pressed : 1;
+    uint invertedAppearance : 1;
+    uint invertedControls : 1;
+    Qt::Orientation orientation;
+
+    QBasicTimer repeatActionTimer;
+    int repeatActionTime;
+    QAbstractSlider64::SliderAction repeatAction;
+    
+#ifdef QT_KEYPAD_NAVIGATION
+    qint64 origValue;
+
+    /**
+     */
+    bool isAutoRepeating;
+
+    /**
+     * When we're auto repeating, we multiply singleStep with this value to
+     * get our effective step.
+     */
+    qreal repeatMultiplier;
+
+    /**
+     * The time of when the first auto repeating key press event occurs.
+     */
+    QElapsedTimer firstRepeat;
+
+#endif
+
+    inline qint64 effectiveSingleStep() const
+    {
+        return singleStep
+#ifdef QT_KEYPAD_NAVIGATION
+        * repeatMultiplier
+#endif
+        ;
+    }
+
+    virtual qint64 bound(qint64 val) const { return qMax(minimum, qMin(maximum, val)); }
+    inline qint64 overflowSafeAdd(qint64 add) const
+    {
+        qint64 newValue = value + add;
+        if (add > 0 && newValue < value)
+            newValue = maximum;
+        else if (add < 0 && newValue > value)
+            newValue = minimum;
+        return newValue;
+    }
+    inline void setAdjustedSliderPosition(qint64 position)
+    {
+        Q_Q(QAbstractSlider64);
+        if (q->style()->styleHint(QStyle::SH_Slider_StopMouseOverSlider, 0, q)) {
+            if ((position > pressValue - 2 * pageStep) && (position < pressValue + 2 * pageStep)) {
+                repeatAction = QAbstractSlider64::SliderNoAction;
+                q->setSliderPosition(pressValue);
+                return;
+            }
+        }
+        q->triggerAction(repeatAction);
+    }
+    bool scrollByDelta(Qt::Orientation orientation, Qt::KeyboardModifiers modifiers, qint64 delta);
+};
+
+QT_END_NAMESPACE
+
+#endif // QABSTRACTSLIDER64_P_H
diff -N -u qt4-x11-4.8.2+dfsg-org/src/gui/widgets/qscrollbar64.cpp qt4-x11-4.8.2+dfsg/src/gui/widgets/qscrollbar64.cpp
--- qt4-x11-4.8.2+dfsg-org/src/gui/widgets/qscrollbar64.cpp	1970-01-01 01:00:00.000000000 +0100
+++ qt4-x11-4.8.2+dfsg/src/gui/widgets/qscrollbar64.cpp	2013-01-17 11:09:07.135948162 +0100
@@ -0,0 +1,764 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qapplication.h"
+#include "qcursor.h"
+#include "qevent.h"
+#include "qpainter.h"
+#include "qscrollbar64.h"
+#include "qstyle.h"
+#include "qstyleoption.h"
+#include "qmenu.h"
+#include <QtCore/qelapsedtimer.h>
+
+#ifndef QT_NO_SCROLLBAR
+
+#ifndef QT_NO_ACCESSIBILITY
+#include "qaccessible.h"
+#endif
+#include <limits.h>
+#include "qabstractslider64_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QScrollBar64
+    \brief The QScrollBar64 widget provides a vertical or horizontal scroll bar.
+
+    \ingroup basicwidgets
+
+    A scroll bar is a control that enables the user to access parts of a
+    document that is larger than the widget used to display it. It provides
+    a visual indication of the user's current position within the document
+    and the amount of the document that is visible. Scroll bars are usually
+    equipped with other controls that enable more accurate navigation.
+    Qt displays scroll bars in a way that is appropriate for each platform.
+
+    If you need to provide a scrolling view onto another widget, it may be
+    more convenient to use the QScrollArea class because this provides a
+    viewport widget and scroll bars. QScrollBar64 is useful if you need to
+    implement similar functionality for specialized widgets using QAbstractScrollArea;
+    for example, if you decide to subclass QAbstractItemView.
+    For most other situations where a slider control is used to obtain a value
+    within a given range, the QSlider class may be more appropriate for your
+    needs.
+
+    \table
+    \row \o \image qscrollbar-picture.png
+    \o Scroll bars typically include four separate controls: a slider,
+    scroll arrows, and a page control.
+
+    \list
+    \o a. The slider provides a way to quickly go to any part of the
+    document, but does not support accurate navigation within large
+    documents.
+    \o b. The scroll arrows are push buttons which can be used to accurately
+    navigate to a particular place in a document. For a vertical scroll bar
+    connected to a text editor, these typically move the current position one
+    "line" up or down, and adjust the position of the slider by a small
+    amount. In editors and list boxes a "line" might mean one line of text;
+    in an image viewer it might mean 20 pixels.
+    \o c. The page control is the area over which the slider is dragged (the
+    scroll bar's background). Clicking here moves the scroll bar towards
+    the click by one "page". This value is usually the same as the length of
+    the slider.
+    \endlist
+    \endtable
+
+    Each scroll bar has a value that indicates how far the slider is from
+    the start of the scroll bar; this is obtained with value() and set
+    with setValue(). This value always lies within the range of values
+    defined for the scroll bar, from \l{QAbstractSlider64::minimum()}{minimum()}
+    to \l{QAbstractSlider64::minimum()}{maximum()} inclusive. The range of
+    acceptable values can be set with setMinimum() and setMaximum().
+    At the minimum value, the top edge of the slider (for a vertical scroll
+    bar) or left edge (for a horizontal scroll bar) will be at the top (or
+    left) end of the scroll bar. At the maximum value, the bottom (or right)
+    edge of the slider will be at the bottom (or right) end of the scroll bar.
+
+    The length of the slider is usually related to the value of the page step,
+    and typically represents the proportion of the document area shown in a
+    scrolling view. The page step is the amount that the value changes by
+    when the user presses the \key{Page Up} and \key{Page Down} keys, and is
+    set with setPageStep(). Smaller changes to the value defined by the
+    line step are made using the cursor keys, and this quantity is set with
+    \l{QAbstractSlider64::}{setSingleStep()}.
+
+    Note that the range of values used is independent of the actual size
+    of the scroll bar widget. You do not need to take this into account when
+    you choose values for the range and the page step.
+
+    The range of values specified for the scroll bar are often determined
+    differently to those for a QSlider because the length of the slider
+    needs to be taken into account. If we have a document with 100 lines,
+    and we can only show 20 lines in a widget, we may wish to construct a
+    scroll bar with a page step of 20, a minimum value of 0, and a maximum
+    value of 80. This would give us a scroll bar with five "pages".
+
+    \table
+    \row \o \inlineimage qscrollbar-values.png
+    \o The relationship between a document length, the range of values used
+    in a scroll bar, and the page step is simple in many common situations.
+    The scroll bar's range of values is determined by subtracting a
+    chosen page step from some value representing the length of the document.
+    In such cases, the following equation is useful:
+    \e{document length} = maximum() - minimum() + pageStep().
+    \endtable
+
+    QScrollBar64 only provides integer ranges. Note that although
+    QScrollBar64 handles very large numbers, scroll bars on current
+    screens cannot usefully represent ranges above about 100,000 pixels.
+    Beyond that, it becomes difficult for the user to control the
+    slider using either the keyboard or the mouse, and the scroll
+    arrows will have limited use.
+
+    ScrollBar inherits a comprehensive set of signals from QAbstractSlider64:
+    \list
+    \o \l{QAbstractSlider64::valueChanged()}{valueChanged()} is emitted when the
+       scroll bar's value has changed. The tracking() determines whether this
+       signal is emitted during user interaction.
+    \o \l{QAbstractSlider64::rangeChanged()}{rangeChanged()} is emitted when the
+       scroll bar's range of values has changed.
+    \o \l{QAbstractSlider64::sliderPressed()}{sliderPressed()} is emitted when
+       the user starts to drag the slider.
+    \o \l{QAbstractSlider64::sliderMoved()}{sliderMoved()} is emitted when the user
+       drags the slider.
+    \o \l{QAbstractSlider64::sliderReleased()}{sliderReleased()} is emitted when
+       the user releases the slider.
+    \o \l{QAbstractSlider64::actionTriggered()}{actionTriggered()} is emitted
+       when the scroll bar is changed by user interaction or via the
+       \l{QAbstractSlider64::triggerAction()}{triggerAction()} function.
+    \endlist
+
+    A scroll bar can be controlled by the keyboard, but it has a
+    default focusPolicy() of Qt::NoFocus. Use setFocusPolicy() to
+    enable keyboard interaction with the scroll bar:
+    \list
+         \o Left/Right move a horizontal scroll bar by one single step.
+         \o Up/Down move a vertical scroll bar by one single step.
+         \o PageUp moves up one page.
+         \o PageDown moves down one page.
+         \o Home moves to the start (mininum).
+         \o End moves to the end (maximum).
+     \endlist
+
+    The slider itself can be controlled by using the
+    \l{QAbstractSlider64::triggerAction()}{triggerAction()} function to simulate
+    user interaction with the scroll bar controls. This is useful if you have
+    many different widgets that use a common range of values.
+
+    Most GUI styles use the pageStep() value to calculate the size of the
+    slider.
+
+    \table 100%
+    \row \o \inlineimage macintosh-horizontalscrollbar.png Screenshot of a Macintosh style scroll bar
+         \o A scroll bar shown in the \l{Macintosh Style Widget Gallery}{Macintosh widget style}.
+    \row \o \inlineimage windowsxp-horizontalscrollbar.png Screenshot of a Windows XP style scroll bar
+         \o A scroll bar shown in the \l{Windows XP Style Widget Gallery}{Windows XP widget style}.
+    \row \o \inlineimage plastique-horizontalscrollbar.png Screenshot of a Plastique style scroll bar
+         \o A scroll bar shown in the \l{Plastique Style Widget Gallery}{Plastique widget style}.
+    \endtable
+
+    \sa QScrollArea, QSlider, QDial, QSpinBox, {fowler}{GUI Design Handbook: Scroll Bar}, {Sliders Example}
+*/
+
+class QScrollBar64Private : public QAbstractSlider64Private
+{
+    Q_DECLARE_PUBLIC(QScrollBar64)
+public:
+    QStyle::SubControl pressedControl;
+    bool pointerOutsidePressedControl;
+
+    qint64 clickOffset, snapBackPosition;
+
+    void activateControl(uint control, int threshold = 500);
+    void stopRepeatAction();
+    qint64 pixelPosToRangeValue(int pos) const;
+    void init();
+    bool updateHoverControl(const QPoint &pos);
+    QStyle::SubControl newHoverControl(const QPoint &pos);
+
+    QStyle::SubControl hoverControl;
+    QRect hoverRect;
+};
+
+bool QScrollBar64Private::updateHoverControl(const QPoint &pos)
+{
+    Q_Q(QScrollBar64);
+    QRect lastHoverRect = hoverRect;
+    QStyle::SubControl lastHoverControl = hoverControl;
+    bool doesHover = q->testAttribute(Qt::WA_Hover);
+    if (lastHoverControl != newHoverControl(pos) && doesHover) {
+        q->update(lastHoverRect);
+        q->update(hoverRect);
+        return true;
+    }
+    return !doesHover;
+}
+
+QStyle::SubControl QScrollBar64Private::newHoverControl(const QPoint &pos)
+{
+    Q_Q(QScrollBar64);
+    QStyleOptionSlider opt;
+    q->initStyleOption(&opt);
+    opt.subControls = QStyle::SC_All;
+    hoverControl = q->style()->hitTestComplexControl(QStyle::CC_ScrollBar, &opt, pos, q);
+    if (hoverControl == QStyle::SC_None)
+        hoverRect = QRect();
+    else
+        hoverRect = q->style()->subControlRect(QStyle::CC_ScrollBar, &opt, hoverControl, q);
+    return hoverControl;
+}
+
+void QScrollBar64Private::activateControl(uint control, int threshold)
+{
+    QAbstractSlider64::SliderAction action = QAbstractSlider64::SliderNoAction;
+    switch (control) {
+    case QStyle::SC_ScrollBarAddPage:
+        action = QAbstractSlider64::SliderPageStepAdd;
+        break;
+    case QStyle::SC_ScrollBarSubPage:
+        action = QAbstractSlider64::SliderPageStepSub;
+        break;
+    case QStyle::SC_ScrollBarAddLine:
+        action = QAbstractSlider64::SliderSingleStepAdd;
+        break;
+    case QStyle::SC_ScrollBarSubLine:
+        action = QAbstractSlider64::SliderSingleStepSub;
+        break;
+    case QStyle::SC_ScrollBarFirst:
+        action = QAbstractSlider64::SliderToMinimum;
+        break;
+    case QStyle::SC_ScrollBarLast:
+        action = QAbstractSlider64::SliderToMaximum;
+        break;
+    default:
+        break;
+    }
+
+    if (action) {
+        q_func()->setRepeatAction(action, threshold);
+        q_func()->triggerAction(action);
+    }
+}
+
+void QScrollBar64Private::stopRepeatAction()
+{
+    Q_Q(QScrollBar64);
+    QStyle::SubControl tmp = pressedControl;
+    q->setRepeatAction(QAbstractSlider64::SliderNoAction);
+    pressedControl = QStyle::SC_None;
+
+    if (tmp == QStyle::SC_ScrollBarSlider)
+        q->setSliderDown(false);
+
+    QStyleOptionSlider opt;
+    q->initStyleOption(&opt);
+    q->repaint(q->style()->subControlRect(QStyle::CC_ScrollBar, &opt, tmp, q));
+}
+
+/*!
+    Initialize \a option with the values from this QScrollBar64. This method
+    is useful for subclasses when they need a QStyleOptionSlider, but don't want
+    to fill in all the information themselves.
+
+    \sa QStyleOption::initFrom()
+*/
+void QScrollBar64::initStyleOption(QStyleOptionSlider *option) const
+{
+    if (!option)
+        return;
+
+    Q_D(const QScrollBar64);
+    option->initFrom(this);
+    option->subControls = QStyle::SC_None;
+    option->activeSubControls = QStyle::SC_None;
+    option->orientation = d->orientation;
+    option->minimum = d->minimum;
+    option->maximum = d->maximum;
+    option->sliderPosition = d->position;
+    option->sliderValue = d->value;
+    option->singleStep = d->singleStep;
+    option->pageStep = d->pageStep;
+    option->upsideDown = d->invertedAppearance;
+    if (d->orientation == Qt::Horizontal)
+        option->state |= QStyle::State_Horizontal;
+}
+
+
+#define HORIZONTAL (d_func()->orientation == Qt::Horizontal)
+#define VERTICAL !HORIZONTAL
+
+/*!
+    Constructs a vertical scroll bar.
+
+    The \a parent argument is sent to the QWidget constructor.
+
+    The \l {QAbstractSlider64::minimum} {minimum} defaults to 0, the
+    \l {QAbstractSlider64::maximum} {maximum} to 99, with a
+    \l {QAbstractSlider64::singleStep} {singleStep} size of 1 and a
+    \l {QAbstractSlider64::pageStep} {pageStep} size of 10, and an
+    initial \l {QAbstractSlider64::value} {value} of 0.
+*/
+QScrollBar64::QScrollBar64(QWidget *parent)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    d_func()->orientation = Qt::Vertical;
+    d_func()->init();
+}
+
+/*!
+    Constructs a scroll bar with the given \a orientation.
+
+    The \a parent argument is passed to the QWidget constructor.
+
+    The \l {QAbstractSlider64::minimum} {minimum} defaults to 0, the
+    \l {QAbstractSlider64::maximum} {maximum} to 99, with a
+    \l {QAbstractSlider64::singleStep} {singleStep} size of 1 and a
+    \l {QAbstractSlider64::pageStep} {pageStep} size of 10, and an
+    initial \l {QAbstractSlider64::value} {value} of 0.
+*/
+QScrollBar64::QScrollBar64(Qt::Orientation orientation, QWidget *parent)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    d_func()->orientation = orientation;
+    d_func()->init();
+}
+
+
+#ifdef QT3_SUPPORT
+/*!
+    Use one of the constructors that doesn't take the \a name
+    argument and then use setObjectName() instead.
+*/
+QScrollBar64::QScrollBar64(QWidget *parent, const char *name)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    setObjectName(QString::fromAscii(name));
+    d_func()->orientation = Qt::Vertical;
+    d_func()->init();
+}
+
+/*!
+    Use one of the constructors that doesn't take the \a name
+    argument and then use setObjectName() instead.
+*/
+QScrollBar64::QScrollBar64(Qt::Orientation orientation, QWidget *parent, const char *name)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    setObjectName(QString::fromAscii(name));
+    d_func()->orientation = orientation;
+    d_func()->init();
+}
+
+/*!
+    Use one of the constructors that doesn't take the \a name
+    argument and then use setObjectName() instead.
+*/
+QScrollBar64::QScrollBar64(qint64 minimum, qint64 maximum, qint64 lineStep, qint64 pageStep,
+                        qint64 value, Qt::Orientation orientation,
+                        QWidget *parent, const char *name)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    Q_D(QScrollBar64);
+    setObjectName(QString::fromAscii(name));
+    d->minimum = minimum;
+    d->maximum = maximum;
+    d->singleStep = lineStep;
+    d->pageStep = pageStep;
+    d->value = value;
+    d->orientation = orientation;
+    d->init();
+}
+#endif // QT3_SUPPORT
+
+/*!
+    Destroys the scroll bar.
+*/
+QScrollBar64::~QScrollBar64()
+{
+}
+
+void QScrollBar64Private::init()
+{
+    Q_Q(QScrollBar64);
+    invertedControls = true;
+    pressedControl = hoverControl = QStyle::SC_None;
+    pointerOutsidePressedControl = false;
+    q->setFocusPolicy(Qt::NoFocus);
+    QSizePolicy sp(QSizePolicy::Minimum, QSizePolicy::Fixed, QSizePolicy::Slider);
+    if (orientation == Qt::Vertical)
+        sp.transpose();
+    q->setSizePolicy(sp);
+    q->setAttribute(Qt::WA_WState_OwnSizePolicy, false);
+    q->setAttribute(Qt::WA_OpaquePaintEvent);
+
+#if !defined(QT_NO_CONTEXTMENU) && defined(Q_WS_WINCE)
+    if (!q->style()->styleHint(QStyle::SH_ScrollBar_ContextMenu, 0, q)) {
+        q->setContextMenuPolicy(Qt::PreventContextMenu);
+    }
+#endif
+}
+
+#ifndef QT_NO_CONTEXTMENU
+/*! \reimp */
+void QScrollBar64::contextMenuEvent(QContextMenuEvent *event)
+{
+    if (!style()->styleHint(QStyle::SH_ScrollBar_ContextMenu, 0, this)) {
+        QAbstractSlider64::contextMenuEvent(event);
+        return ;
+    }
+
+#ifndef QT_NO_MENU
+    bool horiz = HORIZONTAL;
+    QPointer<QMenu> menu = new QMenu(this);
+    QAction *actScrollHere = menu->addAction(tr("Scroll here"));
+    menu->addSeparator();
+    QAction *actScrollTop =  menu->addAction(horiz ? tr("Left edge") : tr("Top"));
+    QAction *actScrollBottom = menu->addAction(horiz ? tr("Right edge") : tr("Bottom"));
+    menu->addSeparator();
+    QAction *actPageUp = menu->addAction(horiz ? tr("Page left") : tr("Page up"));
+    QAction *actPageDn = menu->addAction(horiz ? tr("Page right") : tr("Page down"));
+    menu->addSeparator();
+    QAction *actScrollUp = menu->addAction(horiz ? tr("Scroll left") : tr("Scroll up"));
+    QAction *actScrollDn = menu->addAction(horiz ? tr("Scroll right") : tr("Scroll down"));
+    QAction *actionSelected = menu->exec(event->globalPos());
+    delete menu;
+    if (actionSelected == 0)
+        /* do nothing */ ;
+    else if (actionSelected == actScrollHere)
+        setValue(d_func()->pixelPosToRangeValue(horiz ? event->pos().x() : event->pos().y()));
+    else if (actionSelected == actScrollTop)
+        triggerAction(QAbstractSlider64::SliderToMinimum);
+    else if (actionSelected == actScrollBottom)
+        triggerAction(QAbstractSlider64::SliderToMaximum);
+    else if (actionSelected == actPageUp)
+        triggerAction(QAbstractSlider64::SliderPageStepSub);
+    else if (actionSelected == actPageDn)
+        triggerAction(QAbstractSlider64::SliderPageStepAdd);
+    else if (actionSelected == actScrollUp)
+        triggerAction(QAbstractSlider64::SliderSingleStepSub);
+    else if (actionSelected == actScrollDn)
+        triggerAction(QAbstractSlider64::SliderSingleStepAdd);
+#endif // QT_NO_MENU
+}
+#endif // QT_NO_CONTEXTMENU
+
+
+/*! \reimp */
+QSize QScrollBar64::sizeHint() const
+{
+    ensurePolished();
+    QStyleOptionSlider opt;
+    initStyleOption(&opt);
+
+    int scrollBarExtent = style()->pixelMetric(QStyle::PM_ScrollBarExtent, &opt, this);
+    int scrollBarSliderMin = style()->pixelMetric(QStyle::PM_ScrollBarSliderMin, &opt, this);
+    QSize size;
+    if (opt.orientation == Qt::Horizontal)
+        size = QSize(scrollBarExtent * 2 + scrollBarSliderMin, scrollBarExtent);
+    else
+        size = QSize(scrollBarExtent, scrollBarExtent * 2 + scrollBarSliderMin);
+
+    return style()->sizeFromContents(QStyle::CT_ScrollBar, &opt, size, this)
+        .expandedTo(QApplication::globalStrut());
+ }
+
+/*!\reimp */
+void QScrollBar64::sliderChange(SliderChange change)
+{
+    QAbstractSlider64::sliderChange(change);
+}
+
+/*!
+    \reimp
+*/
+bool QScrollBar64::event(QEvent *event)
+{
+    switch(event->type()) {
+    case QEvent::HoverEnter:
+    case QEvent::HoverLeave:
+    case QEvent::HoverMove:
+    if (const QHoverEvent *he = static_cast<const QHoverEvent *>(event))
+        d_func()->updateHoverControl(he->pos());
+        break;
+#ifndef QT_NO_WHEELEVENT
+    case QEvent::Wheel: {
+        event->ignore();
+        // override wheel event without adding virtual function override
+        QWheelEvent *ev = static_cast<QWheelEvent *>(event);
+        int delta = ev->delta();
+        // scrollbar is a special case - in vertical mode it reaches minimum
+        // value in the upper position, however QSlider's minimum value is on
+        // the bottom. So we need to invert a value, but since the scrollbar is
+        // inverted by default, we need to inverse the delta value for the
+        // horizontal orientation.
+        if (ev->orientation() == Qt::Horizontal)
+            delta = -delta;
+        Q_D(QScrollBar64);
+        if (d->scrollByDelta(ev->orientation(), ev->modifiers(), delta))
+            event->accept();
+        return true;
+    }
+#endif
+    default:
+        break;
+    }
+    return QAbstractSlider64::event(event);
+}
+
+/*!
+    \reimp
+*/
+void QScrollBar64::paintEvent(QPaintEvent *)
+{
+    Q_D(QScrollBar64);
+    QPainter p(this);
+    QStyleOptionSlider opt;
+    initStyleOption(&opt);
+    opt.subControls = QStyle::SC_All;
+    if (d->pressedControl) {
+        opt.activeSubControls = (QStyle::SubControl)d->pressedControl;
+        if (!d->pointerOutsidePressedControl)
+            opt.state |= QStyle::State_Sunken;
+    } else {
+        opt.activeSubControls = (QStyle::SubControl)d->hoverControl;
+    }
+    style()->drawComplexControl(QStyle::CC_ScrollBar, &opt, &p, this);
+}
+
+/*!
+    \reimp
+*/
+void QScrollBar64::mousePressEvent(QMouseEvent *e)
+{
+    Q_D(QScrollBar64);
+
+    if (d->repeatActionTimer.isActive())
+        d->stopRepeatAction();
+
+    bool midButtonAbsPos = style()->styleHint(QStyle::SH_ScrollBar_MiddleClickAbsolutePosition,
+                                             0, this);
+    QStyleOptionSlider opt;
+    initStyleOption(&opt);
+
+    if (d->maximum == d->minimum // no range
+        || (e->buttons() & (~e->button())) // another button was clicked before
+        || !(e->button() == Qt::LeftButton || (midButtonAbsPos && e->button() == Qt::MidButton)))
+        return;
+
+    d->pressedControl = style()->hitTestComplexControl(QStyle::CC_ScrollBar, &opt, e->pos(), this);
+    d->pointerOutsidePressedControl = false;
+
+    QRect sr = style()->subControlRect(QStyle::CC_ScrollBar, &opt,
+                                       QStyle::SC_ScrollBarSlider, this);
+    QPoint click = e->pos();
+    QPoint pressValue = click - sr.center() + sr.topLeft();
+    d->pressValue = d->orientation == Qt::Horizontal ? d->pixelPosToRangeValue(pressValue.x()) :
+        d->pixelPosToRangeValue(pressValue.y());
+    if (d->pressedControl == QStyle::SC_ScrollBarSlider) {
+        d->clickOffset = HORIZONTAL ? (click.x()-sr.x()) : (click.y()-sr.y());
+        d->snapBackPosition = d->position;
+    }
+
+    if ((d->pressedControl == QStyle::SC_ScrollBarAddPage
+          || d->pressedControl == QStyle::SC_ScrollBarSubPage)
+        && ((midButtonAbsPos && e->button() == Qt::MidButton)
+            || (style()->styleHint(QStyle::SH_ScrollBar_LeftClickAbsolutePosition, &opt, this)
+                && e->button() == Qt::LeftButton))) {
+        qint64 sliderLength = HORIZONTAL ? sr.width() : sr.height();
+        setSliderPosition(d->pixelPosToRangeValue((HORIZONTAL ? e->pos().x()
+                                                              : e->pos().y()) - sliderLength / 2));
+        d->pressedControl = QStyle::SC_ScrollBarSlider;
+        d->clickOffset = sliderLength / 2;
+    }
+    const int initialDelay = 500; // default threshold
+    d->activateControl(d->pressedControl, initialDelay);
+    QElapsedTimer time;
+    time.start();
+    repaint(style()->subControlRect(QStyle::CC_ScrollBar, &opt, d->pressedControl, this));
+    if (time.elapsed() >= initialDelay && d->repeatActionTimer.isActive()) {
+        // It took more than 500ms (the initial timer delay) to process the repaint(), we
+        // therefore need to restart the timer in case we have a pending mouse release event;
+        // otherwise we'll get a timer event right before the release event,
+        // causing the repeat action to be invoked twice on a single mouse click.
+        // 50ms is the default repeat time (see activateControl/setRepeatAction).
+        d->repeatActionTimer.start(50, this);
+    }
+    if (d->pressedControl == QStyle::SC_ScrollBarSlider)
+        setSliderDown(true);
+}
+
+
+/*!
+    \reimp
+*/
+void QScrollBar64::mouseReleaseEvent(QMouseEvent *e)
+{
+    Q_D(QScrollBar64);
+    if (!d->pressedControl)
+        return;
+
+    if (e->buttons() & (~e->button())) // some other button is still pressed
+        return;
+
+    d->stopRepeatAction();
+}
+
+
+/*!
+    \reimp
+*/
+void QScrollBar64::mouseMoveEvent(QMouseEvent *e)
+{
+    Q_D(QScrollBar64);
+    if (!d->pressedControl)
+        return;
+
+    QStyleOptionSlider opt;
+    initStyleOption(&opt);
+    if (!(e->buttons() & Qt::LeftButton
+          ||  ((e->buttons() & Qt::MidButton)
+               && style()->styleHint(QStyle::SH_ScrollBar_MiddleClickAbsolutePosition, &opt, this))))
+        return;
+
+    if (d->pressedControl == QStyle::SC_ScrollBarSlider) {
+        QPoint click = e->pos();
+        qint64 newPosition = d->pixelPosToRangeValue((HORIZONTAL ? click.x() : click.y()) -d->clickOffset);
+        int m = style()->pixelMetric(QStyle::PM_MaximumDragDistance, &opt, this);
+        if (m >= 0) {
+            QRect r = rect();
+            r.adjust(-m, -m, m, m);
+            if (! r.contains(e->pos()))
+                newPosition = d->snapBackPosition;
+        }
+        setSliderPosition(newPosition);
+    } else if (!style()->styleHint(QStyle::SH_ScrollBar_ScrollWhenPointerLeavesControl, &opt, this)) {
+
+        if (style()->styleHint(QStyle::SH_ScrollBar_RollBetweenButtons, &opt, this)
+                && d->pressedControl & (QStyle::SC_ScrollBarAddLine | QStyle::SC_ScrollBarSubLine)) {
+            QStyle::SubControl newSc = style()->hitTestComplexControl(QStyle::CC_ScrollBar, &opt, e->pos(), this);
+            if (newSc == d->pressedControl && !d->pointerOutsidePressedControl)
+                return; // nothing to do
+            if (newSc & (QStyle::SC_ScrollBarAddLine | QStyle::SC_ScrollBarSubLine)) {
+                d->pointerOutsidePressedControl = false;
+                QRect scRect = style()->subControlRect(QStyle::CC_ScrollBar, &opt, newSc, this);
+                scRect |= style()->subControlRect(QStyle::CC_ScrollBar, &opt, d->pressedControl, this);
+                d->pressedControl = newSc;
+                d->activateControl(d->pressedControl, 0);
+                update(scRect);
+                return;
+            }
+        }
+
+        // stop scrolling when the mouse pointer leaves a control
+        // similar to push buttons
+        QRect pr = style()->subControlRect(QStyle::CC_ScrollBar, &opt, d->pressedControl, this);
+        if (pr.contains(e->pos()) == d->pointerOutsidePressedControl) {
+            if ((d->pointerOutsidePressedControl = !d->pointerOutsidePressedControl)) {
+                d->pointerOutsidePressedControl = true;
+                setRepeatAction(SliderNoAction);
+                repaint(pr);
+            } else  {
+                d->activateControl(d->pressedControl);
+            }
+        }
+    }
+}
+
+
+qint64 QScrollBar64Private::pixelPosToRangeValue(int pos) const
+{
+    Q_Q(const QScrollBar64);
+    QStyleOptionSlider opt;
+    q->initStyleOption(&opt);
+    QRect gr = q->style()->subControlRect(QStyle::CC_ScrollBar, &opt,
+                                          QStyle::SC_ScrollBarGroove, q);
+    QRect sr = q->style()->subControlRect(QStyle::CC_ScrollBar, &opt,
+                                          QStyle::SC_ScrollBarSlider, q);
+    qint64 sliderMin, sliderMax, sliderLength;
+
+    if (orientation == Qt::Horizontal) {
+        sliderLength = sr.width();
+        sliderMin = gr.x();
+        sliderMax = gr.right() - sliderLength + 1;
+        if (q->layoutDirection() == Qt::RightToLeft)
+            opt.upsideDown = !opt.upsideDown;
+    } else {
+        sliderLength = sr.height();
+        sliderMin = gr.y();
+        sliderMax = gr.bottom() - sliderLength + 1;
+    }
+
+    return  QStyle::sliderValueFromPosition(minimum, maximum, pos - sliderMin,
+                                            sliderMax - sliderMin, opt.upsideDown);
+}
+
+/*! \reimp
+*/
+void QScrollBar64::hideEvent(QHideEvent *)
+{
+    Q_D(QScrollBar64);
+    if (d->pressedControl) {
+        d->pressedControl = QStyle::SC_None;
+        setRepeatAction(SliderNoAction);
+    }
+}
+
+/*!
+    \fn bool QScrollBar64::draggingSlider()
+
+    Use isSliderDown() instead.
+*/
+
+/*! \internal
+    Returns the style option for scroll bar.
+*/
+Q_GUI_EXPORT QStyleOptionSlider qt_qscrollbarStyleOption(QScrollBar64 *scrollbar)
+{
+    QStyleOptionSlider opt;
+    scrollbar->initStyleOption(&opt);
+    return opt;
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_SCROLLBAR
diff -N -u qt4-x11-4.8.2+dfsg-org/src/gui/widgets/qscrollbar64.h qt4-x11-4.8.2+dfsg/src/gui/widgets/qscrollbar64.h
--- qt4-x11-4.8.2+dfsg-org/src/gui/widgets/qscrollbar64.h	1970-01-01 01:00:00.000000000 +0100
+++ qt4-x11-4.8.2+dfsg/src/gui/widgets/qscrollbar64.h	2013-01-16 16:31:20.837546473 +0100
@@ -0,0 +1,63 @@
+#ifndef QSCROLLBAR64_H
+#define QSCROLLBAR64_H
+
+#include <QtGui/qwidget.h>
+#include <QtGui/qabstractslider64.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Gui)
+
+#ifndef QT_NO_SCROLLBAR
+
+class QScrollBar64Private;
+class QStyleOptionSlider;
+
+class Q_GUI_EXPORT QScrollBar64 : public QAbstractSlider64
+{
+    Q_OBJECT
+public:
+    explicit QScrollBar64(QWidget *parent=0);
+    explicit QScrollBar64(Qt::Orientation, QWidget *parent=0);
+    ~QScrollBar64();
+
+    QSize sizeHint() const;
+    bool event(QEvent *event);
+
+protected:
+    void paintEvent(QPaintEvent *);
+    void mousePressEvent(QMouseEvent *);
+    void mouseReleaseEvent(QMouseEvent *);
+    void mouseMoveEvent(QMouseEvent *);
+    void hideEvent(QHideEvent*);
+    void sliderChange(SliderChange change);
+#ifndef QT_NO_CONTEXTMENU
+    void contextMenuEvent(QContextMenuEvent *);
+#endif
+    void initStyleOption(QStyleOptionSlider *option) const;
+
+#ifdef QT3_SUPPORT
+public:
+    QT3_SUPPORT_CONSTRUCTOR QScrollBar64(QWidget *parent, const char* name);
+    QT3_SUPPORT_CONSTRUCTOR QScrollBar64(Qt::Orientation, QWidget *parent, const char* name);
+    QT3_SUPPORT_CONSTRUCTOR QScrollBar64(qint64 minValue, qint64 maxValue, qint64 lineStep, qint64 pageStep,
+                qint64 value, Qt::Orientation, QWidget *parent=0, const char* name = 0);
+    inline QT3_SUPPORT bool draggingSlider() { return isSliderDown(); }
+#endif
+
+private:
+    friend Q_GUI_EXPORT QStyleOptionSlider qt_qscrollbarStyleOption(QScrollBar64 *scrollBar);
+
+    Q_DISABLE_COPY(QScrollBar64)
+    Q_DECLARE_PRIVATE(QScrollBar64)
+};
+
+#endif // QT_NO_SCROLLBAR
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QSCROLLBAR64_H
diff -N -u qt4-x11-4.8.2+dfsg-org/src/gui/widgets/widgets.pri qt4-x11-4.8.2+dfsg/src/gui/widgets/widgets.pri
--- qt4-x11-4.8.2+dfsg-org/src/gui/widgets/widgets.pri	2012-04-26 21:46:11.000000000 +0200
+++ qt4-x11-4.8.2+dfsg/src/gui/widgets/widgets.pri	2013-01-16 11:19:14.478544097 +0100
@@ -6,6 +6,8 @@
         widgets/qabstractbutton_p.h \
         widgets/qabstractslider.h \
         widgets/qabstractslider_p.h \
+        widgets/qabstractslider64.h \
+        widgets/qabstractslider64_p.h \
         widgets/qabstractspinbox.h \
         widgets/qabstractspinbox_p.h \
         widgets/qcalendartextnavigator_p.h \
@@ -48,6 +50,7 @@
         widgets/qradiobutton.h \
         widgets/qrubberband.h \
         widgets/qscrollbar.h \
+        widgets/qscrollbar64.h \
         widgets/qscrollarea_p.h \
         widgets/qsizegrip.h \
         widgets/qslider.h \
@@ -85,6 +88,7 @@
 SOURCES += \
         widgets/qabstractbutton.cpp \
         widgets/qabstractslider.cpp \
+        widgets/qabstractslider64.cpp \
         widgets/qabstractspinbox.cpp \
         widgets/qcalendarwidget.cpp \
         widgets/qcheckbox.cpp \
@@ -116,6 +120,7 @@
         widgets/qradiobutton.cpp \
         widgets/qrubberband.cpp \
         widgets/qscrollbar.cpp \
+        widgets/qscrollbar64.cpp \
         widgets/qsizegrip.cpp \
         widgets/qslider.cpp \
         widgets/qspinbox.cpp \
Common subdirectories: qt4-x11-4.8.2+dfsg-org/src/gui/styles/images and qt4-x11-4.8.2+dfsg/src/gui/styles/images
diff -u qt4-x11-4.8.2+dfsg-org/src/gui/styles/qcleanlooksstyle.cpp qt4-x11-4.8.2+dfsg/src/gui/styles/qcleanlooksstyle.cpp
--- qt4-x11-4.8.2+dfsg-org/src/gui/styles/qcleanlooksstyle.cpp	2012-04-26 21:46:09.000000000 +0200
+++ qt4-x11-4.8.2+dfsg/src/gui/styles/qcleanlooksstyle.cpp	2013-01-17 10:49:36.332495003 +0100
@@ -3617,7 +3617,7 @@
                 painter->setPen(darkOutline);
                 int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
                 int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
-                int interval = slider->tickInterval;
+                qint64 interval = slider->tickInterval;
                 if (interval <= 0) {
                     interval = slider->singleStep;
                     if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
@@ -3629,13 +3629,13 @@
                 if (interval <= 0)
                     interval = 1;
 
-                int v = slider->minimum;
+                qint64 v = slider->minimum;
                 int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
                 while (v <= slider->maximum + 1) {
                     if (v == slider->maximum + 1 && interval == 1)
                         break;
-                    const int v_ = qMin(v, slider->maximum);
-                    int pos = sliderPositionFromValue(slider->minimum, slider->maximum,
+                    const qint64 v_ = qMin(v, slider->maximum);
+                    qint64 pos = sliderPositionFromValue(slider->minimum, slider->maximum,
                                                     v_, (horizontal
                                                         ? slider->rect.width()
                                                         : slider->rect.height()) - len,
@@ -3662,7 +3662,7 @@
                         }
                     }
                     // in the case where maximum is max int
-                    int nextInterval = v + interval;
+                    qint64 nextInterval = v + interval;
                     if (nextInterval < v)
                         break;
                     v = nextInterval;
diff -u qt4-x11-4.8.2+dfsg-org/src/gui/styles/qcommonstyle.cpp qt4-x11-4.8.2+dfsg/src/gui/styles/qcommonstyle.cpp
--- qt4-x11-4.8.2+dfsg-org/src/gui/styles/qcommonstyle.cpp	2012-04-26 21:46:09.000000000 +0200
+++ qt4-x11-4.8.2+dfsg/src/gui/styles/qcommonstyle.cpp	2013-01-17 10:44:07.572175546 +0100
@@ -3108,7 +3108,7 @@
                 int thickness = proxy()->pixelMetric(PM_SliderControlThickness, slider, widget);
                 int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
                 int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
-                int interval = slider->tickInterval;
+                qint64 interval = slider->tickInterval;
                 if (interval <= 0) {
                     interval = slider->singleStep;
                     if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
@@ -3120,16 +3120,16 @@
                 if (!interval)
                     interval = 1;
                 int fudge = len / 2;
-                int pos;
+                qint64 pos;
                 // Since there is no subrect for tickmarks do a translation here.
                 p->save();
                 p->translate(slider->rect.x(), slider->rect.y());
                 p->setPen(slider->palette.foreground().color());
-                int v = slider->minimum;
+                qint64 v = slider->minimum;
                 while (v <= slider->maximum + 1) {
                     if (v == slider->maximum + 1 && interval == 1)
                         break;
-                    const int v_ = qMin(v, slider->maximum);
+                    const qint64 v_ = qMin(v, slider->maximum);
                     pos = QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
                                                           v_, available) + fudge;
                     if (slider->orientation == Qt::Horizontal) {
@@ -3146,7 +3146,7 @@
                                         slider->rect.width()-1, pos);
                     }
                     // in the case where maximum is max int
-                    int nextInterval = v + interval;
+                    qint64 nextInterval = v + interval;
                     if (nextInterval < v)
                         break;
                     v = nextInterval;
@@ -3977,14 +3977,14 @@
             int sbextent = proxy()->pixelMetric(PM_ScrollBarExtent, scrollbar, widget);
             int maxlen = ((scrollbar->orientation == Qt::Horizontal) ?
                           scrollBarRect.width() : scrollBarRect.height()) - (sbextent * 2);
-            int sliderlen;
+            qint64 sliderlen;
 
             // calculate slider length
             if (scrollbar->maximum != scrollbar->minimum) {
-                uint range = scrollbar->maximum - scrollbar->minimum;
+                quint64 range = scrollbar->maximum - scrollbar->minimum;
                 sliderlen = (qint64(scrollbar->pageStep) * maxlen) / (range + scrollbar->pageStep);
 
-                int slidermin = proxy()->pixelMetric(PM_ScrollBarSliderMin, scrollbar, widget);
+                qint64 slidermin = proxy()->pixelMetric(PM_ScrollBarSliderMin, scrollbar, widget);
                 if (sliderlen < slidermin || range > INT_MAX / 2)
                     sliderlen = slidermin;
                 if (sliderlen > maxlen)
@@ -3993,7 +3993,7 @@
                 sliderlen = maxlen;
             }
 
-            int sliderstart = sbextent + sliderPositionFromValue(scrollbar->minimum,
+            qint64 sliderstart = sbextent + sliderPositionFromValue(scrollbar->minimum,
                                                                  scrollbar->maximum,
                                                                  scrollbar->sliderPosition,
                                                                  maxlen - sliderlen,
diff -u qt4-x11-4.8.2+dfsg-org/src/gui/styles/qgtkstyle.cpp qt4-x11-4.8.2+dfsg/src/gui/styles/qgtkstyle.cpp
--- qt4-x11-4.8.2+dfsg-org/src/gui/styles/qgtkstyle.cpp	2012-04-26 21:46:09.000000000 +0200
+++ qt4-x11-4.8.2+dfsg/src/gui/styles/qgtkstyle.cpp	2013-01-17 10:48:49.311876108 +0100
@@ -1696,8 +1696,8 @@
 
             // Some styles check the position of scrollbars in order to determine
             // if lines should be painted when the scrollbar is in max or min positions.
-            int maximum = 2;
-            int fakePos = 0;
+            qint64 maximum = 2;
+            qint64 fakePos = 0;
             bool reverse = (option->direction == Qt::RightToLeft);
             if (scrollBar->minimum == scrollBar->maximum)
                 maximum = 0;
@@ -2063,7 +2063,7 @@
                 painter->setPen(darkOutline);
                 int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
                 int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
-                int interval = slider->tickInterval;
+                qint64 interval = slider->tickInterval;
 
                 if (interval <= 0) {
                     interval = slider->singleStep;
@@ -2078,13 +2078,13 @@
                 if (interval <= 0)
                     interval = 1;
 
-                int v = slider->minimum;
+                qint64 v = slider->minimum;
                 int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
                 while (v <= slider->maximum + 1) {
                     if (v == slider->maximum + 1 && interval == 1)
                         break;
-                    const int v_ = qMin(v, slider->maximum);
-                    int pos = sliderPositionFromValue(slider->minimum, slider->maximum,
+                    const qint64 v_ = qMin(v, slider->maximum);
+                    qint64 pos = sliderPositionFromValue(slider->minimum, slider->maximum,
                                                       v_, (horizontal
                                                            ? slider->rect.width()
                                                            : slider->rect.height()) - len,
@@ -2108,7 +2108,7 @@
                     }
 
                     // In the case where maximum is max int
-                    int nextInterval = v + interval;
+                    qint64 nextInterval = v + interval;
                     if (nextInterval < v)
                         break;
                     v = nextInterval;
diff -u qt4-x11-4.8.2+dfsg-org/src/gui/styles/qplastiquestyle.cpp qt4-x11-4.8.2+dfsg/src/gui/styles/qplastiquestyle.cpp
--- qt4-x11-4.8.2+dfsg-org/src/gui/styles/qplastiquestyle.cpp	2012-04-26 21:46:09.000000000 +0200
+++ qt4-x11-4.8.2+dfsg/src/gui/styles/qplastiquestyle.cpp	2013-01-17 10:45:05.656937362 +0100
@@ -3956,7 +3956,7 @@
                 painter->setPen(borderColor);
                 int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
                 int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
-                int interval = slider->tickInterval;
+                qint64 interval = slider->tickInterval;
                 if (interval <= 0) {
                     interval = slider->singleStep;
                     if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
@@ -3968,14 +3968,14 @@
                 if (interval <= 0)
                     interval = 1;
 
-                int v = slider->minimum;
+                qint64 v = slider->minimum;
                 int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
                 QVarLengthArray<QLine, 32> lines;
                 while (v <= slider->maximum + 1) {
                     if (v == slider->maximum + 1 && interval == 1)
                         break;
-                    const int v_ = qMin(v, slider->maximum);
-                    int pos = sliderPositionFromValue(slider->minimum, slider->maximum,
+                    const qint64 v_ = qMin(v, slider->maximum);
+                    qint64 pos = sliderPositionFromValue(slider->minimum, slider->maximum,
                                                       v_, (horizontal
                                                           ? slider->rect.width()
                                                           : slider->rect.height()) - len,
@@ -4004,7 +4004,7 @@
                     }
 
                     // in the case where maximum is max int
-                    int nextInterval = v + interval;
+                    qint64 nextInterval = v + interval;
                     if (nextInterval < v)
                         break;
                     v = nextInterval;
diff -u qt4-x11-4.8.2+dfsg-org/src/gui/styles/qstyle.cpp qt4-x11-4.8.2+dfsg/src/gui/styles/qstyle.cpp
--- qt4-x11-4.8.2+dfsg-org/src/gui/styles/qstyle.cpp	2012-04-26 21:46:09.000000000 +0200
+++ qt4-x11-4.8.2+dfsg/src/gui/styles/qstyle.cpp	2013-01-16 16:29:15.132371290 +0100
@@ -2121,24 +2121,24 @@
     \sa sliderValueFromPosition()
 */
 
-int QStyle::sliderPositionFromValue(int min, int max, int logicalValue, int span, bool upsideDown)
+int QStyle::sliderPositionFromValue(qint64 min, qint64 max, qint64 logicalValue, qint64 span, bool upsideDown)
 {
     if (span <= 0 || logicalValue < min || max <= min)
         return 0;
     if (logicalValue > max)
         return upsideDown ? span : min;
 
-    uint range = max - min;
-    uint p = upsideDown ? max - logicalValue : logicalValue - min;
+    quint64 range = max - min;
+    quint64 p = upsideDown ? max - logicalValue : logicalValue - min;
 
     if (range > (uint)INT_MAX/4096) {
         double dpos = (double(p))/(double(range)/span);
-        return int(dpos);
+        return qint64(dpos);
     } else if (range > (uint)span) {
         return (2 * p * span + range) / (2*range);
     } else {
-        uint div = span / range;
-        uint mod = span % range;
+        quint64 div = span / range;
+        quint64 mod = span % range;
         return p * div + (2 * p * mod + range) / (2 * range);
     }
     // equiv. to (p * span) / range + 0.5
@@ -2164,22 +2164,22 @@
     \sa sliderPositionFromValue()
 */
 
-int QStyle::sliderValueFromPosition(int min, int max, int pos, int span, bool upsideDown)
+qint64 QStyle::sliderValueFromPosition(qint64 min, qint64 max, int pos, qint64 span, bool upsideDown)
 {
     if (span <= 0 || pos <= 0)
         return upsideDown ? max : min;
     if (pos >= span)
         return upsideDown ? min : max;
 
-    uint range = max - min;
+    quint64 range = max - min;
 
     if ((uint)span > range) {
-        int tmp = (2 * pos * range + span) / (2 * span);
+        qint64 tmp = (2 * pos * range + span) / (2 * span);
         return upsideDown ? max - tmp : tmp + min;
     } else {
-        uint div = range / span;
-        uint mod = range % span;
-        int tmp = pos * div + (2 * pos * mod + span) / (2 * span);
+        quint64 div = range / span;
+        quint64 mod = range % span;
+        qint64 tmp = pos * div + (2 * pos * mod + span) / (2 * span);
         return upsideDown ? max - tmp : tmp + min;
     }
     // equiv. to min + (pos*range)/span + 0.5
diff -u qt4-x11-4.8.2+dfsg-org/src/gui/styles/qstyle.h qt4-x11-4.8.2+dfsg/src/gui/styles/qstyle.h
--- qt4-x11-4.8.2+dfsg-org/src/gui/styles/qstyle.h	2012-04-26 21:46:09.000000000 +0200
+++ qt4-x11-4.8.2+dfsg/src/gui/styles/qstyle.h	2013-01-16 16:28:09.323755995 +0100
@@ -839,9 +839,9 @@
                             const QRect &logicalRect);
     static QPoint visualPos(Qt::LayoutDirection direction, const QRect &boundingRect,
                             const QPoint &logicalPos);
-    static int sliderPositionFromValue(int min, int max, int val, int space,
+    static int sliderPositionFromValue(qint64 min, qint64 max, qint64 val, qint64 space,
                                        bool upsideDown = false);
-    static int sliderValueFromPosition(int min, int max, int pos, int space,
+    static qint64 sliderValueFromPosition(qint64 min, qint64 max, int pos, qint64 space,
                                        bool upsideDown = false);
     static Qt::Alignment visualAlignment(Qt::LayoutDirection direction, Qt::Alignment alignment);
     static QRect alignedRect(Qt::LayoutDirection direction, Qt::Alignment alignment,
diff -u qt4-x11-4.8.2+dfsg-org/src/gui/styles/qstyleoption.h qt4-x11-4.8.2+dfsg/src/gui/styles/qstyleoption.h
--- qt4-x11-4.8.2+dfsg-org/src/gui/styles/qstyleoption.h	2012-04-26 21:46:09.000000000 +0200
+++ qt4-x11-4.8.2+dfsg/src/gui/styles/qstyleoption.h	2013-01-17 10:42:46.639115059 +0100
@@ -705,15 +705,15 @@
     enum StyleOptionVersion { Version = 1 };
 
     Qt::Orientation orientation;
-    int minimum;
-    int maximum;
+    qint64 minimum;
+    qint64 maximum;
     QSlider::TickPosition tickPosition;
     int tickInterval;
     bool upsideDown;
-    int sliderPosition;
-    int sliderValue;
-    int singleStep;
-    int pageStep;
+    qint64 sliderPosition;
+    qint64 sliderValue;
+    qint64 singleStep;
+    qint64 pageStep;
     qreal notchTarget;
     bool dialWrapping;
 
Only in qt4-x11-4.8.2+dfsg/src/gui/styles/: tags
