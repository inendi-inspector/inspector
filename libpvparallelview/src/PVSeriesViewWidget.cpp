/**
 * @file
 *
 * @copyright (C) ESI Group INENDI 2018
 */

#include <pvparallelview/PVSeriesViewWidget.h>

#include <pvparallelview/PVSeriesView.h>
#include <pvparallelview/PVSeriesViewParamsWidget.h>
#include <pvparallelview/PVSeriesViewZoomer.h>
#include <pvparallelview/PVDisplayViewScatter.h>
#include <pvkernel/widgets/PVRangeEdit.h>
#include <pvkernel/rush/PVNraw.h>
#include <pvkernel/core/qobject_helpers.h>
#include <inendi/PVSource.h>
#include <pvdisplays/PVDisplayIf.h>

#include <QStateMachine>
#include <QKeyEvent>
#include <QPainter>
#include <QScrollBar>
#include <QMenu>

#include <KF5/KItemModels/klinkitemselectionmodel.h>

#include <memory>

constexpr const size_t TREE_WIDGET_WIDTH = 200;

PVParallelView::PVSeriesViewWidget::PVSeriesViewWidget(Inendi::PVView* view,
                                                       PVCol axis,
                                                       QWidget* parent /*= nullptr*/)
    : QWidget(parent), _view(view), _help_widget(this)
{
	// Define help
	setFocusPolicy(Qt::StrongFocus);
	_help_widget.hide();

	_help_widget.initTextFromFile("series view's help", ":help-style");
	_help_widget.addTextFromFile(":help-series-view-navigation");
	_help_widget.newColumn();
	_help_widget.addTextFromFile(":help-series-view-selection");
	_help_widget.newColumn();
	_help_widget.addTextFromFile(":help-series-view-hunting");
	_help_widget.newTable();
	_help_widget.addTextFromFile(":help-series-view-rendering");
	_help_widget.newColumn();
	_help_widget.addTextFromFile(":help-series-view-sampling");
	_help_widget.newTable();
	_help_widget.addTextFromFile(":help-selection");
	_help_widget.newColumn();
	_help_widget.addTextFromFile(":help-application");

	_help_widget.finalizeText();

	set_abscissa(axis);

	// Subscribe to plotting changes
	_plotting_change_connection = _view->get_parent<Inendi::PVPlotted>()._plotted_updated.connect(
	    [this](const QList<PVCol>& plotteds_updated) {
		    if (_sampler) {
			    std::unordered_set<size_t> updated_timeseries(plotteds_updated.begin(),
			                                                  plotteds_updated.end());
			    _sampler->resubsample(updated_timeseries);
		    }
	    });
	// Subscribe to selection changes
	_selection_change_connection = _view->_update_output_selection.connect([this]() {
		if (_sampler) {
			_sampler->resubsample();
		}
	});
}

void PVParallelView::PVSeriesViewWidget::minmax_changed(const pvcop::db::array& minmax)
{
	PVViewZoomer::Zoom zoom = _zoomer->current_zoom();
	std::tie(zoom.minX, zoom.maxX) = _sampler->minmax_to_ratio(minmax);
	// Fix negative value generated by QDateTime resolution fixed to the millisecond
	zoom.minX = std::max(zoom.minX, (PVViewZoomer::zoom_f)0.);
	_zoomer->reset_and_zoom_in(zoom);
};

void PVParallelView::PVSeriesViewWidget::set_abscissa(PVCol abscissa)
{
	std::vector<QWidget*> replaceable_widgets;

	if (abscissa != PVCol()) {
		PVRush::PVNraw const& nraw = _view->get_rushnraw_parent();

		const pvcop::db::array& time = nraw.column(abscissa);

		{
			auto plotteds = _view->get_parent<Inendi::PVSource>().get_children<Inendi::PVPlotted>();
			const auto& plotteds_vector = plotteds.front()->get_plotteds();

			std::vector<pvcop::core::array<uint32_t>> timeseries;
			for (PVCol col(0); col < nraw.column_count(); col++) {
				timeseries.emplace_back(plotteds_vector[col].to_core_array<uint32_t>());
			}

			_sampler.reset(new Inendi::PVRangeSubSampler(
			    time, std::move(timeseries), nraw, _view->get_real_output_selection(),
			    _split_axis == PVCol() ? nullptr : &nraw.column(_split_axis)));
		}
		_plot = new PVSeriesView(*_sampler, PVSeriesView::Backend::Default);
		_plot->set_background_color(QColor(10, 10, 10, 255));

		setup_series_tree(abscissa);
		setup_selected_series_tree(abscissa);

		_zoomer = new PVSeriesViewZoomer(_plot, *_sampler);

		_range_edit = PVWidgets::PVRangeEditFactory::create(
		    _sampler->minmax_time(),
		    std::bind(&PVSeriesViewWidget::minmax_changed, this, std::placeholders::_1));

		QObject::connect(
		    _zoomer, &PVSeriesViewZoomer::zoom_updated, [this](PVViewZoomer::Zoom zoom) {
			    _range_edit->set_minmax(_sampler->ratio_to_minmax(zoom.minX, zoom.maxX));
		    });

		QObject::connect(
		    _zoomer, &PVSeriesViewZoomer::selection_commit,
		    [&time, &nraw, this](PVViewZoomer::Zoom zoom) {
			    const pvcop::db::array& minmax = _sampler->ratio_to_minmax(zoom.minX, zoom.maxX);
			    _range_edit->set_minmax(minmax);
			    const auto& sorted_indexes = _sampler->sorted_indexes();
			    pvcop::db::range_t selected_range = time.equal_range(minmax, sorted_indexes);
			    const auto& sort = sorted_indexes ? sorted_indexes.to_core_array()
			                                      : pvcop::core::array<pvcop::db::index_t>();
			    Inendi::PVSelection sel(nraw.row_count());
			    sel.select_none(); // Not sur if needed
			    for (size_t i = selected_range.begin; i < selected_range.end; i++) {
				    sel.set_bit_fast(sort ? sort[i] : i);
			    }
			    _view->set_selection_view(sel);
		    });

		replaceable_widgets = {_zoomer, _range_edit};
	} else {
		replaceable_widgets = {new QWidget, new QWidget};
	}

	if (_layout_replacer && layout()) {
		_layout_replacer(replaceable_widgets);
	} else {
		_params_widget = new PVSeriesViewParamsWidget(abscissa, this);

		QVBoxLayout* layout = new QVBoxLayout;
		layout->setContentsMargins(0, 0, 0, 0);

		QHBoxLayout* hlayout = new QHBoxLayout;
		hlayout->setContentsMargins(0, 0, 0, 0);

		hlayout->addWidget(replaceable_widgets[0]);
		auto* vlayout = new QVBoxLayout;
		vlayout->addWidget(_series_tree_widget);
		vlayout->addWidget(_selected_series_tree);
		hlayout->addLayout(vlayout);

		QHBoxLayout* bottom_layout = new QHBoxLayout;
		bottom_layout->addWidget(replaceable_widgets[1]);
		bottom_layout->addStretch();
		bottom_layout->addWidget(_params_widget);

		layout->addLayout(hlayout);
		layout->addLayout(bottom_layout);

		setLayout(layout);
	}

	_layout_replacer = [this, replaceable_widgets](std::vector<QWidget*> const& new_widgets) {
		QLayout* global_layout = layout();
		for (size_t i = 0; i < replaceable_widgets.size(); ++i) {
			delete global_layout->replaceWidget(replaceable_widgets[i], new_widgets[i]);
			replaceable_widgets[i]->deleteLater();
		}
	};
}

void PVParallelView::PVSeriesViewWidget::set_split(PVCol split)
{
	if (split == _split_axis) {
		return;
	}

	PVRush::PVNraw const& nraw = _view->get_rushnraw_parent();
	_sampler->set_split_column(split == PVCol() ? nullptr : &nraw.column(split));
	_split_axis = split;

	// Update range widget
	PVWidgets::PVRangeEdit* range_edit = PVWidgets::PVRangeEditFactory::create(
	    _sampler->minmax_time(),
	    std::bind(&PVSeriesViewWidget::minmax_changed, this, std::placeholders::_1));
	QLayout* global_layout = layout();
	delete global_layout->replaceWidget(_range_edit, range_edit);
	_range_edit->deleteLater();
	_range_edit = range_edit;
}

void PVParallelView::PVSeriesViewWidget::setup_series_tree(PVCol abscissa)
{
	delete _tree_model;
	_tree_model = new PVSeriesTreeModel(_view, *_sampler);
	_selection_model = new QItemSelectionModel(_tree_model);
	if (not _series_tree_widget) {
		delete _series_tree_widget;
		_series_tree_widget = new PVSeriesTreeView();
	}
	QItemSelectionModel* old_selection_model = _series_tree_widget->selectionModel();
	_series_tree_widget->setModel(_tree_model);
	_series_tree_widget->setSelectionModel(_selection_model);
	delete old_selection_model;
	_series_tree_widget->disconnect(); // disconnect local signals

	_series_tree_widget->setHeaderHidden(true);
	_series_tree_widget->setFixedWidth(TREE_WIDGET_WIDTH);

	connect(_series_tree_widget, &PVSeriesTreeView::selection_changed, this,
	        &PVSeriesViewWidget::update_selected_series);

	// connect hunting rectangle
	connect(_zoomer, &PVSeriesViewZoomer::hunt_commit, [this](QRect region, bool addition) {
		const QModelIndexList& selected_indexes = _series_tree_widget->selectedIndexes();
		QItemSelection deselect_list;
		for (const QModelIndex& index : selected_indexes) {
			const PVCol index_id = index.data(Qt::UserRole).value<PVCol>();
			if (is_splitted() and not index.parent().isValid()) {
				continue; // Prevent unselecting whole axes in splitted mode
			}
			if (is_in_region(region, index_id) == not addition) {
				deselect_list.merge(QItemSelection(index, index), QItemSelectionModel::Select);
			}
		}
		// Deselect those not in region unless there would be none left
		if (deselect_list.size() < selected_indexes.size()) {
			_series_tree_widget->selectionModel()->select(deselect_list,
			                                              QItemSelectionModel::Deselect);
		}
	});

	// connect context menu
	_series_tree_widget->setContextMenuPolicy(Qt::CustomContextMenu);
	connect(
	    _series_tree_widget, &QWidget::customContextMenuRequested, this,
	    [this, abscissa](QPoint const& pos) {
		    const QModelIndex& index = _series_tree_widget->indexAt(pos);
		    if (index.parent().isValid()) {
			    return; // not a top level item (aka axis)
		    }
		    PVCol col = index.data(Qt::UserRole).value<PVCol>();
		    QMenu item_menu;
		    auto scatter_action = new QAction(
		        PVDisplays::display_view_if<PVDisplays::PVDisplayViewScatter>().toolbar_icon(),
		        "Scatter view with abscissa", &item_menu);
		    connect(scatter_action, &QAction::triggered, [this, abscissa, col] {
			    if (auto container =
			            PVCore::get_qobject_parent_of_type<PVDisplays::PVDisplaysContainer*>(
			                this)) {
				    container->create_view_widget(
				        PVDisplays::display_view_if<PVDisplays::PVDisplayViewScatter>(), _view,
				        {abscissa, col});
			    }
		    });
		    item_menu.addAction(scatter_action);
		    item_menu.addSeparator();
		    if (auto container =
		            PVCore::get_qobject_parent_of_type<PVDisplays::PVDisplaysContainer*>(this)) {
			    PVDisplays::add_displays_view_axis_menu(item_menu, container, _view, col);
		    }
		    item_menu.exec(_series_tree_widget->mapToGlobal(pos));
	    });

	// Setup initial selection
	const Inendi::PVAxesCombination& axes_comb = _view->get_axes_combination();
	const std::vector<PVCol>& combination = axes_comb.get_combination();
	QAbstractItemModel& model = *_series_tree_widget->model();
	QItemSelection top_selection;
	for (PVCol i(0); i < model.rowCount(); i++) {
		const QModelIndex& index = model.index(i, 0);
		PVCol j = index.data(Qt::UserRole).value<PVCol>();
		if (std::find(combination.begin(), combination.end(), j) != combination.end()) {
			top_selection.merge(QItemSelection(index, index), QItemSelectionModel::Select);
		}
	}
	_series_tree_widget->selectionModel()->select(top_selection, QItemSelectionModel::Select);

	_update_selected_series_resample = false;
	update_selected_series();
	_update_selected_series_resample = true;
}

void PVParallelView::PVSeriesViewWidget::setup_selected_series_tree(PVCol /*abscissa*/)
{
	if (not _selected_series_tree) {
		delete _selected_series_tree;
		_selected_series_tree = new PVSeriesTreeView(true /*filtered*/);
	}
	_selected_series_tree->disconnect(); // disconnect local signals
	PVSeriesTreeFilterProxyModel* filter_proxy_model = new PVSeriesTreeFilterProxyModel();
	KLinkItemSelectionModel* selection_link_model =
	    new KLinkItemSelectionModel(filter_proxy_model, _selection_model);
	filter_proxy_model->setSourceModel(_tree_model);
	_selected_series_tree->setModel(filter_proxy_model);
	_selected_series_tree->setSelectionModel(selection_link_model); // sync selection

	_selected_series_tree->setFixedWidth(TREE_WIDGET_WIDTH);
	_selected_series_tree->setHeaderHidden(true);
	_selected_series_tree->setMaximumHeight(0);
	_selected_series_tree->setSelectionMode(QAbstractItemView::MultiSelection);

	connect(_zoomer, &PVSeriesViewZoomer::cursor_moved, [this, filter_proxy_model](QRect region) {
		QItemSelection selection;
		filter_proxy_model->clear_selection();
		QSet<int> selected_ids;
		for (const QModelIndex& index : _selection_model->selectedIndexes()) {
			const PVCol index_id = index.data(Qt::UserRole).value<PVCol>();
			if ((index.parent().isValid() or not is_splitted()) and
			    is_in_region(region, index_id)) {
				selected_ids.insert(index_id);
				QModelIndex source_index = filter_proxy_model->mapFromSource(index);
				selection.merge(QItemSelection(source_index, source_index),
				                QItemSelectionModel::Select);
				if (is_splitted()) {
					const PVCol parent_id = index.parent().data(Qt::UserRole).value<PVCol>();
					selected_ids.insert(parent_id);
					QModelIndex source_parent_index =
					    filter_proxy_model->mapFromSource(index.parent());
					selection.merge(QItemSelection(source_parent_index, source_parent_index),
					                QItemSelectionModel::Select);
				}
			}
		}
		auto count = selected_ids.count();
		if (count) {
			filter_proxy_model->set_selection(selected_ids);
			_selected_series_tree->selectionModel()->select(selection, QItemSelectionModel::Select);
			_selected_series_tree->expandAll();
		}
		auto scrollbar = _selected_series_tree->horizontalScrollBar();
		_selected_series_tree->setMaximumHeight(
		    count > 0 ? count * _selected_series_tree->sizeHintForRow(0) +
		                    2 * _selected_series_tree->frameWidth() +
		                    (scrollbar->isVisible() ? scrollbar->height() : 0)
		              : 0);
	});
}

void PVParallelView::PVSeriesViewWidget::update_selected_series()
{
	std::vector<PVSeriesView::SerieDrawInfo> series_draw_order;
	std::unordered_set<size_t> selected_timeseries;
	selected_timeseries.reserve(_sampler->timeseries_count() * _sampler->group_count());
	for (const QModelIndex& index : _series_tree_widget->selectedIndexes()) {
		PVCol index_id = index.data(Qt::UserRole).value<PVCol>();
		if ((index.parent().isValid() or not is_splitted())) {
			QColor index_color = index.data(Qt::BackgroundColorRole).value<QColor>();
			series_draw_order.push_back({index_id, index_color});
			selected_timeseries.emplace(index_id);
		}
	}
	_sampler->set_selected_timeseries(selected_timeseries);
	if (_update_selected_series_resample) {
		_sampler->resubsample();
	}
	_plot->show_series(std::move(series_draw_order));
	_plot->update();
}

bool PVParallelView::PVSeriesViewWidget::is_in_region(const QRect region, PVCol col) const
{
	const auto min_value = Inendi::PVRangeSubSampler::display_type_max_val *
	                       uint32_t(_zoomer->height() - (region.top() + region.height()));
	const auto max_value = Inendi::PVRangeSubSampler::display_type_max_val *
	                       uint32_t(_zoomer->height() - region.top());

	const auto& av_ts = _sampler->sampled_timeserie(col);
	for (int pos_x = region.left(); pos_x < region.left() + region.width(); ++pos_x) {
		const auto av_ts_value = av_ts[pos_x] * uint32_t(_zoomer->height());
		if (min_value < av_ts_value and av_ts_value < max_value) {
			return true;
		}
	}
	return false;
}

void PVParallelView::PVSeriesViewWidget::keyPressEvent(QKeyEvent* event)
{
	if (PVWidgets::PVHelpWidget::is_help_key(event->key())) {
		if (_help_widget.isHidden()) {
			_help_widget.popup(this, PVWidgets::PVTextPopupWidget::AlignTop,
			                   PVWidgets::PVTextPopupWidget::ExpandAll);
		}
		return;
	}
	if (event->key() == Qt::Key_A and event->modifiers() & Qt::ControlModifier) {
		_series_tree_widget->selectAll();
		return;
	}

	QWidget::keyPressEvent(event);
}

void PVParallelView::PVSeriesViewWidget::enterEvent(QEvent*)
{
	setFocus(Qt::MouseFocusReason);
}

void PVParallelView::PVSeriesViewWidget::leaveEvent(QEvent*)
{
	clearFocus();
}
