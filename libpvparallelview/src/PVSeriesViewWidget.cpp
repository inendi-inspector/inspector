/**
 * @file
 *
 * @copyright (C) ESI Group INENDI 2018
 */

#include <pvparallelview/PVSeriesViewWidget.h>

#include <pvparallelview/PVSeriesView.h>
#include <pvparallelview/PVSeriesViewParamsWidget.h>
#include <pvparallelview/PVSeriesViewZoomer.h>
#include <pvkernel/widgets/PVRangeEdit.h>
#include <pvkernel/rush/PVNraw.h>
#include <inendi/PVSource.h>
#include <inendi/PVRangeSubSampler.h>

#include <QStateMachine>
#include <QKeyEvent>
#include <QStyledItemDelegate>
#include <QPainter>
#include <QScrollBar>

#include <memory>

PVParallelView::PVSeriesViewWidget::PVSeriesViewWidget(Inendi::PVView* view,
                                                       PVCombCol axis_comb,
                                                       QWidget* parent /*= nullptr*/)
    : QWidget(parent), _help_widget(this)
{

	_params_widget = new PVSeriesViewParamsWidget(this);

	auto plotteds = view->get_parent<Inendi::PVSource>().get_children<Inendi::PVPlotted>();
	const Inendi::PVAxesCombination& axes_comb = view->get_axes_combination();
	PVCol col = axes_comb.get_nraw_axis(axis_comb);
	PVRush::PVNraw const& nraw = view->get_rushnraw_parent();
	const auto& plotteds_vector = plotteds.front()->get_plotteds();

	const pvcop::db::array& time = nraw.column(col);

	std::vector<pvcop::core::array<uint32_t>> timeseries;
	for (PVCol col(0); col < nraw.column_count(); col++) {
		timeseries.emplace_back(plotteds_vector[col].to_core_array<uint32_t>());
	}

	_sampler.reset(
	    new Inendi::PVRangeSubSampler(time, timeseries, nraw, view->get_real_output_selection()));

	_plot = new PVSeriesView(*_sampler, PVSeriesView::Backend::Default);
	_plot->setBackgroundColor(QColor(10, 10, 10, 255));

	struct StyleDelegate : public QStyledItemDelegate {
		StyleDelegate(QWidget* parent = nullptr) : QStyledItemDelegate(parent) {}
		void paint(QPainter* painter,
		           const QStyleOptionViewItem& option,
		           const QModelIndex& index) const override
		{
			auto color = index.model()->data(index, Qt::UserRole).value<SerieListItemData>().color;
			if ((option.state & QStyle::State_Selected)) {
				painter->fillRect(option.rect, color);
				painter->setPen(Qt::black);
				painter->drawText(option.rect,
				                  index.model()->data(index, Qt::DisplayRole).toString());
			} else {
				// painter->fillRect(option.rect, color);
				painter->setPen(color);
				painter->drawText(option.rect,
				                  index.model()->data(index, Qt::DisplayRole).toString());
			}
		}
	};

	_series_list_widget = new QListWidget;
	_series_list_widget->setFixedWidth(200);
	_series_list_widget->setItemDelegate(new StyleDelegate());
	for (PVCol col(0); col < nraw.column_count(); col++) {
		const PVRush::PVAxisFormat& axis = axes_comb.get_axis(col);
		if (axis.get_type().startsWith("number_") or axis.get_type().startsWith("duration")) {
			QListWidgetItem* item = new QListWidgetItem(axis.get_name());
			QColor color(rand() % 156 + 100, rand() % 156 + 100, rand() % 156 + 100);
			item->setData(Qt::UserRole, QVariant::fromValue(SerieListItemData{col, color}));
			item->setBackgroundColor(color);
			_series_list_widget->addItem(item);
		}
	}
	_series_list_widget->setSelectionMode(QAbstractItemView::MultiSelection);
	// _series_list_widget->setAlternatingRowColors(true);

	// for (PVCol i(0); i < _series_list_widget->count(); i++) {
	// 	QColor color(rand() % 156 + 100, rand() % 156 + 100, rand() % 156 + 100);
	// 	_series_list_widget->item(i)->setForeground(color); // FIXME
	// }

	const std::vector<PVCol>& combination = axes_comb.get_combination();
	for (PVCol i(0); i < _series_list_widget->count(); i++) {
		auto item = _series_list_widget->item(i);
		PVCol j = item->data(Qt::UserRole).value<SerieListItemData>().col;
		if (std::find(combination.begin(), combination.end(), j) != combination.end()) {
			item->setSelected(true);
		}
	}

	QObject::connect(_series_list_widget, &QListWidget::itemSelectionChanged, this,
	                 &PVSeriesViewWidget::update_selected_series);
	_update_selected_series_resample = false;
	update_selected_series();
	_update_selected_series_resample = true;

	_zoomer = new PVSeriesViewZoomer(_plot, *_sampler);

	auto minmax_changed_f = [this](const pvcop::db::array& minmax) {
		PVViewZoomer::Zoom zoom = _zoomer->currentZoom();
		std::tie(zoom.minX, zoom.maxX) = _sampler->minmax_to_ratio(minmax);
		// Fix negative value generated by QDateTime resolution fixed to the millisecond
		zoom.minX = std::max(zoom.minX, (PVViewZoomer::zoom_f)0.);
		_zoomer->resetAndZoomIn(zoom);
	};

	PVWidgets::PVRangeEdit* range_edit =
	    PVWidgets::PVRangeEditFactory::create(_sampler->minmax_time(), minmax_changed_f);

	QObject::connect(_zoomer, &PVSeriesViewZoomer::zoomUpdated,
	                 [range_edit, this](PVViewZoomer::Zoom zoom) {
		                 range_edit->set_minmax(_sampler->ratio_to_minmax(zoom.minX, zoom.maxX));
		             });

	QObject::connect(
	    _zoomer, &PVSeriesViewZoomer::selectionCommit,
	    [range_edit, &time, &nraw, view, this](PVViewZoomer::Zoom zoom) {
		    const pvcop::db::array& minmax = _sampler->ratio_to_minmax(zoom.minX, zoom.maxX);
		    range_edit->set_minmax(minmax);
		    const auto& sorted_indexes = _sampler->sorted_indexes();
		    pvcop::db::range_t selected_range = time.equal_range(minmax, sorted_indexes);
		    const auto& sort = sorted_indexes ? sorted_indexes.to_core_array()
		                                      : pvcop::core::array<pvcop::db::index_t>();
		    Inendi::PVSelection sel(nraw.row_count());
		    sel.select_none(); // Not sur if needed
		    for (size_t i = selected_range.begin; i < selected_range.end; i++) {
			    sel.set_bit_fast(sort ? sort[i] : i);
		    }
		    view->set_selection_view(sel);
		});

	// Subscribe to plotting changes
	_plotting_change_connection = view->get_parent<Inendi::PVPlotted>()._plotted_updated.connect(
	    [this](const QList<PVCol>& plotteds_updated) {
		    std::unordered_set<size_t> updated_timeseries(plotteds_updated.begin(),
		                                                  plotteds_updated.end());
		    _sampler->resubsample(updated_timeseries);
		});

	// Subscribe to selection changes
	_selection_change_connection =
	    view->_update_output_selection.connect([this]() { _sampler->resubsample(); });

	QListWidget* selected_series_list = new QListWidget;
	selected_series_list->setFixedWidth(_series_list_widget->width());
	selected_series_list->setMaximumHeight(0);
	selected_series_list->setItemDelegate(new StyleDelegate());
	selected_series_list->setSelectionMode(QAbstractItemView::MultiSelection);

	QObject::connect(
	    _zoomer, &PVSeriesViewZoomer::cursorMoved, [selected_series_list, this](QRect region) {
		    selected_series_list->clear();
		    for (const QListWidgetItem* item : _series_list_widget->selectedItems()) {
			    const PVCol item_col = item->data(Qt::UserRole).value<SerieListItemData>().col;
			    if (is_in_region(region, item_col)) {
				    QListWidgetItem* selected_item = new QListWidgetItem(item->text());
				    selected_item->setData(Qt::UserRole, item->data(Qt::UserRole));
				    selected_item->setBackground(
				        item->data(Qt::UserRole).value<SerieListItemData>().color);
				    selected_series_list->addItem(selected_item);
				    selected_item->setSelected(true);
			    }
		    }
		    auto count = selected_series_list->count();
		    auto scrollbar = selected_series_list->horizontalScrollBar();
		    selected_series_list->setMaximumHeight(
		        count > 0
		            ? count * selected_series_list->sizeHintForRow(0) +
		                  2 * selected_series_list->frameWidth() +
		                  (scrollbar->isVisible() ? scrollbar->height() : 0)
		            : 0);
		});

	QObject::connect(_zoomer, &PVSeriesViewZoomer::huntCommit, [this](QRect region, bool addition) {
		auto selected_items_list = _series_list_widget->selectedItems();
		decltype(selected_items_list) deselect_list;
		std::copy_if(
		    selected_items_list.begin(), selected_items_list.end(),
		    std::back_inserter(deselect_list), [region, addition, this](QListWidgetItem* item) {
			    const PVCol item_col = item->data(Qt::UserRole).value<SerieListItemData>().col;
			    return is_in_region(region, item_col) == not addition;
			});
		// Deselect those not in region unless there would be none left
		if (deselect_list.size() < selected_items_list.size()) {
			_update_selected_series_resample = false;
			for (auto* item : deselect_list) {
				item->setSelected(false);
			}
			_update_selected_series_resample = true;
			update_selected_series();
		}
	});

	auto synchro_list = [](auto list_src, auto list_dest) {
		auto src_seleted_items = list_src->selectedItems();
		for (int i = 0; i < list_dest->count(); ++i) {
			QListWidgetItem* item = list_dest->item(i);
			const PVCol item_col = item->data(Qt::UserRole).value<SerieListItemData>().col;
			auto src_selected_it = std::find_if(
			    src_seleted_items.begin(), src_seleted_items.end(),
			    [item_col](QListWidgetItem* selected_item) {
				    return item_col ==
				           selected_item->data(Qt::UserRole).value<SerieListItemData>().col;
				});
			item->setSelected(src_selected_it != src_seleted_items.end());
		}
	};

	auto semi_synchro_list = [](auto list_src, auto list_dest) {
		for (int src_index = 0; src_index < list_src->count(); ++src_index) {
			QListWidgetItem* src_item = list_src->item(src_index);
			const PVCol src_item_col = src_item->data(Qt::UserRole).value<SerieListItemData>().col;
			for (int dest_index = 0; dest_index < list_dest->count(); ++dest_index) {
				QListWidgetItem* dest_item = list_dest->item(dest_index);
				const PVCol dest_item_col =
				    dest_item->data(Qt::UserRole).value<SerieListItemData>().col;
				if (src_item_col == dest_item_col) {
					dest_item->setSelected(src_item->isSelected());
					break;
				}
			}
		}
	};

	QObject::connect(_series_list_widget, &QListWidget::itemSelectionChanged,
	                 [synchro_list, selected_series_list, this]() {
		                 synchro_list(_series_list_widget, selected_series_list);
		             });
	QObject::connect(selected_series_list, &QListWidget::itemSelectionChanged,
	                 [semi_synchro_list, selected_series_list, this]() {
		                 if (_synchro_selected_list) {
			                 semi_synchro_list(selected_series_list, _series_list_widget);
		                 }
		             });

	struct SynchroFilter : QObject {
		SynchroFilter(std::function<void()> enter, std::function<void()> leave)
		    : enter(enter), leave(leave)
		{
		}
		std::function<void()> enter;
		std::function<void()> leave;
		bool eventFilter(QObject* obj, QEvent* event) override
		{
			if (event->type() == QEvent::Enter) {
				enter();
				return true;
			} else if (event->type() == QEvent::Leave) {
				leave();
				return true;
			}
			return QObject::eventFilter(obj, event);
		}
	};

	selected_series_list->installEventFilter(new SynchroFilter{
	    [this] { _synchro_selected_list = true; }, [this] { _synchro_selected_list = false; }});

	QVBoxLayout* layout = new QVBoxLayout;
	layout->setContentsMargins(0, 0, 0, 0);

	QHBoxLayout* hlayout = new QHBoxLayout;
	hlayout->setContentsMargins(0, 0, 0, 0);

	hlayout->addWidget(_zoomer);
	auto* vlayout = new QVBoxLayout;
	vlayout->addWidget(_series_list_widget);
	vlayout->addWidget(selected_series_list);
	hlayout->addLayout(vlayout);

	QHBoxLayout* bottom_layout = new QHBoxLayout;
	bottom_layout->addWidget(range_edit);
	bottom_layout->addStretch();
	bottom_layout->addWidget(_params_widget);

	layout->addLayout(hlayout);
	layout->addLayout(bottom_layout);

	// Define help
	setFocusPolicy(Qt::StrongFocus);
	_help_widget.hide();

	_help_widget.initTextFromFile("series view's help", ":help-style");
	_help_widget.addTextFromFile(":help-mouse-series-view");
	_help_widget.newColumn();
	_help_widget.addTextFromFile(":help-selection");

	_help_widget.newTable();
	_help_widget.addTextFromFile(":help-application");
	_help_widget.newColumn();
	_help_widget.finalizeText();

	setLayout(layout);
}

void PVParallelView::PVSeriesViewWidget::keyPressEvent(QKeyEvent* event)
{
	if (PVWidgets::PVHelpWidget::is_help_key(event->key())) {
		if (_help_widget.isHidden()) {
			_help_widget.popup(this, PVWidgets::PVTextPopupWidget::AlignTop,
			                   PVWidgets::PVTextPopupWidget::ExpandAll);
		}
		return;
	}
	if (event->key() == Qt::Key_A and event->modifiers() & Qt::ControlModifier) {
		_series_list_widget->selectAll();
		return;
	}

	QWidget::keyPressEvent(event);
}

void PVParallelView::PVSeriesViewWidget::enterEvent(QEvent*)
{
	setFocus(Qt::MouseFocusReason);
}

void PVParallelView::PVSeriesViewWidget::leaveEvent(QEvent*)
{
	clearFocus();
}

void PVParallelView::PVSeriesViewWidget::update_selected_series()
{
	// FIXME : should put newly selected timeserie on top
	std::vector<PVSeriesView::SerieDrawInfo> seriesDrawOrder;
	std::unordered_set<size_t> selected_timeseries;
	selected_timeseries.reserve(_sampler->timeseries_count());
	for (const QListWidgetItem* item : _series_list_widget->selectedItems()) {
		auto item_data = item->data(Qt::UserRole).value<SerieListItemData>();
		seriesDrawOrder.push_back({size_t(item_data.col), item_data.color});
		selected_timeseries.emplace(item_data.col);
	}
	_sampler->set_selected_timeseries(selected_timeseries);
	if (_update_selected_series_resample) {
		_sampler->resubsample();
	}
	_plot->showSeries(std::move(seriesDrawOrder));
	_plot->update();
}

bool PVParallelView::PVSeriesViewWidget::is_in_region(QRect region, PVCol col) const
{
	auto& av_ts = _sampler->sampled_timeserie(col);
	for (int pos_x = region.left(); pos_x < region.left() + region.width(); ++pos_x) {
		auto av_ts_value = av_ts[pos_x] * uint32_t(_zoomer->height());
		auto min_value = Inendi::PVRangeSubSampler::display_type_max_val *
		                 (_zoomer->height() - (region.top() + region.height()));
		auto max_value =
		    Inendi::PVRangeSubSampler::display_type_max_val * (_zoomer->height() - region.top());
		if (min_value < av_ts_value and av_ts_value < max_value) {
			return true;
		}
	}
	return false;
}
