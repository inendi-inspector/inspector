/**
 * @file
 *
 * @copyright (C) ESI Group INENDI 2018
 */

#include <pvparallelview/PVSeriesViewWidget.h>

#include <pvparallelview/PVSeriesView.h>
#include <pvparallelview/PVSeriesViewParamsWidget.h>
#include <pvparallelview/PVSeriesViewZoomer.h>
#include <pvparallelview/PVDisplayViewScatter.h>
#include <pvkernel/widgets/PVRangeEdit.h>
#include <pvkernel/rush/PVNraw.h>
#include <pvkernel/core/qobject_helpers.h>
#include <inendi/PVSource.h>
#include <inendi/PVRangeSubSampler.h>
#include <pvdisplays/PVDisplayIf.h>

#include <QStateMachine>
#include <QKeyEvent>
#include <QPainter>
#include <QScrollBar>
#include <QMenu>

#include <memory>

PVParallelView::PVSeriesViewWidget::PVSeriesViewWidget(Inendi::PVView* view,
                                                       PVCol axis,
                                                       QWidget* parent /*= nullptr*/)
    : QWidget(parent), _view(view), _help_widget(this)
{
	// Define help
	setFocusPolicy(Qt::StrongFocus);
	_help_widget.hide();

	_help_widget.initTextFromFile("series view's help", ":help-style");
	_help_widget.addTextFromFile(":help-series-view-navigation");
	_help_widget.newColumn();
	_help_widget.addTextFromFile(":help-series-view-selection");
	_help_widget.newColumn();
	_help_widget.addTextFromFile(":help-series-view-hunting");
	_help_widget.newTable();
	_help_widget.addTextFromFile(":help-series-view-rendering");
	_help_widget.newColumn();
	_help_widget.addTextFromFile(":help-series-view-sampling");
	_help_widget.newTable();
	_help_widget.addTextFromFile(":help-selection");
	_help_widget.newColumn();
	_help_widget.addTextFromFile(":help-application");

	_help_widget.finalizeText();

	set_abscissa(axis);

	// Subscribe to plotting changes
	_plotting_change_connection = _view->get_parent<Inendi::PVPlotted>()._plotted_updated.connect(
	    [this](const QList<PVCol>& plotteds_updated) {
		    if (_sampler) {
			    std::unordered_set<size_t> updated_timeseries(plotteds_updated.begin(),
			                                                  plotteds_updated.end());
			    _sampler->resubsample(updated_timeseries);
		    }
		});
	// Subscribe to selection changes
	_selection_change_connection = _view->_update_output_selection.connect([this]() {
		if (_sampler) {
			_sampler->resubsample();
		}
	});
}

void PVParallelView::PVSeriesViewWidget::set_abscissa(PVCol abscissa)
{
	std::vector<QWidget*> replaceable_widgets;

	if (abscissa != PVCol()) {
		PVRush::PVNraw const& nraw = _view->get_rushnraw_parent();

		const pvcop::db::array& time = nraw.column(abscissa);

		{
			auto plotteds = _view->get_parent<Inendi::PVSource>().get_children<Inendi::PVPlotted>();
			const auto& plotteds_vector = plotteds.front()->get_plotteds();

			std::vector<pvcop::core::array<uint32_t>> timeseries;
			for (PVCol col(0); col < nraw.column_count(); col++) {
				timeseries.emplace_back(plotteds_vector[col].to_core_array<uint32_t>());
			}

			_sampler.reset(new Inendi::PVRangeSubSampler(
			    time, std::move(timeseries), nraw, _view->get_real_output_selection(),
			    _split_axis == PVCol() ? nullptr : &nraw.column(_split_axis)));
		}

		_plot = new PVSeriesView(*_sampler, PVSeriesView::Backend::Default);
		_plot->set_background_color(QColor(10, 10, 10, 255));

		setup_series_list(abscissa);

		_zoomer = new PVSeriesViewZoomer(_plot, *_sampler);

		auto minmax_changed_f = [this](const pvcop::db::array& minmax) {
			PVViewZoomer::Zoom zoom = _zoomer->current_zoom();
			std::tie(zoom.minX, zoom.maxX) = _sampler->minmax_to_ratio(minmax);
			// Fix negative value generated by QDateTime resolution fixed to the millisecond
			zoom.minX = std::max(zoom.minX, (PVViewZoomer::zoom_f)0.);
			_zoomer->reset_and_zoom_in(zoom);
		};

		PVWidgets::PVRangeEdit* range_edit =
		    PVWidgets::PVRangeEditFactory::create(_sampler->minmax_time(), minmax_changed_f);

		QObject::connect(_zoomer, &PVSeriesViewZoomer::zoom_updated, [range_edit, this](
		                                                                 PVViewZoomer::Zoom zoom) {
			range_edit->set_minmax(_sampler->ratio_to_minmax(zoom.minX, zoom.maxX));
		});

		QObject::connect(
		    _zoomer, &PVSeriesViewZoomer::selection_commit,
		    [range_edit, &time, &nraw, this](PVViewZoomer::Zoom zoom) {
			    const pvcop::db::array& minmax = _sampler->ratio_to_minmax(zoom.minX, zoom.maxX);
			    range_edit->set_minmax(minmax);
			    const auto& sorted_indexes = _sampler->sorted_indexes();
			    pvcop::db::range_t selected_range = time.equal_range(minmax, sorted_indexes);
			    const auto& sort = sorted_indexes ? sorted_indexes.to_core_array()
			                                      : pvcop::core::array<pvcop::db::index_t>();
			    Inendi::PVSelection sel(nraw.row_count());
			    sel.select_none(); // Not sur if needed
			    for (size_t i = selected_range.begin; i < selected_range.end; i++) {
				    sel.set_bit_fast(sort ? sort[i] : i);
			    }
			    _view->set_selection_view(sel);
			});

		setup_selected_series_list(abscissa);

		replaceable_widgets = {_zoomer, _series_list_widget, _selected_series_list, range_edit};
	} else {
		replaceable_widgets = {new QWidget, new QWidget, new QWidget, new QWidget};
	}

	if (_layout_replacer && layout()) {
		_layout_replacer(replaceable_widgets);
	} else {
		_params_widget = new PVSeriesViewParamsWidget(abscissa, this);

		QVBoxLayout* layout = new QVBoxLayout;
		layout->setContentsMargins(0, 0, 0, 0);

		QHBoxLayout* hlayout = new QHBoxLayout;
		hlayout->setContentsMargins(0, 0, 0, 0);

		hlayout->addWidget(replaceable_widgets[0]);
		auto* vlayout = new QVBoxLayout;
		vlayout->addWidget(replaceable_widgets[1]);
		vlayout->addWidget(replaceable_widgets[2]);
		hlayout->addLayout(vlayout);

		QHBoxLayout* bottom_layout = new QHBoxLayout;
		bottom_layout->addWidget(replaceable_widgets[3]);
		bottom_layout->addStretch();
		bottom_layout->addWidget(_params_widget);

		layout->addLayout(hlayout);
		layout->addLayout(bottom_layout);

		setLayout(layout);
	}

	_layout_replacer = [this, replaceable_widgets](std::vector<QWidget*> const& new_widgets) {
		QLayout* global_layout = layout();
		for (size_t i = 0; i < replaceable_widgets.size(); ++i) {
			delete global_layout->replaceWidget(replaceable_widgets[i], new_widgets[i]);
			replaceable_widgets[i]->deleteLater();
		}
	};
}

void PVParallelView::PVSeriesViewWidget::set_split(PVCol split)
{
	PVRush::PVNraw const& nraw = _view->get_rushnraw_parent();
	_sampler->set_split_column(split == PVCol() ? nullptr : &nraw.column(split));
}

void PVParallelView::PVSeriesViewWidget::setup_series_list(PVCol abscissa,
                                                           bool recreate_widget /* = true */)
{
	if (not _series_list_widget or recreate_widget) {
		_series_list_widget = new QListWidget;
	}
	_series_list_widget->clear();
	_series_list_widget->setFixedWidth(200);
	_series_list_widget->setItemDelegate(new StyleDelegate());

	const Inendi::PVAxesCombination& axes_comb = _view->get_axes_combination();

	PVCol column_count = _view->get_rushnraw_parent().column_count();
	for (PVCol col(0); col < column_count; col++) {
		const PVRush::PVAxisFormat& axis = axes_comb.get_axis(col);
		if (axis.get_type().startsWith("number_") or axis.get_type().startsWith("duration")) {
			QColor color(rand() % 156 + 100, rand() % 156 + 100, rand() % 156 + 100);
			for (size_t i = 0; i < _sampler->group_count(); i++) {
				QListWidgetItem* item = new QListWidgetItem(
				    axis.get_name() + (_sampler->group_count() > 1
				                           ? (QString(" (") + _sampler->group_name(i).c_str() + ")")
				                           : "")); // FIXME
				item->setData(Qt::UserRole, QVariant::fromValue(SerieListItemData{
				                                PVCol(_sampler->group_count() * col + i), color}));
				item->setBackgroundColor(color);
				_series_list_widget->addItem(item);
			}
		}
	}
	_series_list_widget->setSelectionMode(QAbstractItemView::MultiSelection);

	_series_list_widget->setContextMenuPolicy(Qt::CustomContextMenu);
	connect(_series_list_widget, &QWidget::customContextMenuRequested, [this, abscissa](
	                                                                       QPoint const& pos) {
		auto item = _series_list_widget->itemAt(pos);
		PVCol col = item->data(Qt::UserRole).value<SerieListItemData>().col;
		QMenu item_menu;
		auto scatter_action = new QAction(
		    PVDisplays::display_view_if<PVDisplays::PVDisplayViewScatter>().toolbar_icon(),
		    "Scatter view with abscissa", &item_menu);
		connect(scatter_action, &QAction::triggered, [this, abscissa, col] {
			if (auto container =
			        PVCore::get_qobject_parent_of_type<PVDisplays::PVDisplaysContainer*>(this)) {
				container->create_view_widget(
				    PVDisplays::display_view_if<PVDisplays::PVDisplayViewScatter>(), _view,
				    {abscissa, col});
			}
		});
		item_menu.addAction(scatter_action);
		item_menu.addSeparator();
		if (auto container =
		        PVCore::get_qobject_parent_of_type<PVDisplays::PVDisplaysContainer*>(this)) {
			PVDisplays::add_displays_view_axis_menu(item_menu, container, _view, col);
		}
		item_menu.exec(_series_list_widget->mapToGlobal(pos));
	});

	const std::vector<PVCol>& combination = axes_comb.get_combination();
	for (PVCol i(0); i < _series_list_widget->count(); i++) {
		auto item = _series_list_widget->item(i);
		PVCol j = item->data(Qt::UserRole).value<SerieListItemData>().col;
		if (std::find(combination.begin(), combination.end(), j) != combination.end()) {
			item->setSelected(true);
		}
	}

	QObject::connect(_series_list_widget, &QListWidget::itemSelectionChanged, this,
	                 &PVSeriesViewWidget::update_selected_series);
	_update_selected_series_resample = false;
	update_selected_series();
	_update_selected_series_resample = true;
}

void PVParallelView::PVSeriesViewWidget::setup_selected_series_list(PVCol /*abscissa*/)
{
	_selected_series_list = new QListWidget;
	_selected_series_list->setFixedWidth(_series_list_widget->width());
	_selected_series_list->setMaximumHeight(0);
	_selected_series_list->setItemDelegate(new StyleDelegate());
	_selected_series_list->setSelectionMode(QAbstractItemView::MultiSelection);

	QObject::connect(_zoomer, &PVSeriesViewZoomer::cursor_moved, [this](QRect region) {
		_selected_series_list->clear();
		for (const QListWidgetItem* item : _series_list_widget->selectedItems()) {
			const PVCol item_col = item->data(Qt::UserRole).value<SerieListItemData>().col;
			if (is_in_region(region, item_col)) {
				QListWidgetItem* selected_item = new QListWidgetItem(item->text());
				selected_item->setData(Qt::UserRole, item->data(Qt::UserRole));
				selected_item->setBackground(
				    item->data(Qt::UserRole).value<SerieListItemData>().color);
				_selected_series_list->addItem(selected_item);
			}
		}
		_selected_series_list->selectAll();
		auto count = _selected_series_list->count();
		auto scrollbar = _selected_series_list->horizontalScrollBar();
		_selected_series_list->setMaximumHeight(
		    count > 0
		        ? count * _selected_series_list->sizeHintForRow(0) +
		              2 * _selected_series_list->frameWidth() +
		              (scrollbar->isVisible() ? scrollbar->height() : 0)
		        : 0);
	});

	QObject::connect(
	    _zoomer, &PVSeriesViewZoomer::hunt_commit, [this](QRect region, bool addition) {
		    auto selected_items_list = _series_list_widget->selectedItems();
		    decltype(selected_items_list) deselect_list;
		    std::copy_if(
		        selected_items_list.begin(), selected_items_list.end(),
		        std::back_inserter(deselect_list), [region, addition, this](QListWidgetItem* item) {
			        const PVCol item_col = item->data(Qt::UserRole).value<SerieListItemData>().col;
			        return is_in_region(region, item_col) == not addition;
			    });
		    // Deselect those not in region unless there would be none left
		    if (deselect_list.size() < selected_items_list.size()) {
			    _update_selected_series_resample = false;
			    _series_list_widget->blockSignals(true);
			    for (auto* item : deselect_list) {
				    item->setSelected(false);
			    }
			    _series_list_widget->blockSignals(false);
			    _update_selected_series_resample = true;
			    update_selected_series();
		    }
		});

	auto synchro_list = [](auto list_src, auto list_dest) {
		auto src_seleted_items = list_src->selectedItems();
		for (int i = 0; i < list_dest->count(); ++i) {
			QListWidgetItem* item = list_dest->item(i);
			const PVCol item_col = item->data(Qt::UserRole).value<SerieListItemData>().col;
			auto src_selected_it = std::find_if(
			    src_seleted_items.begin(), src_seleted_items.end(),
			    [item_col](QListWidgetItem* selected_item) {
				    return item_col ==
				           selected_item->data(Qt::UserRole).value<SerieListItemData>().col;
				});
			item->setSelected(src_selected_it != src_seleted_items.end());
		}
	};

	auto semi_synchro_list = [](auto list_src, auto list_dest) {
		for (int src_index = 0; src_index < list_src->count(); ++src_index) {
			QListWidgetItem* src_item = list_src->item(src_index);
			const PVCol src_item_col = src_item->data(Qt::UserRole).value<SerieListItemData>().col;
			for (int dest_index = 0; dest_index < list_dest->count(); ++dest_index) {
				QListWidgetItem* dest_item = list_dest->item(dest_index);
				const PVCol dest_item_col =
				    dest_item->data(Qt::UserRole).value<SerieListItemData>().col;
				if (src_item_col == dest_item_col) {
					dest_item->setSelected(src_item->isSelected());
					break;
				}
			}
		}
	};

	QObject::connect(
	    _series_list_widget, &QListWidget::itemSelectionChanged,
	    [synchro_list, this]() { synchro_list(_series_list_widget, _selected_series_list); });
	QObject::connect(_selected_series_list, &QListWidget::itemSelectionChanged,
	                 [semi_synchro_list, this]() {
		                 if (_synchro_selected_list) {
			                 semi_synchro_list(_selected_series_list, _series_list_widget);
		                 }
		             });

	struct SynchroFilter : QObject {
		SynchroFilter(std::function<void()> enter, std::function<void()> leave)
		    : enter(enter), leave(leave)
		{
		}
		std::function<void()> enter;
		std::function<void()> leave;
		bool eventFilter(QObject* obj, QEvent* event) override
		{
			if (event->type() == QEvent::Enter) {
				enter();
				return true;
			} else if (event->type() == QEvent::Leave) {
				leave();
				return true;
			}
			return QObject::eventFilter(obj, event);
		}
	};

	_selected_series_list->installEventFilter(new SynchroFilter{
	    [this] { _synchro_selected_list = true; }, [this] { _synchro_selected_list = false; }});
}

void PVParallelView::PVSeriesViewWidget::keyPressEvent(QKeyEvent* event)
{
	if (PVWidgets::PVHelpWidget::is_help_key(event->key())) {
		if (_help_widget.isHidden()) {
			_help_widget.popup(this, PVWidgets::PVTextPopupWidget::AlignTop,
			                   PVWidgets::PVTextPopupWidget::ExpandAll);
		}
		return;
	}
	if (event->key() == Qt::Key_A and event->modifiers() & Qt::ControlModifier) {
		_series_list_widget->selectAll();
		return;
	}

	QWidget::keyPressEvent(event);
}

void PVParallelView::PVSeriesViewWidget::enterEvent(QEvent*)
{
	setFocus(Qt::MouseFocusReason);
}

void PVParallelView::PVSeriesViewWidget::leaveEvent(QEvent*)
{
	clearFocus();
}

void PVParallelView::PVSeriesViewWidget::update_selected_series()
{
	// FIXME : should put newly selected timeserie on top
	std::vector<PVSeriesView::SerieDrawInfo> series_draw_order;
	std::unordered_set<size_t> selected_timeseries;
	selected_timeseries.reserve(_sampler->timeseries_count());
	for (const QListWidgetItem* item : _series_list_widget->selectedItems()) {
		auto item_data = item->data(Qt::UserRole).value<SerieListItemData>();
		series_draw_order.push_back({size_t(item_data.col), item_data.color});
		selected_timeseries.emplace(item_data.col);
	}
	_sampler->set_selected_timeseries(selected_timeseries);
	if (_update_selected_series_resample) {
		_sampler->resubsample();
	}
	_plot->show_series(std::move(series_draw_order));
	_plot->update();
}

bool PVParallelView::PVSeriesViewWidget::is_in_region(const QRect region, PVCol col) const
{
	const auto min_value = Inendi::PVRangeSubSampler::display_type_max_val *
	                       uint32_t(_zoomer->height() - (region.top() + region.height()));
	const auto max_value = Inendi::PVRangeSubSampler::display_type_max_val *
	                       uint32_t(_zoomer->height() - region.top());

	const auto& av_ts = _sampler->sampled_timeserie(col);
	for (int pos_x = region.left(); pos_x < region.left() + region.width(); ++pos_x) {
		const auto av_ts_value = av_ts[pos_x] * uint32_t(_zoomer->height());
		if (min_value < av_ts_value and av_ts_value < max_value) {
			return true;
		}
	}
	return false;
}

void PVParallelView::PVSeriesViewWidget::StyleDelegate::paint(QPainter* painter,
                                                              const QStyleOptionViewItem& option,
                                                              const QModelIndex& index) const
{
	auto color = index.model()->data(index, Qt::UserRole).value<SerieListItemData>().color;
	if ((option.state & QStyle::State_Selected)) {
		painter->fillRect(option.rect, color);
		painter->setPen(Qt::black);
	} else {
		painter->setPen(color);
	}
	painter->drawText(option.rect, index.model()->data(index, Qt::DisplayRole).toString());
}
