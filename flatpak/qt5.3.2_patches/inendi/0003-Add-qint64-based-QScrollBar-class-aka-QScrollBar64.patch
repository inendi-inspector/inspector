From dc5b95f2197e655a8e946a9b0f9ec862799c2863 Mon Sep 17 00:00:00 2001
From: Remi Herilier <remi.herilier@picviz.com>
Date: Fri, 11 Sep 2015 16:14:17 +0200
Subject: [PATCH 3/6] Add qint64 based QScrollBar class (aka QScrollBar64)

This class is use for our own implementation of QGraphicsView as a
work-around for an overflow bug in QAbstractScrollArea.
---
 include/QtWidgets/QtWidgets               |    2 +
 include/QtWidgets/headers.pri             |    6 +-
 src/widgets/styles/qcommonstyle.cpp       |  468 ++++---
 src/widgets/styles/qfusionstyle.cpp       | 2146 +++++++++++++++--------------
 src/widgets/styles/qgtkstyle.cpp          |  840 +++++------
 src/widgets/styles/qstyle.cpp             |   42 +-
 src/widgets/styles/qstyle.h               |    6 +
 src/widgets/styles/qstyleoption.cpp       |   19 +
 src/widgets/styles/qstyleoption.h         |   29 +-
 src/widgets/widgets/qabstractslider64.cpp | 1014 ++++++++++++++
 src/widgets/widgets/qabstractslider64.h   |  143 ++
 src/widgets/widgets/qabstractslider64_p.h |  106 ++
 src/widgets/widgets/qscrollbar64.cpp      |  764 ++++++++++
 src/widgets/widgets/qscrollbar64.h        |   63 +
 src/widgets/widgets/widgets.pri           |    5 +
 15 files changed, 3968 insertions(+), 1685 deletions(-)
 create mode 100644 src/widgets/widgets/qabstractslider64.cpp
 create mode 100644 src/widgets/widgets/qabstractslider64.h
 create mode 100644 src/widgets/widgets/qabstractslider64_p.h
 create mode 100644 src/widgets/widgets/qscrollbar64.cpp
 create mode 100644 src/widgets/widgets/qscrollbar64.h

diff --git a/include/QtWidgets/QtWidgets b/include/QtWidgets/QtWidgets
index f0f7de2..2837b72 100644
--- a/include/QtWidgets/QtWidgets
+++ b/include/QtWidgets/QtWidgets
@@ -82,6 +82,7 @@
 #include "qabstractbutton.h"
 #include "qabstractscrollarea.h"
 #include "qabstractslider.h"
+#include "qabstractslider64.h"
 #include "qabstractspinbox.h"
 #include "qbuttongroup.h"
 #include "qcalendarwidget.h"
@@ -112,6 +113,7 @@
 #include "qrubberband.h"
 #include "qscrollarea.h"
 #include "qscrollbar.h"
+#include "qscrollbar64.h"
 #include "qsizegrip.h"
 #include "qslider.h"
 #include "qspinbox.h"
diff --git a/include/QtWidgets/headers.pri b/include/QtWidgets/headers.pri
index 5daee6e..0ec1f68 100644
--- a/include/QtWidgets/headers.pri
+++ b/include/QtWidgets/headers.pri
@@ -1,5 +1,5 @@
-SYNCQT.HEADER_FILES = accessible/qaccessiblewidget.h dialogs/qcolordialog.h dialogs/qdialog.h dialogs/qerrormessage.h dialogs/qfiledialog.h dialogs/qfilesystemmodel.h dialogs/qfontdialog.h dialogs/qinputdialog.h dialogs/qmessagebox.h dialogs/qprogressdialog.h dialogs/qwizard.h effects/qgraphicseffect.h graphicsview/qgraphicsanchorlayout.h graphicsview/qgraphicsgridlayout.h graphicsview/qgraphicsitem.h graphicsview/qgraphicsitemanimation.h graphicsview/qgraphicslayout.h graphicsview/qgraphicslayoutitem.h graphicsview/qgraphicslinearlayout.h graphicsview/qgraphicsproxywidget.h graphicsview/qgraphicsscene.h graphicsview/qgraphicssceneevent.h graphicsview/qgraphicstransform.h graphicsview/qgraphicsview.h graphicsview/qgraphicswidget.h itemviews/qabstractitemdelegate.h itemviews/qabstractitemview.h itemviews/qcolumnview.h itemviews/qdatawidgetmapper.h itemviews/qdirmodel.h itemviews/qfileiconprovider.h itemviews/qheaderview.h itemviews/qitemdelegate.h itemviews/qitemeditorfactory.h itemviews/qlistview.h itemviews/qlistwidget.h itemviews/qstyleditemdelegate.h itemviews/qtableview.h itemviews/qtablewidget.h itemviews/qtreeview.h itemviews/qtreewidget.h itemviews/qtreewidgetitemiterator.h kernel/qaction.h kernel/qactiongroup.h kernel/qapplication.h kernel/qboxlayout.h kernel/qdesktopwidget.h kernel/qformlayout.h kernel/qgesture.h kernel/qgesturerecognizer.h kernel/qgridlayout.h kernel/qlayout.h kernel/qlayoutitem.h kernel/qshortcut.h kernel/qsizepolicy.h kernel/qstackedlayout.h kernel/qtooltip.h kernel/qwhatsthis.h kernel/qwidget.h kernel/qwidgetaction.h kernel/qwidgetsfunctions_wince.h statemachine/qkeyeventtransition.h statemachine/qmouseeventtransition.h styles/qcommonstyle.h styles/qdrawutil.h styles/qproxystyle.h styles/qstyle.h styles/qstylefactory.h styles/qstyleoption.h styles/qstylepainter.h styles/qstyleplugin.h util/qcolormap.h util/qcompleter.h util/qscroller.h util/qscrollerproperties.h util/qsystemtrayicon.h util/qundogroup.h util/qundostack.h util/qundoview.h widgets/qabstractbutton.h widgets/qabstractscrollarea.h widgets/qabstractslider.h widgets/qabstractspinbox.h widgets/qbuttongroup.h widgets/qcalendarwidget.h widgets/qcheckbox.h widgets/qcombobox.h widgets/qcommandlinkbutton.h widgets/qdatetimeedit.h widgets/qdial.h widgets/qdialogbuttonbox.h widgets/qdockwidget.h widgets/qfocusframe.h widgets/qfontcombobox.h widgets/qframe.h widgets/qgroupbox.h widgets/qkeysequenceedit.h widgets/qlabel.h widgets/qlcdnumber.h widgets/qlineedit.h widgets/qmaccocoaviewcontainer_mac.h widgets/qmacnativewidget_mac.h widgets/qmainwindow.h widgets/qmdiarea.h widgets/qmdisubwindow.h widgets/qmenu.h widgets/qmenubar.h widgets/qplaintextedit.h widgets/qprogressbar.h widgets/qpushbutton.h widgets/qradiobutton.h widgets/qrubberband.h widgets/qscrollarea.h widgets/qscrollbar.h widgets/qsizegrip.h widgets/qslider.h widgets/qspinbox.h widgets/qsplashscreen.h widgets/qsplitter.h widgets/qstackedwidget.h widgets/qstatusbar.h widgets/qtabbar.h widgets/qtabwidget.h widgets/qtextbrowser.h widgets/qtextedit.h widgets/qtoolbar.h widgets/qtoolbox.h widgets/qtoolbutton.h ../../include/QtWidgets/qtwidgetsversion.h ../../include/QtWidgets/QtWidgets 
-SYNCQT.HEADER_CLASSES = ../../include/QtWidgets/QAccessibleWidget ../../include/QtWidgets/QColorDialog ../../include/QtWidgets/QDialog ../../include/QtWidgets/QErrorMessage ../../include/QtWidgets/QFileDialog ../../include/QtWidgets/QFileSystemModel ../../include/QtWidgets/QFontDialog ../../include/QtWidgets/QInputDialog ../../include/QtWidgets/QMessageBox ../../include/QtWidgets/QProgressDialog ../../include/QtWidgets/QWizard ../../include/QtWidgets/QWizardPage ../../include/QtWidgets/QGraphicsEffect ../../include/QtWidgets/QGraphicsColorizeEffect ../../include/QtWidgets/QGraphicsBlurEffect ../../include/QtWidgets/QGraphicsDropShadowEffect ../../include/QtWidgets/QGraphicsOpacityEffect ../../include/QtWidgets/QGraphicsAnchor ../../include/QtWidgets/QGraphicsAnchorLayout ../../include/QtWidgets/QGraphicsGridLayout ../../include/QtWidgets/QGraphicsItem ../../include/QtWidgets/QGraphicsObject ../../include/QtWidgets/QAbstractGraphicsShapeItem ../../include/QtWidgets/QGraphicsPathItem ../../include/QtWidgets/QGraphicsRectItem ../../include/QtWidgets/QGraphicsEllipseItem ../../include/QtWidgets/QGraphicsPolygonItem ../../include/QtWidgets/QGraphicsLineItem ../../include/QtWidgets/QGraphicsPixmapItem ../../include/QtWidgets/QGraphicsTextItem ../../include/QtWidgets/QGraphicsSimpleTextItem ../../include/QtWidgets/QGraphicsItemGroup ../../include/QtWidgets/QGraphicsItemAnimation ../../include/QtWidgets/QGraphicsLayout ../../include/QtWidgets/QGraphicsLayoutItem ../../include/QtWidgets/QGraphicsLinearLayout ../../include/QtWidgets/QGraphicsProxyWidget ../../include/QtWidgets/QGraphicsScene ../../include/QtWidgets/QGraphicsSceneEvent ../../include/QtWidgets/QGraphicsSceneMouseEvent ../../include/QtWidgets/QGraphicsSceneWheelEvent ../../include/QtWidgets/QGraphicsSceneContextMenuEvent ../../include/QtWidgets/QGraphicsSceneHoverEvent ../../include/QtWidgets/QGraphicsSceneHelpEvent ../../include/QtWidgets/QGraphicsSceneDragDropEvent ../../include/QtWidgets/QGraphicsSceneResizeEvent ../../include/QtWidgets/QGraphicsSceneMoveEvent ../../include/QtWidgets/QGraphicsTransform ../../include/QtWidgets/QGraphicsScale ../../include/QtWidgets/QGraphicsRotation ../../include/QtWidgets/QGraphicsView ../../include/QtWidgets/QGraphicsWidget ../../include/QtWidgets/QAbstractItemDelegate ../../include/QtWidgets/QAbstractItemView ../../include/QtWidgets/QColumnView ../../include/QtWidgets/QDataWidgetMapper ../../include/QtWidgets/QDirModel ../../include/QtWidgets/QFileIconProvider ../../include/QtWidgets/QHeaderView ../../include/QtWidgets/QItemDelegate ../../include/QtWidgets/QItemEditorCreatorBase ../../include/QtWidgets/QItemEditorCreator ../../include/QtWidgets/QStandardItemEditorCreator ../../include/QtWidgets/QItemEditorFactory ../../include/QtWidgets/QListView ../../include/QtWidgets/QListWidgetItem ../../include/QtWidgets/QListWidget ../../include/QtWidgets/QStyledItemDelegate ../../include/QtWidgets/QTableView ../../include/QtWidgets/QTableWidgetSelectionRange ../../include/QtWidgets/QTableWidgetItem ../../include/QtWidgets/QTableWidget ../../include/QtWidgets/QTreeView ../../include/QtWidgets/QTreeWidgetItem ../../include/QtWidgets/QTreeWidget ../../include/QtWidgets/QTreeWidgetItemIterator ../../include/QtWidgets/QAction ../../include/QtWidgets/QActionGroup ../../include/QtWidgets/QApplication ../../include/QtWidgets/QBoxLayout ../../include/QtWidgets/QHBoxLayout ../../include/QtWidgets/QVBoxLayout ../../include/QtWidgets/QDesktopWidget ../../include/QtWidgets/QFormLayout ../../include/QtWidgets/QGesture ../../include/QtWidgets/QPanGesture ../../include/QtWidgets/QPinchGesture ../../include/QtWidgets/QSwipeGesture ../../include/QtWidgets/QTapGesture ../../include/QtWidgets/QTapAndHoldGesture ../../include/QtWidgets/QGestureEvent ../../include/QtWidgets/QGestureRecognizer ../../include/QtWidgets/QGridLayout ../../include/QtWidgets/QLayout ../../include/QtWidgets/QLayoutItem ../../include/QtWidgets/QSpacerItem ../../include/QtWidgets/QWidgetItem ../../include/QtWidgets/QWidgetItemV2 ../../include/QtWidgets/QShortcut ../../include/QtWidgets/QSizePolicy ../../include/QtWidgets/QStackedLayout ../../include/QtWidgets/QToolTip ../../include/QtWidgets/QWhatsThis ../../include/QtWidgets/QWidgetData ../../include/QtWidgets/QWidget ../../include/QtWidgets/QWidgetAction ../../include/QtWidgets/QKeyEventTransition ../../include/QtWidgets/QMouseEventTransition ../../include/QtWidgets/QCommonStyle ../../include/QtWidgets/QTileRules ../../include/QtWidgets/QProxyStyle ../../include/QtWidgets/QStyle ../../include/QtWidgets/QStyleFactory ../../include/QtWidgets/QStyleOption ../../include/QtWidgets/QStyleOptionFocusRect ../../include/QtWidgets/QStyleOptionFrame ../../include/QtWidgets/QStyleOptionFrameV2 ../../include/QtWidgets/QStyleOptionFrameV3 ../../include/QtWidgets/QStyleOptionTabWidgetFrame ../../include/QtWidgets/QStyleOptionTabWidgetFrameV2 ../../include/QtWidgets/QStyleOptionTabBarBase ../../include/QtWidgets/QStyleOptionTabBarBaseV2 ../../include/QtWidgets/QStyleOptionHeader ../../include/QtWidgets/QStyleOptionButton ../../include/QtWidgets/QStyleOptionTab ../../include/QtWidgets/QStyleOptionTabV2 ../../include/QtWidgets/QStyleOptionTabV3 ../../include/QtWidgets/QStyleOptionToolBar ../../include/QtWidgets/QStyleOptionProgressBar ../../include/QtWidgets/QStyleOptionProgressBarV2 ../../include/QtWidgets/QStyleOptionMenuItem ../../include/QtWidgets/QStyleOptionDockWidget ../../include/QtWidgets/QStyleOptionDockWidgetV2 ../../include/QtWidgets/QStyleOptionViewItem ../../include/QtWidgets/QStyleOptionViewItemV2 ../../include/QtWidgets/QStyleOptionViewItemV3 ../../include/QtWidgets/QStyleOptionViewItemV4 ../../include/QtWidgets/QStyleOptionToolBox ../../include/QtWidgets/QStyleOptionToolBoxV2 ../../include/QtWidgets/QStyleOptionRubberBand ../../include/QtWidgets/QStyleOptionComplex ../../include/QtWidgets/QStyleOptionSlider ../../include/QtWidgets/QStyleOptionSpinBox ../../include/QtWidgets/QStyleOptionToolButton ../../include/QtWidgets/QStyleOptionComboBox ../../include/QtWidgets/QStyleOptionTitleBar ../../include/QtWidgets/QStyleOptionGroupBox ../../include/QtWidgets/QStyleOptionSizeGrip ../../include/QtWidgets/QStyleOptionGraphicsItem ../../include/QtWidgets/QStyleHintReturn ../../include/QtWidgets/QStyleHintReturnMask ../../include/QtWidgets/QStyleHintReturnVariant ../../include/QtWidgets/QStylePainter ../../include/QtWidgets/QStylePlugin ../../include/QtWidgets/QColormap ../../include/QtWidgets/QCompleter ../../include/QtWidgets/QScroller ../../include/QtWidgets/QScrollerProperties ../../include/QtWidgets/QSystemTrayIcon ../../include/QtWidgets/QUndoGroup ../../include/QtWidgets/QUndoCommand ../../include/QtWidgets/QUndoStack ../../include/QtWidgets/QUndoView ../../include/QtWidgets/QAbstractButton ../../include/QtWidgets/QAbstractScrollArea ../../include/QtWidgets/QAbstractSlider ../../include/QtWidgets/QAbstractSpinBox ../../include/QtWidgets/QButtonGroup ../../include/QtWidgets/QCalendarWidget ../../include/QtWidgets/QCheckBox ../../include/QtWidgets/QComboBox ../../include/QtWidgets/QCommandLinkButton ../../include/QtWidgets/QDateTimeEdit ../../include/QtWidgets/QTimeEdit ../../include/QtWidgets/QDateEdit ../../include/QtWidgets/QDial ../../include/QtWidgets/QDialogButtonBox ../../include/QtWidgets/QDockWidget ../../include/QtWidgets/QFocusFrame ../../include/QtWidgets/QFontComboBox ../../include/QtWidgets/QFrame ../../include/QtWidgets/QGroupBox ../../include/QtWidgets/QKeySequenceEdit ../../include/QtWidgets/QLabel ../../include/QtWidgets/QLCDNumber ../../include/QtWidgets/QLineEdit ../../include/QtWidgets/QMacCocoaViewContainer ../../include/QtWidgets/QMacNativeWidget ../../include/QtWidgets/QMainWindow ../../include/QtWidgets/QMdiArea ../../include/QtWidgets/QMdiSubWindow ../../include/QtWidgets/QMenu ../../include/QtWidgets/QMenuBar ../../include/QtWidgets/QPlainTextEdit ../../include/QtWidgets/QPlainTextDocumentLayout ../../include/QtWidgets/QProgressBar ../../include/QtWidgets/QPushButton ../../include/QtWidgets/QRadioButton ../../include/QtWidgets/QRubberBand ../../include/QtWidgets/QScrollArea ../../include/QtWidgets/QScrollBar ../../include/QtWidgets/QSizeGrip ../../include/QtWidgets/QSlider ../../include/QtWidgets/QSpinBox ../../include/QtWidgets/QDoubleSpinBox ../../include/QtWidgets/QSplashScreen ../../include/QtWidgets/QSplitter ../../include/QtWidgets/QSplitterHandle ../../include/QtWidgets/QStackedWidget ../../include/QtWidgets/QStatusBar ../../include/QtWidgets/QTabBar ../../include/QtWidgets/QTabWidget ../../include/QtWidgets/QTextBrowser ../../include/QtWidgets/QTextEdit ../../include/QtWidgets/QToolBar ../../include/QtWidgets/QToolBox ../../include/QtWidgets/QToolButton ../../include/QtWidgets/QtWidgetsVersion 
-SYNCQT.PRIVATE_HEADER_FILES = dialogs/qcolordialog_p.h dialogs/qdialog_p.h dialogs/qfiledialog_p.h dialogs/qfileinfogatherer_p.h dialogs/qfilesystemmodel_p.h dialogs/qfontdialog_p.h dialogs/qfscompleter_p.h dialogs/qsidebar_p.h dialogs/qwizard_win_p.h effects/qgraphicseffect_p.h effects/qpixmapfilter_p.h graphicsview/qgraph_p.h graphicsview/qgraphicsanchorlayout_p.h graphicsview/qgraphicsgridlayoutengine_p.h graphicsview/qgraphicsitem_p.h graphicsview/qgraphicslayout_p.h graphicsview/qgraphicslayoutitem_p.h graphicsview/qgraphicslayoutstyleinfo_p.h graphicsview/qgraphicsproxywidget_p.h graphicsview/qgraphicsscene_bsp_p.h graphicsview/qgraphicsscene_p.h graphicsview/qgraphicsscenebsptreeindex_p.h graphicsview/qgraphicssceneindex_p.h graphicsview/qgraphicsscenelinearindex_p.h graphicsview/qgraphicstransform_p.h graphicsview/qgraphicsview_p.h graphicsview/qgraphicswidget_p.h graphicsview/qsimplex_p.h itemviews/qabstractitemview_p.h itemviews/qbsptree_p.h itemviews/qcolumnview_p.h itemviews/qcolumnviewgrip_p.h itemviews/qfileiconprovider_p.h itemviews/qheaderview_p.h itemviews/qitemeditorfactory_p.h itemviews/qlistview_p.h itemviews/qlistwidget_p.h itemviews/qtableview_p.h itemviews/qtablewidget_p.h itemviews/qtreeview_p.h itemviews/qtreewidget_p.h itemviews/qtreewidgetitemiterator_p.h itemviews/qwidgetitemdata_p.h kernel/qaction_p.h kernel/qapplication_p.h kernel/qdesktopwidget_qpa_p.h kernel/qgesture_p.h kernel/qgesturemanager_p.h kernel/qlayout_p.h kernel/qlayoutengine_p.h kernel/qmacgesturerecognizer_p.h kernel/qopenglwidget_p.h kernel/qstandardgestures_p.h kernel/qt_widgets_pch.h kernel/qwidget_p.h kernel/qwidgetaction_p.h kernel/qwidgetbackingstore_p.h kernel/qwidgetwindow_qpa_p.h kernel/qwindowcontainer_p.h statemachine/qbasickeyeventtransition_p.h statemachine/qbasicmouseeventtransition_p.h styles/qandroidstyle_p.h styles/qcommonstyle_p.h styles/qcommonstylepixmaps_p.h styles/qfusionstyle_p.h styles/qfusionstyle_p_p.h styles/qgtk2painter_p.h styles/qgtkglobal_p.h styles/qgtkpainter_p.h styles/qgtkstyle_p.h styles/qgtkstyle_p_p.h styles/qmacstyle_mac_p.h styles/qmacstyle_mac_p_p.h styles/qproxystyle_p.h styles/qstyle_p.h styles/qstyleanimation_p.h styles/qstylehelper_p.h styles/qstylesheetstyle_p.h styles/qwindowscestyle_p.h styles/qwindowscestyle_p_p.h styles/qwindowsmobilestyle_p.h styles/qwindowsmobilestyle_p_p.h styles/qwindowsstyle_p.h styles/qwindowsstyle_p_p.h styles/qwindowsvistastyle_p.h styles/qwindowsvistastyle_p_p.h styles/qwindowsxpstyle_p.h styles/qwindowsxpstyle_p_p.h util/qcompleter_p.h util/qflickgesture_p.h util/qscroller_p.h util/qscrollerproperties_p.h util/qsystemtrayicon_p.h util/qundostack_p.h widgets/qabstractbutton_p.h widgets/qabstractscrollarea_p.h widgets/qabstractslider_p.h widgets/qabstractspinbox_p.h widgets/qcalendartextnavigator_p.h widgets/qcombobox_p.h widgets/qdatetimeedit_p.h widgets/qdockarealayout_p.h widgets/qdockwidget_p.h widgets/qeffects_p.h widgets/qframe_p.h widgets/qkeysequenceedit_p.h widgets/qlabel_p.h widgets/qlineedit_p.h widgets/qmainwindowlayout_p.h widgets/qmdiarea_p.h widgets/qmdisubwindow_p.h widgets/qmenu_p.h widgets/qmenu_wince_resource_p.h widgets/qmenubar_p.h widgets/qplaintextedit_p.h widgets/qpushbutton_p.h widgets/qscrollarea_p.h widgets/qscrollbar_p.h widgets/qsplitter_p.h widgets/qtabbar_p.h widgets/qtextedit_p.h widgets/qtoolbar_p.h widgets/qtoolbararealayout_p.h widgets/qtoolbarextension_p.h widgets/qtoolbarlayout_p.h widgets/qtoolbarseparator_p.h widgets/qwidgetanimator_p.h widgets/qwidgetlinecontrol_p.h widgets/qwidgetresizehandler_p.h widgets/qwidgettextcontrol_p.h widgets/qwidgettextcontrol_p_p.h 
+SYNCQT.HEADER_FILES = accessible/qaccessiblewidget.h dialogs/qcolordialog.h dialogs/qdialog.h dialogs/qerrormessage.h dialogs/qfiledialog.h dialogs/qfilesystemmodel.h dialogs/qfontdialog.h dialogs/qinputdialog.h dialogs/qmessagebox.h dialogs/qprogressdialog.h dialogs/qwizard.h effects/qgraphicseffect.h graphicsview/qgraphicsanchorlayout.h graphicsview/qgraphicsgridlayout.h graphicsview/qgraphicsitem.h graphicsview/qgraphicsitemanimation.h graphicsview/qgraphicslayout.h graphicsview/qgraphicslayoutitem.h graphicsview/qgraphicslinearlayout.h graphicsview/qgraphicsproxywidget.h graphicsview/qgraphicsscene.h graphicsview/qgraphicssceneevent.h graphicsview/qgraphicstransform.h graphicsview/qgraphicsview.h graphicsview/qgraphicswidget.h itemviews/qabstractitemdelegate.h itemviews/qabstractitemview.h itemviews/qcolumnview.h itemviews/qdatawidgetmapper.h itemviews/qdirmodel.h itemviews/qfileiconprovider.h itemviews/qheaderview.h itemviews/qitemdelegate.h itemviews/qitemeditorfactory.h itemviews/qlistview.h itemviews/qlistwidget.h itemviews/qstyleditemdelegate.h itemviews/qtableview.h itemviews/qtablewidget.h itemviews/qtreeview.h itemviews/qtreewidget.h itemviews/qtreewidgetitemiterator.h kernel/qaction.h kernel/qactiongroup.h kernel/qapplication.h kernel/qboxlayout.h kernel/qdesktopwidget.h kernel/qformlayout.h kernel/qgesture.h kernel/qgesturerecognizer.h kernel/qgridlayout.h kernel/qlayout.h kernel/qlayoutitem.h kernel/qshortcut.h kernel/qsizepolicy.h kernel/qstackedlayout.h kernel/qtooltip.h kernel/qwhatsthis.h kernel/qwidget.h kernel/qwidgetaction.h kernel/qwidgetsfunctions_wince.h statemachine/qkeyeventtransition.h statemachine/qmouseeventtransition.h styles/qcommonstyle.h styles/qdrawutil.h styles/qproxystyle.h styles/qstyle.h styles/qstylefactory.h styles/qstyleoption.h styles/qstylepainter.h styles/qstyleplugin.h util/qcolormap.h util/qcompleter.h util/qscroller.h util/qscrollerproperties.h util/qsystemtrayicon.h util/qundogroup.h util/qundostack.h util/qundoview.h widgets/qabstractbutton.h widgets/qabstractscrollarea.h widgets/qabstractslider.h widgets/qabstractslider64.h widgets/qabstractspinbox.h widgets/qbuttongroup.h widgets/qcalendarwidget.h widgets/qcheckbox.h widgets/qcombobox.h widgets/qcommandlinkbutton.h widgets/qdatetimeedit.h widgets/qdial.h widgets/qdialogbuttonbox.h widgets/qdockwidget.h widgets/qfocusframe.h widgets/qfontcombobox.h widgets/qframe.h widgets/qgroupbox.h widgets/qkeysequenceedit.h widgets/qlabel.h widgets/qlcdnumber.h widgets/qlineedit.h widgets/qmaccocoaviewcontainer_mac.h widgets/qmacnativewidget_mac.h widgets/qmainwindow.h widgets/qmdiarea.h widgets/qmdisubwindow.h widgets/qmenu.h widgets/qmenubar.h widgets/qplaintextedit.h widgets/qprogressbar.h widgets/qpushbutton.h widgets/qradiobutton.h widgets/qrubberband.h widgets/qscrollarea.h widgets/qscrollbar.h widgets/qscrollbar64.h widgets/qsizegrip.h widgets/qslider.h widgets/qspinbox.h widgets/qsplashscreen.h widgets/qsplitter.h widgets/qstackedwidget.h widgets/qstatusbar.h widgets/qtabbar.h widgets/qtabwidget.h widgets/qtextbrowser.h widgets/qtextedit.h widgets/qtoolbar.h widgets/qtoolbox.h widgets/qtoolbutton.h ../../include/QtWidgets/qtwidgetsversion.h ../../include/QtWidgets/QtWidgets 
+SYNCQT.HEADER_CLASSES = ../../include/QtWidgets/QAccessibleWidget ../../include/QtWidgets/QColorDialog ../../include/QtWidgets/QDialog ../../include/QtWidgets/QErrorMessage ../../include/QtWidgets/QFileDialog ../../include/QtWidgets/QFileSystemModel ../../include/QtWidgets/QFontDialog ../../include/QtWidgets/QInputDialog ../../include/QtWidgets/QMessageBox ../../include/QtWidgets/QProgressDialog ../../include/QtWidgets/QWizard ../../include/QtWidgets/QWizardPage ../../include/QtWidgets/QGraphicsEffect ../../include/QtWidgets/QGraphicsColorizeEffect ../../include/QtWidgets/QGraphicsBlurEffect ../../include/QtWidgets/QGraphicsDropShadowEffect ../../include/QtWidgets/QGraphicsOpacityEffect ../../include/QtWidgets/QGraphicsAnchor ../../include/QtWidgets/QGraphicsAnchorLayout ../../include/QtWidgets/QGraphicsGridLayout ../../include/QtWidgets/QGraphicsItem ../../include/QtWidgets/QGraphicsObject ../../include/QtWidgets/QAbstractGraphicsShapeItem ../../include/QtWidgets/QGraphicsPathItem ../../include/QtWidgets/QGraphicsRectItem ../../include/QtWidgets/QGraphicsEllipseItem ../../include/QtWidgets/QGraphicsPolygonItem ../../include/QtWidgets/QGraphicsLineItem ../../include/QtWidgets/QGraphicsPixmapItem ../../include/QtWidgets/QGraphicsTextItem ../../include/QtWidgets/QGraphicsSimpleTextItem ../../include/QtWidgets/QGraphicsItemGroup ../../include/QtWidgets/QGraphicsItemAnimation ../../include/QtWidgets/QGraphicsLayout ../../include/QtWidgets/QGraphicsLayoutItem ../../include/QtWidgets/QGraphicsLinearLayout ../../include/QtWidgets/QGraphicsProxyWidget ../../include/QtWidgets/QGraphicsScene ../../include/QtWidgets/QGraphicsSceneEvent ../../include/QtWidgets/QGraphicsSceneMouseEvent ../../include/QtWidgets/QGraphicsSceneWheelEvent ../../include/QtWidgets/QGraphicsSceneContextMenuEvent ../../include/QtWidgets/QGraphicsSceneHoverEvent ../../include/QtWidgets/QGraphicsSceneHelpEvent ../../include/QtWidgets/QGraphicsSceneDragDropEvent ../../include/QtWidgets/QGraphicsSceneResizeEvent ../../include/QtWidgets/QGraphicsSceneMoveEvent ../../include/QtWidgets/QGraphicsTransform ../../include/QtWidgets/QGraphicsScale ../../include/QtWidgets/QGraphicsRotation ../../include/QtWidgets/QGraphicsView ../../include/QtWidgets/QGraphicsWidget ../../include/QtWidgets/QAbstractItemDelegate ../../include/QtWidgets/QAbstractItemView ../../include/QtWidgets/QColumnView ../../include/QtWidgets/QDataWidgetMapper ../../include/QtWidgets/QDirModel ../../include/QtWidgets/QFileIconProvider ../../include/QtWidgets/QHeaderView ../../include/QtWidgets/QItemDelegate ../../include/QtWidgets/QItemEditorCreatorBase ../../include/QtWidgets/QItemEditorCreator ../../include/QtWidgets/QStandardItemEditorCreator ../../include/QtWidgets/QItemEditorFactory ../../include/QtWidgets/QListView ../../include/QtWidgets/QListWidgetItem ../../include/QtWidgets/QListWidget ../../include/QtWidgets/QStyledItemDelegate ../../include/QtWidgets/QTableView ../../include/QtWidgets/QTableWidgetSelectionRange ../../include/QtWidgets/QTableWidgetItem ../../include/QtWidgets/QTableWidget ../../include/QtWidgets/QTreeView ../../include/QtWidgets/QTreeWidgetItem ../../include/QtWidgets/QTreeWidget ../../include/QtWidgets/QTreeWidgetItemIterator ../../include/QtWidgets/QAction ../../include/QtWidgets/QActionGroup ../../include/QtWidgets/QApplication ../../include/QtWidgets/QBoxLayout ../../include/QtWidgets/QHBoxLayout ../../include/QtWidgets/QVBoxLayout ../../include/QtWidgets/QDesktopWidget ../../include/QtWidgets/QFormLayout ../../include/QtWidgets/QGesture ../../include/QtWidgets/QPanGesture ../../include/QtWidgets/QPinchGesture ../../include/QtWidgets/QSwipeGesture ../../include/QtWidgets/QTapGesture ../../include/QtWidgets/QTapAndHoldGesture ../../include/QtWidgets/QGestureEvent ../../include/QtWidgets/QGestureRecognizer ../../include/QtWidgets/QGridLayout ../../include/QtWidgets/QLayout ../../include/QtWidgets/QLayoutItem ../../include/QtWidgets/QSpacerItem ../../include/QtWidgets/QWidgetItem ../../include/QtWidgets/QWidgetItemV2 ../../include/QtWidgets/QShortcut ../../include/QtWidgets/QSizePolicy ../../include/QtWidgets/QStackedLayout ../../include/QtWidgets/QToolTip ../../include/QtWidgets/QWhatsThis ../../include/QtWidgets/QWidgetData ../../include/QtWidgets/QWidget ../../include/QtWidgets/QWidgetAction ../../include/QtWidgets/QKeyEventTransition ../../include/QtWidgets/QMouseEventTransition ../../include/QtWidgets/QCommonStyle ../../include/QtWidgets/QTileRules ../../include/QtWidgets/QProxyStyle ../../include/QtWidgets/QStyle ../../include/QtWidgets/QStyleFactory ../../include/QtWidgets/QStyleOption ../../include/QtWidgets/QStyleOptionFocusRect ../../include/QtWidgets/QStyleOptionFrame ../../include/QtWidgets/QStyleOptionFrameV2 ../../include/QtWidgets/QStyleOptionFrameV3 ../../include/QtWidgets/QStyleOptionTabWidgetFrame ../../include/QtWidgets/QStyleOptionTabWidgetFrameV2 ../../include/QtWidgets/QStyleOptionTabBarBase ../../include/QtWidgets/QStyleOptionTabBarBaseV2 ../../include/QtWidgets/QStyleOptionHeader ../../include/QtWidgets/QStyleOptionButton ../../include/QtWidgets/QStyleOptionTab ../../include/QtWidgets/QStyleOptionTabV2 ../../include/QtWidgets/QStyleOptionTabV3 ../../include/QtWidgets/QStyleOptionToolBar ../../include/QtWidgets/QStyleOptionProgressBar ../../include/QtWidgets/QStyleOptionProgressBarV2 ../../include/QtWidgets/QStyleOptionMenuItem ../../include/QtWidgets/QStyleOptionDockWidget ../../include/QtWidgets/QStyleOptionDockWidgetV2 ../../include/QtWidgets/QStyleOptionViewItem ../../include/QtWidgets/QStyleOptionViewItemV2 ../../include/QtWidgets/QStyleOptionViewItemV3 ../../include/QtWidgets/QStyleOptionViewItemV4 ../../include/QtWidgets/QStyleOptionToolBox ../../include/QtWidgets/QStyleOptionToolBoxV2 ../../include/QtWidgets/QStyleOptionRubberBand ../../include/QtWidgets/QStyleOptionComplex ../../include/QtWidgets/QStyleOptionSlider ../../include/QtWidgets/QStyleOptionSlider64 ../../include/QtWidgets/QStyleOptionSpinBox ../../include/QtWidgets/QStyleOptionToolButton ../../include/QtWidgets/QStyleOptionComboBox ../../include/QtWidgets/QStyleOptionTitleBar ../../include/QtWidgets/QStyleOptionGroupBox ../../include/QtWidgets/QStyleOptionSizeGrip ../../include/QtWidgets/QStyleOptionGraphicsItem ../../include/QtWidgets/QStyleHintReturn ../../include/QtWidgets/QStyleHintReturnMask ../../include/QtWidgets/QStyleHintReturnVariant ../../include/QtWidgets/QStylePainter ../../include/QtWidgets/QStylePlugin ../../include/QtWidgets/QColormap ../../include/QtWidgets/QCompleter ../../include/QtWidgets/QScroller ../../include/QtWidgets/QScrollerProperties ../../include/QtWidgets/QSystemTrayIcon ../../include/QtWidgets/QUndoGroup ../../include/QtWidgets/QUndoCommand ../../include/QtWidgets/QUndoStack ../../include/QtWidgets/QUndoView ../../include/QtWidgets/QAbstractButton ../../include/QtWidgets/QAbstractScrollArea ../../include/QtWidgets/QAbstractSlider ../../include/QtWidgets/QAbstractSlider64 ../../include/QtWidgets/QAbstractSpinBox ../../include/QtWidgets/QButtonGroup ../../include/QtWidgets/QCalendarWidget ../../include/QtWidgets/QCheckBox ../../include/QtWidgets/QComboBox ../../include/QtWidgets/QCommandLinkButton ../../include/QtWidgets/QDateTimeEdit ../../include/QtWidgets/QTimeEdit ../../include/QtWidgets/QDateEdit ../../include/QtWidgets/QDial ../../include/QtWidgets/QDialogButtonBox ../../include/QtWidgets/QDockWidget ../../include/QtWidgets/QFocusFrame ../../include/QtWidgets/QFontComboBox ../../include/QtWidgets/QFrame ../../include/QtWidgets/QGroupBox ../../include/QtWidgets/QKeySequenceEdit ../../include/QtWidgets/QLabel ../../include/QtWidgets/QLCDNumber ../../include/QtWidgets/QLineEdit ../../include/QtWidgets/QMacCocoaViewContainer ../../include/QtWidgets/QMacNativeWidget ../../include/QtWidgets/QMainWindow ../../include/QtWidgets/QMdiArea ../../include/QtWidgets/QMdiSubWindow ../../include/QtWidgets/QMenu ../../include/QtWidgets/QMenuBar ../../include/QtWidgets/QPlainTextEdit ../../include/QtWidgets/QPlainTextDocumentLayout ../../include/QtWidgets/QProgressBar ../../include/QtWidgets/QPushButton ../../include/QtWidgets/QRadioButton ../../include/QtWidgets/QRubberBand ../../include/QtWidgets/QScrollArea ../../include/QtWidgets/QScrollBar ../../include/QtWidgets/QScrollBar64 ../../include/QtWidgets/QSizeGrip ../../include/QtWidgets/QSlider ../../include/QtWidgets/QSpinBox ../../include/QtWidgets/QDoubleSpinBox ../../include/QtWidgets/QSplashScreen ../../include/QtWidgets/QSplitter ../../include/QtWidgets/QSplitterHandle ../../include/QtWidgets/QStackedWidget ../../include/QtWidgets/QStatusBar ../../include/QtWidgets/QTabBar ../../include/QtWidgets/QTabWidget ../../include/QtWidgets/QTextBrowser ../../include/QtWidgets/QTextEdit ../../include/QtWidgets/QToolBar ../../include/QtWidgets/QToolBox ../../include/QtWidgets/QToolButton ../../include/QtWidgets/QtWidgetsVersion 
+SYNCQT.PRIVATE_HEADER_FILES = dialogs/qcolordialog_p.h dialogs/qdialog_p.h dialogs/qfiledialog_p.h dialogs/qfileinfogatherer_p.h dialogs/qfilesystemmodel_p.h dialogs/qfontdialog_p.h dialogs/qfscompleter_p.h dialogs/qsidebar_p.h dialogs/qwizard_win_p.h effects/qgraphicseffect_p.h effects/qpixmapfilter_p.h graphicsview/qgraph_p.h graphicsview/qgraphicsanchorlayout_p.h graphicsview/qgraphicsgridlayoutengine_p.h graphicsview/qgraphicsitem_p.h graphicsview/qgraphicslayout_p.h graphicsview/qgraphicslayoutitem_p.h graphicsview/qgraphicslayoutstyleinfo_p.h graphicsview/qgraphicsproxywidget_p.h graphicsview/qgraphicsscene_bsp_p.h graphicsview/qgraphicsscene_p.h graphicsview/qgraphicsscenebsptreeindex_p.h graphicsview/qgraphicssceneindex_p.h graphicsview/qgraphicsscenelinearindex_p.h graphicsview/qgraphicstransform_p.h graphicsview/qgraphicsview_p.h graphicsview/qgraphicswidget_p.h graphicsview/qsimplex_p.h itemviews/qabstractitemview_p.h itemviews/qbsptree_p.h itemviews/qcolumnview_p.h itemviews/qcolumnviewgrip_p.h itemviews/qfileiconprovider_p.h itemviews/qheaderview_p.h itemviews/qitemeditorfactory_p.h itemviews/qlistview_p.h itemviews/qlistwidget_p.h itemviews/qtableview_p.h itemviews/qtablewidget_p.h itemviews/qtreeview_p.h itemviews/qtreewidget_p.h itemviews/qtreewidgetitemiterator_p.h itemviews/qwidgetitemdata_p.h kernel/qaction_p.h kernel/qapplication_p.h kernel/qdesktopwidget_qpa_p.h kernel/qgesture_p.h kernel/qgesturemanager_p.h kernel/qlayout_p.h kernel/qlayoutengine_p.h kernel/qmacgesturerecognizer_p.h kernel/qopenglwidget_p.h kernel/qstandardgestures_p.h kernel/qt_widgets_pch.h kernel/qwidget_p.h kernel/qwidgetaction_p.h kernel/qwidgetbackingstore_p.h kernel/qwidgetwindow_qpa_p.h kernel/qwindowcontainer_p.h statemachine/qbasickeyeventtransition_p.h statemachine/qbasicmouseeventtransition_p.h styles/qandroidstyle_p.h styles/qcommonstyle_p.h styles/qcommonstylepixmaps_p.h styles/qfusionstyle_p.h styles/qfusionstyle_p_p.h styles/qgtk2painter_p.h styles/qgtkglobal_p.h styles/qgtkpainter_p.h styles/qgtkstyle_p.h styles/qgtkstyle_p_p.h styles/qmacstyle_mac_p.h styles/qmacstyle_mac_p_p.h styles/qproxystyle_p.h styles/qstyle_p.h styles/qstyleanimation_p.h styles/qstylehelper_p.h styles/qstylesheetstyle_p.h styles/qwindowscestyle_p.h styles/qwindowscestyle_p_p.h styles/qwindowsmobilestyle_p.h styles/qwindowsmobilestyle_p_p.h styles/qwindowsstyle_p.h styles/qwindowsstyle_p_p.h styles/qwindowsvistastyle_p.h styles/qwindowsvistastyle_p_p.h styles/qwindowsxpstyle_p.h styles/qwindowsxpstyle_p_p.h util/qcompleter_p.h util/qflickgesture_p.h util/qscroller_p.h util/qscrollerproperties_p.h util/qsystemtrayicon_p.h util/qundostack_p.h widgets/qabstractbutton_p.h widgets/qabstractscrollarea_p.h widgets/qabstractslider_p.h widgets/qabstractslider64_p.h widgets/qabstractspinbox_p.h widgets/qcalendartextnavigator_p.h widgets/qcombobox_p.h widgets/qdatetimeedit_p.h widgets/qdockarealayout_p.h widgets/qdockwidget_p.h widgets/qeffects_p.h widgets/qframe_p.h widgets/qkeysequenceedit_p.h widgets/qlabel_p.h widgets/qlineedit_p.h widgets/qmainwindowlayout_p.h widgets/qmdiarea_p.h widgets/qmdisubwindow_p.h widgets/qmenu_p.h widgets/qmenu_wince_resource_p.h widgets/qmenubar_p.h widgets/qplaintextedit_p.h widgets/qpushbutton_p.h widgets/qscrollarea_p.h widgets/qscrollbar_p.h widgets/qsplitter_p.h widgets/qtabbar_p.h widgets/qtextedit_p.h widgets/qtoolbar_p.h widgets/qtoolbararealayout_p.h widgets/qtoolbarextension_p.h widgets/qtoolbarlayout_p.h widgets/qtoolbarseparator_p.h widgets/qwidgetanimator_p.h widgets/qwidgetlinecontrol_p.h widgets/qwidgetresizehandler_p.h widgets/qwidgettextcontrol_p.h widgets/qwidgettextcontrol_p_p.h 
 SYNCQT.QPA_HEADER_FILES = 
 SYNCQT.INJECTIONS =
diff --git a/src/widgets/styles/qcommonstyle.cpp b/src/widgets/styles/qcommonstyle.cpp
index 27fef46..578e29b 100644
--- a/src/widgets/styles/qcommonstyle.cpp
+++ b/src/widgets/styles/qcommonstyle.cpp
@@ -3075,6 +3075,153 @@ static QPolygonF calcArrow(const QStyleOptionSlider *dial, qreal &a)
 
 #endif // QT_NO_DIAL
 
+template <class OptionSlider>
+static void drawSlider(const QStyleOptionComplex* opt, const QWidget* widget, QPainter* p, const QStyle* proxy)
+{
+	if (const OptionSlider *slider = qstyleoption_cast<const OptionSlider*>(opt)) {
+		if (slider->subControls == QCommonStyle::SC_SliderTickmarks) {
+			int tickOffset = proxy->pixelMetric(QCommonStyle::PM_SliderTickmarkOffset, slider, widget);
+			int ticks = slider->tickPosition;
+			int thickness = proxy->pixelMetric(QCommonStyle::PM_SliderControlThickness, slider, widget);
+			int len = proxy->pixelMetric(QCommonStyle::PM_SliderLength, slider, widget);
+			qint64 available = proxy->pixelMetric(QCommonStyle::PM_SliderSpaceAvailable, slider, widget);
+			qint64 interval = slider->tickInterval;
+			if (interval <= 0) {
+				interval = slider->singleStep;
+				if (QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum, interval,
+													available)
+					- QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum,
+													  (qint64) 0, available) < 3)
+					interval = slider->pageStep;
+			}
+			if (!interval)
+				interval = 1;
+			int fudge = len / 2;
+			qint64 pos;
+			// Since there is no subrect for tickmarks do a translation here.
+			p->save();
+			p->translate(slider->rect.x(), slider->rect.y());
+			p->setPen(slider->palette.foreground().color());
+			qint64 v = slider->minimum;
+			while (v <= slider->maximum + 1) {
+				if (v == slider->maximum + 1 && interval == 1)
+					break;
+				const qint64 v_ = qMin(v, (qint64) slider->maximum);
+				pos = QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum,
+													  v_, available) + fudge;
+				if (slider->orientation == Qt::Horizontal) {
+					if (ticks & QSlider::TicksAbove)
+						p->drawLine(pos, 0, pos, tickOffset - 2);
+					if (ticks & QSlider::TicksBelow)
+						p->drawLine(pos, tickOffset + thickness + 1, pos,
+									slider->rect.height()-1);
+				} else {
+					if (ticks & QSlider::TicksAbove)
+						p->drawLine(0, pos, tickOffset - 2, pos);
+					if (ticks & QSlider::TicksBelow)
+						p->drawLine(tickOffset + thickness + 1, pos,
+									slider->rect.width()-1, pos);
+				}
+				// in the case where maximum is max int
+				qint64 nextInterval = v + interval;
+				if (nextInterval < v)
+					break;
+				v = nextInterval;
+			}
+			p->restore();
+		}
+	}
+}
+
+template <class OptionStyle>
+static void drawScrollBar(const QStyleOptionComplex* opt, QCommonStyle::ComplexControl cc, const QWidget* widget, QPainter* p, QStyle const* proxy)
+{
+	if (const OptionStyle *scrollbar = qstyleoption_cast<const OptionStyle *>(opt)) {
+		// Make a copy here and reset it for each primitive.
+		OptionStyle newScrollbar = *scrollbar;
+		QCommonStyle::State saveFlags = scrollbar->state;
+
+		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarSubLine) {
+			newScrollbar.state = saveFlags;
+			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarSubLine, widget);
+			if (newScrollbar.rect.isValid()) {
+				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarSubLine))
+					newScrollbar.state &= ~(QCommonStyle::QCommonStyle::State_Sunken | QCommonStyle::QCommonStyle::State_MouseOver);
+				proxy->drawControl(QCommonStyle::QCommonStyle::CE_ScrollBarSubLine, &newScrollbar, p, widget);
+			}
+		}
+		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarAddLine) {
+			newScrollbar.rect = scrollbar->rect;
+			newScrollbar.state = saveFlags;
+			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarAddLine, widget);
+			if (newScrollbar.rect.isValid()) {
+				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarAddLine))
+					newScrollbar.state &= ~(QCommonStyle::QCommonStyle::State_Sunken | QCommonStyle::QCommonStyle::State_MouseOver);
+				proxy->drawControl(QCommonStyle::QCommonStyle::CE_ScrollBarAddLine, &newScrollbar, p, widget);
+			}
+		}
+		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarSubPage) {
+			newScrollbar.rect = scrollbar->rect;
+			newScrollbar.state = saveFlags;
+			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarSubPage, widget);
+			if (newScrollbar.rect.isValid()) {
+				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarSubPage))
+					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
+				proxy->drawControl(QCommonStyle::CE_ScrollBarSubPage, &newScrollbar, p, widget);
+			}
+		}
+		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarAddPage) {
+			newScrollbar.rect = scrollbar->rect;
+			newScrollbar.state = saveFlags;
+			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarAddPage, widget);
+			if (newScrollbar.rect.isValid()) {
+				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarAddPage))
+					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
+				proxy->drawControl(QCommonStyle::CE_ScrollBarAddPage, &newScrollbar, p, widget);
+			}
+		}
+		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarFirst) {
+			newScrollbar.rect = scrollbar->rect;
+			newScrollbar.state = saveFlags;
+			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarFirst, widget);
+			if (newScrollbar.rect.isValid()) {
+				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarFirst))
+					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
+				proxy->drawControl(QCommonStyle::CE_ScrollBarFirst, &newScrollbar, p, widget);
+			}
+		}
+		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarLast) {
+			newScrollbar.rect = scrollbar->rect;
+			newScrollbar.state = saveFlags;
+			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarLast, widget);
+			if (newScrollbar.rect.isValid()) {
+				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarLast))
+					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
+				proxy->drawControl(QCommonStyle::CE_ScrollBarLast, &newScrollbar, p, widget);
+			}
+		}
+		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarSlider) {
+			newScrollbar.rect = scrollbar->rect;
+			newScrollbar.state = saveFlags;
+			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarSlider, widget);
+			if (newScrollbar.rect.isValid()) {
+				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarSlider))
+					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
+				proxy->drawControl(QCommonStyle::CE_ScrollBarSlider, &newScrollbar, p, widget);
+
+				if (scrollbar->state & QCommonStyle::State_HasFocus) {
+					QStyleOptionFocusRect fropt;
+					fropt.QStyleOption::operator=(newScrollbar);
+					fropt.rect.setRect(newScrollbar.rect.x() + 2, newScrollbar.rect.y() + 2,
+									   newScrollbar.rect.width() - 5,
+									   newScrollbar.rect.height() - 5);
+					proxy->drawPrimitive(QCommonStyle::PE_FrameFocusRect, &fropt, p, widget);
+				}
+			}
+		}
+	}
+}
+
 /*!
   \reimp
 */
@@ -3084,147 +3231,18 @@ void QCommonStyle::drawComplexControl(ComplexControl cc, const QStyleOptionCompl
     switch (cc) {
 #ifndef QT_NO_SLIDER
     case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
-            if (slider->subControls == SC_SliderTickmarks) {
-                int tickOffset = proxy()->pixelMetric(PM_SliderTickmarkOffset, slider, widget);
-                int ticks = slider->tickPosition;
-                int thickness = proxy()->pixelMetric(PM_SliderControlThickness, slider, widget);
-                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
-                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
-                int interval = slider->tickInterval;
-                if (interval <= 0) {
-                    interval = slider->singleStep;
-                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
-                                                        available)
-                        - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                          0, available) < 3)
-                        interval = slider->pageStep;
-                }
-                if (!interval)
-                    interval = 1;
-                int fudge = len / 2;
-                int pos;
-                // Since there is no subrect for tickmarks do a translation here.
-                p->save();
-                p->translate(slider->rect.x(), slider->rect.y());
-                p->setPen(slider->palette.foreground().color());
-                int v = slider->minimum;
-                while (v <= slider->maximum + 1) {
-                    if (v == slider->maximum + 1 && interval == 1)
-                        break;
-                    const int v_ = qMin(v, slider->maximum);
-                    pos = QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                          v_, available) + fudge;
-                    if (slider->orientation == Qt::Horizontal) {
-                        if (ticks & QSlider::TicksAbove)
-                            p->drawLine(pos, 0, pos, tickOffset - 2);
-                        if (ticks & QSlider::TicksBelow)
-                            p->drawLine(pos, tickOffset + thickness + 1, pos,
-                                        slider->rect.height()-1);
-                    } else {
-                        if (ticks & QSlider::TicksAbove)
-                            p->drawLine(0, pos, tickOffset - 2, pos);
-                        if (ticks & QSlider::TicksBelow)
-                            p->drawLine(tickOffset + thickness + 1, pos,
-                                        slider->rect.width()-1, pos);
-                    }
-                    // in the case where maximum is max int
-                    int nextInterval = v + interval;
-                    if (nextInterval < v)
-                        break;
-                    v = nextInterval;
-                }
-                p->restore();
-            }
-        }
+		drawSlider<QStyleOptionSlider>(opt, widget, p, proxy());
+        break;
+    case CC_Slider64:
+		drawSlider<QStyleOptionSlider64>(opt, widget, p, proxy());
         break;
 #endif // QT_NO_SLIDER
 #ifndef QT_NO_SCROLLBAR
     case CC_ScrollBar:
-        if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
-            // Make a copy here and reset it for each primitive.
-            QStyleOptionSlider newScrollbar = *scrollbar;
-            State saveFlags = scrollbar->state;
-
-            if (scrollbar->subControls & SC_ScrollBarSubLine) {
-                newScrollbar.state = saveFlags;
-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarSubLine, widget);
-                if (newScrollbar.rect.isValid()) {
-                    if (!(scrollbar->activeSubControls & SC_ScrollBarSubLine))
-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
-                    proxy()->drawControl(CE_ScrollBarSubLine, &newScrollbar, p, widget);
-                }
-            }
-            if (scrollbar->subControls & SC_ScrollBarAddLine) {
-                newScrollbar.rect = scrollbar->rect;
-                newScrollbar.state = saveFlags;
-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarAddLine, widget);
-                if (newScrollbar.rect.isValid()) {
-                    if (!(scrollbar->activeSubControls & SC_ScrollBarAddLine))
-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
-                    proxy()->drawControl(CE_ScrollBarAddLine, &newScrollbar, p, widget);
-                }
-            }
-            if (scrollbar->subControls & SC_ScrollBarSubPage) {
-                newScrollbar.rect = scrollbar->rect;
-                newScrollbar.state = saveFlags;
-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarSubPage, widget);
-                if (newScrollbar.rect.isValid()) {
-                    if (!(scrollbar->activeSubControls & SC_ScrollBarSubPage))
-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
-                    proxy()->drawControl(CE_ScrollBarSubPage, &newScrollbar, p, widget);
-                }
-            }
-            if (scrollbar->subControls & SC_ScrollBarAddPage) {
-                newScrollbar.rect = scrollbar->rect;
-                newScrollbar.state = saveFlags;
-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarAddPage, widget);
-                if (newScrollbar.rect.isValid()) {
-                    if (!(scrollbar->activeSubControls & SC_ScrollBarAddPage))
-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
-                    proxy()->drawControl(CE_ScrollBarAddPage, &newScrollbar, p, widget);
-                }
-            }
-            if (scrollbar->subControls & SC_ScrollBarFirst) {
-                newScrollbar.rect = scrollbar->rect;
-                newScrollbar.state = saveFlags;
-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarFirst, widget);
-                if (newScrollbar.rect.isValid()) {
-                    if (!(scrollbar->activeSubControls & SC_ScrollBarFirst))
-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
-                    proxy()->drawControl(CE_ScrollBarFirst, &newScrollbar, p, widget);
-                }
-            }
-            if (scrollbar->subControls & SC_ScrollBarLast) {
-                newScrollbar.rect = scrollbar->rect;
-                newScrollbar.state = saveFlags;
-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarLast, widget);
-                if (newScrollbar.rect.isValid()) {
-                    if (!(scrollbar->activeSubControls & SC_ScrollBarLast))
-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
-                    proxy()->drawControl(CE_ScrollBarLast, &newScrollbar, p, widget);
-                }
-            }
-            if (scrollbar->subControls & SC_ScrollBarSlider) {
-                newScrollbar.rect = scrollbar->rect;
-                newScrollbar.state = saveFlags;
-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarSlider, widget);
-                if (newScrollbar.rect.isValid()) {
-                    if (!(scrollbar->activeSubControls & SC_ScrollBarSlider))
-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
-                    proxy()->drawControl(CE_ScrollBarSlider, &newScrollbar, p, widget);
-
-                    if (scrollbar->state & State_HasFocus) {
-                        QStyleOptionFocusRect fropt;
-                        fropt.QStyleOption::operator=(newScrollbar);
-                        fropt.rect.setRect(newScrollbar.rect.x() + 2, newScrollbar.rect.y() + 2,
-                                           newScrollbar.rect.width() - 5,
-                                           newScrollbar.rect.height() - 5);
-                        proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, p, widget);
-                    }
-                }
-            }
-        }
+		drawScrollBar<QStyleOptionSlider>(opt, cc, widget, p, proxy());
+        break;
+    case CC_ScrollBar64:
+		drawScrollBar<QStyleOptionSlider64>(opt, cc, widget, p, proxy());
         break;
 #endif // QT_NO_SCROLLBAR
 #ifndef QT_NO_SPINBOX
@@ -3756,6 +3774,92 @@ void QCommonStyle::drawComplexControl(ComplexControl cc, const QStyleOptionCompl
     }
 }
 
+template <class OptionStyle, class Class>
+void hitTestComplexControlScrollbar(const QStyleOptionComplex* opt, const QWidget* widget, QCommonStyle::SubControl sc, QRect& ret, QStyle const* proxy, Class* c)
+{
+        if (const OptionStyle *scrollbar = qstyleoption_cast<const OptionStyle*>(opt)) {
+            const QRect scrollBarRect = scrollbar->rect;
+            int sbextent = 0;
+            if (!proxy->styleHint(QStyle::SH_ScrollBar_Transient, scrollbar, widget))
+                sbextent = proxy->pixelMetric(QStyle::PM_ScrollBarExtent, scrollbar, widget);
+            int maxlen = ((scrollbar->orientation == Qt::Horizontal) ?
+                          scrollBarRect.width() : scrollBarRect.height()) - (sbextent * 2);
+            int sliderlen;
+
+            // calculate slider length
+            if (scrollbar->maximum != scrollbar->minimum) {
+                uint range = scrollbar->maximum - scrollbar->minimum;
+                sliderlen = (qint64(scrollbar->pageStep) * maxlen) / (range + scrollbar->pageStep);
+
+                int slidermin = proxy->pixelMetric(QCommonStyle::PM_ScrollBarSliderMin, scrollbar, widget);
+                if (sliderlen < slidermin || range > INT_MAX / 2)
+                    sliderlen = slidermin;
+                if (sliderlen > maxlen)
+                    sliderlen = maxlen;
+            } else {
+                sliderlen = maxlen;
+            }
+
+            int sliderstart = sbextent + QStyle::sliderPositionFromValue((qint64)scrollbar->minimum,
+                                                                         (qint64) scrollbar->maximum,
+                                                                         (qint64)scrollbar->sliderPosition,
+                                                                         (qint64)maxlen - sliderlen,
+                                                                         scrollbar->upsideDown);
+
+            switch (sc) {
+            case QStyle::SC_ScrollBarSubLine:            // top/left button
+                if (scrollbar->orientation == Qt::Horizontal) {
+                    int buttonWidth = qMin(scrollBarRect.width() / 2, sbextent);
+                    ret.setRect(0, 0, buttonWidth, scrollBarRect.height());
+                } else {
+                    int buttonHeight = qMin(scrollBarRect.height() / 2, sbextent);
+                    ret.setRect(0, 0, scrollBarRect.width(), buttonHeight);
+                }
+                break;
+            case QStyle::SC_ScrollBarAddLine:            // bottom/right button
+                if (scrollbar->orientation == Qt::Horizontal) {
+                    int buttonWidth = qMin(scrollBarRect.width()/2, sbextent);
+                    ret.setRect(scrollBarRect.width() - buttonWidth, 0, buttonWidth, scrollBarRect.height());
+                } else {
+                    int buttonHeight = qMin(scrollBarRect.height()/2, sbextent);
+                    ret.setRect(0, scrollBarRect.height() - buttonHeight, scrollBarRect.width(), buttonHeight);
+                }
+                break;
+            case QStyle::SC_ScrollBarSubPage:            // between top/left button and slider
+                if (scrollbar->orientation == Qt::Horizontal)
+                    ret.setRect(sbextent, 0, sliderstart - sbextent, scrollBarRect.height());
+                else
+                    ret.setRect(0, sbextent, scrollBarRect.width(), sliderstart - sbextent);
+                break;
+            case QStyle::SC_ScrollBarAddPage:            // between bottom/right button and slider
+                if (scrollbar->orientation == Qt::Horizontal)
+                    ret.setRect(sliderstart + sliderlen, 0,
+                                maxlen - sliderstart - sliderlen + sbextent, scrollBarRect.height());
+                else
+                    ret.setRect(0, sliderstart + sliderlen, scrollBarRect.width(),
+                                maxlen - sliderstart - sliderlen + sbextent);
+                break;
+            case QStyle::SC_ScrollBarGroove:
+                if (scrollbar->orientation == Qt::Horizontal)
+                    ret.setRect(sbextent, 0, scrollBarRect.width() - sbextent * 2,
+                                scrollBarRect.height());
+                else
+                    ret.setRect(0, sbextent, scrollBarRect.width(),
+                                scrollBarRect.height() - sbextent * 2);
+                break;
+            case QStyle::SC_ScrollBarSlider:
+                if (scrollbar->orientation == Qt::Horizontal)
+                    ret.setRect(sliderstart, 0, sliderlen, scrollBarRect.height());
+                else
+                    ret.setRect(0, sliderstart, scrollBarRect.width(), sliderlen);
+                break;
+            default:
+                break;
+            }
+            ret = c->visualRect(scrollbar->direction, scrollBarRect, ret);
+        }
+}
+
 /*!
     \reimp
 */
@@ -3780,11 +3884,12 @@ QStyle::SubControl QCommonStyle::hitTestComplexControl(ComplexControl cc, const
 #endif // QT_NO_SLIDER
 #ifndef QT_NO_SCROLLBAR
     case CC_ScrollBar:
-        if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+    case CC_ScrollBar64:
+        if (qstyleoption_cast<const QStyleOptionSlider *>(opt) || qstyleoption_cast<const QStyleOptionSlider64 *>(opt)) {
             QRect r;
             uint ctrl = SC_ScrollBarAddLine;
             while (ctrl <= SC_ScrollBarGroove) {
-                r = proxy()->subControlRect(cc, scrollbar, QStyle::SubControl(ctrl), widget);
+                r = proxy()->subControlRect(cc, opt, QStyle::SubControl(ctrl), widget);
                 if (r.isValid() && r.contains(pt)) {
                     sc = QStyle::SubControl(ctrl);
                     break;
@@ -3939,87 +4044,10 @@ QRect QCommonStyle::subControlRect(ComplexControl cc, const QStyleOptionComplex
 #endif // QT_NO_SLIDER
 #ifndef QT_NO_SCROLLBAR
     case CC_ScrollBar:
-        if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
-            const QRect scrollBarRect = scrollbar->rect;
-            int sbextent = 0;
-            if (!proxy()->styleHint(SH_ScrollBar_Transient, scrollbar, widget))
-                sbextent = proxy()->pixelMetric(PM_ScrollBarExtent, scrollbar, widget);
-            int maxlen = ((scrollbar->orientation == Qt::Horizontal) ?
-                          scrollBarRect.width() : scrollBarRect.height()) - (sbextent * 2);
-            int sliderlen;
-
-            // calculate slider length
-            if (scrollbar->maximum != scrollbar->minimum) {
-                uint range = scrollbar->maximum - scrollbar->minimum;
-                sliderlen = (qint64(scrollbar->pageStep) * maxlen) / (range + scrollbar->pageStep);
-
-                int slidermin = proxy()->pixelMetric(PM_ScrollBarSliderMin, scrollbar, widget);
-                if (sliderlen < slidermin || range > INT_MAX / 2)
-                    sliderlen = slidermin;
-                if (sliderlen > maxlen)
-                    sliderlen = maxlen;
-            } else {
-                sliderlen = maxlen;
-            }
-
-            int sliderstart = sbextent + sliderPositionFromValue(scrollbar->minimum,
-                                                                 scrollbar->maximum,
-                                                                 scrollbar->sliderPosition,
-                                                                 maxlen - sliderlen,
-                                                                 scrollbar->upsideDown);
-
-            switch (sc) {
-            case SC_ScrollBarSubLine:            // top/left button
-                if (scrollbar->orientation == Qt::Horizontal) {
-                    int buttonWidth = qMin(scrollBarRect.width() / 2, sbextent);
-                    ret.setRect(0, 0, buttonWidth, scrollBarRect.height());
-                } else {
-                    int buttonHeight = qMin(scrollBarRect.height() / 2, sbextent);
-                    ret.setRect(0, 0, scrollBarRect.width(), buttonHeight);
-                }
-                break;
-            case SC_ScrollBarAddLine:            // bottom/right button
-                if (scrollbar->orientation == Qt::Horizontal) {
-                    int buttonWidth = qMin(scrollBarRect.width()/2, sbextent);
-                    ret.setRect(scrollBarRect.width() - buttonWidth, 0, buttonWidth, scrollBarRect.height());
-                } else {
-                    int buttonHeight = qMin(scrollBarRect.height()/2, sbextent);
-                    ret.setRect(0, scrollBarRect.height() - buttonHeight, scrollBarRect.width(), buttonHeight);
-                }
-                break;
-            case SC_ScrollBarSubPage:            // between top/left button and slider
-                if (scrollbar->orientation == Qt::Horizontal)
-                    ret.setRect(sbextent, 0, sliderstart - sbextent, scrollBarRect.height());
-                else
-                    ret.setRect(0, sbextent, scrollBarRect.width(), sliderstart - sbextent);
-                break;
-            case SC_ScrollBarAddPage:            // between bottom/right button and slider
-                if (scrollbar->orientation == Qt::Horizontal)
-                    ret.setRect(sliderstart + sliderlen, 0,
-                                maxlen - sliderstart - sliderlen + sbextent, scrollBarRect.height());
-                else
-                    ret.setRect(0, sliderstart + sliderlen, scrollBarRect.width(),
-                                maxlen - sliderstart - sliderlen + sbextent);
-                break;
-            case SC_ScrollBarGroove:
-                if (scrollbar->orientation == Qt::Horizontal)
-                    ret.setRect(sbextent, 0, scrollBarRect.width() - sbextent * 2,
-                                scrollBarRect.height());
-                else
-                    ret.setRect(0, sbextent, scrollBarRect.width(),
-                                scrollBarRect.height() - sbextent * 2);
-                break;
-            case SC_ScrollBarSlider:
-                if (scrollbar->orientation == Qt::Horizontal)
-                    ret.setRect(sliderstart, 0, sliderlen, scrollBarRect.height());
-                else
-                    ret.setRect(0, sliderstart, scrollBarRect.width(), sliderlen);
-                break;
-            default:
-                break;
-            }
-            ret = visualRect(scrollbar->direction, scrollBarRect, ret);
-        }
+	    hitTestComplexControlScrollbar<QStyleOptionSlider>(opt, widget, sc, ret, proxy(), this);
+        break;
+    case CC_ScrollBar64:
+	    hitTestComplexControlScrollbar<QStyleOptionSlider64>(opt, widget, sc, ret, proxy(), this);
         break;
 #endif // QT_NO_SCROLLBAR
 #ifndef QT_NO_SPINBOX
diff --git a/src/widgets/styles/qfusionstyle.cpp b/src/widgets/styles/qfusionstyle.cpp
index 012f5ea..45827f1 100644
--- a/src/widgets/styles/qfusionstyle.cpp
+++ b/src/widgets/styles/qfusionstyle.cpp
@@ -333,150 +333,744 @@ static void qt_fusion_draw_mdibutton(QPainter *painter, const QStyleOptionTitleB
     painter->drawPoint(tmp.right() , tmp.bottom() - 1);
 }
 
-/*
-    \internal
-*/
-QFusionStylePrivate::QFusionStylePrivate()
+template <class OptionStyle, class PrivClass>
+static void drawComplexControlScrollBar(QStyle::ComplexControl control,
+                                        const QStyleOptionComplex *option,
+                                        QPainter *painter, const QWidget *widget,
+                                        QStyle const* proxy,
+                                        PrivClass *d)
 {
-    animationFps = 60;
-}
+        painter->save();
+        QColor outline = d->outline(option->palette);
+        QColor buttonColor = d->buttonColor(option->palette);
+        QColor gradientStartColor = buttonColor.lighter(104);
+        QColor gradientStopColor = buttonColor.darker(102);
 
-/*!
-    \class QFusionStyle
-    \brief The QFusionStyle class provides a custom widget style
+        if (const OptionStyle *scrollBar = qstyleoption_cast<const OptionStyle *>(option)) {
+            bool wasActive = false;
+            qreal expandScale = 1.0;
+            qreal expandOffset = -1.0;
+            QObject *styleObject = option->styleObject;
+            if (styleObject && proxy->styleHint(QStyle::SH_ScrollBar_Transient, option, widget)) {
+                qreal opacity = 0.0;
+                bool shouldExpand = false;
+                const qreal maxExpandScale = 13.0 / 9.0;
 
-    \inmodule QtWidgets
-    \internal
+                int oldPos = styleObject->property("_q_stylepos").toInt();
+                int oldMin = styleObject->property("_q_stylemin").toInt();
+                int oldMax = styleObject->property("_q_stylemax").toInt();
+                QRect oldRect = styleObject->property("_q_stylerect").toRect();
+                int oldState = styleObject->property("_q_stylestate").toInt();
+                uint oldActiveControls = styleObject->property("_q_stylecontrols").toUInt();
 
-    The Fusion style provides a custom look and feel that is not
-    tied to a particular platform.
-    //{Fusion Style Widget Gallery}
-    \sa QWindowsStyle, QWindowsVistaStyle, QMacStyle, QCommonStyle
-*/
+                // a scrollbar is transient when the the scrollbar itself and
+                // its sibling are both inactive (ie. not pressed/hovered/moved)
+                bool transient = !option->activeSubControls && !(option->state & QStyle::State_On);
 
-/*!
-    Constructs a QFusionStyle object.
-*/
-QFusionStyle::QFusionStyle() : QCommonStyle(*new QFusionStylePrivate)
-{
-    setObjectName(QLatin1String("Fusion"));
-}
+                if (!transient ||
+                        oldPos != scrollBar->sliderPosition ||
+                        oldMin != scrollBar->minimum ||
+                        oldMax != scrollBar->maximum ||
+                        oldRect != scrollBar->rect ||
+                        oldState != scrollBar->state ||
+                        oldActiveControls != scrollBar->activeSubControls) {
 
-/*!
-    \internal
+                    // if the scrollbar is transient or its attributes, geometry or
+                    // state has changed, the opacity is reset back to 100% opaque
+                    opacity = 1.0;
 
-    Constructs a QFusionStyle object.
-*/
-QFusionStyle::QFusionStyle(QFusionStylePrivate &dd) : QCommonStyle(dd)
-{
-}
+                    styleObject->setProperty("_q_stylepos", scrollBar->sliderPosition);
+                    styleObject->setProperty("_q_stylemin", scrollBar->minimum);
+                    styleObject->setProperty("_q_stylemax", scrollBar->maximum);
+                    styleObject->setProperty("_q_stylerect", scrollBar->rect);
+                    styleObject->setProperty("_q_stylestate", static_cast<int>(scrollBar->state));
+                    styleObject->setProperty("_q_stylecontrols", static_cast<uint>(scrollBar->activeSubControls));
 
-/*!
-    Destroys the QFusionStyle object.
-*/
-QFusionStyle::~QFusionStyle()
-{
-}
+                    QScrollbarStyleAnimation *anim  = qobject_cast<QScrollbarStyleAnimation *>(d->animation(styleObject));
+                    if (transient) {
+                        if (!anim) {
+                            anim = new QScrollbarStyleAnimation(QScrollbarStyleAnimation::Deactivating, styleObject);
+                            d->startAnimation(anim);
+                        } else if (anim->mode() == QScrollbarStyleAnimation::Deactivating) {
+                            // the scrollbar was already fading out while the
+                            // state changed -> restart the fade out animation
+                            anim->setCurrentTime(0);
+                        }
+                    } else if (anim && anim->mode() == QScrollbarStyleAnimation::Deactivating) {
+                        d->stopAnimation(styleObject);
+                    }
+                }
 
-/*!
-    \fn void QFusionStyle::drawItemText(QPainter *painter, const QRect &rectangle, int alignment, const QPalette &palette,
-                                    bool enabled, const QString& text, QPalette::ColorRole textRole) const
+                QScrollbarStyleAnimation *anim = qobject_cast<QScrollbarStyleAnimation *>(d->animation(styleObject));
+                if (anim && anim->mode() == QScrollbarStyleAnimation::Deactivating) {
+                    // once a scrollbar was active (hovered/pressed), it retains
+                    // the active look even if it's no longer active while fading out
+                    if (oldActiveControls)
+                        anim->setActive(true);
 
-    Draws the given \a text in the specified \a rectangle using the
-    provided \a painter and \a palette.
+                    wasActive = anim->wasActive();
+                    opacity = anim->currentValue();
+                }
 
-    Text is drawn using the painter's pen. If an explicit \a textRole
-    is specified, then the text is drawn using the \a palette's color
-    for the specified role.  The \a enabled value indicates whether or
-    not the item is enabled; when reimplementing, this value should
-    influence how the item is drawn.
+                shouldExpand = (option->activeSubControls || wasActive);
+                if (shouldExpand) {
+                    if (!anim && !oldActiveControls) {
+                        // Start expand animation only once and when entering
+                        anim = new QScrollbarStyleAnimation(QScrollbarStyleAnimation::Activating, styleObject);
+                        d->startAnimation(anim);
+                    }
+                    if (anim && anim->mode() == QScrollbarStyleAnimation::Activating) {
+                        expandScale = 1.0 + (maxExpandScale - 1.0) * anim->currentValue();
+                        expandOffset = 5.5 * anim->currentValue() - 1;
+                    } else {
+                        // Keep expanded state after the animation ends, and when fading out
+                        expandScale = maxExpandScale;
+                        expandOffset = 4.5;
+                    }
+                }
+                painter->setOpacity(opacity);
+            }
 
-    The text is aligned and wrapped according to the specified \a
-    alignment.
+            bool transient = proxy->styleHint(QStyle::SH_ScrollBar_Transient, option, widget);
+            bool horizontal = scrollBar->orientation == Qt::Horizontal;
+            bool sunken = scrollBar->state & QStyle::State_Sunken;
 
-    \sa Qt::Alignment
-*/
-void QFusionStyle::drawItemText(QPainter *painter, const QRect &rect, int alignment, const QPalette &pal,
-                                bool enabled, const QString& text, QPalette::ColorRole textRole) const
-{
-    if (text.isEmpty())
-        return;
+            QRect scrollBarSubLine = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarSubLine, widget);
+            QRect scrollBarAddLine = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarAddLine, widget);
+            QRect scrollBarSlider = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarSlider, widget);
+            QRect scrollBarGroove = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarGroove, widget);
 
-    QPen savedPen = painter->pen();
-    if (textRole != QPalette::NoRole) {
-        painter->setPen(QPen(pal.brush(textRole), savedPen.widthF()));
-    }
-    if (!enabled) {
-        QPen pen = painter->pen();
-        painter->setPen(pen);
-    }
-    painter->drawText(rect, alignment, text);
-    painter->setPen(savedPen);
-}
+            QRect rect = option->rect;
+            QColor alphaOutline = outline;
+            alphaOutline.setAlpha(180);
 
+            QColor arrowColor = option->palette.foreground().color();
+            arrowColor.setAlpha(220);
 
-/*!
-    \reimp
-*/
-void QFusionStyle::drawPrimitive(PrimitiveElement elem,
-                                 const QStyleOption *option,
-                                 QPainter *painter, const QWidget *widget) const
-{
-    Q_ASSERT(option);
-    Q_D (const QFusionStyle);
+            const QColor bgColor = QStyleHelper::backgroundColor(option->palette, widget);
+            const bool isDarkBg = bgColor.red() < 128 && bgColor.green() < 128 && bgColor.blue() < 128;
 
-    QRect rect = option->rect;
-    int state = option->state;
+            if (transient) {
+                if (horizontal) {
+                    rect.setY(rect.y() + 4.5 - expandOffset);
+                    scrollBarSlider.setY(scrollBarSlider.y() + 4.5 - expandOffset);
+                    scrollBarGroove.setY(scrollBarGroove.y() + 4.5 - expandOffset);
 
-    QColor outline = d->outline(option->palette);
-    QColor highlightedOutline = d->highlightedOutline(option->palette);
+                    rect.setHeight(rect.height() * expandScale);
+                    scrollBarGroove.setHeight(scrollBarGroove.height() * expandScale);
+                } else {
+                    rect.setX(rect.x() + 4.5 - expandOffset);
+                    scrollBarSlider.setX(scrollBarSlider.x() + 4.5 - expandOffset);
+                    scrollBarGroove.setX(scrollBarGroove.x() + 4.5 - expandOffset);
 
-    QColor tabFrameColor = d->tabFrameColor(option->palette);
+                    rect.setWidth(rect.width() * expandScale);
+                    scrollBarGroove.setWidth(scrollBarGroove.width() * expandScale);
+                }
+            }
 
-    switch (elem) {
+            // Paint groove
+            if ((!transient || scrollBar->activeSubControls || wasActive) && scrollBar->subControls & QStyle::SC_ScrollBarGroove) {
+                QLinearGradient gradient(rect.center().x(), rect.top(),
+                                         rect.center().x(), rect.bottom());
+                if (!horizontal)
+                    gradient = QLinearGradient(rect.left(), rect.center().y(),
+                                               rect.right(), rect.center().y());
+                if (!transient || !isDarkBg) {
+                    gradient.setColorAt(0, buttonColor.darker(107));
+                    gradient.setColorAt(0.1, buttonColor.darker(105));
+                    gradient.setColorAt(0.9, buttonColor.darker(105));
+                    gradient.setColorAt(1, buttonColor.darker(107));
+                } else {
+                    gradient.setColorAt(0, bgColor.lighter(157));
+                    gradient.setColorAt(0.1, bgColor.lighter(155));
+                    gradient.setColorAt(0.9, bgColor.lighter(155));
+                    gradient.setColorAt(1, bgColor.lighter(157));
+                }
 
-    // No frame drawn
-    case PE_FrameGroupBox:
-    {
-        QPixmap pixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_groupbox.png"));
-        int topMargin = qMax(pixelMetric(PM_ExclusiveIndicatorHeight), option->fontMetrics.height()) + groupBoxTopMargin;
-        QRect frame = option->rect.adjusted(0, topMargin, 0, 0);
-        qDrawBorderPixmap(painter, frame, QMargins(6, 6, 6, 6), pixmap);
-        break;
-    }
-    case PE_IndicatorBranch: {
-        if (!(option->state & State_Children))
-            break;
-        if (option->state & State_Open)
-            drawPrimitive(PE_IndicatorArrowDown, option, painter, widget);
-        else
-            drawPrimitive(PE_IndicatorArrowRight, option, painter, widget);
-        break;
-    }
-    case PE_FrameTabBarBase:
-        if (const QStyleOptionTabBarBase *tbb
-                = qstyleoption_cast<const QStyleOptionTabBarBase *>(option)) {
-            painter->save();
-            painter->setPen(QPen(outline.lighter(110)));
-            switch (tbb->shape) {
-            case QTabBar::RoundedNorth: {
-                QRegion region(tbb->rect);
-                region -= tbb->selectedTabRect;
-                painter->drawLine(tbb->rect.topLeft(), tbb->rect.topRight());
-                painter->setClipRegion(region);
-                painter->setPen(option->palette.light().color());
-                painter->drawLine(tbb->rect.topLeft() + QPoint(0, 1), tbb->rect.topRight() + QPoint(0, 1));
+                painter->save();
+                if (transient)
+                    painter->setOpacity(0.8);
+                painter->fillRect(rect, gradient);
+                painter->setPen(Qt::NoPen);
+                if (transient)
+                    painter->setOpacity(0.4);
+                painter->setPen(alphaOutline);
+                if (horizontal)
+                    painter->drawLine(rect.topLeft(), rect.topRight());
+                else
+                    painter->drawLine(rect.topLeft(), rect.bottomLeft());
+
+                QColor subtleEdge = alphaOutline;
+                subtleEdge.setAlpha(40);
+                painter->setPen(Qt::NoPen);
+                painter->setBrush(Qt::NoBrush);
+                painter->setClipRect(scrollBarGroove.adjusted(1, 0, -1, -3));
+                painter->drawRect(scrollBarGroove.adjusted(1, 0, -1, -1));
+                painter->restore();
             }
-                break;
-            case QTabBar::RoundedWest:
-                painter->drawLine(tbb->rect.left(), tbb->rect.top(), tbb->rect.left(), tbb->rect.bottom());
-                break;
-            case QTabBar::RoundedSouth:
-                painter->drawLine(tbb->rect.left(), tbb->rect.bottom(),
-                                  tbb->rect.right(), tbb->rect.bottom());
-                break;
-            case QTabBar::RoundedEast:
-                painter->drawLine(tbb->rect.topRight(), tbb->rect.bottomRight());
+
+            QRect pixmapRect = scrollBarSlider;
+            QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
+                                     pixmapRect.center().x(), pixmapRect.bottom());
+            if (!horizontal)
+                gradient = QLinearGradient(pixmapRect.left(), pixmapRect.center().y(),
+                                           pixmapRect.right(), pixmapRect.center().y());
+
+            QLinearGradient highlightedGradient = gradient;
+
+            QColor midColor2 = mergedColors(gradientStartColor, gradientStopColor, 40);
+            gradient.setColorAt(0, d->buttonColor(option->palette).lighter(108));
+            gradient.setColorAt(1, d->buttonColor(option->palette));
+
+            highlightedGradient.setColorAt(0, gradientStartColor.darker(102));
+            highlightedGradient.setColorAt(1, gradientStopColor.lighter(102));
+
+            // Paint slider
+            if (scrollBar->subControls & QStyle::SC_ScrollBarSlider) {
+                if (transient) {
+                    QRect rect = scrollBarSlider.adjusted(horizontal ? 1 : 2, horizontal ? 2 : 1, -1, -1);
+                    painter->setPen(Qt::NoPen);
+                    painter->setBrush(isDarkBg ? d->lightShade() : d->darkShade());
+                    int r = qMin(rect.width(), rect.height()) / 2;
+
+                    painter->save();
+                    painter->setRenderHint(QPainter::Antialiasing, true);
+                    painter->drawRoundedRect(rect, r, r);
+                    painter->restore();
+                } else {
+                    QRect pixmapRect = scrollBarSlider;
+                    painter->setPen(QPen(alphaOutline));
+                    if (option->state & QStyle::State_Sunken && scrollBar->activeSubControls & QStyle::SC_ScrollBarSlider)
+                        painter->setBrush(midColor2);
+                    else if (option->state & QStyle::State_MouseOver && scrollBar->activeSubControls & QStyle::SC_ScrollBarSlider)
+                        painter->setBrush(highlightedGradient);
+                    else
+                        painter->setBrush(gradient);
+
+                    painter->drawRect(pixmapRect.adjusted(horizontal ? -1 : 0, horizontal ? 0 : -1, horizontal ? 0 : 1, horizontal ? 1 : 0));
+
+                    painter->setPen(d->innerContrastLine());
+                    painter->drawRect(scrollBarSlider.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, -1, -1));
+
+                    // Outer shadow
+                    //                  painter->setPen(subtleEdge);
+                    //                  if (horizontal) {
+                    ////                    painter->drawLine(scrollBarSlider.topLeft() + QPoint(-2, 0), scrollBarSlider.bottomLeft() + QPoint(2, 0));
+                    ////                    painter->drawLine(scrollBarSlider.topRight() + QPoint(-2, 0), scrollBarSlider.bottomRight() + QPoint(2, 0));
+                    //                  } else {
+                    ////                    painter->drawLine(pixmapRect.topLeft() + QPoint(0, -2), pixmapRect.bottomLeft() + QPoint(0, -2));
+                    ////                    painter->drawLine(pixmapRect.topRight() + QPoint(0, 2), pixmapRect.bottomRight() + QPoint(0, 2));
+                    //                  }
+                }
+            }
+
+            // The SubLine (up/left) buttons
+            if (!transient && scrollBar->subControls & QStyle::SC_ScrollBarSubLine) {
+                if ((scrollBar->activeSubControls & QStyle::SC_ScrollBarSubLine) && sunken)
+                    painter->setBrush(gradientStopColor);
+                else if ((scrollBar->activeSubControls & QStyle::SC_ScrollBarSubLine))
+                    painter->setBrush(highlightedGradient);
+                else
+                    painter->setBrush(gradient);
+
+                painter->setPen(Qt::NoPen);
+                painter->drawRect(scrollBarSubLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, 0, 0));
+                painter->setPen(QPen(alphaOutline));
+                if (option->state & QStyle::State_Horizontal) {
+                    if (option->direction == Qt::RightToLeft) {
+                        pixmapRect.setLeft(scrollBarSubLine.left());
+                        painter->drawLine(pixmapRect.topLeft(), pixmapRect.bottomLeft());
+                    } else {
+                        pixmapRect.setRight(scrollBarSubLine.right());
+                        painter->drawLine(pixmapRect.topRight(), pixmapRect.bottomRight());
+                    }
+                } else {
+                    pixmapRect.setBottom(scrollBarSubLine.bottom());
+                    painter->drawLine(pixmapRect.bottomLeft(), pixmapRect.bottomRight());
+                }
+
+                painter->setBrush(Qt::NoBrush);
+                painter->setPen(d->innerContrastLine());
+                painter->drawRect(scrollBarSubLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0 ,  horizontal ? -2 : -1, horizontal ? -1 : -2));
+
+                // Arrows
+                int rotation = 0;
+                if (option->state & QStyle::State_Horizontal)
+                    rotation = option->direction == Qt::LeftToRight ? -90 : 90;
+                QRect upRect = scrollBarSubLine.translated(horizontal ? -2 : -1, 0);
+                QPixmap arrowPixmap = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), arrowColor, rotation);
+                painter->drawPixmap(QRectF(upRect.center().x() - arrowPixmap.width() / 4.0  + 2.0,
+                                          upRect.center().y() - arrowPixmap.height() / 4.0 + 1.0,
+                                          arrowPixmap.width() / 2.0, arrowPixmap.height() / 2.0),
+                                          arrowPixmap, QRectF(QPoint(0.0, 0.0), arrowPixmap.size()));
+            }
+
+            // The AddLine (down/right) button
+            if (!transient && scrollBar->subControls & QStyle::SC_ScrollBarAddLine) {
+                if ((scrollBar->activeSubControls & QStyle::SC_ScrollBarAddLine) && sunken)
+                    painter->setBrush(gradientStopColor);
+                else if ((scrollBar->activeSubControls & QStyle::SC_ScrollBarAddLine))
+                    painter->setBrush(midColor2);
+                else
+                    painter->setBrush(gradient);
+
+                painter->setPen(Qt::NoPen);
+                painter->drawRect(scrollBarAddLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, 0, 0));
+                painter->setPen(QPen(alphaOutline, 1));
+                if (option->state & QStyle::State_Horizontal) {
+                    if (option->direction == Qt::LeftToRight) {
+                        pixmapRect.setLeft(scrollBarAddLine.left());
+                        painter->drawLine(pixmapRect.topLeft(), pixmapRect.bottomLeft());
+                    } else {
+                        pixmapRect.setRight(scrollBarAddLine.right());
+                        painter->drawLine(pixmapRect.topRight(), pixmapRect.bottomRight());
+                    }
+                } else {
+                    pixmapRect.setTop(scrollBarAddLine.top());
+                    painter->drawLine(pixmapRect.topLeft(), pixmapRect.topRight());
+                }
+
+                painter->setPen(d->innerContrastLine());
+                painter->setBrush(Qt::NoBrush);
+                painter->drawRect(scrollBarAddLine.adjusted(1, 1, -1, -1));
+
+                int rotation = 180;
+                if (option->state & QStyle::State_Horizontal)
+                    rotation = option->direction == Qt::LeftToRight ? 90 : -90;
+                QRect downRect = scrollBarAddLine.translated(-1, 1);
+                QPixmap arrowPixmap = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), arrowColor, rotation);
+                painter->drawPixmap(QRectF(downRect.center().x() - arrowPixmap.width() / 4.0 + 2.0,
+                                           downRect.center().y() - arrowPixmap.height() / 4.0,
+                                           arrowPixmap.width() / 2.0, arrowPixmap.height() / 2.0),
+                                           arrowPixmap, QRectF(QPoint(0.0, 0.0), arrowPixmap.size()));
+            }
+        }
+        painter->restore();
+}
+
+template <class OptionStyle, class PrivClass>
+static void drawComplexControlSlider(QStyle::ComplexControl control,
+                                     const QStyleOptionComplex *option,
+                                     QPainter *painter,
+                                     const QWidget *widget,
+                                     const QStyle* proxy,
+                                     PrivClass *d)
+{
+        if (const OptionStyle *slider = qstyleoption_cast<const OptionStyle *>(option)) {
+            QRect groove = proxy->subControlRect(control, option, QStyle::SC_SliderGroove, widget);
+            QRect handle = proxy->subControlRect(control, option, QStyle::SC_SliderHandle, widget);
+
+            bool horizontal = slider->orientation == Qt::Horizontal;
+            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
+            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
+            QColor activeHighlight = d->highlight(option->palette);
+            QPixmap cache;
+            QBrush oldBrush = painter->brush();
+            QPen oldPen = painter->pen();
+            QColor shadowAlpha(Qt::black);
+            QColor outline = d->outline(option->palette);
+            QColor buttonColor = d->buttonColor(option->palette);
+
+            shadowAlpha.setAlpha(10);
+            if (option->state & QStyle::State_HasFocus && option->state & QStyle::State_KeyboardFocusChange)
+                outline = d->highlightedOutline(option->palette);
+
+
+            if ((option->subControls & QStyle::SC_SliderGroove) && groove.isValid()) {
+                QColor grooveColor;
+                grooveColor.setHsv(buttonColor.hue(),
+                                   qMin(255, (int)(buttonColor.saturation())),
+                                   qMin(255, (int)(buttonColor.value()*0.9)));
+                QString groovePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_groove"), option, groove.size());
+                QRect pixmapRect(0, 0, groove.width(), groove.height());
+                QColor outline = d->outline(option->palette);
+
+                // draw background groove
+                if (!QPixmapCache::find(groovePixmapName, cache)) {
+                    cache = styleCachePixmap(pixmapRect.size());
+                    cache.fill(Qt::transparent);
+                    QPainter groovePainter(&cache);
+                    groovePainter.setRenderHint(QPainter::Antialiasing, true);
+                    groovePainter.translate(0.5, 0.5);
+                    QLinearGradient gradient;
+                    if (horizontal) {
+                        gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
+                        gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
+                    }
+                    else {
+                        gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
+                        gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
+                    }
+                    groovePainter.setPen(QPen(outline));
+                    gradient.setColorAt(0, grooveColor.darker(110));
+                    gradient.setColorAt(1, grooveColor.lighter(110));//palette.button().color().darker(115));
+                    groovePainter.setBrush(gradient);
+                    groovePainter.drawRoundedRect(pixmapRect.adjusted(1, 1, -2, -2), 1, 1);
+                    groovePainter.end();
+                    QPixmapCache::insert(groovePixmapName, cache);
+                }
+                painter->drawPixmap(groove.topLeft(), cache);
+
+                // draw blue groove highlight
+                QRect clipRect;
+                groovePixmapName += QLatin1String("_blue");
+                if (!QPixmapCache::find(groovePixmapName, cache)) {
+                    cache = styleCachePixmap(pixmapRect.size());
+                    cache.fill(Qt::transparent);
+                    QPainter groovePainter(&cache);
+                    QLinearGradient gradient;
+                    if (horizontal) {
+                        gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
+                        gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
+                    }
+                    else {
+                        gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
+                        gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
+                    }
+                    QColor highlight = d->highlight(option->palette);
+                    QColor highlightedoutline = highlight.darker(140);
+                    if (qGray(outline.rgb()) > qGray(highlightedoutline.rgb()))
+                        outline = highlightedoutline;
+
+
+                    groovePainter.setRenderHint(QPainter::Antialiasing, true);
+                    groovePainter.translate(0.5, 0.5);
+                    groovePainter.setPen(QPen(outline));
+                    gradient.setColorAt(0, activeHighlight);
+                    gradient.setColorAt(1, activeHighlight.lighter(130));
+                    groovePainter.setBrush(gradient);
+                    groovePainter.drawRoundedRect(pixmapRect.adjusted(1, 1, -2, -2), 1, 1);
+                    groovePainter.setPen(d->innerContrastLine());
+                    groovePainter.setBrush(Qt::NoBrush);
+                    groovePainter.drawRoundedRect(pixmapRect.adjusted(2, 2, -3, -3), 1, 1);
+                    groovePainter.end();
+                    QPixmapCache::insert(groovePixmapName, cache);
+                }
+                if (horizontal) {
+                    if (slider->upsideDown)
+                        clipRect = QRect(handle.right(), groove.top(), groove.right() - handle.right(), groove.height());
+                    else
+                        clipRect = QRect(groove.left(), groove.top(), handle.left(), groove.height());
+                } else {
+                    if (slider->upsideDown)
+                        clipRect = QRect(groove.left(), handle.bottom(), groove.width(), groove.height() - handle.bottom());
+                    else
+                        clipRect = QRect(groove.left(), groove.top(), groove.width(), handle.top() - groove.top());
+                }
+                painter->save();
+                painter->setClipRect(clipRect.adjusted(0, 0, 1, 1), Qt::IntersectClip);
+                painter->drawPixmap(groove.topLeft(), cache);
+                painter->restore();
+            }
+
+            if (option->subControls & QStyle::SC_SliderTickmarks) {
+                painter->setPen(outline);
+                int tickSize = proxy->pixelMetric(QStyle::PM_SliderTickmarkOffset, option, widget);
+                int available = proxy->pixelMetric(QStyle::PM_SliderSpaceAvailable, slider, widget);
+                int interval = slider->tickInterval;
+                if (interval <= 0) {
+                    interval = slider->singleStep;
+                    if (QStyle::sliderPositionFromValue((qint64)slider->minimum, (qint64)slider->maximum, (qint64)interval,
+                                                        (qint64)available)
+                        - QStyle::sliderPositionFromValue((qint64)slider->minimum, (qint64)slider->maximum,
+                                                              (qint64)0, (qint64)available) < 3)
+                        interval = slider->pageStep;
+                }
+                if (interval <= 0)
+                    interval = 1;
+
+                int v = slider->minimum;
+                int len = proxy->pixelMetric(QStyle::PM_SliderLength, slider, widget);
+                while (v <= slider->maximum + 1) {
+                    if (v == slider->maximum + 1 && interval == 1)
+                        break;
+                    const int v_ = qMin((qint64)v, (qint64)slider->maximum);
+                    int pos = QStyle::sliderPositionFromValue((qint64)slider->minimum, (qint64)slider->maximum,
+                                                              (qint64)v_, (horizontal
+                                                                   ? slider->rect.width()
+                                                                   : slider->rect.height()) - (qint64)len,
+                                                              slider->upsideDown) + len / 2;
+                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
+
+                    if (horizontal) {
+                        if (ticksAbove) {
+                            painter->drawLine(pos, slider->rect.top() + extra,
+                                              pos, slider->rect.top() + tickSize);
+                        }
+                        if (ticksBelow) {
+                            painter->drawLine(pos, slider->rect.bottom() - extra,
+                                              pos, slider->rect.bottom() - tickSize);
+                        }
+                    } else {
+                        if (ticksAbove) {
+                            painter->drawLine(slider->rect.left() + extra, pos,
+                                              slider->rect.left() + tickSize, pos);
+                        }
+                        if (ticksBelow) {
+                            painter->drawLine(slider->rect.right() - extra, pos,
+                                              slider->rect.right() - tickSize, pos);
+                        }
+                    }
+                    // in the case where maximum is max int
+                    int nextInterval = v + interval;
+                    if (nextInterval < v)
+                        break;
+                    v = nextInterval;
+                }
+            }
+            // draw handle
+            if ((option->subControls & QStyle::SC_SliderHandle) ) {
+                QString handlePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_handle"), option, handle.size());
+                if (!QPixmapCache::find(handlePixmapName, cache)) {
+                    cache = styleCachePixmap(handle.size());
+                    cache.fill(Qt::transparent);
+                    QRect pixmapRect(0, 0, handle.width(), handle.height());
+                    QPainter handlePainter(&cache);
+                    QRect gradRect = pixmapRect.adjusted(2, 2, -2, -2);
+
+                    // gradient fill
+                    QRect r = pixmapRect.adjusted(1, 1, -2, -2);
+                    QLinearGradient gradient = qt_fusion_gradient(gradRect, d->buttonColor(option->palette),horizontal ? TopDown : FromLeft);
+
+                    handlePainter.setRenderHint(QPainter::Antialiasing, true);
+                    handlePainter.translate(0.5, 0.5);
+
+                    handlePainter.setPen(Qt::NoPen);
+                    handlePainter.setBrush(QColor(0, 0, 0, 40));
+                    handlePainter.drawRect(r.adjusted(-1, 2, 1, -2));
+
+                    handlePainter.setPen(QPen(d->outline(option->palette)));
+                    if (option->state & QStyle::State_HasFocus && option->state & QStyle::State_KeyboardFocusChange)
+                        handlePainter.setPen(QPen(d->highlightedOutline(option->palette)));
+
+                    handlePainter.setBrush(gradient);
+                    handlePainter.drawRoundedRect(r, 2, 2);
+                    handlePainter.setBrush(Qt::NoBrush);
+                    handlePainter.setPen(d->innerContrastLine());
+                    handlePainter.drawRoundedRect(r.adjusted(1, 1, -1, -1), 2, 2);
+
+                    QColor cornerAlpha = outline.darker(120);
+                    cornerAlpha.setAlpha(80);
+
+                    //handle shadow
+                    handlePainter.setPen(shadowAlpha);
+                    handlePainter.drawLine(QPoint(r.left() + 2, r.bottom() + 1), QPoint(r.right() - 2, r.bottom() + 1));
+                    handlePainter.drawLine(QPoint(r.right() + 1, r.bottom() - 3), QPoint(r.right() + 1, r.top() + 4));
+                    handlePainter.drawLine(QPoint(r.right() - 1, r.bottom()), QPoint(r.right() + 1, r.bottom() - 2));
+
+                    handlePainter.end();
+                    QPixmapCache::insert(handlePixmapName, cache);
+                }
+
+                painter->drawPixmap(handle.topLeft(), cache);
+
+            }
+            painter->setBrush(oldBrush);
+            painter->setPen(oldPen);
+        }
+}
+
+template <class OptionStyle>
+static void subControlRectSlider(QStyle::ComplexControl control,
+                                 const QStyleOptionComplex *option,
+                                 QStyle::SubControl subControl,
+                                 const QWidget *widget,
+                                 QRect &rect,
+                                 const QStyle* proxy)
+{
+        if (const OptionStyle *slider = qstyleoption_cast<const OptionStyle *>(option)) {
+            int tickSize = proxy->pixelMetric(QStyle::PM_SliderTickmarkOffset, option, widget);
+            switch (subControl) {
+            case QStyle::SC_SliderHandle: {
+                if (slider->orientation == Qt::Horizontal) {
+                    rect.setHeight(proxy->pixelMetric(QStyle::PM_SliderThickness));
+                    rect.setWidth(proxy->pixelMetric(QStyle::PM_SliderLength));
+                    int centerY = slider->rect.center().y() - rect.height() / 2;
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        centerY += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        centerY -= tickSize;
+                    rect.moveTop(centerY);
+                } else {
+                    rect.setWidth(proxy->pixelMetric(QStyle::PM_SliderThickness));
+                    rect.setHeight(proxy->pixelMetric(QStyle::PM_SliderLength));
+                    int centerX = slider->rect.center().x() - rect.width() / 2;
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        centerX += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        centerX -= tickSize;
+                    rect.moveLeft(centerX);
+                }
+            }
+                break;
+            case QStyle::SC_SliderGroove: {
+                QPoint grooveCenter = slider->rect.center();
+                if (slider->orientation == Qt::Horizontal) {
+                    rect.setHeight(7);
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        grooveCenter.ry() += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        grooveCenter.ry() -= tickSize;
+                } else {
+                    rect.setWidth(7);
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        grooveCenter.rx() += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        grooveCenter.rx() -= tickSize;
+                }
+                rect.moveCenter(grooveCenter);
+                break;
+            }
+            default:
+                break;
+            }
+        }
+}
+
+/*
+    \internal
+*/
+QFusionStylePrivate::QFusionStylePrivate()
+{
+    animationFps = 60;
+}
+
+/*!
+    \class QFusionStyle
+    \brief The QFusionStyle class provides a custom widget style
+
+    \inmodule QtWidgets
+    \internal
+
+    The Fusion style provides a custom look and feel that is not
+    tied to a particular platform.
+    //{Fusion Style Widget Gallery}
+    \sa QWindowsStyle, QWindowsVistaStyle, QMacStyle, QCommonStyle
+*/
+
+/*!
+    Constructs a QFusionStyle object.
+*/
+QFusionStyle::QFusionStyle() : QCommonStyle(*new QFusionStylePrivate)
+{
+    setObjectName(QLatin1String("Fusion"));
+}
+
+/*!
+    \internal
+
+    Constructs a QFusionStyle object.
+*/
+QFusionStyle::QFusionStyle(QFusionStylePrivate &dd) : QCommonStyle(dd)
+{
+}
+
+/*!
+    Destroys the QFusionStyle object.
+*/
+QFusionStyle::~QFusionStyle()
+{
+}
+
+/*!
+    \fn void QFusionStyle::drawItemText(QPainter *painter, const QRect &rectangle, int alignment, const QPalette &palette,
+                                    bool enabled, const QString& text, QPalette::ColorRole textRole) const
+
+    Draws the given \a text in the specified \a rectangle using the
+    provided \a painter and \a palette.
+
+    Text is drawn using the painter's pen. If an explicit \a textRole
+    is specified, then the text is drawn using the \a palette's color
+    for the specified role.  The \a enabled value indicates whether or
+    not the item is enabled; when reimplementing, this value should
+    influence how the item is drawn.
+
+    The text is aligned and wrapped according to the specified \a
+    alignment.
+
+    \sa Qt::Alignment
+*/
+void QFusionStyle::drawItemText(QPainter *painter, const QRect &rect, int alignment, const QPalette &pal,
+                                bool enabled, const QString& text, QPalette::ColorRole textRole) const
+{
+    if (text.isEmpty())
+        return;
+
+    QPen savedPen = painter->pen();
+    if (textRole != QPalette::NoRole) {
+        painter->setPen(QPen(pal.brush(textRole), savedPen.widthF()));
+    }
+    if (!enabled) {
+        QPen pen = painter->pen();
+        painter->setPen(pen);
+    }
+    painter->drawText(rect, alignment, text);
+    painter->setPen(savedPen);
+}
+
+
+/*!
+    \reimp
+*/
+void QFusionStyle::drawPrimitive(PrimitiveElement elem,
+                                 const QStyleOption *option,
+                                 QPainter *painter, const QWidget *widget) const
+{
+    Q_ASSERT(option);
+    Q_D (const QFusionStyle);
+
+    QRect rect = option->rect;
+    int state = option->state;
+
+    QColor outline = d->outline(option->palette);
+    QColor highlightedOutline = d->highlightedOutline(option->palette);
+
+    QColor tabFrameColor = d->tabFrameColor(option->palette);
+
+    switch (elem) {
+
+    // No frame drawn
+    case PE_FrameGroupBox:
+    {
+        QPixmap pixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_groupbox.png"));
+        int topMargin = qMax(pixelMetric(PM_ExclusiveIndicatorHeight), option->fontMetrics.height()) + groupBoxTopMargin;
+        QRect frame = option->rect.adjusted(0, topMargin, 0, 0);
+        qDrawBorderPixmap(painter, frame, QMargins(6, 6, 6, 6), pixmap);
+        break;
+    }
+    case PE_IndicatorBranch: {
+        if (!(option->state & State_Children))
+            break;
+        if (option->state & State_Open)
+            drawPrimitive(PE_IndicatorArrowDown, option, painter, widget);
+        else
+            drawPrimitive(PE_IndicatorArrowRight, option, painter, widget);
+        break;
+    }
+    case PE_FrameTabBarBase:
+        if (const QStyleOptionTabBarBase *tbb
+                = qstyleoption_cast<const QStyleOptionTabBarBase *>(option)) {
+            painter->save();
+            painter->setPen(QPen(outline.lighter(110)));
+            switch (tbb->shape) {
+            case QTabBar::RoundedNorth: {
+                QRegion region(tbb->rect);
+                region -= tbb->selectedTabRect;
+                painter->drawLine(tbb->rect.topLeft(), tbb->rect.topRight());
+                painter->setClipRegion(region);
+                painter->setPen(option->palette.light().color());
+                painter->drawLine(tbb->rect.topLeft() + QPoint(0, 1), tbb->rect.topRight() + QPoint(0, 1));
+            }
+                break;
+            case QTabBar::RoundedWest:
+                painter->drawLine(tbb->rect.left(), tbb->rect.top(), tbb->rect.left(), tbb->rect.bottom());
+                break;
+            case QTabBar::RoundedSouth:
+                painter->drawLine(tbb->rect.left(), tbb->rect.bottom(),
+                                  tbb->rect.right(), tbb->rect.bottom());
+                break;
+            case QTabBar::RoundedEast:
+                painter->drawLine(tbb->rect.topRight(), tbb->rect.bottomRight());
                 break;
             case QTabBar::TriangularNorth:
             case QTabBar::TriangularEast:
@@ -1920,7 +2514,6 @@ void QFusionStyle::drawComplexControl(ComplexControl control, const QStyleOption
     Q_D (const QFusionStyle);
 
     QColor buttonColor = d->buttonColor(option->palette);
-    QColor gradientStartColor = buttonColor.lighter(118);
     QColor gradientStopColor = buttonColor;
     QColor outline = d->outline(option->palette);
 
@@ -1956,743 +2549,445 @@ void QFusionStyle::drawComplexControl(ComplexControl control, const QStyleOption
                 painter->setPen(QPen(option->palette.windowText(), 1));
                 int alignment = int(groupBox->textAlignment);
                 if (!proxy()->styleHint(QStyle::SH_UnderlineShortcut, option, widget))
-                    alignment |= Qt::TextHideMnemonic;
-
-                proxy()->drawItemText(painter, textRect,  Qt::TextShowMnemonic | Qt::AlignLeft | alignment,
-                                      groupBox->palette, groupBox->state & State_Enabled, groupBox->text, QPalette::NoRole);
-
-                if (groupBox->state & State_HasFocus) {
-                    QStyleOptionFocusRect fropt;
-                    fropt.QStyleOption::operator=(*groupBox);
-                    fropt.rect = textRect.adjusted(-2, -1, 2, 1);
-                    proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
-                }
-            }
-
-            // Draw checkbox
-            if (groupBox->subControls & SC_GroupBoxCheckBox) {
-                QStyleOptionButton box;
-                box.QStyleOption::operator=(*groupBox);
-                box.rect = checkBoxRect;
-                proxy()->drawPrimitive(PE_IndicatorCheckBox, &box, painter, widget);
-            }
-        }
-        painter->restore();
-        break;
-    case CC_SpinBox:
-        if (const QStyleOptionSpinBox *spinBox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
-            QPixmap cache;
-            QString pixmapName = QStyleHelper::uniqueName(QLatin1String("spinbox"), spinBox, spinBox->rect.size());
-            if (!QPixmapCache::find(pixmapName, cache)) {
-
-                cache = styleCachePixmap(spinBox->rect.size());
-                cache.fill(Qt::transparent);
-
-                QRect pixmapRect(0, 0, spinBox->rect.width(), spinBox->rect.height());
-                QRect rect = pixmapRect;
-                QRect r = rect.adjusted(0, 1, 0, -1);
-                QPainter cachePainter(&cache);
-                QColor arrowColor = spinBox->palette.foreground().color();
-                arrowColor.setAlpha(220);
-
-                bool isEnabled = (spinBox->state & State_Enabled);
-                bool hover = isEnabled && (spinBox->state & State_MouseOver);
-                bool sunken = (spinBox->state & State_Sunken);
-                bool upIsActive = (spinBox->activeSubControls == SC_SpinBoxUp);
-                bool downIsActive = (spinBox->activeSubControls == SC_SpinBoxDown);
-                bool hasFocus = (option->state & State_HasFocus);
-
-                QStyleOptionSpinBox spinBoxCopy = *spinBox;
-                spinBoxCopy.rect = pixmapRect;
-                QRect upRect = proxy()->subControlRect(CC_SpinBox, &spinBoxCopy, SC_SpinBoxUp, widget);
-                QRect downRect = proxy()->subControlRect(CC_SpinBox, &spinBoxCopy, SC_SpinBoxDown, widget);
-
-                if (spinBox->frame) {
-                    cachePainter.save();
-                    cachePainter.setRenderHint(QPainter::Antialiasing, true);
-                    cachePainter.translate(0.5, 0.5);
-
-                    // Fill background
-                    cachePainter.setPen(Qt::NoPen);
-                    cachePainter.setBrush(option->palette.base());
-                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
-
-                    // Draw inner shadow
-                    cachePainter.setPen(d->topShadow());
-                    cachePainter.drawLine(QPoint(r.left() + 2, r.top() + 1), QPoint(r.right() - 2, r.top() + 1));
-
-                    // Draw button gradient
-                    QColor buttonColor = d->buttonColor(option->palette);
-                    QRect updownRect = upRect.adjusted(0, -2, 0, downRect.height() + 2);
-                    QLinearGradient gradient = qt_fusion_gradient(updownRect, (isEnabled && option->state & State_MouseOver ) ? buttonColor : buttonColor.darker(104));
-
-                    // Draw button gradient
-                    cachePainter.setPen(Qt::NoPen);
-                    cachePainter.setBrush(gradient);
-
-                    cachePainter.save();
-                    cachePainter.setClipRect(updownRect);
-                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
-                    cachePainter.setPen(QPen(d->innerContrastLine()));
-                    cachePainter.setBrush(Qt::NoBrush);
-                    cachePainter.drawRoundedRect(r.adjusted(1, 1, -2, -2), 2, 2);
-                    cachePainter.restore();
-
-                    if ((spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) && upIsActive) {
-                        if (sunken)
-                            cachePainter.fillRect(upRect.adjusted(0, -1, 0, 0), gradientStopColor.darker(110));
-                        else if (hover)
-                            cachePainter.fillRect(upRect.adjusted(0, -1, 0, 0), d->innerContrastLine());
-                    }
-
-                    if ((spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) && downIsActive) {
-                        if (sunken)
-                            cachePainter.fillRect(downRect.adjusted(0, 0, 0, 1), gradientStopColor.darker(110));
-                        else if (hover)
-                            cachePainter.fillRect(downRect.adjusted(0, 0, 0, 1), d->innerContrastLine());
-                    }
-
-                    cachePainter.setPen(hasFocus ? d->highlightedOutline(option->palette) : outline);
-                    cachePainter.setBrush(Qt::NoBrush);
-                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
-                    if (hasFocus) {
-                        QColor softHighlight = option->palette.highlight().color();
-                        softHighlight.setAlpha(40);
-                        cachePainter.setPen(softHighlight);
-                        cachePainter.drawRoundedRect(r.adjusted(1, 1, -2, -2), 1.7, 1.7);
-                    }
-                    cachePainter.restore();
-                }
-
-                // outline the up/down buttons
-                cachePainter.setPen(outline);
-                if (spinBox->direction == Qt::RightToLeft) {
-                    cachePainter.drawLine(upRect.right(), upRect.top() - 1, upRect.right(), downRect.bottom() + 1);
-                } else {
-                    cachePainter.drawLine(upRect.left(), upRect.top() - 1, upRect.left(), downRect.bottom() + 1);
-                }
-
-                if (upIsActive && sunken) {
-                    cachePainter.setPen(gradientStopColor.darker(130));
-                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.right(), downRect.top());
-                    cachePainter.drawLine(upRect.left() + 1, upRect.top(), upRect.left() + 1, upRect.bottom());
-                    cachePainter.drawLine(upRect.left() + 1, upRect.top() - 1, upRect.right(), upRect.top() - 1);
-                }
-
-                if (downIsActive && sunken) {
-                    cachePainter.setPen(gradientStopColor.darker(130));
-                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.left() + 1, downRect.bottom() + 1);
-                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.right(), downRect.top());
-                    cachePainter.setPen(gradientStopColor.darker(110));
-                    cachePainter.drawLine(downRect.left() + 1, downRect.bottom() + 1, downRect.right(), downRect.bottom() + 1);
-                }
-
-                QColor disabledColor = mergedColors(arrowColor, option->palette.button().color());
-                if (spinBox->buttonSymbols == QAbstractSpinBox::PlusMinus) {
-                    int centerX = upRect.center().x();
-                    int centerY = upRect.center().y();
-
-                    // plus/minus
-                    cachePainter.setPen((spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) ? arrowColor : disabledColor);
-                    cachePainter.drawLine(centerX - 1, centerY, centerX + 3, centerY);
-                    cachePainter.drawLine(centerX + 1, centerY - 2, centerX + 1, centerY + 2);
-
-                    centerX = downRect.center().x();
-                    centerY = downRect.center().y();
-                    cachePainter.setPen((spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) ? arrowColor : disabledColor);
-                    cachePainter.drawLine(centerX - 1, centerY, centerX + 3, centerY);
-
-                } else if (spinBox->buttonSymbols == QAbstractSpinBox::UpDownArrows){
-                    // arrows
-                    painter->setRenderHint(QPainter::SmoothPixmapTransform);
-
-                    QPixmap upArrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"),
-                                                     (spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) ? arrowColor : disabledColor);
-
-                    QRectF upArrowRect = QRectF(upRect.center().x() - upArrow.width() / 4.0 + 1.0,
-                                                upRect.center().y() - upArrow.height() / 4.0 + 1.0,
-                                                upArrow.width() / 2.0, upArrow.height() / 2.0);
-
-                    cachePainter.drawPixmap(upArrowRect, upArrow, QRectF(QPointF(0.0, 0.0), upArrow.size()));
-
-                    QPixmap downArrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"),
-                                                       (spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) ? arrowColor : disabledColor, 180);
-                    QRectF downArrowRect = QRectF(downRect.center().x() - downArrow.width() / 4.0 + 1.0,
-                                                  downRect.center().y() - downArrow.height() / 4.0 + 1.0,
-                                                  downArrow.width() / 2.0, downArrow.height() / 2.0);
-                    cachePainter.drawPixmap(downArrowRect, downArrow, QRectF(QPointF(0.0, 0.0), downArrow.size()));
-                }
-
-                cachePainter.end();
-                QPixmapCache::insert(pixmapName, cache);
-            }
-            painter->drawPixmap(spinBox->rect.topLeft(), cache);
-        }
-        break;
-    case CC_TitleBar:
-        painter->save();
-        if (const QStyleOptionTitleBar *titleBar = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {
-            const int buttonMargin = 5;
-            bool active = (titleBar->titleBarState & State_Active);
-            QRect fullRect = titleBar->rect;
-            QPalette palette = option->palette;
-            QColor highlight = option->palette.highlight().color();
-
-            QColor titleBarFrameBorder(active ? highlight.darker(180): outline.darker(110));
-            QColor titleBarHighlight(active ? highlight.lighter(120): palette.background().color().lighter(120));
-            QColor textColor(active ? 0xffffff : 0xff000000);
-            QColor textAlphaColor(active ? 0xffffff : 0xff000000 );
-
-            {
-                // Fill title bar gradient
-                QColor titlebarColor = QColor(active ? highlight: palette.background().color());
-                QLinearGradient gradient(option->rect.center().x(), option->rect.top(),
-                                         option->rect.center().x(), option->rect.bottom());
-
-                gradient.setColorAt(0, titlebarColor.lighter(114));
-                gradient.setColorAt(0.5, titlebarColor.lighter(102));
-                gradient.setColorAt(0.51, titlebarColor.darker(104));
-                gradient.setColorAt(1, titlebarColor);
-                painter->fillRect(option->rect.adjusted(1, 1, -1, 0), gradient);
-
-                // Frame and rounded corners
-                painter->setPen(titleBarFrameBorder);
-
-                // top outline
-                painter->drawLine(fullRect.left() + 5, fullRect.top(), fullRect.right() - 5, fullRect.top());
-                painter->drawLine(fullRect.left(), fullRect.top() + 4, fullRect.left(), fullRect.bottom());
-                const QPoint points[5] = {
-                    QPoint(fullRect.left() + 4, fullRect.top() + 1),
-                    QPoint(fullRect.left() + 3, fullRect.top() + 1),
-                    QPoint(fullRect.left() + 2, fullRect.top() + 2),
-                    QPoint(fullRect.left() + 1, fullRect.top() + 3),
-                    QPoint(fullRect.left() + 1, fullRect.top() + 4)
-                };
-                painter->drawPoints(points, 5);
-
-                painter->drawLine(fullRect.right(), fullRect.top() + 4, fullRect.right(), fullRect.bottom());
-                const QPoint points2[5] = {
-                    QPoint(fullRect.right() - 3, fullRect.top() + 1),
-                    QPoint(fullRect.right() - 4, fullRect.top() + 1),
-                    QPoint(fullRect.right() - 2, fullRect.top() + 2),
-                    QPoint(fullRect.right() - 1, fullRect.top() + 3),
-                    QPoint(fullRect.right() - 1, fullRect.top() + 4)
-                };
-                painter->drawPoints(points2, 5);
+                    alignment |= Qt::TextHideMnemonic;
 
-                // draw bottomline
-                painter->drawLine(fullRect.right(), fullRect.bottom(), fullRect.left(), fullRect.bottom());
+                proxy()->drawItemText(painter, textRect,  Qt::TextShowMnemonic | Qt::AlignLeft | alignment,
+                                      groupBox->palette, groupBox->state & State_Enabled, groupBox->text, QPalette::NoRole);
 
-                // top highlight
-                painter->setPen(titleBarHighlight);
-                painter->drawLine(fullRect.left() + 6, fullRect.top() + 1, fullRect.right() - 6, fullRect.top() + 1);
-            }
-            // draw title
-            QRect textRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarLabel, widget);
-            painter->setPen(active? (titleBar->palette.text().color().lighter(120)) :
-                                    titleBar->palette.text().color() );
-            // Note workspace also does elliding but it does not use the correct font
-            QString title = painter->fontMetrics().elidedText(titleBar->text, Qt::ElideRight, textRect.width() - 14);
-            painter->drawText(textRect.adjusted(1, 1, 1, 1), title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
-            painter->setPen(Qt::white);
-            if (active)
-                painter->drawText(textRect, title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
-            // min button
-            if ((titleBar->subControls & SC_TitleBarMinButton) && (titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
-                    !(titleBar->titleBarState& Qt::WindowMinimized)) {
-                QRect minButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMinButton, widget);
-                if (minButtonRect.isValid()) {
-                    bool hover = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_MouseOver);
-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_Sunken);
-                    qt_fusion_draw_mdibutton(painter, titleBar, minButtonRect, hover, sunken);
-                    QRect minButtonIconRect = minButtonRect.adjusted(buttonMargin ,buttonMargin , -buttonMargin, -buttonMargin);
-                    painter->setPen(textColor);
-                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 3,
-                                      minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 3);
-                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 4,
-                                      minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 4);
-                    painter->setPen(textAlphaColor);
-                    painter->drawLine(minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 3,
-                                      minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 4);
-                    painter->drawLine(minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 3,
-                                      minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 4);
+                if (groupBox->state & State_HasFocus) {
+                    QStyleOptionFocusRect fropt;
+                    fropt.QStyleOption::operator=(*groupBox);
+                    fropt.rect = textRect.adjusted(-2, -1, 2, 1);
+                    proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
                 }
             }
-            // max button
-            if ((titleBar->subControls & SC_TitleBarMaxButton) && (titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
-                    !(titleBar->titleBarState & Qt::WindowMaximized)) {
-                QRect maxButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMaxButton, widget);
-                if (maxButtonRect.isValid()) {
-                    bool hover = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_MouseOver);
-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_Sunken);
-                    qt_fusion_draw_mdibutton(painter, titleBar, maxButtonRect, hover, sunken);
-
-                    QRect maxButtonIconRect = maxButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
 
-                    painter->setPen(textColor);
-                    painter->drawRect(maxButtonIconRect.adjusted(0, 0, -1, -1));
-                    painter->drawLine(maxButtonIconRect.left() + 1, maxButtonIconRect.top() + 1,
-                                      maxButtonIconRect.right() - 1, maxButtonIconRect.top() + 1);
-                    painter->setPen(textAlphaColor);
-                    const QPoint points[4] = {
-                        maxButtonIconRect.topLeft(),
-                        maxButtonIconRect.topRight(),
-                        maxButtonIconRect.bottomLeft(),
-                        maxButtonIconRect.bottomRight()
-                    };
-                    painter->drawPoints(points, 4);
-                }
+            // Draw checkbox
+            if (groupBox->subControls & SC_GroupBoxCheckBox) {
+                QStyleOptionButton box;
+                box.QStyleOption::operator=(*groupBox);
+                box.rect = checkBoxRect;
+                proxy()->drawPrimitive(PE_IndicatorCheckBox, &box, painter, widget);
             }
+        }
+        painter->restore();
+        break;
+    case CC_SpinBox:
+        if (const QStyleOptionSpinBox *spinBox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
+            QPixmap cache;
+            QString pixmapName = QStyleHelper::uniqueName(QLatin1String("spinbox"), spinBox, spinBox->rect.size());
+            if (!QPixmapCache::find(pixmapName, cache)) {
 
-            // close button
-            if ((titleBar->subControls & SC_TitleBarCloseButton) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
-                QRect closeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarCloseButton, widget);
-                if (closeButtonRect.isValid()) {
-                    bool hover = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_MouseOver);
-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_Sunken);
-                    qt_fusion_draw_mdibutton(painter, titleBar, closeButtonRect, hover, sunken);
-                    QRect closeIconRect = closeButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
-                    painter->setPen(textAlphaColor);
-                    const QLine lines[4] = {
-                        QLine(closeIconRect.left() + 1, closeIconRect.top(),
-                        closeIconRect.right(), closeIconRect.bottom() - 1),
-                        QLine(closeIconRect.left(), closeIconRect.top() + 1,
-                        closeIconRect.right() - 1, closeIconRect.bottom()),
-                        QLine(closeIconRect.right() - 1, closeIconRect.top(),
-                        closeIconRect.left(), closeIconRect.bottom() - 1),
-                        QLine(closeIconRect.right(), closeIconRect.top() + 1,
-                        closeIconRect.left() + 1, closeIconRect.bottom())
-                    };
-                    painter->drawLines(lines, 4);
-                    const QPoint points[4] = {
-                        closeIconRect.topLeft(),
-                        closeIconRect.topRight(),
-                        closeIconRect.bottomLeft(),
-                        closeIconRect.bottomRight()
-                    };
-                    painter->drawPoints(points, 4);
+                cache = styleCachePixmap(spinBox->rect.size());
+                cache.fill(Qt::transparent);
 
-                    painter->setPen(textColor);
-                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.top() + 1,
-                                      closeIconRect.right() - 1, closeIconRect.bottom() - 1);
-                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.bottom() - 1,
-                                      closeIconRect.right() - 1, closeIconRect.top() + 1);
-                }
-            }
+                QRect pixmapRect(0, 0, spinBox->rect.width(), spinBox->rect.height());
+                QRect rect = pixmapRect;
+                QRect r = rect.adjusted(0, 1, 0, -1);
+                QPainter cachePainter(&cache);
+                QColor arrowColor = spinBox->palette.foreground().color();
+                arrowColor.setAlpha(220);
 
-            // normalize button
-            if ((titleBar->subControls & SC_TitleBarNormalButton) &&
-                    (((titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
-                      (titleBar->titleBarState & Qt::WindowMinimized)) ||
-                     ((titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
-                      (titleBar->titleBarState & Qt::WindowMaximized)))) {
-                QRect normalButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarNormalButton, widget);
-                if (normalButtonRect.isValid()) {
+                bool isEnabled = (spinBox->state & State_Enabled);
+                bool hover = isEnabled && (spinBox->state & State_MouseOver);
+                bool sunken = (spinBox->state & State_Sunken);
+                bool upIsActive = (spinBox->activeSubControls == SC_SpinBoxUp);
+                bool downIsActive = (spinBox->activeSubControls == SC_SpinBoxDown);
+                bool hasFocus = (option->state & State_HasFocus);
 
-                    bool hover = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_MouseOver);
-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_Sunken);
-                    QRect normalButtonIconRect = normalButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
-                    qt_fusion_draw_mdibutton(painter, titleBar, normalButtonRect, hover, sunken);
+                QStyleOptionSpinBox spinBoxCopy = *spinBox;
+                spinBoxCopy.rect = pixmapRect;
+                QRect upRect = proxy()->subControlRect(CC_SpinBox, &spinBoxCopy, SC_SpinBoxUp, widget);
+                QRect downRect = proxy()->subControlRect(CC_SpinBox, &spinBoxCopy, SC_SpinBoxDown, widget);
 
-                    QRect frontWindowRect = normalButtonIconRect.adjusted(0, 3, -3, 0);
-                    painter->setPen(textColor);
-                    painter->drawRect(frontWindowRect.adjusted(0, 0, -1, -1));
-                    painter->drawLine(frontWindowRect.left() + 1, frontWindowRect.top() + 1,
-                                      frontWindowRect.right() - 1, frontWindowRect.top() + 1);
-                    painter->setPen(textAlphaColor);
-                    const QPoint points[4] = {
-                        frontWindowRect.topLeft(),
-                        frontWindowRect.topRight(),
-                        frontWindowRect.bottomLeft(),
-                        frontWindowRect.bottomRight()
-                    };
-                    painter->drawPoints(points, 4);
+                if (spinBox->frame) {
+                    cachePainter.save();
+                    cachePainter.setRenderHint(QPainter::Antialiasing, true);
+                    cachePainter.translate(0.5, 0.5);
 
-                    QRect backWindowRect = normalButtonIconRect.adjusted(3, 0, 0, -3);
-                    QRegion clipRegion = backWindowRect;
-                    clipRegion -= frontWindowRect;
-                    painter->save();
-                    painter->setClipRegion(clipRegion);
-                    painter->setPen(textColor);
-                    painter->drawRect(backWindowRect.adjusted(0, 0, -1, -1));
-                    painter->drawLine(backWindowRect.left() + 1, backWindowRect.top() + 1,
-                                      backWindowRect.right() - 1, backWindowRect.top() + 1);
-                    painter->setPen(textAlphaColor);
-                    const QPoint points2[4] = {
-                        backWindowRect.topLeft(),
-                        backWindowRect.topRight(),
-                        backWindowRect.bottomLeft(),
-                        backWindowRect.bottomRight()
-                    };
-                    painter->drawPoints(points2, 4);
-                    painter->restore();
-                }
-            }
+                    // Fill background
+                    cachePainter.setPen(Qt::NoPen);
+                    cachePainter.setBrush(option->palette.base());
+                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
 
-            // context help button
-            if (titleBar->subControls & SC_TitleBarContextHelpButton
-                    && (titleBar->titleBarFlags & Qt::WindowContextHelpButtonHint)) {
-                QRect contextHelpButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarContextHelpButton, widget);
-                if (contextHelpButtonRect.isValid()) {
-                    bool hover = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_MouseOver);
-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_Sunken);
-                    qt_fusion_draw_mdibutton(painter, titleBar, contextHelpButtonRect, hover, sunken);
-                    QImage image(qt_titlebar_context_help);
-                    QColor alpha = textColor;
-                    alpha.setAlpha(128);
-                    image.setColor(1, textColor.rgba());
-                    image.setColor(2, alpha.rgba());
-                    painter->setRenderHint(QPainter::SmoothPixmapTransform);
-                    painter->drawImage(contextHelpButtonRect.adjusted(4, 4, -4, -4), image);
+                    // Draw inner shadow
+                    cachePainter.setPen(d->topShadow());
+                    cachePainter.drawLine(QPoint(r.left() + 2, r.top() + 1), QPoint(r.right() - 2, r.top() + 1));
+
+                    // Draw button gradient
+                    QColor buttonColor = d->buttonColor(option->palette);
+                    QRect updownRect = upRect.adjusted(0, -2, 0, downRect.height() + 2);
+                    QLinearGradient gradient = qt_fusion_gradient(updownRect, (isEnabled && option->state & State_MouseOver ) ? buttonColor : buttonColor.darker(104));
+
+                    // Draw button gradient
+                    cachePainter.setPen(Qt::NoPen);
+                    cachePainter.setBrush(gradient);
+
+                    cachePainter.save();
+                    cachePainter.setClipRect(updownRect);
+                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
+                    cachePainter.setPen(QPen(d->innerContrastLine()));
+                    cachePainter.setBrush(Qt::NoBrush);
+                    cachePainter.drawRoundedRect(r.adjusted(1, 1, -2, -2), 2, 2);
+                    cachePainter.restore();
+
+                    if ((spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) && upIsActive) {
+                        if (sunken)
+                            cachePainter.fillRect(upRect.adjusted(0, -1, 0, 0), gradientStopColor.darker(110));
+                        else if (hover)
+                            cachePainter.fillRect(upRect.adjusted(0, -1, 0, 0), d->innerContrastLine());
+                    }
+
+                    if ((spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) && downIsActive) {
+                        if (sunken)
+                            cachePainter.fillRect(downRect.adjusted(0, 0, 0, 1), gradientStopColor.darker(110));
+                        else if (hover)
+                            cachePainter.fillRect(downRect.adjusted(0, 0, 0, 1), d->innerContrastLine());
+                    }
+
+                    cachePainter.setPen(hasFocus ? d->highlightedOutline(option->palette) : outline);
+                    cachePainter.setBrush(Qt::NoBrush);
+                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
+                    if (hasFocus) {
+                        QColor softHighlight = option->palette.highlight().color();
+                        softHighlight.setAlpha(40);
+                        cachePainter.setPen(softHighlight);
+                        cachePainter.drawRoundedRect(r.adjusted(1, 1, -2, -2), 1.7, 1.7);
+                    }
+                    cachePainter.restore();
                 }
-            }
 
-            // shade button
-            if (titleBar->subControls & SC_TitleBarShadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
-                QRect shadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarShadeButton, widget);
-                if (shadeButtonRect.isValid()) {
-                    bool hover = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_MouseOver);
-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_Sunken);
-                    qt_fusion_draw_mdibutton(painter, titleBar, shadeButtonRect, hover, sunken);
-                    QPixmap arrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), textColor);
-                    painter->drawPixmap(shadeButtonRect.adjusted(5, 7, -5, -7), arrow);
+                // outline the up/down buttons
+                cachePainter.setPen(outline);
+                if (spinBox->direction == Qt::RightToLeft) {
+                    cachePainter.drawLine(upRect.right(), upRect.top() - 1, upRect.right(), downRect.bottom() + 1);
+                } else {
+                    cachePainter.drawLine(upRect.left(), upRect.top() - 1, upRect.left(), downRect.bottom() + 1);
                 }
-            }
 
-            // unshade button
-            if (titleBar->subControls & SC_TitleBarUnshadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
-                QRect unshadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarUnshadeButton, widget);
-                if (unshadeButtonRect.isValid()) {
-                    bool hover = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_MouseOver);
-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_Sunken);
-                    qt_fusion_draw_mdibutton(painter, titleBar, unshadeButtonRect, hover, sunken);
-                    QPixmap arrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), textColor, 180);
-                    painter->drawPixmap(unshadeButtonRect.adjusted(5, 7, -5, -7), arrow);
+                if (upIsActive && sunken) {
+                    cachePainter.setPen(gradientStopColor.darker(130));
+                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.right(), downRect.top());
+                    cachePainter.drawLine(upRect.left() + 1, upRect.top(), upRect.left() + 1, upRect.bottom());
+                    cachePainter.drawLine(upRect.left() + 1, upRect.top() - 1, upRect.right(), upRect.top() - 1);
                 }
-            }
 
-            if ((titleBar->subControls & SC_TitleBarSysMenu) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
-                QRect iconRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarSysMenu, widget);
-                if (iconRect.isValid()) {
-                    if (!titleBar->icon.isNull()) {
-                        titleBar->icon.paint(painter, iconRect);
-                    } else {
-                        QStyleOption tool(0);
-                        tool.palette = titleBar->palette;
-                        QPixmap pm = standardIcon(SP_TitleBarMenuButton, &tool, widget).pixmap(16, 16);
-                        tool.rect = iconRect;
-                        painter->save();
-                        proxy()->drawItemPixmap(painter, iconRect, Qt::AlignCenter, pm);
-                        painter->restore();
-                    }
+                if (downIsActive && sunken) {
+                    cachePainter.setPen(gradientStopColor.darker(130));
+                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.left() + 1, downRect.bottom() + 1);
+                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.right(), downRect.top());
+                    cachePainter.setPen(gradientStopColor.darker(110));
+                    cachePainter.drawLine(downRect.left() + 1, downRect.bottom() + 1, downRect.right(), downRect.bottom() + 1);
                 }
-            }
-        }
-        painter->restore();
-        break;
-    case CC_ScrollBar:
-        painter->save();
-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            bool wasActive = false;
-            qreal expandScale = 1.0;
-            qreal expandOffset = -1.0;
-            QObject *styleObject = option->styleObject;
-            if (styleObject && proxy()->styleHint(SH_ScrollBar_Transient, option, widget)) {
-                qreal opacity = 0.0;
-                bool shouldExpand = false;
-                const qreal maxExpandScale = 13.0 / 9.0;
 
-                int oldPos = styleObject->property("_q_stylepos").toInt();
-                int oldMin = styleObject->property("_q_stylemin").toInt();
-                int oldMax = styleObject->property("_q_stylemax").toInt();
-                QRect oldRect = styleObject->property("_q_stylerect").toRect();
-                int oldState = styleObject->property("_q_stylestate").toInt();
-                uint oldActiveControls = styleObject->property("_q_stylecontrols").toUInt();
+                QColor disabledColor = mergedColors(arrowColor, option->palette.button().color());
+                if (spinBox->buttonSymbols == QAbstractSpinBox::PlusMinus) {
+                    int centerX = upRect.center().x();
+                    int centerY = upRect.center().y();
 
-                // a scrollbar is transient when the the scrollbar itself and
-                // its sibling are both inactive (ie. not pressed/hovered/moved)
-                bool transient = !option->activeSubControls && !(option->state & State_On);
+                    // plus/minus
+                    cachePainter.setPen((spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) ? arrowColor : disabledColor);
+                    cachePainter.drawLine(centerX - 1, centerY, centerX + 3, centerY);
+                    cachePainter.drawLine(centerX + 1, centerY - 2, centerX + 1, centerY + 2);
 
-                if (!transient ||
-                        oldPos != scrollBar->sliderPosition ||
-                        oldMin != scrollBar->minimum ||
-                        oldMax != scrollBar->maximum ||
-                        oldRect != scrollBar->rect ||
-                        oldState != scrollBar->state ||
-                        oldActiveControls != scrollBar->activeSubControls) {
+                    centerX = downRect.center().x();
+                    centerY = downRect.center().y();
+                    cachePainter.setPen((spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) ? arrowColor : disabledColor);
+                    cachePainter.drawLine(centerX - 1, centerY, centerX + 3, centerY);
 
-                    // if the scrollbar is transient or its attributes, geometry or
-                    // state has changed, the opacity is reset back to 100% opaque
-                    opacity = 1.0;
+                } else if (spinBox->buttonSymbols == QAbstractSpinBox::UpDownArrows){
+                    // arrows
+                    painter->setRenderHint(QPainter::SmoothPixmapTransform);
 
-                    styleObject->setProperty("_q_stylepos", scrollBar->sliderPosition);
-                    styleObject->setProperty("_q_stylemin", scrollBar->minimum);
-                    styleObject->setProperty("_q_stylemax", scrollBar->maximum);
-                    styleObject->setProperty("_q_stylerect", scrollBar->rect);
-                    styleObject->setProperty("_q_stylestate", static_cast<int>(scrollBar->state));
-                    styleObject->setProperty("_q_stylecontrols", static_cast<uint>(scrollBar->activeSubControls));
+                    QPixmap upArrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"),
+                                                     (spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) ? arrowColor : disabledColor);
 
-                    QScrollbarStyleAnimation *anim  = qobject_cast<QScrollbarStyleAnimation *>(d->animation(styleObject));
-                    if (transient) {
-                        if (!anim) {
-                            anim = new QScrollbarStyleAnimation(QScrollbarStyleAnimation::Deactivating, styleObject);
-                            d->startAnimation(anim);
-                        } else if (anim->mode() == QScrollbarStyleAnimation::Deactivating) {
-                            // the scrollbar was already fading out while the
-                            // state changed -> restart the fade out animation
-                            anim->setCurrentTime(0);
-                        }
-                    } else if (anim && anim->mode() == QScrollbarStyleAnimation::Deactivating) {
-                        d->stopAnimation(styleObject);
-                    }
-                }
+                    QRectF upArrowRect = QRectF(upRect.center().x() - upArrow.width() / 4.0 + 1.0,
+                                                upRect.center().y() - upArrow.height() / 4.0 + 1.0,
+                                                upArrow.width() / 2.0, upArrow.height() / 2.0);
 
-                QScrollbarStyleAnimation *anim = qobject_cast<QScrollbarStyleAnimation *>(d->animation(styleObject));
-                if (anim && anim->mode() == QScrollbarStyleAnimation::Deactivating) {
-                    // once a scrollbar was active (hovered/pressed), it retains
-                    // the active look even if it's no longer active while fading out
-                    if (oldActiveControls)
-                        anim->setActive(true);
+                    cachePainter.drawPixmap(upArrowRect, upArrow, QRectF(QPointF(0.0, 0.0), upArrow.size()));
 
-                    wasActive = anim->wasActive();
-                    opacity = anim->currentValue();
+                    QPixmap downArrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"),
+                                                       (spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) ? arrowColor : disabledColor, 180);
+                    QRectF downArrowRect = QRectF(downRect.center().x() - downArrow.width() / 4.0 + 1.0,
+                                                  downRect.center().y() - downArrow.height() / 4.0 + 1.0,
+                                                  downArrow.width() / 2.0, downArrow.height() / 2.0);
+                    cachePainter.drawPixmap(downArrowRect, downArrow, QRectF(QPointF(0.0, 0.0), downArrow.size()));
                 }
 
-                shouldExpand = (option->activeSubControls || wasActive);
-                if (shouldExpand) {
-                    if (!anim && !oldActiveControls) {
-                        // Start expand animation only once and when entering
-                        anim = new QScrollbarStyleAnimation(QScrollbarStyleAnimation::Activating, styleObject);
-                        d->startAnimation(anim);
-                    }
-                    if (anim && anim->mode() == QScrollbarStyleAnimation::Activating) {
-                        expandScale = 1.0 + (maxExpandScale - 1.0) * anim->currentValue();
-                        expandOffset = 5.5 * anim->currentValue() - 1;
-                    } else {
-                        // Keep expanded state after the animation ends, and when fading out
-                        expandScale = maxExpandScale;
-                        expandOffset = 4.5;
-                    }
-                }
-                painter->setOpacity(opacity);
+                cachePainter.end();
+                QPixmapCache::insert(pixmapName, cache);
             }
+            painter->drawPixmap(spinBox->rect.topLeft(), cache);
+        }
+        break;
+    case CC_TitleBar:
+        painter->save();
+        if (const QStyleOptionTitleBar *titleBar = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {
+            const int buttonMargin = 5;
+            bool active = (titleBar->titleBarState & State_Active);
+            QRect fullRect = titleBar->rect;
+            QPalette palette = option->palette;
+            QColor highlight = option->palette.highlight().color();
 
-            bool transient = proxy()->styleHint(SH_ScrollBar_Transient, option, widget);
-            bool horizontal = scrollBar->orientation == Qt::Horizontal;
-            bool sunken = scrollBar->state & State_Sunken;
+            QColor titleBarFrameBorder(active ? highlight.darker(180): outline.darker(110));
+            QColor titleBarHighlight(active ? highlight.lighter(120): palette.background().color().lighter(120));
+            QColor textColor(active ? 0xffffff : 0xff000000);
+            QColor textAlphaColor(active ? 0xffffff : 0xff000000 );
 
-            QRect scrollBarSubLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSubLine, widget);
-            QRect scrollBarAddLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarAddLine, widget);
-            QRect scrollBarSlider = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSlider, widget);
-            QRect scrollBarGroove = proxy()->subControlRect(control, scrollBar, SC_ScrollBarGroove, widget);
+            {
+                // Fill title bar gradient
+                QColor titlebarColor = QColor(active ? highlight: palette.background().color());
+                QLinearGradient gradient(option->rect.center().x(), option->rect.top(),
+                                         option->rect.center().x(), option->rect.bottom());
 
-            QRect rect = option->rect;
-            QColor alphaOutline = outline;
-            alphaOutline.setAlpha(180);
+                gradient.setColorAt(0, titlebarColor.lighter(114));
+                gradient.setColorAt(0.5, titlebarColor.lighter(102));
+                gradient.setColorAt(0.51, titlebarColor.darker(104));
+                gradient.setColorAt(1, titlebarColor);
+                painter->fillRect(option->rect.adjusted(1, 1, -1, 0), gradient);
 
-            QColor arrowColor = option->palette.foreground().color();
-            arrowColor.setAlpha(220);
+                // Frame and rounded corners
+                painter->setPen(titleBarFrameBorder);
 
-            const QColor bgColor = QStyleHelper::backgroundColor(option->palette, widget);
-            const bool isDarkBg = bgColor.red() < 128 && bgColor.green() < 128 && bgColor.blue() < 128;
+                // top outline
+                painter->drawLine(fullRect.left() + 5, fullRect.top(), fullRect.right() - 5, fullRect.top());
+                painter->drawLine(fullRect.left(), fullRect.top() + 4, fullRect.left(), fullRect.bottom());
+                const QPoint points[5] = {
+                    QPoint(fullRect.left() + 4, fullRect.top() + 1),
+                    QPoint(fullRect.left() + 3, fullRect.top() + 1),
+                    QPoint(fullRect.left() + 2, fullRect.top() + 2),
+                    QPoint(fullRect.left() + 1, fullRect.top() + 3),
+                    QPoint(fullRect.left() + 1, fullRect.top() + 4)
+                };
+                painter->drawPoints(points, 5);
 
-            if (transient) {
-                if (horizontal) {
-                    rect.setY(rect.y() + 4.5 - expandOffset);
-                    scrollBarSlider.setY(scrollBarSlider.y() + 4.5 - expandOffset);
-                    scrollBarGroove.setY(scrollBarGroove.y() + 4.5 - expandOffset);
+                painter->drawLine(fullRect.right(), fullRect.top() + 4, fullRect.right(), fullRect.bottom());
+                const QPoint points2[5] = {
+                    QPoint(fullRect.right() - 3, fullRect.top() + 1),
+                    QPoint(fullRect.right() - 4, fullRect.top() + 1),
+                    QPoint(fullRect.right() - 2, fullRect.top() + 2),
+                    QPoint(fullRect.right() - 1, fullRect.top() + 3),
+                    QPoint(fullRect.right() - 1, fullRect.top() + 4)
+                };
+                painter->drawPoints(points2, 5);
 
-                    rect.setHeight(rect.height() * expandScale);
-                    scrollBarGroove.setHeight(scrollBarGroove.height() * expandScale);
-                } else {
-                    rect.setX(rect.x() + 4.5 - expandOffset);
-                    scrollBarSlider.setX(scrollBarSlider.x() + 4.5 - expandOffset);
-                    scrollBarGroove.setX(scrollBarGroove.x() + 4.5 - expandOffset);
+                // draw bottomline
+                painter->drawLine(fullRect.right(), fullRect.bottom(), fullRect.left(), fullRect.bottom());
 
-                    rect.setWidth(rect.width() * expandScale);
-                    scrollBarGroove.setWidth(scrollBarGroove.width() * expandScale);
-                }
+                // top highlight
+                painter->setPen(titleBarHighlight);
+                painter->drawLine(fullRect.left() + 6, fullRect.top() + 1, fullRect.right() - 6, fullRect.top() + 1);
             }
-
-            // Paint groove
-            if ((!transient || scrollBar->activeSubControls || wasActive) && scrollBar->subControls & SC_ScrollBarGroove) {
-                QLinearGradient gradient(rect.center().x(), rect.top(),
-                                         rect.center().x(), rect.bottom());
-                if (!horizontal)
-                    gradient = QLinearGradient(rect.left(), rect.center().y(),
-                                               rect.right(), rect.center().y());
-                if (!transient || !isDarkBg) {
-                    gradient.setColorAt(0, buttonColor.darker(107));
-                    gradient.setColorAt(0.1, buttonColor.darker(105));
-                    gradient.setColorAt(0.9, buttonColor.darker(105));
-                    gradient.setColorAt(1, buttonColor.darker(107));
-                } else {
-                    gradient.setColorAt(0, bgColor.lighter(157));
-                    gradient.setColorAt(0.1, bgColor.lighter(155));
-                    gradient.setColorAt(0.9, bgColor.lighter(155));
-                    gradient.setColorAt(1, bgColor.lighter(157));
+            // draw title
+            QRect textRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarLabel, widget);
+            painter->setPen(active? (titleBar->palette.text().color().lighter(120)) :
+                                    titleBar->palette.text().color() );
+            // Note workspace also does elliding but it does not use the correct font
+            QString title = painter->fontMetrics().elidedText(titleBar->text, Qt::ElideRight, textRect.width() - 14);
+            painter->drawText(textRect.adjusted(1, 1, 1, 1), title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
+            painter->setPen(Qt::white);
+            if (active)
+                painter->drawText(textRect, title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
+            // min button
+            if ((titleBar->subControls & SC_TitleBarMinButton) && (titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
+                    !(titleBar->titleBarState& Qt::WindowMinimized)) {
+                QRect minButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMinButton, widget);
+                if (minButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_Sunken);
+                    qt_fusion_draw_mdibutton(painter, titleBar, minButtonRect, hover, sunken);
+                    QRect minButtonIconRect = minButtonRect.adjusted(buttonMargin ,buttonMargin , -buttonMargin, -buttonMargin);
+                    painter->setPen(textColor);
+                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 3,
+                                      minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 3);
+                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 4,
+                                      minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 4);
+                    painter->setPen(textAlphaColor);
+                    painter->drawLine(minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 3,
+                                      minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 4);
+                    painter->drawLine(minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 3,
+                                      minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 4);
                 }
+            }
+            // max button
+            if ((titleBar->subControls & SC_TitleBarMaxButton) && (titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
+                    !(titleBar->titleBarState & Qt::WindowMaximized)) {
+                QRect maxButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMaxButton, widget);
+                if (maxButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_Sunken);
+                    qt_fusion_draw_mdibutton(painter, titleBar, maxButtonRect, hover, sunken);
 
-                painter->save();
-                if (transient)
-                    painter->setOpacity(0.8);
-                painter->fillRect(rect, gradient);
-                painter->setPen(Qt::NoPen);
-                if (transient)
-                    painter->setOpacity(0.4);
-                painter->setPen(alphaOutline);
-                if (horizontal)
-                    painter->drawLine(rect.topLeft(), rect.topRight());
-                else
-                    painter->drawLine(rect.topLeft(), rect.bottomLeft());
+                    QRect maxButtonIconRect = maxButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
 
-                QColor subtleEdge = alphaOutline;
-                subtleEdge.setAlpha(40);
-                painter->setPen(Qt::NoPen);
-                painter->setBrush(Qt::NoBrush);
-                painter->setClipRect(scrollBarGroove.adjusted(1, 0, -1, -3));
-                painter->drawRect(scrollBarGroove.adjusted(1, 0, -1, -1));
-                painter->restore();
+                    painter->setPen(textColor);
+                    painter->drawRect(maxButtonIconRect.adjusted(0, 0, -1, -1));
+                    painter->drawLine(maxButtonIconRect.left() + 1, maxButtonIconRect.top() + 1,
+                                      maxButtonIconRect.right() - 1, maxButtonIconRect.top() + 1);
+                    painter->setPen(textAlphaColor);
+                    const QPoint points[4] = {
+                        maxButtonIconRect.topLeft(),
+                        maxButtonIconRect.topRight(),
+                        maxButtonIconRect.bottomLeft(),
+                        maxButtonIconRect.bottomRight()
+                    };
+                    painter->drawPoints(points, 4);
+                }
             }
 
-            QRect pixmapRect = scrollBarSlider;
-            QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
-                                     pixmapRect.center().x(), pixmapRect.bottom());
-            if (!horizontal)
-                gradient = QLinearGradient(pixmapRect.left(), pixmapRect.center().y(),
-                                           pixmapRect.right(), pixmapRect.center().y());
+            // close button
+            if ((titleBar->subControls & SC_TitleBarCloseButton) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
+                QRect closeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarCloseButton, widget);
+                if (closeButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_Sunken);
+                    qt_fusion_draw_mdibutton(painter, titleBar, closeButtonRect, hover, sunken);
+                    QRect closeIconRect = closeButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+                    painter->setPen(textAlphaColor);
+                    const QLine lines[4] = {
+                        QLine(closeIconRect.left() + 1, closeIconRect.top(),
+                        closeIconRect.right(), closeIconRect.bottom() - 1),
+                        QLine(closeIconRect.left(), closeIconRect.top() + 1,
+                        closeIconRect.right() - 1, closeIconRect.bottom()),
+                        QLine(closeIconRect.right() - 1, closeIconRect.top(),
+                        closeIconRect.left(), closeIconRect.bottom() - 1),
+                        QLine(closeIconRect.right(), closeIconRect.top() + 1,
+                        closeIconRect.left() + 1, closeIconRect.bottom())
+                    };
+                    painter->drawLines(lines, 4);
+                    const QPoint points[4] = {
+                        closeIconRect.topLeft(),
+                        closeIconRect.topRight(),
+                        closeIconRect.bottomLeft(),
+                        closeIconRect.bottomRight()
+                    };
+                    painter->drawPoints(points, 4);
 
-            QLinearGradient highlightedGradient = gradient;
+                    painter->setPen(textColor);
+                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.top() + 1,
+                                      closeIconRect.right() - 1, closeIconRect.bottom() - 1);
+                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.bottom() - 1,
+                                      closeIconRect.right() - 1, closeIconRect.top() + 1);
+                }
+            }
 
-            QColor midColor2 = mergedColors(gradientStartColor, gradientStopColor, 40);
-            gradient.setColorAt(0, d->buttonColor(option->palette).lighter(108));
-            gradient.setColorAt(1, d->buttonColor(option->palette));
+            // normalize button
+            if ((titleBar->subControls & SC_TitleBarNormalButton) &&
+                    (((titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
+                      (titleBar->titleBarState & Qt::WindowMinimized)) ||
+                     ((titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
+                      (titleBar->titleBarState & Qt::WindowMaximized)))) {
+                QRect normalButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarNormalButton, widget);
+                if (normalButtonRect.isValid()) {
 
-            highlightedGradient.setColorAt(0, gradientStartColor.darker(102));
-            highlightedGradient.setColorAt(1, gradientStopColor.lighter(102));
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_Sunken);
+                    QRect normalButtonIconRect = normalButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+                    qt_fusion_draw_mdibutton(painter, titleBar, normalButtonRect, hover, sunken);
 
-            // Paint slider
-            if (scrollBar->subControls & SC_ScrollBarSlider) {
-                if (transient) {
-                    QRect rect = scrollBarSlider.adjusted(horizontal ? 1 : 2, horizontal ? 2 : 1, -1, -1);
-                    painter->setPen(Qt::NoPen);
-                    painter->setBrush(isDarkBg ? d->lightShade() : d->darkShade());
-                    int r = qMin(rect.width(), rect.height()) / 2;
+                    QRect frontWindowRect = normalButtonIconRect.adjusted(0, 3, -3, 0);
+                    painter->setPen(textColor);
+                    painter->drawRect(frontWindowRect.adjusted(0, 0, -1, -1));
+                    painter->drawLine(frontWindowRect.left() + 1, frontWindowRect.top() + 1,
+                                      frontWindowRect.right() - 1, frontWindowRect.top() + 1);
+                    painter->setPen(textAlphaColor);
+                    const QPoint points[4] = {
+                        frontWindowRect.topLeft(),
+                        frontWindowRect.topRight(),
+                        frontWindowRect.bottomLeft(),
+                        frontWindowRect.bottomRight()
+                    };
+                    painter->drawPoints(points, 4);
 
+                    QRect backWindowRect = normalButtonIconRect.adjusted(3, 0, 0, -3);
+                    QRegion clipRegion = backWindowRect;
+                    clipRegion -= frontWindowRect;
                     painter->save();
-                    painter->setRenderHint(QPainter::Antialiasing, true);
-                    painter->drawRoundedRect(rect, r, r);
+                    painter->setClipRegion(clipRegion);
+                    painter->setPen(textColor);
+                    painter->drawRect(backWindowRect.adjusted(0, 0, -1, -1));
+                    painter->drawLine(backWindowRect.left() + 1, backWindowRect.top() + 1,
+                                      backWindowRect.right() - 1, backWindowRect.top() + 1);
+                    painter->setPen(textAlphaColor);
+                    const QPoint points2[4] = {
+                        backWindowRect.topLeft(),
+                        backWindowRect.topRight(),
+                        backWindowRect.bottomLeft(),
+                        backWindowRect.bottomRight()
+                    };
+                    painter->drawPoints(points2, 4);
                     painter->restore();
-                } else {
-                    QRect pixmapRect = scrollBarSlider;
-                    painter->setPen(QPen(alphaOutline));
-                    if (option->state & State_Sunken && scrollBar->activeSubControls & SC_ScrollBarSlider)
-                        painter->setBrush(midColor2);
-                    else if (option->state & State_MouseOver && scrollBar->activeSubControls & SC_ScrollBarSlider)
-                        painter->setBrush(highlightedGradient);
-                    else
-                        painter->setBrush(gradient);
-
-                    painter->drawRect(pixmapRect.adjusted(horizontal ? -1 : 0, horizontal ? 0 : -1, horizontal ? 0 : 1, horizontal ? 1 : 0));
-
-                    painter->setPen(d->innerContrastLine());
-                    painter->drawRect(scrollBarSlider.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, -1, -1));
-
-                    // Outer shadow
-                    //                  painter->setPen(subtleEdge);
-                    //                  if (horizontal) {
-                    ////                    painter->drawLine(scrollBarSlider.topLeft() + QPoint(-2, 0), scrollBarSlider.bottomLeft() + QPoint(2, 0));
-                    ////                    painter->drawLine(scrollBarSlider.topRight() + QPoint(-2, 0), scrollBarSlider.bottomRight() + QPoint(2, 0));
-                    //                  } else {
-                    ////                    painter->drawLine(pixmapRect.topLeft() + QPoint(0, -2), pixmapRect.bottomLeft() + QPoint(0, -2));
-                    ////                    painter->drawLine(pixmapRect.topRight() + QPoint(0, 2), pixmapRect.bottomRight() + QPoint(0, 2));
-                    //                  }
                 }
             }
 
-            // The SubLine (up/left) buttons
-            if (!transient && scrollBar->subControls & SC_ScrollBarSubLine) {
-                if ((scrollBar->activeSubControls & SC_ScrollBarSubLine) && sunken)
-                    painter->setBrush(gradientStopColor);
-                else if ((scrollBar->activeSubControls & SC_ScrollBarSubLine))
-                    painter->setBrush(highlightedGradient);
-                else
-                    painter->setBrush(gradient);
-
-                painter->setPen(Qt::NoPen);
-                painter->drawRect(scrollBarSubLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, 0, 0));
-                painter->setPen(QPen(alphaOutline));
-                if (option->state & State_Horizontal) {
-                    if (option->direction == Qt::RightToLeft) {
-                        pixmapRect.setLeft(scrollBarSubLine.left());
-                        painter->drawLine(pixmapRect.topLeft(), pixmapRect.bottomLeft());
-                    } else {
-                        pixmapRect.setRight(scrollBarSubLine.right());
-                        painter->drawLine(pixmapRect.topRight(), pixmapRect.bottomRight());
-                    }
-                } else {
-                    pixmapRect.setBottom(scrollBarSubLine.bottom());
-                    painter->drawLine(pixmapRect.bottomLeft(), pixmapRect.bottomRight());
+            // context help button
+            if (titleBar->subControls & SC_TitleBarContextHelpButton
+                    && (titleBar->titleBarFlags & Qt::WindowContextHelpButtonHint)) {
+                QRect contextHelpButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarContextHelpButton, widget);
+                if (contextHelpButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_Sunken);
+                    qt_fusion_draw_mdibutton(painter, titleBar, contextHelpButtonRect, hover, sunken);
+                    QImage image(qt_titlebar_context_help);
+                    QColor alpha = textColor;
+                    alpha.setAlpha(128);
+                    image.setColor(1, textColor.rgba());
+                    image.setColor(2, alpha.rgba());
+                    painter->setRenderHint(QPainter::SmoothPixmapTransform);
+                    painter->drawImage(contextHelpButtonRect.adjusted(4, 4, -4, -4), image);
                 }
+            }
 
-                painter->setBrush(Qt::NoBrush);
-                painter->setPen(d->innerContrastLine());
-                painter->drawRect(scrollBarSubLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0 ,  horizontal ? -2 : -1, horizontal ? -1 : -2));
-
-                // Arrows
-                int rotation = 0;
-                if (option->state & State_Horizontal)
-                    rotation = option->direction == Qt::LeftToRight ? -90 : 90;
-                QRect upRect = scrollBarSubLine.translated(horizontal ? -2 : -1, 0);
-                QPixmap arrowPixmap = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), arrowColor, rotation);
-                painter->drawPixmap(QRectF(upRect.center().x() - arrowPixmap.width() / 4.0  + 2.0,
-                                          upRect.center().y() - arrowPixmap.height() / 4.0 + 1.0,
-                                          arrowPixmap.width() / 2.0, arrowPixmap.height() / 2.0),
-                                          arrowPixmap, QRectF(QPoint(0.0, 0.0), arrowPixmap.size()));
+            // shade button
+            if (titleBar->subControls & SC_TitleBarShadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
+                QRect shadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarShadeButton, widget);
+                if (shadeButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_Sunken);
+                    qt_fusion_draw_mdibutton(painter, titleBar, shadeButtonRect, hover, sunken);
+                    QPixmap arrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), textColor);
+                    painter->drawPixmap(shadeButtonRect.adjusted(5, 7, -5, -7), arrow);
+                }
             }
 
-            // The AddLine (down/right) button
-            if (!transient && scrollBar->subControls & SC_ScrollBarAddLine) {
-                if ((scrollBar->activeSubControls & SC_ScrollBarAddLine) && sunken)
-                    painter->setBrush(gradientStopColor);
-                else if ((scrollBar->activeSubControls & SC_ScrollBarAddLine))
-                    painter->setBrush(midColor2);
-                else
-                    painter->setBrush(gradient);
+            // unshade button
+            if (titleBar->subControls & SC_TitleBarUnshadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
+                QRect unshadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarUnshadeButton, widget);
+                if (unshadeButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_Sunken);
+                    qt_fusion_draw_mdibutton(painter, titleBar, unshadeButtonRect, hover, sunken);
+                    QPixmap arrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), textColor, 180);
+                    painter->drawPixmap(unshadeButtonRect.adjusted(5, 7, -5, -7), arrow);
+                }
+            }
 
-                painter->setPen(Qt::NoPen);
-                painter->drawRect(scrollBarAddLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, 0, 0));
-                painter->setPen(QPen(alphaOutline, 1));
-                if (option->state & State_Horizontal) {
-                    if (option->direction == Qt::LeftToRight) {
-                        pixmapRect.setLeft(scrollBarAddLine.left());
-                        painter->drawLine(pixmapRect.topLeft(), pixmapRect.bottomLeft());
+            if ((titleBar->subControls & SC_TitleBarSysMenu) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
+                QRect iconRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarSysMenu, widget);
+                if (iconRect.isValid()) {
+                    if (!titleBar->icon.isNull()) {
+                        titleBar->icon.paint(painter, iconRect);
                     } else {
-                        pixmapRect.setRight(scrollBarAddLine.right());
-                        painter->drawLine(pixmapRect.topRight(), pixmapRect.bottomRight());
+                        QStyleOption tool(0);
+                        tool.palette = titleBar->palette;
+                        QPixmap pm = standardIcon(SP_TitleBarMenuButton, &tool, widget).pixmap(16, 16);
+                        tool.rect = iconRect;
+                        painter->save();
+                        proxy()->drawItemPixmap(painter, iconRect, Qt::AlignCenter, pm);
+                        painter->restore();
                     }
-                } else {
-                    pixmapRect.setTop(scrollBarAddLine.top());
-                    painter->drawLine(pixmapRect.topLeft(), pixmapRect.topRight());
                 }
-
-                painter->setPen(d->innerContrastLine());
-                painter->setBrush(Qt::NoBrush);
-                painter->drawRect(scrollBarAddLine.adjusted(1, 1, -1, -1));
-
-                int rotation = 180;
-                if (option->state & State_Horizontal)
-                    rotation = option->direction == Qt::LeftToRight ? 90 : -90;
-                QRect downRect = scrollBarAddLine.translated(-1, 1);
-                QPixmap arrowPixmap = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), arrowColor, rotation);
-                painter->drawPixmap(QRectF(downRect.center().x() - arrowPixmap.width() / 4.0 + 2.0,
-                                           downRect.center().y() - arrowPixmap.height() / 4.0,
-                                           arrowPixmap.width() / 2.0, arrowPixmap.height() / 2.0),
-                                           arrowPixmap, QRectF(QPoint(0.0, 0.0), arrowPixmap.size()));
             }
-
         }
         painter->restore();
+        break;
+    case CC_ScrollBar:
+        drawComplexControlScrollBar<QStyleOptionSlider>(control, option, painter, widget, proxy(), d);
+        break;;
+    case CC_ScrollBar64:
+        drawComplexControlScrollBar<QStyleOptionSlider64>(control, option, painter, widget, proxy(), d);
         break;;
     case CC_ComboBox:
         painter->save();
@@ -2792,214 +3087,10 @@ void QFusionStyle::drawComplexControl(ComplexControl control, const QStyleOption
         painter->restore();
         break;
     case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            QRect groove = proxy()->subControlRect(CC_Slider, option, SC_SliderGroove, widget);
-            QRect handle = proxy()->subControlRect(CC_Slider, option, SC_SliderHandle, widget);
-
-            bool horizontal = slider->orientation == Qt::Horizontal;
-            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
-            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
-            QColor activeHighlight = d->highlight(option->palette);
-            QPixmap cache;
-            QBrush oldBrush = painter->brush();
-            QPen oldPen = painter->pen();
-            QColor shadowAlpha(Qt::black);
-            shadowAlpha.setAlpha(10);
-            if (option->state & State_HasFocus && option->state & State_KeyboardFocusChange)
-                outline = d->highlightedOutline(option->palette);
-
-
-            if ((option->subControls & SC_SliderGroove) && groove.isValid()) {
-                QColor grooveColor;
-                grooveColor.setHsv(buttonColor.hue(),
-                                   qMin(255, (int)(buttonColor.saturation())),
-                                   qMin(255, (int)(buttonColor.value()*0.9)));
-                QString groovePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_groove"), option, groove.size());
-                QRect pixmapRect(0, 0, groove.width(), groove.height());
-
-                // draw background groove
-                if (!QPixmapCache::find(groovePixmapName, cache)) {
-                    cache = styleCachePixmap(pixmapRect.size());
-                    cache.fill(Qt::transparent);
-                    QPainter groovePainter(&cache);
-                    groovePainter.setRenderHint(QPainter::Antialiasing, true);
-                    groovePainter.translate(0.5, 0.5);
-                    QLinearGradient gradient;
-                    if (horizontal) {
-                        gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
-                        gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
-                    }
-                    else {
-                        gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
-                        gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
-                    }
-                    groovePainter.setPen(QPen(outline));
-                    gradient.setColorAt(0, grooveColor.darker(110));
-                    gradient.setColorAt(1, grooveColor.lighter(110));//palette.button().color().darker(115));
-                    groovePainter.setBrush(gradient);
-                    groovePainter.drawRoundedRect(pixmapRect.adjusted(1, 1, -2, -2), 1, 1);
-                    groovePainter.end();
-                    QPixmapCache::insert(groovePixmapName, cache);
-                }
-                painter->drawPixmap(groove.topLeft(), cache);
-
-                // draw blue groove highlight
-                QRect clipRect;
-                groovePixmapName += QLatin1String("_blue");
-                if (!QPixmapCache::find(groovePixmapName, cache)) {
-                    cache = styleCachePixmap(pixmapRect.size());
-                    cache.fill(Qt::transparent);
-                    QPainter groovePainter(&cache);
-                    QLinearGradient gradient;
-                    if (horizontal) {
-                        gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
-                        gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
-                    }
-                    else {
-                        gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
-                        gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
-                    }
-                    QColor highlight = d->highlight(option->palette);
-                    QColor highlightedoutline = highlight.darker(140);
-                    if (qGray(outline.rgb()) > qGray(highlightedoutline.rgb()))
-                        outline = highlightedoutline;
-
-
-                    groovePainter.setRenderHint(QPainter::Antialiasing, true);
-                    groovePainter.translate(0.5, 0.5);
-                    groovePainter.setPen(QPen(outline));
-                    gradient.setColorAt(0, activeHighlight);
-                    gradient.setColorAt(1, activeHighlight.lighter(130));
-                    groovePainter.setBrush(gradient);
-                    groovePainter.drawRoundedRect(pixmapRect.adjusted(1, 1, -2, -2), 1, 1);
-                    groovePainter.setPen(d->innerContrastLine());
-                    groovePainter.setBrush(Qt::NoBrush);
-                    groovePainter.drawRoundedRect(pixmapRect.adjusted(2, 2, -3, -3), 1, 1);
-                    groovePainter.end();
-                    QPixmapCache::insert(groovePixmapName, cache);
-                }
-                if (horizontal) {
-                    if (slider->upsideDown)
-                        clipRect = QRect(handle.right(), groove.top(), groove.right() - handle.right(), groove.height());
-                    else
-                        clipRect = QRect(groove.left(), groove.top(), handle.left(), groove.height());
-                } else {
-                    if (slider->upsideDown)
-                        clipRect = QRect(groove.left(), handle.bottom(), groove.width(), groove.height() - handle.bottom());
-                    else
-                        clipRect = QRect(groove.left(), groove.top(), groove.width(), handle.top() - groove.top());
-                }
-                painter->save();
-                painter->setClipRect(clipRect.adjusted(0, 0, 1, 1), Qt::IntersectClip);
-                painter->drawPixmap(groove.topLeft(), cache);
-                painter->restore();
-            }
-
-            if (option->subControls & SC_SliderTickmarks) {
-                painter->setPen(outline);
-                int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
-                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
-                int interval = slider->tickInterval;
-                if (interval <= 0) {
-                    interval = slider->singleStep;
-                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
-                                                        available)
-                            - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                              0, available) < 3)
-                        interval = slider->pageStep;
-                }
-                if (interval <= 0)
-                    interval = 1;
-
-                int v = slider->minimum;
-                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
-                while (v <= slider->maximum + 1) {
-                    if (v == slider->maximum + 1 && interval == 1)
-                        break;
-                    const int v_ = qMin(v, slider->maximum);
-                    int pos = sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                      v_, (horizontal
-                                                           ? slider->rect.width()
-                                                           : slider->rect.height()) - len,
-                                                      slider->upsideDown) + len / 2;
-                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
-
-                    if (horizontal) {
-                        if (ticksAbove) {
-                            painter->drawLine(pos, slider->rect.top() + extra,
-                                              pos, slider->rect.top() + tickSize);
-                        }
-                        if (ticksBelow) {
-                            painter->drawLine(pos, slider->rect.bottom() - extra,
-                                              pos, slider->rect.bottom() - tickSize);
-                        }
-                    } else {
-                        if (ticksAbove) {
-                            painter->drawLine(slider->rect.left() + extra, pos,
-                                              slider->rect.left() + tickSize, pos);
-                        }
-                        if (ticksBelow) {
-                            painter->drawLine(slider->rect.right() - extra, pos,
-                                              slider->rect.right() - tickSize, pos);
-                        }
-                    }
-                    // in the case where maximum is max int
-                    int nextInterval = v + interval;
-                    if (nextInterval < v)
-                        break;
-                    v = nextInterval;
-                }
-            }
-            // draw handle
-            if ((option->subControls & SC_SliderHandle) ) {
-                QString handlePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_handle"), option, handle.size());
-                if (!QPixmapCache::find(handlePixmapName, cache)) {
-                    cache = styleCachePixmap(handle.size());
-                    cache.fill(Qt::transparent);
-                    QRect pixmapRect(0, 0, handle.width(), handle.height());
-                    QPainter handlePainter(&cache);
-                    QRect gradRect = pixmapRect.adjusted(2, 2, -2, -2);
-
-                    // gradient fill
-                    QRect r = pixmapRect.adjusted(1, 1, -2, -2);
-                    QLinearGradient gradient = qt_fusion_gradient(gradRect, d->buttonColor(option->palette),horizontal ? TopDown : FromLeft);
-
-                    handlePainter.setRenderHint(QPainter::Antialiasing, true);
-                    handlePainter.translate(0.5, 0.5);
-
-                    handlePainter.setPen(Qt::NoPen);
-                    handlePainter.setBrush(QColor(0, 0, 0, 40));
-                    handlePainter.drawRect(r.adjusted(-1, 2, 1, -2));
-
-                    handlePainter.setPen(QPen(d->outline(option->palette)));
-                    if (option->state & State_HasFocus && option->state & State_KeyboardFocusChange)
-                        handlePainter.setPen(QPen(d->highlightedOutline(option->palette)));
-
-                    handlePainter.setBrush(gradient);
-                    handlePainter.drawRoundedRect(r, 2, 2);
-                    handlePainter.setBrush(Qt::NoBrush);
-                    handlePainter.setPen(d->innerContrastLine());
-                    handlePainter.drawRoundedRect(r.adjusted(1, 1, -1, -1), 2, 2);
-
-                    QColor cornerAlpha = outline.darker(120);
-                    cornerAlpha.setAlpha(80);
-
-                    //handle shadow
-                    handlePainter.setPen(shadowAlpha);
-                    handlePainter.drawLine(QPoint(r.left() + 2, r.bottom() + 1), QPoint(r.right() - 2, r.bottom() + 1));
-                    handlePainter.drawLine(QPoint(r.right() + 1, r.bottom() - 3), QPoint(r.right() + 1, r.top() + 4));
-                    handlePainter.drawLine(QPoint(r.right() - 1, r.bottom()), QPoint(r.right() + 1, r.bottom() - 2));
-
-                    handlePainter.end();
-                    QPixmapCache::insert(handlePixmapName, cache);
-                }
-
-                painter->drawPixmap(handle.topLeft(), cache);
-
-            }
-            painter->setBrush(oldBrush);
-            painter->setPen(oldPen);
-        }
+        drawComplexControlSlider<QStyleOptionSlider>(control, option, painter, widget, proxy(), d);
+        break;
+    case CC_Slider64:
+        drawComplexControlSlider<QStyleOptionSlider64>(control, option, painter, widget, proxy(), d);
         break;
     case CC_Dial:
         if (const QStyleOptionSlider *dial = qstyleoption_cast<const QStyleOptionSlider *>(option))
@@ -3282,53 +3373,10 @@ QRect QFusionStyle::subControlRect(ComplexControl control, const QStyleOptionCom
 
     switch (control) {
     case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
-            switch (subControl) {
-            case SC_SliderHandle: {
-                if (slider->orientation == Qt::Horizontal) {
-                    rect.setHeight(proxy()->pixelMetric(PM_SliderThickness));
-                    rect.setWidth(proxy()->pixelMetric(PM_SliderLength));
-                    int centerY = slider->rect.center().y() - rect.height() / 2;
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        centerY += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        centerY -= tickSize;
-                    rect.moveTop(centerY);
-                } else {
-                    rect.setWidth(proxy()->pixelMetric(PM_SliderThickness));
-                    rect.setHeight(proxy()->pixelMetric(PM_SliderLength));
-                    int centerX = slider->rect.center().x() - rect.width() / 2;
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        centerX += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        centerX -= tickSize;
-                    rect.moveLeft(centerX);
-                }
-            }
-                break;
-            case SC_SliderGroove: {
-                QPoint grooveCenter = slider->rect.center();
-                if (slider->orientation == Qt::Horizontal) {
-                    rect.setHeight(7);
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        grooveCenter.ry() += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        grooveCenter.ry() -= tickSize;
-                } else {
-                    rect.setWidth(7);
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        grooveCenter.rx() += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        grooveCenter.rx() -= tickSize;
-                }
-                rect.moveCenter(grooveCenter);
-                break;
-            }
-            default:
-                break;
-            }
-        }
+        subControlRectSlider<QStyleOptionSlider>(control, option, subControl, widget, rect, proxy());
+        break;
+    case CC_Slider64:
+        subControlRectSlider<QStyleOptionSlider64>(control, option, subControl, widget, rect, proxy());
         break;
     case CC_SpinBox:
         if (const QStyleOptionSpinBox *spinbox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
diff --git a/src/widgets/styles/qgtkstyle.cpp b/src/widgets/styles/qgtkstyle.cpp
index 9fa0569..c2c3844 100644
--- a/src/widgets/styles/qgtkstyle.cpp
+++ b/src/widgets/styles/qgtkstyle.cpp
@@ -1472,6 +1472,367 @@ void QGtkStyle::drawPrimitive(PrimitiveElement element,
     }
 }
 
+template <class OptionStyle>
+static void drawSlider(QGtkStyle::ComplexControl control, const QStyleOptionComplex* option,
+                       const QGtkStylePrivate* const d, const QWidget* widget,
+                       QGtkPainter* gtkPainter, QPainter* painter, GtkStyle* style,
+                       QStyle const* proxy)
+{
+        if (const OptionStyle *slider = qstyleoption_cast<const OptionStyle *>(option)) {
+            GtkWidget *hScaleWidget = d->gtkWidget("GtkHScale");
+            GtkWidget *vScaleWidget = d->gtkWidget("GtkVScale");
+
+            QRect groove = proxy->subControlRect(QStyle::CC_Slider, option, QStyle::SC_SliderGroove, widget);
+            QRect handle = proxy->subControlRect(QStyle::CC_Slider, option, QStyle::SC_SliderHandle, widget);
+
+            bool horizontal = slider->orientation == Qt::Horizontal;
+            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
+            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
+            QColor button = option->palette.button().color();
+            QColor darkOutline;
+            darkOutline.setHsv(button.hue(),
+                               qMin(255, (int)(button.saturation()*3.0)),
+                               qMin(255, (int)(button.value()*0.6)));
+
+            QBrush oldBrush = painter->brush();
+            QPen oldPen = painter->pen();
+
+            QColor shadowAlpha(Qt::black);
+            shadowAlpha.setAlpha(10);
+            QColor highlightAlpha(Qt::white);
+            highlightAlpha.setAlpha(80);
+
+            QGtkStylePrivate::gtk_widget_set_direction(hScaleWidget, slider->upsideDown ?
+                                                       GTK_TEXT_DIR_RTL : GTK_TEXT_DIR_LTR);
+            GtkWidget *scaleWidget = horizontal ? hScaleWidget : vScaleWidget;
+            style = d->gtk_widget_get_style(scaleWidget);
+
+            if ((option->subControls & QStyle::SC_SliderGroove) && groove.isValid()) {
+
+                GtkRange *range = (GtkRange*)scaleWidget;
+                GtkAdjustment *adjustment = 0;
+                if (d->gtk_adjustment_configure)
+                    adjustment = d->gtk_range_get_adjustment(range);
+                if (adjustment) {
+                    d->gtk_adjustment_configure(adjustment,
+                                                slider->sliderPosition,
+                                                slider->minimum,
+                                                slider->maximum,
+                                                slider->singleStep,
+                                                slider->singleStep,
+                                                slider->pageStep);
+                } else {
+                    adjustment = (GtkAdjustment*)d->gtk_adjustment_new(slider->sliderPosition,
+                                                                       slider->minimum,
+                                                                       slider->maximum,
+                                                                       slider->singleStep,
+                                                                       slider->singleStep,
+                                                                       slider->pageStep);
+                    d->gtk_range_set_adjustment(range, adjustment);
+                }
+
+                int outerSize;
+                d->gtk_range_set_inverted(range, !horizontal);
+                d->gtk_widget_style_get(scaleWidget, "trough-border", &outerSize, NULL);
+                outerSize++;
+
+                GtkStateType state = qt_gtk_state(option);
+                int focusFrameMargin = 2;
+                QRect grooveRect = option->rect.adjusted(focusFrameMargin, outerSize + focusFrameMargin,
+                                   -focusFrameMargin, -outerSize - focusFrameMargin);
+
+                gboolean trough_side_details = false; // Indicates if the upper or lower scale background differs
+                if (!d->gtk_check_version(2, 10, 0))
+                    d->gtk_widget_style_get((GtkWidget*)(scaleWidget), "trough-side-details", &trough_side_details, NULL);
+
+                if (!trough_side_details) {
+                    gtkPainter->paintBox(scaleWidget, "trough", grooveRect, state,
+                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
+                } else {
+                    QRect upperGroove = grooveRect;
+                    QRect lowerGroove = grooveRect;
+
+                    if (horizontal) {
+                        if (slider->upsideDown) {
+                            lowerGroove.setLeft(handle.center().x());
+                            upperGroove.setRight(handle.center().x());
+                        } else {
+                            upperGroove.setLeft(handle.center().x());
+                            lowerGroove.setRight(handle.center().x());
+                        }
+                    } else {
+                        if (!slider->upsideDown) {
+                            lowerGroove.setBottom(handle.center().y());
+                            upperGroove.setTop(handle.center().y());
+                        } else {
+                            upperGroove.setBottom(handle.center().y());
+                            lowerGroove.setTop(handle.center().y());
+                        }
+                    }
+
+                    gtkPainter->paintBox(scaleWidget, "trough-upper", upperGroove, state,
+                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
+                    gtkPainter->paintBox(scaleWidget, "trough-lower", lowerGroove, state,
+                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
+                }
+            }
+
+            if (option->subControls & QStyle::SC_SliderTickmarks) {
+                painter->setPen(darkOutline);
+                int tickSize = proxy->pixelMetric(QStyle::PM_SliderTickmarkOffset, option, widget);
+                int available = proxy->pixelMetric(QStyle::PM_SliderSpaceAvailable, slider, widget);
+                int interval = slider->tickInterval;
+
+                if (interval <= 0) {
+                    interval = slider->singleStep;
+
+                    if (QStyle::sliderPositionFromValue((qint64)slider->minimum, (qint64)slider->maximum, (qint64)interval,
+                                                        (qint64)available)
+                            - QStyle::sliderPositionFromValue((qint64)slider->minimum, (qint64)slider->maximum,
+                                                              (qint64)0, (qint64)available) < 3)
+                        interval = slider->pageStep;
+                }
+
+                if (interval <= 0)
+                    interval = 1;
+
+                int v = slider->minimum;
+                int len = proxy->pixelMetric(QStyle::PM_SliderLength, slider, widget);
+                while (v <= slider->maximum + 1) {
+                    if (v == slider->maximum + 1 && interval == 1)
+                        break;
+                    const int v_ = qMin((qint64)v, (qint64)slider->maximum);
+                    int pos = QStyle::sliderPositionFromValue((qint64)slider->minimum, (qint64)slider->maximum,
+                                                      (qint64)v_, (qint64)(horizontal
+                                                           ? slider->rect.width()
+                                                           : slider->rect.height()) - len,
+                                                      slider->upsideDown) + len / 2;
+                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
+                    if (horizontal) {
+                        if (ticksAbove)
+                            painter->drawLine(pos, slider->rect.top() + extra,
+                                              pos, slider->rect.top() + tickSize);
+                        if (ticksBelow)
+                            painter->drawLine(pos, slider->rect.bottom() - extra,
+                                              pos, slider->rect.bottom() - tickSize);
+
+                    } else {
+                        if (ticksAbove)
+                            painter->drawLine(slider->rect.left() + extra, pos,
+                                              slider->rect.left() + tickSize, pos);
+                        if (ticksBelow)
+                            painter->drawLine(slider->rect.right() - extra, pos,
+                                              slider->rect.right() - tickSize, pos);
+                    }
+
+                    // In the case where maximum is max int
+                    int nextInterval = v + interval;
+                    if (nextInterval < v)
+                        break;
+                    v = nextInterval;
+                }
+            }
+
+            // Draw slider handle
+            if (option->subControls & QStyle::SC_SliderHandle) {
+                GtkShadowType shadow =  GTK_SHADOW_OUT;
+                GtkStateType state = GTK_STATE_NORMAL;
+
+                if (!(option->state & QStyle::State_Enabled))
+                    state = GTK_STATE_INSENSITIVE;
+                else if (option->state & QStyle::State_MouseOver && option->activeSubControls & QStyle::SC_SliderHandle)
+                    state = GTK_STATE_PRELIGHT;
+
+                bool horizontal = option->state & QStyle::State_Horizontal;
+
+                if (slider->state & QStyle::State_HasFocus) {
+                    QStyleOptionFocusRect fropt;
+                    fropt.QStyleOption::operator=(*slider);
+                    fropt.rect = slider->rect.adjusted(-1, -1 ,1, 1);
+
+                    if (horizontal) {
+                        fropt.rect.setTop(handle.top() - 3);
+                        fropt.rect.setBottom(handle.bottom() + 4);
+
+                    } else {
+                        fropt.rect.setLeft(handle.left() - 3);
+                        fropt.rect.setRight(handle.right() + 3);
+                    }
+                    proxy->drawPrimitive(QStyle::PE_FrameFocusRect, &fropt, painter, widget);
+                }
+                gtkPainter->paintSlider(scaleWidget, horizontal ? "hscale" : "vscale", handle, state, shadow, style,
+                                        horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL);
+            }
+            painter->setBrush(oldBrush);
+            painter->setPen(oldPen);
+        }
+}
+
+template <class OptionStyle>
+void drawScrollBar(const QStyleOptionComplex* option, QGtkStyle::ComplexControl control, const QGtkStylePrivate* const d, const QWidget* widget, QGtkPainter* gtkPainter, QPainter* painter, GtkStyle* style, QStyle const* proxy)
+{
+        if (const OptionStyle *scrollBar = qstyleoption_cast<const OptionStyle *>(option)) {
+            GtkWidget *gtkHScrollBar = d->gtkWidget("GtkHScrollbar");
+            GtkWidget *gtkVScrollBar = d->gtkWidget("GtkVScrollbar");
+
+            // Fill background in case the scrollbar is partially transparent
+            painter->fillRect(option->rect, option->palette.background());
+
+            QRect rect = scrollBar->rect;
+            QRect scrollBarSubLine = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarSubLine, widget);
+            QRect scrollBarAddLine = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarAddLine, widget);
+            QRect scrollBarSlider = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarSlider, widget);
+            QRect grooveRect = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarGroove, widget);
+            bool horizontal = scrollBar->orientation == Qt::Horizontal;
+            GtkWidget * scrollbarWidget = horizontal ? gtkHScrollBar : gtkVScrollBar;
+            style = d->gtk_widget_get_style(scrollbarWidget);
+            gboolean trough_under_steppers = true;
+            gboolean trough_side_details = false;
+            gboolean activate_slider = false;
+            gboolean stepper_size = 14;
+            gint trough_border = 1;
+            if (!d->gtk_check_version(2, 10, 0)) {
+                d->gtk_widget_style_get((GtkWidget*)(scrollbarWidget),
+                                           "trough-border",         &trough_border,
+                                           "trough-side-details",   &trough_side_details,
+                                           "trough-under-steppers", &trough_under_steppers,
+                                           "activate-slider",       &activate_slider,
+                                           "stepper-size",          &stepper_size, NULL);
+            }
+            if (trough_under_steppers) {
+                scrollBarAddLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
+                scrollBarSubLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
+                scrollBarSlider.adjust(horizontal ? -trough_border : 0, horizontal ? 0 : -trough_border,
+                                       horizontal ? trough_border : 0, horizontal ? 0 : trough_border);
+            }
+
+            // Some styles check the position of scrollbars in order to determine
+            // if lines should be painted when the scrollbar is in max or min positions.
+            int maximum = 2;
+            int fakePos = 0;
+            bool reverse = (option->direction == Qt::RightToLeft);
+            if (scrollBar->minimum == scrollBar->maximum)
+                maximum = 0;
+            if (scrollBar->sliderPosition == scrollBar->maximum)
+                fakePos = maximum;
+            else if (scrollBar->sliderPosition > scrollBar->minimum)
+                fakePos = maximum - 1;
+
+
+            GtkRange *range = (GtkRange*)(horizontal ? gtkHScrollBar : gtkVScrollBar);
+            GtkAdjustment *adjustment = 0;
+
+            if (d->gtk_adjustment_configure)
+                adjustment = d->gtk_range_get_adjustment(range);
+            if (adjustment) {
+                d->gtk_adjustment_configure(adjustment, fakePos, 0, maximum, 0, 0, 0);
+            } else {
+                adjustment = (GtkAdjustment*)d->gtk_adjustment_new(fakePos, 0, maximum, 0, 0, 0);
+                d->gtk_range_set_adjustment(range, adjustment);
+            }
+
+            if (scrollBar->subControls & QStyle::SC_ScrollBarGroove) {
+                GtkStateType state = GTK_STATE_ACTIVE;
+
+                if (!(option->state & QStyle::State_Enabled))
+                    state = GTK_STATE_INSENSITIVE;
+
+                if (trough_under_steppers)
+                    grooveRect = option->rect;
+
+                gtkPainter->paintBox(scrollbarWidget, "trough", grooveRect, state, GTK_SHADOW_IN, style);
+            }
+
+            //paint slider
+            if (scrollBar->subControls & QStyle::SC_ScrollBarSlider) {
+                GtkStateType state = GTK_STATE_NORMAL;
+
+                if (!(option->state & QStyle::State_Enabled))
+                    state = GTK_STATE_INSENSITIVE;
+                else if (activate_slider &&
+                         option->state & QStyle::State_Sunken && (scrollBar->activeSubControls & QStyle::SC_ScrollBarSlider))
+                    state = GTK_STATE_ACTIVE;
+                else if (option->state & QStyle::State_MouseOver && (scrollBar->activeSubControls & QStyle::SC_ScrollBarSlider))
+                    state = GTK_STATE_PRELIGHT;
+
+                GtkShadowType shadow = GTK_SHADOW_OUT;
+
+                if (trough_under_steppers) {
+                    if (!horizontal)
+                        scrollBarSlider.adjust(trough_border, 0, -trough_border, 0);
+                    else
+                        scrollBarSlider.adjust(0, trough_border, 0, -trough_border);
+                }
+
+                gtkPainter->paintSlider(scrollbarWidget, "slider", scrollBarSlider, state, shadow, style,
+                                        horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL, QString(QLS("%0%1")).arg(fakePos).arg(maximum));
+            }
+
+            if (scrollBar->subControls & QStyle::SC_ScrollBarAddLine) {
+                GtkAllocation vAllocation;
+                vAllocation.y = scrollBarAddLine.top();
+                vAllocation.height = scrollBarAddLine.height() - rect.height() + 6;
+                d->gtk_widget_set_allocation(gtkVScrollBar, &vAllocation);
+
+                GtkAllocation hAllocation;
+                hAllocation.x = scrollBarAddLine.right();
+                hAllocation.width = scrollBarAddLine.width() - rect.width();
+                d->gtk_widget_set_allocation(gtkHScrollBar, &hAllocation);
+
+                GtkShadowType shadow = GTK_SHADOW_OUT;
+                GtkStateType state = GTK_STATE_NORMAL;
+
+                if (!(option->state & QStyle::State_Enabled) || (fakePos == maximum))
+                    state = GTK_STATE_INSENSITIVE;
+                else if (option->state & QStyle::State_Sunken && (scrollBar->activeSubControls & QStyle::SC_ScrollBarAddLine)) {
+                    state = GTK_STATE_ACTIVE;
+                    shadow = GTK_SHADOW_IN;
+
+                } else if (option->state & QStyle::State_MouseOver && (scrollBar->activeSubControls & QStyle::SC_ScrollBarAddLine))
+                    state = GTK_STATE_PRELIGHT;
+
+                gtkPainter->paintBox(scrollbarWidget,
+                                     horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine,
+                                     state, shadow, style, QLS("add"));
+
+                gtkPainter->paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine.adjusted(4, 4, -4, -4),
+                                       horizontal ? (reverse ? GTK_ARROW_LEFT : GTK_ARROW_RIGHT) :
+                                       GTK_ARROW_DOWN, state, GTK_SHADOW_NONE, false, style);
+            }
+
+            if (scrollBar->subControls & QStyle::SC_ScrollBarSubLine) {
+                GtkAllocation vAllocation;
+                vAllocation.y = 0;
+                vAllocation.height = scrollBarSubLine.height();
+                d->gtk_widget_set_allocation(gtkVScrollBar, &vAllocation);
+
+                GtkAllocation hAllocation;
+                hAllocation.x = 0;
+                hAllocation.width = scrollBarSubLine.width();
+                d->gtk_widget_set_allocation(gtkHScrollBar, &hAllocation);
+
+                GtkShadowType shadow = GTK_SHADOW_OUT;
+                GtkStateType state = GTK_STATE_NORMAL;
+
+                if (!(option->state & QStyle::State_Enabled) || (fakePos == 0))
+                    state = GTK_STATE_INSENSITIVE;
+                else if (option->state & QStyle::State_Sunken && (scrollBar->activeSubControls & QStyle::SC_ScrollBarSubLine)) {
+                    shadow = GTK_SHADOW_IN;
+                    state = GTK_STATE_ACTIVE;
+
+                } else if (option->state & QStyle::State_MouseOver && (scrollBar->activeSubControls & QStyle::SC_ScrollBarSubLine))
+                    state = GTK_STATE_PRELIGHT;
+
+                gtkPainter->paintBox(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine,
+                                     state, shadow, style, QLS("sub"));
+
+                gtkPainter->paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine.adjusted(4, 4, -4, -4),
+                                       horizontal ? (reverse ? GTK_ARROW_RIGHT : GTK_ARROW_LEFT) :
+                                       GTK_ARROW_UP, state, GTK_SHADOW_NONE, false, style);
+            }
+        }
+}
+
 /*!
     \reimp
 */
@@ -2096,208 +2457,53 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
 
             if (toolbutton->state & State_HasFocus) {
                 QStyleOptionFocusRect fr;
-                fr.QStyleOption::operator=(*toolbutton);
-                fr.rect = proxy()->subControlRect(CC_ToolButton, toolbutton, SC_ToolButton, widget);
-                fr.rect.adjust(1, 1, -1, -1);
-                proxy()->drawPrimitive(PE_FrameFocusRect, &fr, painter, widget);
-            }
-
-            QStyleOptionToolButton label = *toolbutton;
-            label.state = bflags;
-            GtkWidget *gtkButton = d->gtkWidget("GtkToolButton.GtkButton");
-            QPalette pal = toolbutton->palette;
-            if (option->state & State_Enabled &&
-                option->state & State_MouseOver && !(widget && widget->testAttribute(Qt::WA_SetPalette))) {
-                GdkColor gdkText = d->gtk_widget_get_style(gtkButton)->fg[GTK_STATE_PRELIGHT];
-                QColor textColor = QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
-                pal.setBrush(QPalette::All, QPalette::ButtonText, textColor);
-                label.palette = pal;
-            }
-            label.rect = button.adjusted(style->xthickness, style->ythickness,
-                                        -style->xthickness - popupArrowSize, -style->ythickness);
-            proxy()->drawControl(CE_ToolButtonLabel, &label, painter, widget);
-
-            if (toolbutton->subControls & SC_ToolButtonMenu) {
-                tool.rect = menuarea;
-                tool.state = mflags;
-                if ((mflags & State_Enabled && (mflags & (State_Sunken | State_Raised | State_MouseOver))) || !(mflags & State_AutoRaise))
-                    proxy()->drawPrimitive(PE_IndicatorButtonDropDown, &tool, painter, widget);
-
-                proxy()->drawPrimitive(PE_IndicatorArrowDown, &tool, painter, widget);
-
-            } else if (drawMenuArrow) {
-                QRect ir = toolbutton->rect;
-                QStyleOptionToolButton newBtn = *toolbutton;
-                newBtn.rect = QRect(ir.right() - popupArrowSize - style->xthickness - 3, ir.height()/2 - 1, popupArrowSize, popupArrowSize);
-                proxy()->drawPrimitive(PE_IndicatorArrowDown, &newBtn, painter, widget);
-            }
-        }
-        break;
-
-#endif // QT_NO_TOOLBUTTON
-#ifndef QT_NO_SCROLLBAR
-
-    case CC_ScrollBar:
-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            GtkWidget *gtkHScrollBar = d->gtkWidget("GtkHScrollbar");
-            GtkWidget *gtkVScrollBar = d->gtkWidget("GtkVScrollbar");
-
-            // Fill background in case the scrollbar is partially transparent
-            painter->fillRect(option->rect, option->palette.background());
-
-            QRect rect = scrollBar->rect;
-            QRect scrollBarSubLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSubLine, widget);
-            QRect scrollBarAddLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarAddLine, widget);
-            QRect scrollBarSlider = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSlider, widget);
-            QRect grooveRect = proxy()->subControlRect(control, scrollBar, SC_ScrollBarGroove, widget);
-            bool horizontal = scrollBar->orientation == Qt::Horizontal;
-            GtkWidget * scrollbarWidget = horizontal ? gtkHScrollBar : gtkVScrollBar;
-            style = d->gtk_widget_get_style(scrollbarWidget);
-            gboolean trough_under_steppers = true;
-            gboolean trough_side_details = false;
-            gboolean activate_slider = false;
-            gboolean stepper_size = 14;
-            gint trough_border = 1;
-            if (!d->gtk_check_version(2, 10, 0)) {
-                d->gtk_widget_style_get((GtkWidget*)(scrollbarWidget),
-                                           "trough-border",         &trough_border,
-                                           "trough-side-details",   &trough_side_details,
-                                           "trough-under-steppers", &trough_under_steppers,
-                                           "activate-slider",       &activate_slider,
-                                           "stepper-size",          &stepper_size, NULL);
-            }
-            if (trough_under_steppers) {
-                scrollBarAddLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
-                scrollBarSubLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
-                scrollBarSlider.adjust(horizontal ? -trough_border : 0, horizontal ? 0 : -trough_border,
-                                       horizontal ? trough_border : 0, horizontal ? 0 : trough_border);
-            }
-
-            // Some styles check the position of scrollbars in order to determine
-            // if lines should be painted when the scrollbar is in max or min positions.
-            int maximum = 2;
-            int fakePos = 0;
-            bool reverse = (option->direction == Qt::RightToLeft);
-            if (scrollBar->minimum == scrollBar->maximum)
-                maximum = 0;
-            if (scrollBar->sliderPosition == scrollBar->maximum)
-                fakePos = maximum;
-            else if (scrollBar->sliderPosition > scrollBar->minimum)
-                fakePos = maximum - 1;
-
-
-            GtkRange *range = (GtkRange*)(horizontal ? gtkHScrollBar : gtkVScrollBar);
-            GtkAdjustment *adjustment = 0;
-
-            if (d->gtk_adjustment_configure)
-                adjustment = d->gtk_range_get_adjustment(range);
-            if (adjustment) {
-                d->gtk_adjustment_configure(adjustment, fakePos, 0, maximum, 0, 0, 0);
-            } else {
-                adjustment = (GtkAdjustment*)d->gtk_adjustment_new(fakePos, 0, maximum, 0, 0, 0);
-                d->gtk_range_set_adjustment(range, adjustment);
-            }
-
-            if (scrollBar->subControls & SC_ScrollBarGroove) {
-                GtkStateType state = GTK_STATE_ACTIVE;
-
-                if (!(option->state & State_Enabled))
-                    state = GTK_STATE_INSENSITIVE;
-
-                if (trough_under_steppers)
-                    grooveRect = option->rect;
-
-                gtkPainter->paintBox(scrollbarWidget, "trough", grooveRect, state, GTK_SHADOW_IN, style);
-            }
-
-            //paint slider
-            if (scrollBar->subControls & SC_ScrollBarSlider) {
-                GtkStateType state = GTK_STATE_NORMAL;
-
-                if (!(option->state & State_Enabled))
-                    state = GTK_STATE_INSENSITIVE;
-                else if (activate_slider &&
-                         option->state & State_Sunken && (scrollBar->activeSubControls & SC_ScrollBarSlider))
-                    state = GTK_STATE_ACTIVE;
-                else if (option->state & State_MouseOver && (scrollBar->activeSubControls & SC_ScrollBarSlider))
-                    state = GTK_STATE_PRELIGHT;
-
-                GtkShadowType shadow = GTK_SHADOW_OUT;
-
-                if (trough_under_steppers) {
-                    if (!horizontal)
-                        scrollBarSlider.adjust(trough_border, 0, -trough_border, 0);
-                    else
-                        scrollBarSlider.adjust(0, trough_border, 0, -trough_border);
-                }
-
-                gtkPainter->paintSlider(scrollbarWidget, "slider", scrollBarSlider, state, shadow, style,
-                                        horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL, QString(QLS("%0%1")).arg(fakePos).arg(maximum));
-            }
-
-            if (scrollBar->subControls & SC_ScrollBarAddLine) {
-                GtkAllocation vAllocation;
-                vAllocation.y = scrollBarAddLine.top();
-                vAllocation.height = scrollBarAddLine.height() - rect.height() + 6;
-                d->gtk_widget_set_allocation(gtkVScrollBar, &vAllocation);
-
-                GtkAllocation hAllocation;
-                hAllocation.x = scrollBarAddLine.right();
-                hAllocation.width = scrollBarAddLine.width() - rect.width();
-                d->gtk_widget_set_allocation(gtkHScrollBar, &hAllocation);
-
-                GtkShadowType shadow = GTK_SHADOW_OUT;
-                GtkStateType state = GTK_STATE_NORMAL;
-
-                if (!(option->state & State_Enabled) || (fakePos == maximum))
-                    state = GTK_STATE_INSENSITIVE;
-                else if (option->state & State_Sunken && (scrollBar->activeSubControls & SC_ScrollBarAddLine)) {
-                    state = GTK_STATE_ACTIVE;
-                    shadow = GTK_SHADOW_IN;
-
-                } else if (option->state & State_MouseOver && (scrollBar->activeSubControls & SC_ScrollBarAddLine))
-                    state = GTK_STATE_PRELIGHT;
-
-                gtkPainter->paintBox(scrollbarWidget,
-                                     horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine,
-                                     state, shadow, style, QLS("add"));
-
-                gtkPainter->paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine.adjusted(4, 4, -4, -4),
-                                       horizontal ? (reverse ? GTK_ARROW_LEFT : GTK_ARROW_RIGHT) :
-                                       GTK_ARROW_DOWN, state, GTK_SHADOW_NONE, false, style);
+                fr.QStyleOption::operator=(*toolbutton);
+                fr.rect = proxy()->subControlRect(CC_ToolButton, toolbutton, SC_ToolButton, widget);
+                fr.rect.adjust(1, 1, -1, -1);
+                proxy()->drawPrimitive(PE_FrameFocusRect, &fr, painter, widget);
             }
 
-            if (scrollBar->subControls & SC_ScrollBarSubLine) {
-                GtkAllocation vAllocation;
-                vAllocation.y = 0;
-                vAllocation.height = scrollBarSubLine.height();
-                d->gtk_widget_set_allocation(gtkVScrollBar, &vAllocation);
+            QStyleOptionToolButton label = *toolbutton;
+            label.state = bflags;
+            GtkWidget *gtkButton = d->gtkWidget("GtkToolButton.GtkButton");
+            QPalette pal = toolbutton->palette;
+            if (option->state & State_Enabled &&
+                option->state & State_MouseOver && !(widget && widget->testAttribute(Qt::WA_SetPalette))) {
+                GdkColor gdkText = d->gtk_widget_get_style(gtkButton)->fg[GTK_STATE_PRELIGHT];
+                QColor textColor = QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
+                pal.setBrush(QPalette::All, QPalette::ButtonText, textColor);
+                label.palette = pal;
+            }
+            label.rect = button.adjusted(style->xthickness, style->ythickness,
+                                        -style->xthickness - popupArrowSize, -style->ythickness);
+            proxy()->drawControl(CE_ToolButtonLabel, &label, painter, widget);
 
-                GtkAllocation hAllocation;
-                hAllocation.x = 0;
-                hAllocation.width = scrollBarSubLine.width();
-                d->gtk_widget_set_allocation(gtkHScrollBar, &hAllocation);
+            if (toolbutton->subControls & SC_ToolButtonMenu) {
+                tool.rect = menuarea;
+                tool.state = mflags;
+                if ((mflags & State_Enabled && (mflags & (State_Sunken | State_Raised | State_MouseOver))) || !(mflags & State_AutoRaise))
+                    proxy()->drawPrimitive(PE_IndicatorButtonDropDown, &tool, painter, widget);
 
-                GtkShadowType shadow = GTK_SHADOW_OUT;
-                GtkStateType state = GTK_STATE_NORMAL;
+                proxy()->drawPrimitive(PE_IndicatorArrowDown, &tool, painter, widget);
 
-                if (!(option->state & State_Enabled) || (fakePos == 0))
-                    state = GTK_STATE_INSENSITIVE;
-                else if (option->state & State_Sunken && (scrollBar->activeSubControls & SC_ScrollBarSubLine)) {
-                    shadow = GTK_SHADOW_IN;
-                    state = GTK_STATE_ACTIVE;
+            } else if (drawMenuArrow) {
+                QRect ir = toolbutton->rect;
+                QStyleOptionToolButton newBtn = *toolbutton;
+                newBtn.rect = QRect(ir.right() - popupArrowSize - style->xthickness - 3, ir.height()/2 - 1, popupArrowSize, popupArrowSize);
+                proxy()->drawPrimitive(PE_IndicatorArrowDown, &newBtn, painter, widget);
+            }
+        }
+        break;
 
-                } else if (option->state & State_MouseOver && (scrollBar->activeSubControls & SC_ScrollBarSubLine))
-                    state = GTK_STATE_PRELIGHT;
+#endif // QT_NO_TOOLBUTTON
+#ifndef QT_NO_SCROLLBAR
 
-                gtkPainter->paintBox(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine,
-                                     state, shadow, style, QLS("sub"));
+    case CC_ScrollBar:
+        drawScrollBar<QStyleOptionSlider>(option, control, d, widget, gtkPainter, painter, style, proxy());
+        break;
 
-                gtkPainter->paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine.adjusted(4, 4, -4, -4),
-                                       horizontal ? (reverse ? GTK_ARROW_RIGHT : GTK_ARROW_LEFT) :
-                                       GTK_ARROW_UP, state, GTK_SHADOW_NONE, false, style);
-            }
-        }
+    case CC_ScrollBar64:
+        drawScrollBar<QStyleOptionSlider64>(option, control, d, widget, gtkPainter, painter, style, proxy());
         break;
 
 #endif //QT_NO_SCROLLBAR
@@ -2457,189 +2663,10 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
 #ifndef QT_NO_SLIDER
 
     case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            GtkWidget *hScaleWidget = d->gtkWidget("GtkHScale");
-            GtkWidget *vScaleWidget = d->gtkWidget("GtkVScale");
-
-            QRect groove = proxy()->subControlRect(CC_Slider, option, SC_SliderGroove, widget);
-            QRect handle = proxy()->subControlRect(CC_Slider, option, SC_SliderHandle, widget);
-
-            bool horizontal = slider->orientation == Qt::Horizontal;
-            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
-            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
-
-            QBrush oldBrush = painter->brush();
-            QPen oldPen = painter->pen();
-
-            QColor shadowAlpha(Qt::black);
-            shadowAlpha.setAlpha(10);
-            QColor highlightAlpha(Qt::white);
-            highlightAlpha.setAlpha(80);
-
-            QGtkStylePrivate::gtk_widget_set_direction(hScaleWidget, slider->upsideDown ?
-                                                       GTK_TEXT_DIR_RTL : GTK_TEXT_DIR_LTR);
-            GtkWidget *scaleWidget = horizontal ? hScaleWidget : vScaleWidget;
-            style = d->gtk_widget_get_style(scaleWidget);
-
-            if ((option->subControls & SC_SliderGroove) && groove.isValid()) {
-
-                GtkRange *range = (GtkRange*)scaleWidget;
-                GtkAdjustment *adjustment = 0;
-                if (d->gtk_adjustment_configure)
-                    adjustment = d->gtk_range_get_adjustment(range);
-                if (adjustment) {
-                    d->gtk_adjustment_configure(adjustment,
-                                                slider->sliderPosition,
-                                                slider->minimum,
-                                                slider->maximum,
-                                                slider->singleStep,
-                                                slider->singleStep,
-                                                slider->pageStep);
-                } else {
-                    adjustment = (GtkAdjustment*)d->gtk_adjustment_new(slider->sliderPosition,
-                                                                       slider->minimum,
-                                                                       slider->maximum,
-                                                                       slider->singleStep,
-                                                                       slider->singleStep,
-                                                                       slider->pageStep);
-                    d->gtk_range_set_adjustment(range, adjustment);
-                }
-
-                int outerSize;
-                d->gtk_range_set_inverted(range, !horizontal);
-                d->gtk_widget_style_get(scaleWidget, "trough-border", &outerSize, NULL);
-                outerSize++;
-
-                GtkStateType state = qt_gtk_state(option);
-                int focusFrameMargin = 2;
-                QRect grooveRect = option->rect.adjusted(focusFrameMargin, outerSize + focusFrameMargin,
-                                   -focusFrameMargin, -outerSize - focusFrameMargin);
-
-                gboolean trough_side_details = false; // Indicates if the upper or lower scale background differs
-                if (!d->gtk_check_version(2, 10, 0))
-                    d->gtk_widget_style_get((GtkWidget*)(scaleWidget), "trough-side-details", &trough_side_details, NULL);
-
-                if (!trough_side_details) {
-                    gtkPainter->paintBox(scaleWidget, "trough", grooveRect, state,
-                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
-                } else {
-                    QRect upperGroove = grooveRect;
-                    QRect lowerGroove = grooveRect;
-
-                    if (horizontal) {
-                        if (slider->upsideDown) {
-                            lowerGroove.setLeft(handle.center().x());
-                            upperGroove.setRight(handle.center().x());
-                        } else {
-                            upperGroove.setLeft(handle.center().x());
-                            lowerGroove.setRight(handle.center().x());
-                        }
-                    } else {
-                        if (!slider->upsideDown) {
-                            lowerGroove.setBottom(handle.center().y());
-                            upperGroove.setTop(handle.center().y());
-                        } else {
-                            upperGroove.setBottom(handle.center().y());
-                            lowerGroove.setTop(handle.center().y());
-                        }
-                    }
-
-                    gtkPainter->paintBox(scaleWidget, "trough-upper", upperGroove, state,
-                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
-                    gtkPainter->paintBox(scaleWidget, "trough-lower", lowerGroove, state,
-                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
-                }
-            }
-
-            if (option->subControls & SC_SliderTickmarks) {
-                painter->setPen(darkOutline);
-                int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
-                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
-                int interval = slider->tickInterval;
-
-                if (interval <= 0) {
-                    interval = slider->singleStep;
-
-                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
-                                                        available)
-                            - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                              0, available) < 3)
-                        interval = slider->pageStep;
-                }
-
-                if (interval <= 0)
-                    interval = 1;
-
-                int v = slider->minimum;
-                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
-                while (v <= slider->maximum + 1) {
-                    if (v == slider->maximum + 1 && interval == 1)
-                        break;
-                    const int v_ = qMin(v, slider->maximum);
-                    int pos = sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                      v_, (horizontal
-                                                           ? slider->rect.width()
-                                                           : slider->rect.height()) - len,
-                                                      slider->upsideDown) + len / 2;
-                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
-                    if (horizontal) {
-                        if (ticksAbove)
-                            painter->drawLine(pos, slider->rect.top() + extra,
-                                              pos, slider->rect.top() + tickSize);
-                        if (ticksBelow)
-                            painter->drawLine(pos, slider->rect.bottom() - extra,
-                                              pos, slider->rect.bottom() - tickSize);
-
-                    } else {
-                        if (ticksAbove)
-                            painter->drawLine(slider->rect.left() + extra, pos,
-                                              slider->rect.left() + tickSize, pos);
-                        if (ticksBelow)
-                            painter->drawLine(slider->rect.right() - extra, pos,
-                                              slider->rect.right() - tickSize, pos);
-                    }
-
-                    // In the case where maximum is max int
-                    int nextInterval = v + interval;
-                    if (nextInterval < v)
-                        break;
-                    v = nextInterval;
-                }
-            }
-
-            // Draw slider handle
-            if (option->subControls & SC_SliderHandle) {
-                GtkShadowType shadow =  GTK_SHADOW_OUT;
-                GtkStateType state = GTK_STATE_NORMAL;
-
-                if (!(option->state & State_Enabled))
-                    state = GTK_STATE_INSENSITIVE;
-                else if (option->state & State_MouseOver && option->activeSubControls & SC_SliderHandle)
-                    state = GTK_STATE_PRELIGHT;
-
-                bool horizontal = option->state & State_Horizontal;
-
-                if (slider->state & State_HasFocus) {
-                    QStyleOptionFocusRect fropt;
-                    fropt.QStyleOption::operator=(*slider);
-                    fropt.rect = slider->rect.adjusted(-1, -1 ,1, 1);
-
-                    if (horizontal) {
-                        fropt.rect.setTop(handle.top() - 3);
-                        fropt.rect.setBottom(handle.bottom() + 4);
-
-                    } else {
-                        fropt.rect.setLeft(handle.left() - 3);
-                        fropt.rect.setRight(handle.right() + 3);
-                    }
-                    proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
-                }
-                gtkPainter->paintSlider(scaleWidget, horizontal ? "hscale" : "vscale", handle, state, shadow, style,
-                                        horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL);
-            }
-            painter->setBrush(oldBrush);
-            painter->setPen(oldPen);
-        }
+        drawSlider<QStyleOptionSlider>(control, option, d, widget, gtkPainter, painter, style, proxy());
+        break;
+    case CC_Slider64:
+        drawSlider<QStyleOptionSlider64>(control, option, d, widget, gtkPainter, painter, style, proxy());
         break;
     case CC_Dial:
         if (const QStyleOptionSlider *dial = qstyleoption_cast<const QStyleOptionSlider *>(option))
@@ -3548,29 +3575,19 @@ void QGtkStyle::drawControl(ControlElement element,
     }
 }
 
-/*!
-  \reimp
-*/
-QRect QGtkStyle::subControlRect(ComplexControl control, const QStyleOptionComplex *option,
-                                SubControl subControl, const QWidget *widget) const
+template <class OptionStyle>
+static void subControlRectSlider(QStyle::ComplexControl control, const QStyleOptionComplex *option,
+                                 QStyle::SubControl subControl, const QWidget *widget,
+                                 QStyle const* proxy,
+                                 QRect& rect)
 {
-    Q_D(const QGtkStyle);
-
-    QRect rect = QCommonStyle::subControlRect(control, option, subControl, widget);
-    if (!d->isThemeAvailable())
-        return QCommonStyle::subControlRect(control, option, subControl, widget);
-
-    switch (control) {
-    case CC_ScrollBar:
-        break;
-    case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
+        if (const OptionStyle *slider = qstyleoption_cast<const OptionStyle *>(option)) {
+            int tickSize = proxy->pixelMetric(QStyle::PM_SliderTickmarkOffset, option, widget);
             switch (subControl) {
-            case SC_SliderHandle: {
+            case QStyle::SC_SliderHandle: {
                 if (slider->orientation == Qt::Horizontal) {
-                    rect.setHeight(proxy()->pixelMetric(PM_SliderThickness));
-                    rect.setWidth(proxy()->pixelMetric(PM_SliderLength));
+                    rect.setHeight(proxy->pixelMetric(QStyle::PM_SliderThickness));
+                    rect.setWidth(proxy->pixelMetric(QStyle::PM_SliderLength));
                     int centerY = slider->rect.center().y() - rect.height() / 2;
                     if (slider->tickPosition & QSlider::TicksAbove)
                         centerY += tickSize;
@@ -3578,8 +3595,8 @@ QRect QGtkStyle::subControlRect(ComplexControl control, const QStyleOptionComple
                         centerY -= tickSize;
                     rect.moveTop(centerY);
                 } else {
-                    rect.setWidth(proxy()->pixelMetric(PM_SliderThickness));
-                    rect.setHeight(proxy()->pixelMetric(PM_SliderLength));
+                    rect.setWidth(proxy->pixelMetric(QStyle::PM_SliderThickness));
+                    rect.setHeight(proxy->pixelMetric(QStyle::PM_SliderLength));
                     int centerX = slider->rect.center().x() - rect.width() / 2;
                     if (slider->tickPosition & QSlider::TicksAbove)
                         centerX += tickSize;
@@ -3589,7 +3606,7 @@ QRect QGtkStyle::subControlRect(ComplexControl control, const QStyleOptionComple
                 }
             }
                 break;
-            case SC_SliderGroove: {
+            case QStyle::SC_SliderGroove: {
                 QPoint grooveCenter = slider->rect.center();
                 if (slider->orientation == Qt::Horizontal) {
                     rect.setHeight(7);
@@ -3611,6 +3628,29 @@ QRect QGtkStyle::subControlRect(ComplexControl control, const QStyleOptionComple
                 break;
             }
         }
+}
+
+/*!
+  \reimp
+*/
+QRect QGtkStyle::subControlRect(ComplexControl control, const QStyleOptionComplex *option,
+                                SubControl subControl, const QWidget *widget) const
+{
+    Q_D(const QGtkStyle);
+
+    QRect rect = QCommonStyle::subControlRect(control, option, subControl, widget);
+    if (!d->isThemeAvailable())
+        return QCommonStyle::subControlRect(control, option, subControl, widget);
+
+    switch (control) {
+    case CC_ScrollBar:
+        break;
+    case CC_Slider:
+        subControlRectSlider<QStyleOptionSlider>(control, option, subControl, widget, proxy(), rect);
+        break;
+
+    case CC_Slider64:
+        subControlRectSlider<QStyleOptionSlider64>(control, option, subControl, widget, proxy(), rect);
         break;
 
 #ifndef QT_NO_GROUPBOX
diff --git a/src/widgets/styles/qstyle.cpp b/src/widgets/styles/qstyle.cpp
index 4c5c7cd..095c37d 100644
--- a/src/widgets/styles/qstyle.cpp
+++ b/src/widgets/styles/qstyle.cpp
@@ -2142,6 +2142,16 @@ Qt::Alignment QStyle::visualAlignment(Qt::LayoutDirection direction, Qt::Alignme
 }
 
 /*!
+    Implemented for ABI compatibility.
+*/
+
+int QStyle::sliderPositionFromValue(int min, int max, int logicalValue, int span, bool upsideDown)
+{
+	return sliderPositionFromValue((qint64) min, (qint64) max, (qint64) logicalValue, (qint64) span, upsideDown);
+}
+
+
+/*!
     Converts the given \a logicalValue to a pixel position. The \a min
     parameter maps to 0, \a max maps to \a span and other values are
     distributed evenly in-between.
@@ -2156,24 +2166,24 @@ Qt::Alignment QStyle::visualAlignment(Qt::LayoutDirection direction, Qt::Alignme
     \sa sliderValueFromPosition()
 */
 
-int QStyle::sliderPositionFromValue(int min, int max, int logicalValue, int span, bool upsideDown)
+int QStyle::sliderPositionFromValue(qint64 min, qint64 max, qint64 logicalValue, qint64 span, bool upsideDown)
 {
     if (span <= 0 || logicalValue < min || max <= min)
         return 0;
     if (logicalValue > max)
         return upsideDown ? span : min;
 
-    uint range = max - min;
-    uint p = upsideDown ? max - logicalValue : logicalValue - min;
+    quint64 range = max - min;
+    quint64 p = upsideDown ? max - logicalValue : logicalValue - min;
 
     if (range > (uint)INT_MAX/4096) {
         double dpos = (double(p))/(double(range)/span);
-        return int(dpos);
+        return qint64(dpos);
     } else if (range > (uint)span) {
         return (2 * p * span + range) / (2*range);
     } else {
-        uint div = span / range;
-        uint mod = span % range;
+        quint64 div = span / range;
+        quint64 mod = span % range;
         return p * div + (2 * p * mod + range) / (2 * range);
     }
     // equiv. to (p * span) / range + 0.5
@@ -2182,6 +2192,14 @@ int QStyle::sliderPositionFromValue(int min, int max, int logicalValue, int span
 }
 
 /*!
+    Implemented for ABI compatibility.
+*/
+int QStyle::sliderValueFromPosition(int min, int max, int pos, int span, bool upsideDown)
+{
+	return sliderValueFromPosition((qint64) min, (qint64) max, pos, (qint64) span, upsideDown);
+}
+
+/*!
     \fn int QStyle::sliderValueFromPosition(int min, int max, int position, int span, bool upsideDown)
 
     Converts the given pixel \a position to a logical value. 0 maps to
@@ -2199,22 +2217,22 @@ int QStyle::sliderPositionFromValue(int min, int max, int logicalValue, int span
     \sa sliderPositionFromValue()
 */
 
-int QStyle::sliderValueFromPosition(int min, int max, int pos, int span, bool upsideDown)
+qint64 QStyle::sliderValueFromPosition(qint64 min, qint64 max, int pos, qint64 span, bool upsideDown)
 {
     if (span <= 0 || pos <= 0)
         return upsideDown ? max : min;
     if (pos >= span)
         return upsideDown ? min : max;
 
-    uint range = max - min;
+    quint64 range = max - min;
 
     if ((uint)span > range) {
-        int tmp = (2 * pos * range + span) / (2 * span);
+        qint64 tmp = (2 * pos * range + span) / (2 * span);
         return upsideDown ? max - tmp : tmp + min;
     } else {
-        uint div = range / span;
-        uint mod = range % span;
-        int tmp = pos * div + (2 * pos * mod + span) / (2 * span);
+        quint64 div = range / span;
+        quint64 mod = range % span;
+        qint64 tmp = pos * div + (2 * pos * mod + span) / (2 * span);
         return upsideDown ? max - tmp : tmp + min;
     }
     // equiv. to min + (pos*range)/span + 0.5
diff --git a/src/widgets/styles/qstyle.h b/src/widgets/styles/qstyle.h
index 136daa9..03d0b19 100644
--- a/src/widgets/styles/qstyle.h
+++ b/src/widgets/styles/qstyle.h
@@ -364,6 +364,8 @@ public:
         CC_Dial,
         CC_GroupBox,
         CC_MdiControls,
+        CC_ScrollBar64,
+        CC_Slider64,
 
         // do not add any values below/greater than this
         CC_CustomBase = 0xf0000000
@@ -804,6 +806,10 @@ public:
                                        bool upsideDown = false);
     static int sliderValueFromPosition(int min, int max, int pos, int space,
                                        bool upsideDown = false);
+	static int sliderPositionFromValue(qint64 min, qint64 max, qint64 val, qint64 space,
+                                       bool upsideDown = false);
+	static qint64 sliderValueFromPosition(qint64 min, qint64 max, int pos, qint64 space,
+                                       bool upsideDown = false);
     static Qt::Alignment visualAlignment(Qt::LayoutDirection direction, Qt::Alignment alignment);
     static QRect alignedRect(Qt::LayoutDirection direction, Qt::Alignment alignment,
                              const QSize &size, const QRect &rectangle);
diff --git a/src/widgets/styles/qstyleoption.cpp b/src/widgets/styles/qstyleoption.cpp
index 5913b2f..a75cbda 100644
--- a/src/widgets/styles/qstyleoption.cpp
+++ b/src/widgets/styles/qstyleoption.cpp
@@ -2143,6 +2143,25 @@ QStyleOptionSlider::QStyleOptionSlider(int version)
 
     \sa QAbstractSlider::pageStep
 */
+
+QStyleOptionSlider64::QStyleOptionSlider64()
+    : QStyleOptionComplex(Version, SO_Slider64), orientation(Qt::Horizontal), minimum(0), maximum(0),
+      tickPosition(QSlider::NoTicks), tickInterval(0), upsideDown(false),
+      sliderPosition(0), sliderValue(0), singleStep(0), pageStep(0), notchTarget(0.0),
+      dialWrapping(false)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionSlider64::QStyleOptionSlider64(int version)
+    : QStyleOptionComplex(version, SO_Slider64), orientation(Qt::Horizontal), minimum(0), maximum(0),
+      tickPosition(QSlider::NoTicks), tickInterval(0), upsideDown(false),
+      sliderPosition(0), sliderValue(0), singleStep(0), pageStep(0), notchTarget(0.0),
+      dialWrapping(false)
+{
+}
 #endif // QT_NO_SLIDER
 
 #ifndef QT_NO_SPINBOX
diff --git a/src/widgets/styles/qstyleoption.h b/src/widgets/styles/qstyleoption.h
index 4f817a3..565b813 100644
--- a/src/widgets/styles/qstyleoption.h
+++ b/src/widgets/styles/qstyleoption.h
@@ -71,7 +71,7 @@ public:
                       SO_TabBarBase, SO_RubberBand, SO_ToolBar, SO_GraphicsItem,
 
                       SO_Complex = 0xf0000, SO_Slider, SO_SpinBox, SO_ToolButton, SO_ComboBox,
-                      SO_TitleBar, SO_GroupBox, SO_SizeGrip,
+                      SO_TitleBar, SO_GroupBox, SO_SizeGrip, SO_Slider64,
 
                       SO_CustomBase = 0xf00,
                       SO_ComplexCustomBase = 0xf000000
@@ -526,6 +526,33 @@ public:
 protected:
     QStyleOptionSlider(int version);
 };
+
+class Q_GUI_EXPORT QStyleOptionSlider64: public QStyleOptionComplex
+{
+public:
+    enum StyleOptionType { Type = SO_Slider64 };
+    enum StyleOptionVersion { Version = 1 };
+
+    Qt::Orientation orientation;
+    qint64 minimum;
+    qint64 maximum;
+    QSlider::TickPosition tickPosition;
+    int tickInterval;
+    bool upsideDown;
+    qint64 sliderPosition;
+    qint64 sliderValue;
+    qint64 singleStep;
+    qint64 pageStep;
+    qreal notchTarget;
+    bool dialWrapping;
+
+    QStyleOptionSlider64();
+    QStyleOptionSlider64(const QStyleOptionSlider64 &other) : QStyleOptionComplex(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionSlider64(int version);
+};
+
 #endif // QT_NO_SLIDER
 
 #ifndef QT_NO_SPINBOX
diff --git a/src/widgets/widgets/qabstractslider64.cpp b/src/widgets/widgets/qabstractslider64.cpp
new file mode 100644
index 0000000..e563634
--- /dev/null
+++ b/src/widgets/widgets/qabstractslider64.cpp
@@ -0,0 +1,1014 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qapplication.h>
+#include "qabstractslider64.h"
+#include "qevent.h"
+#include "qabstractslider64_p.h"
+#include "qdebug.h"
+#ifndef QT_NO_ACCESSIBILITY
+#include "qaccessible.h"
+#endif
+#include <limits.h>
+#define __STDC_LIMIT_MACROS
+#include <stdint.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QAbstractSlider64
+    \brief The QAbstractSlider64 class provides an integer value within a range.
+
+    \ingroup abstractwidgets
+
+    The class is designed as a common super class for widgets like
+    QScrollBar, QSlider and QDial.
+
+    Here are the main properties of the class:
+
+    \list 1
+
+    \i \l value: The bounded integer that QAbstractSlider64 maintains.
+
+    \i \l minimum: The lowest possible value.
+
+    \i \l maximum: The highest possible value.
+
+    \i \l singleStep: The smaller of two natural steps that an
+    abstract sliders provides and typically corresponds to the user
+    pressing an arrow key.
+
+    \i \l pageStep: The larger of two natural steps that an abstract
+    slider provides and typically corresponds to the user pressing
+    PageUp or PageDown.
+
+    \i \l tracking: Whether slider tracking is enabled.
+
+    \i \l sliderPosition: The current position of the slider. If \l
+    tracking is enabled (the default), this is identical to \l value.
+
+    \endlist
+
+    Unity (1) may be viewed as a third step size. setValue() lets you
+    set the current value to any integer in the allowed range, not
+    just minimum() + \e n * singleStep() for integer values of \e n.
+    Some widgets may allow the user to set any value at all; others
+    may just provide multiples of singleStep() or pageStep().
+
+    QAbstractSlider64 emits a comprehensive set of signals:
+
+    \table
+    \header \i Signal \i Emitted when
+    \row \i \l valueChanged()
+         \i the value has changed. The \l tracking
+            determines whether this signal is emitted during user
+            interaction.
+    \row \i \l sliderPressed()
+         \i the user starts to drag the slider.
+    \row \i \l sliderMoved()
+         \i the user drags the slider.
+    \row \i \l sliderReleased()
+         \i the user releases the slider.
+    \row \i \l actionTriggered()
+         \i a slider action was triggerd.
+    \row \i \l rangeChanged()
+         \i a the range has changed.
+    \endtable
+
+    QAbstractSlider64 provides a virtual sliderChange() function that is
+    well suited for updating the on-screen representation of
+    sliders. By calling triggerAction(), subclasses trigger slider
+    actions. Two helper functions QStyle::sliderPositionFromValue() and
+    QStyle::sliderValueFromPosition() help subclasses and styles to map
+    screen coordinates to logical range values.
+
+    \sa QAbstractSpinBox, QSlider, QDial, QScrollBar, {Sliders Example}
+*/
+
+/*!
+    \enum QAbstractSlider64::SliderAction
+
+    \value SliderNoAction
+    \value SliderSingleStepAdd
+    \value SliderSingleStepSub
+    \value SliderPageStepAdd
+    \value SliderPageStepSub
+    \value SliderToMinimum
+    \value SliderToMaximum
+    \value SliderMove
+
+*/
+
+/*!
+    \fn void QAbstractSlider64::valueChanged(int value)
+
+    This signal is emitted when the slider value has changed, with the
+    new slider \a value as argument.
+*/
+
+/*!
+    \fn void QAbstractSlider64::sliderPressed()
+
+    This signal is emitted when the user presses the slider with the
+    mouse, or programmatically when setSliderDown(true) is called.
+
+    \sa sliderReleased(), sliderMoved(), isSliderDown()
+*/
+
+/*!
+    \fn void QAbstractSlider64::sliderMoved(int value)
+
+    This signal is emitted when sliderDown is true and the slider moves. This
+    usually happens when the user is dragging the slider. The \a value
+    is the new slider position.
+
+    This signal is emitted even when tracking is turned off.
+
+    \sa setTracking(), valueChanged(), isSliderDown(),
+    sliderPressed(), sliderReleased()
+*/
+
+/*!
+    \fn void QAbstractSlider64::sliderReleased()
+
+    This signal is emitted when the user releases the slider with the
+    mouse, or programmatically when setSliderDown(false) is called.
+
+    \sa sliderPressed() sliderMoved() sliderDown
+*/
+
+/*!
+    \fn void QAbstractSlider64::rangeChanged(int min, int max)
+
+    This signal is emitted when the slider range has changed, with \a
+    min being the new minimum, and \a max being the new maximum.
+
+    \sa minimum, maximum
+*/
+
+/*!
+    \fn void QAbstractSlider64::actionTriggered(int action)
+
+    This signal is emitted when the slider action \a action is
+    triggered. Actions are \l SliderSingleStepAdd, \l
+    SliderSingleStepSub, \l SliderPageStepAdd, \l SliderPageStepSub,
+    \l SliderToMinimum, \l SliderToMaximum, and \l SliderMove.
+
+    When the signal is emitted, the \l sliderPosition has been
+    adjusted according to the action, but the \l value has not yet
+    been propagated (meaning the valueChanged() signal was not yet
+    emitted), and the visual display has not been updated. In slots
+    connected to this signal you can thus safely adjust any action by
+    calling setSliderPosition() yourself, based on both the action and
+    the slider's value.
+
+    \sa triggerAction()
+*/
+
+/*!
+    \enum QAbstractSlider64::SliderChange
+
+    \value SliderRangeChange
+    \value SliderOrientationChange
+    \value SliderStepsChange
+    \value SliderValueChange
+*/
+
+QAbstractSlider64Private::QAbstractSlider64Private()
+    : minimum(0), maximum(99), pageStep(10), value(0), position(0), pressValue(-1),
+      singleStep(1), offset_accumulated(0), tracking(true),
+      blocktracking(false), pressed(false),
+      invertedAppearance(false), invertedControls(false),
+      orientation(Qt::Horizontal), repeatAction(QAbstractSlider64::SliderNoAction)
+#ifdef QT_KEYPAD_NAVIGATION
+      , isAutoRepeating(false)
+      , repeatMultiplier(1)
+{
+    firstRepeat.invalidate();
+#else
+{
+#endif
+
+}
+
+QAbstractSlider64Private::~QAbstractSlider64Private()
+{
+}
+
+/*!
+    Sets the slider's minimum to \a min and its maximum to \a max.
+
+    If \a max is smaller than \a min, \a min becomes the only legal
+    value.
+
+    \sa minimum maximum
+*/
+void QAbstractSlider64::setRange(qint64 min, qint64 max)
+{
+    Q_D(QAbstractSlider64);
+    qint64 oldMin = d->minimum;
+    qint64 oldMax = d->maximum;
+    d->minimum = min;
+    d->maximum = qMax(min, max);
+    if (oldMin != d->minimum || oldMax != d->maximum) {
+        sliderChange(SliderRangeChange);
+        emit rangeChanged(d->minimum, d->maximum);
+        setValue(d->value); // re-bound
+    }
+}
+
+
+void QAbstractSlider64Private::setSteps(qint64 single, qint64 page)
+{
+    Q_Q(QAbstractSlider64);
+    singleStep = qAbs(single);
+    pageStep = qAbs(page);
+    q->sliderChange(QAbstractSlider64::SliderStepsChange);
+}
+
+/*!
+    Constructs an abstract slider.
+
+    The \a parent argument is sent to the QWidget constructor.
+
+    The \l minimum defaults to 0, the \l maximum to 99, with a \l
+    singleStep size of 1 and a \l pageStep size of 10, and an initial
+    \l value of 0.
+*/
+QAbstractSlider64::QAbstractSlider64(QWidget *parent)
+    :QWidget(*new QAbstractSlider64Private, parent, 0)
+{
+}
+
+/*! \internal */
+QAbstractSlider64::QAbstractSlider64(QAbstractSlider64Private &dd, QWidget *parent)
+    :QWidget(dd, parent, 0)
+{
+}
+
+/*!
+    Destroys the slider.
+*/
+QAbstractSlider64::~QAbstractSlider64()
+{
+}
+
+/*!
+    \property QAbstractSlider64::orientation
+    \brief the orientation of the slider
+
+    The orientation must be \l Qt::Vertical (the default) or \l
+    Qt::Horizontal.
+*/
+void QAbstractSlider64::setOrientation(Qt::Orientation orientation)
+{
+    Q_D(QAbstractSlider64);
+    if (d->orientation == orientation)
+        return;
+
+    d->orientation = orientation;
+    if (!testAttribute(Qt::WA_WState_OwnSizePolicy)) {
+        QSizePolicy sp = sizePolicy();
+        sp.transpose();
+        setSizePolicy(sp);
+        setAttribute(Qt::WA_WState_OwnSizePolicy, false);
+    }
+    update();
+    updateGeometry();
+}
+
+Qt::Orientation QAbstractSlider64::orientation() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->orientation;
+}
+
+
+/*!
+    \property QAbstractSlider64::minimum
+    \brief the sliders's minimum value
+
+    When setting this property, the \l maximum is adjusted if
+    necessary to ensure that the range remains valid. Also the
+    slider's current value is adjusted to be within the new range.
+
+*/
+
+void QAbstractSlider64::setMinimum(qint64 min)
+{
+    Q_D(QAbstractSlider64);
+    setRange(min, qMax(d->maximum, min));
+}
+
+qint64 QAbstractSlider64::minimum() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->minimum;
+}
+
+
+/*!
+    \property QAbstractSlider64::maximum
+    \brief the slider's maximum value
+
+    When setting this property, the \l minimum is adjusted if
+    necessary to ensure that the range remains valid.  Also the
+    slider's current value is adjusted to be within the new range.
+
+
+*/
+
+void QAbstractSlider64::setMaximum(qint64 max)
+{
+    Q_D(QAbstractSlider64);
+    setRange(qMin(d->minimum, max), max);
+}
+
+qint64 QAbstractSlider64::maximum() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->maximum;
+}
+
+
+
+/*!
+    \property QAbstractSlider64::singleStep
+    \brief the single step.
+
+    The smaller of two natural steps that an
+    abstract sliders provides and typically corresponds to the user
+    pressing an arrow key.
+
+    If the property is modified during an auto repeating key event, behavior
+    is undefined.
+
+    \sa pageStep
+*/
+
+void QAbstractSlider64::setSingleStep(qint64 step)
+{
+    Q_D(QAbstractSlider64);
+    if (step != d->singleStep)
+        d->setSteps(step, d->pageStep);
+}
+
+qint64 QAbstractSlider64::singleStep() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->singleStep;
+}
+
+
+/*!
+    \property QAbstractSlider64::pageStep
+    \brief the page step.
+
+    The larger of two natural steps that an abstract slider provides
+    and typically corresponds to the user pressing PageUp or PageDown.
+
+    \sa singleStep
+*/
+
+void QAbstractSlider64::setPageStep(qint64 step)
+{
+    Q_D(QAbstractSlider64);
+    if (step != d->pageStep)
+        d->setSteps(d->singleStep, step);
+}
+
+qint64 QAbstractSlider64::pageStep() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->pageStep;
+}
+
+/*!
+    \property QAbstractSlider64::tracking
+    \brief whether slider tracking is enabled
+
+    If tracking is enabled (the default), the slider emits the
+    valueChanged() signal while the slider is being dragged. If
+    tracking is disabled, the slider emits the valueChanged() signal
+    only when the user releases the slider.
+
+    \sa sliderDown
+*/
+void QAbstractSlider64::setTracking(bool enable)
+{
+    Q_D(QAbstractSlider64);
+    d->tracking = enable;
+}
+
+bool QAbstractSlider64::hasTracking() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->tracking;
+}
+
+
+/*!
+    \property QAbstractSlider64::sliderDown
+    \brief whether the slider is pressed down.
+
+    The property is set by subclasses in order to let the abstract
+    slider know whether or not \l tracking has any effect.
+
+    Changing the slider down property emits the sliderPressed() and
+    sliderReleased() signals.
+
+*/
+void QAbstractSlider64::setSliderDown(bool down)
+{
+    Q_D(QAbstractSlider64);
+    bool doEmit = d->pressed != down;
+
+    d->pressed = down;
+
+    if (doEmit) {
+        if (down)
+            emit sliderPressed();
+        else
+            emit sliderReleased();
+    }
+
+    if (!down && d->position != d->value)
+        triggerAction(SliderMove);
+}
+
+bool QAbstractSlider64::isSliderDown() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->pressed;
+}
+
+
+/*!
+    \property QAbstractSlider64::sliderPosition
+    \brief the current slider position
+
+    If \l tracking is enabled (the default), this is identical to \l value.
+*/
+void QAbstractSlider64::setSliderPosition(qint64 position)
+{
+    Q_D(QAbstractSlider64);
+    position = d->bound(position);
+    if (position == d->position)
+        return;
+    d->position = position;
+    if (!d->tracking)
+        update();
+    if (d->pressed)
+        emit sliderMoved(position);
+    if (d->tracking && !d->blocktracking)
+        triggerAction(SliderMove);
+}
+
+qint64 QAbstractSlider64::sliderPosition() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->position;
+}
+
+
+/*!
+    \property QAbstractSlider64::value
+    \brief the slider's current value
+
+    The slider forces the value to be within the legal range: \l
+    minimum <= \c value <= \l maximum.
+
+    Changing the value also changes the \l sliderPosition.
+*/
+
+
+qint64 QAbstractSlider64::value() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->value;
+}
+
+void QAbstractSlider64::setValue(qint64 value)
+{
+    Q_D(QAbstractSlider64);
+    value = d->bound(value);
+    if (d->value == value && d->position == value)
+        return;
+    d->value = value;
+    if (d->position != value) {
+        d->position = value;
+        if (d->pressed)
+            emit sliderMoved((d->position = value));
+    }
+#ifndef QT_NO_ACCESSIBILITY
+    QAccessibleValueChangeEvent event(this, d->value);
+    QAccessible::updateAccessibility(&event);
+#endif
+    sliderChange(SliderValueChange);
+    emit valueChanged(value);
+}
+
+/*!
+    \property QAbstractSlider64::invertedAppearance
+    \brief whether or not a slider shows its values inverted.
+
+    If this property is false (the default), the minimum and maximum will
+    be shown in its classic position for the inherited widget. If the
+    value is true, the minimum and maximum appear at their opposite location.
+
+    Note: This property makes most sense for sliders and dials. For
+    scroll bars, the visual effect of the scroll bar subcontrols depends on
+    whether or not the styles understand inverted appearance; most styles
+    ignore this property for scroll bars.
+*/
+
+bool QAbstractSlider64::invertedAppearance() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->invertedAppearance;
+}
+
+void QAbstractSlider64::setInvertedAppearance(bool invert)
+{
+    Q_D(QAbstractSlider64);
+    d->invertedAppearance = invert;
+    update();
+}
+
+
+/*!
+    \property QAbstractSlider64::invertedControls
+    \brief whether or not the slider inverts its wheel and key events.
+
+    If this property is false, scrolling the mouse wheel "up" and using keys
+    like page up will increase the slider's value towards its maximum. Otherwise
+    pressing page up will move value towards the slider's minimum.
+*/
+
+
+bool QAbstractSlider64::invertedControls() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->invertedControls;
+}
+
+void QAbstractSlider64::setInvertedControls(bool invert)
+{
+    Q_D(QAbstractSlider64);
+    d->invertedControls = invert;
+}
+
+/*!  Triggers a slider \a action.  Possible actions are \l
+  SliderSingleStepAdd, \l SliderSingleStepSub, \l SliderPageStepAdd,
+  \l SliderPageStepSub, \l SliderToMinimum, \l SliderToMaximum, and \l
+  SliderMove.
+
+  \sa actionTriggered()
+ */
+void QAbstractSlider64::triggerAction(SliderAction action)
+{
+    Q_D(QAbstractSlider64);
+    d->blocktracking = true;
+    switch (action) {
+    case SliderSingleStepAdd:
+        setSliderPosition(d->overflowSafeAdd(d->effectiveSingleStep()));
+        break;
+    case SliderSingleStepSub:
+        setSliderPosition(d->overflowSafeAdd(-d->effectiveSingleStep()));
+        break;
+    case SliderPageStepAdd:
+        setSliderPosition(d->overflowSafeAdd(d->pageStep));
+        break;
+    case SliderPageStepSub:
+        setSliderPosition(d->overflowSafeAdd(-d->pageStep));
+        break;
+    case SliderToMinimum:
+        setSliderPosition(d->minimum);
+        break;
+    case SliderToMaximum:
+        setSliderPosition(d->maximum);
+        break;
+    case SliderMove:
+    case SliderNoAction:
+        break;
+    };
+    emit actionTriggered(action);
+    d->blocktracking = false;
+    setValue(d->position);
+}
+
+/*!  Sets action \a action to be triggered repetitively in intervals
+of \a repeatTime, after an initial delay of \a thresholdTime.
+
+\sa triggerAction() repeatAction()
+ */
+void QAbstractSlider64::setRepeatAction(SliderAction action, int thresholdTime, int repeatTime)
+{
+    Q_D(QAbstractSlider64);
+    if ((d->repeatAction = action) == SliderNoAction) {
+        d->repeatActionTimer.stop();
+    } else {
+        d->repeatActionTime = repeatTime;
+        d->repeatActionTimer.start(thresholdTime, this);
+    }
+}
+
+/*!
+  Returns the current repeat action.
+  \sa setRepeatAction()
+ */
+QAbstractSlider64::SliderAction QAbstractSlider64::repeatAction() const
+{
+    Q_D(const QAbstractSlider64);
+    return d->repeatAction;
+}
+
+/*!\reimp
+ */
+void QAbstractSlider64::timerEvent(QTimerEvent *e)
+{
+    Q_D(QAbstractSlider64);
+    if (e->timerId() == d->repeatActionTimer.timerId()) {
+        if (d->repeatActionTime) { // was threshold time, use repeat time next time
+            d->repeatActionTimer.start(d->repeatActionTime, this);
+            d->repeatActionTime = 0;
+        }
+        if (d->repeatAction == SliderPageStepAdd)
+            d->setAdjustedSliderPosition(d->overflowSafeAdd(d->pageStep));
+        else if (d->repeatAction == SliderPageStepSub)
+            d->setAdjustedSliderPosition(d->overflowSafeAdd(-d->pageStep));
+        else
+            triggerAction(d->repeatAction);
+    }
+}
+
+/*!
+    Reimplement this virtual function to track slider changes such as
+    \l SliderRangeChange, \l SliderOrientationChange, \l
+    SliderStepsChange, or \l SliderValueChange. The default
+    implementation only updates the display and ignores the \a change
+    parameter.
+ */
+void QAbstractSlider64::sliderChange(SliderChange)
+{
+    update();
+}
+
+/*!
+    \internal
+
+    Truncate qreal to int without flipping on overflow.
+*/
+static inline qint64 clampScrollStep(qreal x)
+{
+    return qint64(qBound(qreal(INT64_MIN), x, qreal(INT64_MAX)));
+}
+
+bool QAbstractSlider64Private::scrollByDelta(Qt::Orientation orientation, Qt::KeyboardModifiers modifiers, qint64 delta)
+{
+    Q_Q(QAbstractSlider64);
+    qint64 stepsToScroll = 0;
+    // in Qt scrolling to the right gives negative values.
+    if (orientation == Qt::Horizontal)
+        delta = -delta;
+    qreal offset = qreal(delta) / 120;
+
+    if ((modifiers & Qt::ControlModifier) || (modifiers & Qt::ShiftModifier)) {
+        // Scroll one page regardless of delta:
+        stepsToScroll = qBound(-pageStep, clampScrollStep(offset * pageStep), pageStep);
+        offset_accumulated = 0;
+    } else {
+        // Calculate how many lines to scroll. Depending on what delta is (and
+        // offset), we might end up with a fraction (e.g. scroll 1.3 lines). We can
+        // only scroll whole lines, so we keep the reminder until next event.
+        qreal stepsToScrollF =
+#ifndef QT_NO_WHEELEVENT
+                QApplication::wheelScrollLines() *
+#endif
+                offset * effectiveSingleStep();
+        // Check if wheel changed direction since last event:
+        if (offset_accumulated != 0 && (offset / offset_accumulated) < 0)
+            offset_accumulated = 0;
+
+        offset_accumulated += stepsToScrollF;
+#ifndef Q_WS_MAC
+        // Don't scroll more than one page in any case:
+        stepsToScroll = qBound(-pageStep, clampScrollStep(offset_accumulated), pageStep);
+#else
+        // Native UI-elements on Mac can scroll hundreds of lines at a time as
+        // a result of acceleration. So keep the same behaviour in Qt, and
+        // don't restrict stepsToScroll to certain maximum (pageStep):
+        stepsToScroll = clampScrollStep(offset_accumulated);
+#endif
+        offset_accumulated -= clampScrollStep(offset_accumulated);
+        if (stepsToScroll == 0)
+            return false;
+    }
+
+    if (invertedControls)
+        stepsToScroll = -stepsToScroll;
+
+    qint64 prevValue = value;
+    position = overflowSafeAdd(stepsToScroll); // value will be updated by triggerAction()
+    q->triggerAction(QAbstractSlider64::SliderMove);
+
+    if (prevValue == value) {
+        offset_accumulated = 0;
+        return false;
+    }
+    return true;
+}
+
+/*!
+    \reimp
+*/
+#ifndef QT_NO_WHEELEVENT
+void QAbstractSlider64::wheelEvent(QWheelEvent * e)
+{
+    Q_D(QAbstractSlider64);
+    e->ignore();
+    int delta = e->delta();
+    if (d->scrollByDelta(e->orientation(), e->modifiers(), delta))
+        e->accept();
+}
+
+#endif
+
+/*!
+    \reimp
+*/
+void QAbstractSlider64::keyPressEvent(QKeyEvent *ev)
+{
+    Q_D(QAbstractSlider64);
+    SliderAction action = SliderNoAction;
+#ifdef QT_KEYPAD_NAVIGATION
+    if (ev->isAutoRepeat()) {
+        if (!d->firstRepeat.isValid())
+            d->firstRepeat.start();
+        else if (1 == d->repeatMultiplier) {
+            // This is the interval in milli seconds which one key repetition
+            // takes.
+            const int repeatMSecs = d->firstRepeat.elapsed();
+
+            /**
+             * The time it takes to currently navigate the whole slider.
+             */
+            const qreal currentTimeElapse = (qreal(maximum()) / singleStep()) * repeatMSecs;
+
+            /**
+             * This is an arbitrarily determined constant in msecs that
+             * specifies how long time it should take to navigate from the
+             * start to the end(excluding starting key auto repeat).
+             */
+            const int SliderRepeatElapse = 2500;
+
+            d->repeatMultiplier = currentTimeElapse / SliderRepeatElapse;
+        }
+
+    }
+    else if (d->firstRepeat.isValid()) {
+        d->firstRepeat.invalidate();
+        d->repeatMultiplier = 1;
+    }
+
+#endif
+
+    switch (ev->key()) {
+#ifdef QT_KEYPAD_NAVIGATION
+        case Qt::Key_Select:
+            if (QApplication::keypadNavigationEnabled())
+                setEditFocus(!hasEditFocus());
+            else
+                ev->ignore();
+            break;
+        case Qt::Key_Back:
+            if (QApplication::keypadNavigationEnabled() && hasEditFocus()) {
+                setValue(d->origValue);
+                setEditFocus(false);
+            } else
+                ev->ignore();
+            break;
+#endif
+
+        // It seems we need to use invertedAppearance for Left and right, otherwise, things look weird.
+        case Qt::Key_Left:
+#ifdef QT_KEYPAD_NAVIGATION
+            // In QApplication::KeypadNavigationDirectional, we want to change the slider
+            // value if there is no left/right navigation possible and if this slider is not
+            // inside a tab widget.
+            if (QApplication::keypadNavigationEnabled()
+                    && (!hasEditFocus() && QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
+                    || d->orientation == Qt::Vertical
+                    || !hasEditFocus()
+                    && (QWidgetPrivate::canKeypadNavigate(Qt::Horizontal) || QWidgetPrivate::inTabWidget(this)))) {
+                ev->ignore();
+                return;
+            }
+            if (QApplication::keypadNavigationEnabled() && d->orientation == Qt::Vertical)
+                action = d->invertedControls ? SliderSingleStepSub : SliderSingleStepAdd;
+            else
+#endif
+            if (isRightToLeft())
+                action = d->invertedAppearance ? SliderSingleStepSub : SliderSingleStepAdd;
+            else
+                action = !d->invertedAppearance ? SliderSingleStepSub : SliderSingleStepAdd;
+            break;
+        case Qt::Key_Right:
+#ifdef QT_KEYPAD_NAVIGATION
+            // Same logic as in Qt::Key_Left
+            if (QApplication::keypadNavigationEnabled()
+                    && (!hasEditFocus() && QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
+                    || d->orientation == Qt::Vertical
+                    || !hasEditFocus()
+                    && (QWidgetPrivate::canKeypadNavigate(Qt::Horizontal) || QWidgetPrivate::inTabWidget(this)))) {
+                ev->ignore();
+                return;
+            }
+            if (QApplication::keypadNavigationEnabled() && d->orientation == Qt::Vertical)
+                action = d->invertedControls ? SliderSingleStepAdd : SliderSingleStepSub;
+            else
+#endif
+            if (isRightToLeft())
+                action = d->invertedAppearance ? SliderSingleStepAdd : SliderSingleStepSub;
+            else
+                action = !d->invertedAppearance ? SliderSingleStepAdd : SliderSingleStepSub;
+            break;
+        case Qt::Key_Up:
+#ifdef QT_KEYPAD_NAVIGATION
+            // In QApplication::KeypadNavigationDirectional, we want to change the slider
+            // value if there is no up/down navigation possible.
+            if (QApplication::keypadNavigationEnabled()
+                    && (QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
+                    || d->orientation == Qt::Horizontal
+                    || !hasEditFocus() && QWidgetPrivate::canKeypadNavigate(Qt::Vertical))) {
+                ev->ignore();
+                break;
+            }
+#endif
+            action = d->invertedControls ? SliderSingleStepSub : SliderSingleStepAdd;
+            break;
+        case Qt::Key_Down:
+#ifdef QT_KEYPAD_NAVIGATION
+            // Same logic as in Qt::Key_Up
+            if (QApplication::keypadNavigationEnabled()
+                    && (QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
+                    || d->orientation == Qt::Horizontal
+                    || !hasEditFocus() && QWidgetPrivate::canKeypadNavigate(Qt::Vertical))) {
+                ev->ignore();
+                break;
+            }
+#endif
+            action = d->invertedControls ? SliderSingleStepAdd : SliderSingleStepSub;
+            break;
+        case Qt::Key_PageUp:
+            action = d->invertedControls ? SliderPageStepSub : SliderPageStepAdd;
+            break;
+        case Qt::Key_PageDown:
+            action = d->invertedControls ? SliderPageStepAdd : SliderPageStepSub;
+            break;
+        case Qt::Key_Home:
+            action = SliderToMinimum;
+            break;
+        case Qt::Key_End:
+            action = SliderToMaximum;
+            break;
+        default:
+            ev->ignore();
+            break;
+    }
+    if (action)
+        triggerAction(action);
+}
+
+/*!
+    \reimp
+*/
+void QAbstractSlider64::changeEvent(QEvent *ev)
+{
+    Q_D(QAbstractSlider64);
+    switch (ev->type()) {
+    case QEvent::EnabledChange:
+        if (!isEnabled()) {
+            d->repeatActionTimer.stop();
+            setSliderDown(false);
+        }
+        // fall through...
+    default:
+        QWidget::changeEvent(ev);
+    }
+}
+
+/*!
+    \reimp
+*/
+bool QAbstractSlider64::event(QEvent *e)
+{
+#ifdef QT_KEYPAD_NAVIGATION
+    Q_D(QAbstractSlider64);
+    switch (e->type()) {
+    case QEvent::FocusIn:
+        d->origValue = d->value;
+        break;
+    default:
+        break;
+    }
+#endif
+
+    return QWidget::event(e);
+}
+
+/*! \fn int QAbstractSlider64::minValue() const
+
+    Use minimum() instead.
+*/
+
+/*! \fn int QAbstractSlider64::maxValue() const
+
+    Use maximum() instead.
+*/
+
+/*! \fn int QAbstractSlider64::lineStep() const
+
+    Use singleStep() instead.
+*/
+
+/*! \fn void QAbstractSlider64::setMinValue(int v)
+
+    Use setMinimum() instead.
+*/
+
+/*! \fn void QAbstractSlider64::setMaxValue(int v)
+
+    Use setMaximum() instead.
+*/
+
+/*! \fn void QAbstractSlider64::setLineStep(int v)
+
+    Use setSingleStep() instead.
+*/
+
+/*! \fn void QAbstractSlider64::addPage()
+
+    Use triggerAction(QAbstractSlider64::SliderPageStepAdd) instead.
+*/
+
+/*! \fn void QAbstractSlider64::subtractPage()
+
+    Use triggerAction(QAbstractSlider64::SliderPageStepSub) instead.
+*/
+
+/*! \fn void QAbstractSlider64::addLine()
+
+    Use triggerAction(QAbstractSlider64::SliderSingleStepAdd) instead.
+*/
+
+/*! \fn void QAbstractSlider64::subtractLine()
+
+    Use triggerAction(QAbstractSlider64::SliderSingleStepSub) instead.
+*/
+
+/*! \fn void QAbstractSlider64::setSteps(int single, int page)
+
+    Use setSingleStep(\a single) followed by setPageStep(\a page)
+    instead.
+*/
+
+QT_END_NAMESPACE
diff --git a/src/widgets/widgets/qabstractslider64.h b/src/widgets/widgets/qabstractslider64.h
new file mode 100644
index 0000000..3623f84
--- /dev/null
+++ b/src/widgets/widgets/qabstractslider64.h
@@ -0,0 +1,143 @@
+#ifndef QABSTRACTSLIDER64_H
+#define QABSTRACTSLIDER64_H
+
+#include <QtWidgets/qwidget.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Gui)
+
+class QAbstractSlider64Private;
+
+class Q_GUI_EXPORT QAbstractSlider64 : public QWidget
+{
+    Q_OBJECT
+
+    Q_PROPERTY(qint64 minimum READ minimum WRITE setMinimum)
+    Q_PROPERTY(qint64 maximum READ maximum WRITE setMaximum)
+    Q_PROPERTY(qint64 singleStep READ singleStep WRITE setSingleStep)
+    Q_PROPERTY(qint64 pageStep READ pageStep WRITE setPageStep)
+    Q_PROPERTY(qint64 value READ value WRITE setValue NOTIFY valueChanged USER true)
+    Q_PROPERTY(qint64 sliderPosition READ sliderPosition WRITE setSliderPosition NOTIFY sliderMoved)
+    Q_PROPERTY(bool tracking READ hasTracking WRITE setTracking)
+    Q_PROPERTY(Qt::Orientation orientation READ orientation WRITE setOrientation)
+    Q_PROPERTY(bool invertedAppearance READ invertedAppearance WRITE setInvertedAppearance)
+    Q_PROPERTY(bool invertedControls READ invertedControls WRITE setInvertedControls)
+    Q_PROPERTY(bool sliderDown READ isSliderDown WRITE setSliderDown DESIGNABLE false)
+
+public:
+    explicit QAbstractSlider64(QWidget *parent=0);
+    ~QAbstractSlider64();
+
+    Qt::Orientation orientation() const;
+
+    void setMinimum(qint64);
+    qint64 minimum() const;
+
+    void setMaximum(qint64);
+    qint64 maximum() const;
+
+    void setRange(qint64 min, qint64 max);
+
+    void setSingleStep(qint64);
+    qint64 singleStep() const;
+
+    void setPageStep(qint64);
+    qint64 pageStep() const;
+
+    void setTracking(bool enable);
+    bool hasTracking() const;
+
+    void setSliderDown(bool);
+    bool isSliderDown() const;
+
+    void setSliderPosition(qint64);
+    qint64 sliderPosition() const;
+
+    void setInvertedAppearance(bool);
+    bool invertedAppearance() const;
+
+    void setInvertedControls(bool);
+    bool invertedControls() const;
+
+    enum SliderAction {
+        SliderNoAction,
+        SliderSingleStepAdd,
+        SliderSingleStepSub,
+        SliderPageStepAdd,
+        SliderPageStepSub,
+        SliderToMinimum,
+        SliderToMaximum,
+        SliderMove
+    };
+
+    qint64 value() const;
+
+    void triggerAction(SliderAction action);
+
+public Q_SLOTS:
+    void setValue(qint64);
+    void setOrientation(Qt::Orientation);
+
+Q_SIGNALS:
+    void valueChanged(qint64 value);
+
+    void sliderPressed();
+    void sliderMoved(qint64 position);
+    void sliderReleased();
+
+    void rangeChanged(qint64 min, qint64 max);
+
+    void actionTriggered(int action);
+
+protected:
+    bool event(QEvent *e);
+
+    void setRepeatAction(SliderAction action, int thresholdTime = 500, int repeatTime = 50);
+    SliderAction repeatAction() const;
+
+    enum SliderChange {
+        SliderRangeChange,
+        SliderOrientationChange,
+        SliderStepsChange,
+        SliderValueChange
+    };
+    virtual void sliderChange(SliderChange change);
+
+    void keyPressEvent(QKeyEvent *ev);
+    void timerEvent(QTimerEvent *);
+#ifndef QT_NO_WHEELEVENT
+    void wheelEvent(QWheelEvent *e);
+#endif
+    void changeEvent(QEvent *e);
+
+#ifdef QT3_SUPPORT
+public:
+    inline QT3_SUPPORT qint64 minValue() const { return minimum(); }
+    inline QT3_SUPPORT qint64 maxValue() const { return maximum(); }
+    inline QT3_SUPPORT qint64 lineStep() const { return singleStep(); }
+    inline QT3_SUPPORT void setMinValue(qint64 v) { setMinimum(v); }
+    inline QT3_SUPPORT void setMaxValue(qint64 v) { setMaximum(v); }
+    inline QT3_SUPPORT void setLineStep(qint64 v) { setSingleStep(v); }
+    inline QT3_SUPPORT void setSteps(qint64 single, qint64 page) { setSingleStep(single); setPageStep(page); }
+    inline QT3_SUPPORT void addPage() { triggerAction(SliderPageStepAdd); }
+    inline QT3_SUPPORT void subtractPage() { triggerAction(SliderPageStepSub); }
+    inline QT3_SUPPORT void addLine() { triggerAction(SliderSingleStepAdd); }
+    inline QT3_SUPPORT void subtractLine() { triggerAction(SliderSingleStepSub); }
+#endif
+
+protected:
+    QAbstractSlider64(QAbstractSlider64Private &dd, QWidget *parent=0);
+
+private:
+    Q_DISABLE_COPY(QAbstractSlider64)
+    Q_DECLARE_PRIVATE(QAbstractSlider64)
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QABSTRACTSLIDER64_H
diff --git a/src/widgets/widgets/qabstractslider64_p.h b/src/widgets/widgets/qabstractslider64_p.h
new file mode 100644
index 0000000..6e50fc9
--- /dev/null
+++ b/src/widgets/widgets/qabstractslider64_p.h
@@ -0,0 +1,106 @@
+#ifndef QABSTRACTSLIDER64_P_H
+#define QABSTRACTSLIDER64_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "QtCore/qbasictimer.h"
+#include "QtCore/qelapsedtimer.h"
+#include "private/qwidget_p.h"
+#include "qstyle.h"
+
+QT_BEGIN_NAMESPACE
+
+class QAbstractSlider64Private : public QWidgetPrivate
+{
+    Q_DECLARE_PUBLIC(QAbstractSlider64)
+public:
+    QAbstractSlider64Private();
+    ~QAbstractSlider64Private();
+
+    void setSteps(qint64 single, qint64 page);
+
+    qint64 minimum, maximum, pageStep, value, position, pressValue;
+
+    /**
+     * Call effectiveSingleStep() when changing the slider value.
+     */
+    qint64 singleStep;
+
+    float offset_accumulated;
+    uint tracking : 1;
+    uint blocktracking :1;
+    uint pressed : 1;
+    uint invertedAppearance : 1;
+    uint invertedControls : 1;
+    Qt::Orientation orientation;
+
+    QBasicTimer repeatActionTimer;
+    int repeatActionTime;
+    QAbstractSlider64::SliderAction repeatAction;
+
+#ifdef QT_KEYPAD_NAVIGATION
+    qint64 origValue;
+
+    /**
+     */
+    bool isAutoRepeating;
+
+    /**
+     * When we're auto repeating, we multiply singleStep with this value to
+     * get our effective step.
+     */
+    qreal repeatMultiplier;
+
+    /**
+     * The time of when the first auto repeating key press event occurs.
+     */
+    QElapsedTimer firstRepeat;
+
+#endif
+
+    inline qint64 effectiveSingleStep() const
+    {
+        return singleStep
+#ifdef QT_KEYPAD_NAVIGATION
+        * repeatMultiplier
+#endif
+        ;
+    }
+
+    virtual qint64 bound(qint64 val) const { return qMax(minimum, qMin(maximum, val)); }
+    inline qint64 overflowSafeAdd(qint64 add) const
+    {
+        qint64 newValue = value + add;
+        if (add > 0 && newValue < value)
+            newValue = maximum;
+        else if (add < 0 && newValue > value)
+            newValue = minimum;
+        return newValue;
+    }
+    inline void setAdjustedSliderPosition(qint64 position)
+    {
+        Q_Q(QAbstractSlider64);
+        if (q->style()->styleHint(QStyle::SH_Slider_StopMouseOverSlider, 0, q)) {
+            if ((position > pressValue - 2 * pageStep) && (position < pressValue + 2 * pageStep)) {
+                repeatAction = QAbstractSlider64::SliderNoAction;
+                q->setSliderPosition(pressValue);
+                return;
+            }
+        }
+        q->triggerAction(repeatAction);
+    }
+    bool scrollByDelta(Qt::Orientation orientation, Qt::KeyboardModifiers modifiers, qint64 delta);
+};
+
+QT_END_NAMESPACE
+
+#endif // QABSTRACTSLIDER64_P_H
diff --git a/src/widgets/widgets/qscrollbar64.cpp b/src/widgets/widgets/qscrollbar64.cpp
new file mode 100644
index 0000000..3316f5f
--- /dev/null
+++ b/src/widgets/widgets/qscrollbar64.cpp
@@ -0,0 +1,764 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: Nokia Corporation (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qapplication.h"
+#include "qcursor.h"
+#include "qevent.h"
+#include "qpainter.h"
+#include "qscrollbar64.h"
+#include "qstyle.h"
+#include "qstyleoption.h"
+#include "qmenu.h"
+#include <QtCore/qelapsedtimer.h>
+
+#ifndef QT_NO_SCROLLBAR
+
+#ifndef QT_NO_ACCESSIBILITY
+#include "qaccessible.h"
+#endif
+#include <limits.h>
+#include "qabstractslider64_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QScrollBar64
+    \brief The QScrollBar64 widget provides a vertical or horizontal scroll bar.
+
+    \ingroup basicwidgets
+
+    A scroll bar is a control that enables the user to access parts of a
+    document that is larger than the widget used to display it. It provides
+    a visual indication of the user's current position within the document
+    and the amount of the document that is visible. Scroll bars are usually
+    equipped with other controls that enable more accurate navigation.
+    Qt displays scroll bars in a way that is appropriate for each platform.
+
+    If you need to provide a scrolling view onto another widget, it may be
+    more convenient to use the QScrollArea class because this provides a
+    viewport widget and scroll bars. QScrollBar64 is useful if you need to
+    implement similar functionality for specialized widgets using QAbstractScrollArea;
+    for example, if you decide to subclass QAbstractItemView.
+    For most other situations where a slider control is used to obtain a value
+    within a given range, the QSlider class may be more appropriate for your
+    needs.
+
+    \table
+    \row \o \image qscrollbar-picture.png
+    \o Scroll bars typically include four separate controls: a slider,
+    scroll arrows, and a page control.
+
+    \list
+    \o a. The slider provides a way to quickly go to any part of the
+    document, but does not support accurate navigation within large
+    documents.
+    \o b. The scroll arrows are push buttons which can be used to accurately
+    navigate to a particular place in a document. For a vertical scroll bar
+    connected to a text editor, these typically move the current position one
+    "line" up or down, and adjust the position of the slider by a small
+    amount. In editors and list boxes a "line" might mean one line of text;
+    in an image viewer it might mean 20 pixels.
+    \o c. The page control is the area over which the slider is dragged (the
+    scroll bar's background). Clicking here moves the scroll bar towards
+    the click by one "page". This value is usually the same as the length of
+    the slider.
+    \endlist
+    \endtable
+
+    Each scroll bar has a value that indicates how far the slider is from
+    the start of the scroll bar; this is obtained with value() and set
+    with setValue(). This value always lies within the range of values
+    defined for the scroll bar, from \l{QAbstractSlider64::minimum()}{minimum()}
+    to \l{QAbstractSlider64::minimum()}{maximum()} inclusive. The range of
+    acceptable values can be set with setMinimum() and setMaximum().
+    At the minimum value, the top edge of the slider (for a vertical scroll
+    bar) or left edge (for a horizontal scroll bar) will be at the top (or
+    left) end of the scroll bar. At the maximum value, the bottom (or right)
+    edge of the slider will be at the bottom (or right) end of the scroll bar.
+
+    The length of the slider is usually related to the value of the page step,
+    and typically represents the proportion of the document area shown in a
+    scrolling view. The page step is the amount that the value changes by
+    when the user presses the \key{Page Up} and \key{Page Down} keys, and is
+    set with setPageStep(). Smaller changes to the value defined by the
+    line step are made using the cursor keys, and this quantity is set with
+    \l{QAbstractSlider64::}{setSingleStep()}.
+
+    Note that the range of values used is independent of the actual size
+    of the scroll bar widget. You do not need to take this into account when
+    you choose values for the range and the page step.
+
+    The range of values specified for the scroll bar are often determined
+    differently to those for a QSlider because the length of the slider
+    needs to be taken into account. If we have a document with 100 lines,
+    and we can only show 20 lines in a widget, we may wish to construct a
+    scroll bar with a page step of 20, a minimum value of 0, and a maximum
+    value of 80. This would give us a scroll bar with five "pages".
+
+    \table
+    \row \o \inlineimage qscrollbar-values.png
+    \o The relationship between a document length, the range of values used
+    in a scroll bar, and the page step is simple in many common situations.
+    The scroll bar's range of values is determined by subtracting a
+    chosen page step from some value representing the length of the document.
+    In such cases, the following equation is useful:
+    \e{document length} = maximum() - minimum() + pageStep().
+    \endtable
+
+    QScrollBar64 only provides integer ranges. Note that although
+    QScrollBar64 handles very large numbers, scroll bars on current
+    screens cannot usefully represent ranges above about 100,000 pixels.
+    Beyond that, it becomes difficult for the user to control the
+    slider using either the keyboard or the mouse, and the scroll
+    arrows will have limited use.
+
+    ScrollBar inherits a comprehensive set of signals from QAbstractSlider64:
+    \list
+    \o \l{QAbstractSlider64::valueChanged()}{valueChanged()} is emitted when the
+       scroll bar's value has changed. The tracking() determines whether this
+       signal is emitted during user interaction.
+    \o \l{QAbstractSlider64::rangeChanged()}{rangeChanged()} is emitted when the
+       scroll bar's range of values has changed.
+    \o \l{QAbstractSlider64::sliderPressed()}{sliderPressed()} is emitted when
+       the user starts to drag the slider.
+    \o \l{QAbstractSlider64::sliderMoved()}{sliderMoved()} is emitted when the user
+       drags the slider.
+    \o \l{QAbstractSlider64::sliderReleased()}{sliderReleased()} is emitted when
+       the user releases the slider.
+    \o \l{QAbstractSlider64::actionTriggered()}{actionTriggered()} is emitted
+       when the scroll bar is changed by user interaction or via the
+       \l{QAbstractSlider64::triggerAction()}{triggerAction()} function.
+    \endlist
+
+    A scroll bar can be controlled by the keyboard, but it has a
+    default focusPolicy() of Qt::NoFocus. Use setFocusPolicy() to
+    enable keyboard interaction with the scroll bar:
+    \list
+         \o Left/Right move a horizontal scroll bar by one single step.
+         \o Up/Down move a vertical scroll bar by one single step.
+         \o PageUp moves up one page.
+         \o PageDown moves down one page.
+         \o Home moves to the start (mininum).
+         \o End moves to the end (maximum).
+     \endlist
+
+    The slider itself can be controlled by using the
+    \l{QAbstractSlider64::triggerAction()}{triggerAction()} function to simulate
+    user interaction with the scroll bar controls. This is useful if you have
+    many different widgets that use a common range of values.
+
+    Most GUI styles use the pageStep() value to calculate the size of the
+    slider.
+
+    \table 100%
+    \row \o \inlineimage macintosh-horizontalscrollbar.png Screenshot of a Macintosh style scroll bar
+         \o A scroll bar shown in the \l{Macintosh Style Widget Gallery}{Macintosh widget style}.
+    \row \o \inlineimage windowsxp-horizontalscrollbar.png Screenshot of a Windows XP style scroll bar
+         \o A scroll bar shown in the \l{Windows XP Style Widget Gallery}{Windows XP widget style}.
+    \row \o \inlineimage plastique-horizontalscrollbar.png Screenshot of a Plastique style scroll bar
+         \o A scroll bar shown in the \l{Plastique Style Widget Gallery}{Plastique widget style}.
+    \endtable
+
+    \sa QScrollArea, QSlider, QDial, QSpinBox, {fowler}{GUI Design Handbook: Scroll Bar}, {Sliders Example}
+*/
+
+class QScrollBar64Private : public QAbstractSlider64Private
+{
+    Q_DECLARE_PUBLIC(QScrollBar64)
+public:
+    QStyle::SubControl pressedControl;
+    bool pointerOutsidePressedControl;
+
+    qint64 clickOffset, snapBackPosition;
+
+    void activateControl(uint control, int threshold = 500);
+    void stopRepeatAction();
+    qint64 pixelPosToRangeValue(int pos) const;
+    void init();
+    bool updateHoverControl(const QPoint &pos);
+    QStyle::SubControl newHoverControl(const QPoint &pos);
+
+    QStyle::SubControl hoverControl;
+    QRect hoverRect;
+};
+
+bool QScrollBar64Private::updateHoverControl(const QPoint &pos)
+{
+    Q_Q(QScrollBar64);
+    QRect lastHoverRect = hoverRect;
+    QStyle::SubControl lastHoverControl = hoverControl;
+    bool doesHover = q->testAttribute(Qt::WA_Hover);
+    if (lastHoverControl != newHoverControl(pos) && doesHover) {
+        q->update(lastHoverRect);
+        q->update(hoverRect);
+        return true;
+    }
+    return !doesHover;
+}
+
+QStyle::SubControl QScrollBar64Private::newHoverControl(const QPoint &pos)
+{
+    Q_Q(QScrollBar64);
+    QStyleOptionSlider64 opt;
+    q->initStyleOption(&opt);
+    opt.subControls = QStyle::SC_All;
+    hoverControl = q->style()->hitTestComplexControl(QStyle::CC_ScrollBar64, &opt, pos, q);
+    if (hoverControl == QStyle::SC_None)
+        hoverRect = QRect();
+    else
+        hoverRect = q->style()->subControlRect(QStyle::CC_ScrollBar64, &opt, hoverControl, q);
+    return hoverControl;
+}
+
+void QScrollBar64Private::activateControl(uint control, int threshold)
+{
+    QAbstractSlider64::SliderAction action = QAbstractSlider64::SliderNoAction;
+    switch (control) {
+    case QStyle::SC_ScrollBarAddPage:
+        action = QAbstractSlider64::SliderPageStepAdd;
+        break;
+    case QStyle::SC_ScrollBarSubPage:
+        action = QAbstractSlider64::SliderPageStepSub;
+        break;
+    case QStyle::SC_ScrollBarAddLine:
+        action = QAbstractSlider64::SliderSingleStepAdd;
+        break;
+    case QStyle::SC_ScrollBarSubLine:
+        action = QAbstractSlider64::SliderSingleStepSub;
+        break;
+    case QStyle::SC_ScrollBarFirst:
+        action = QAbstractSlider64::SliderToMinimum;
+        break;
+    case QStyle::SC_ScrollBarLast:
+        action = QAbstractSlider64::SliderToMaximum;
+        break;
+    default:
+        break;
+    }
+
+    if (action) {
+        q_func()->setRepeatAction(action, threshold);
+        q_func()->triggerAction(action);
+    }
+}
+
+void QScrollBar64Private::stopRepeatAction()
+{
+    Q_Q(QScrollBar64);
+    QStyle::SubControl tmp = pressedControl;
+    q->setRepeatAction(QAbstractSlider64::SliderNoAction);
+    pressedControl = QStyle::SC_None;
+
+    if (tmp == QStyle::SC_ScrollBarSlider)
+        q->setSliderDown(false);
+
+    QStyleOptionSlider64 opt;
+    q->initStyleOption(&opt);
+    q->repaint(q->style()->subControlRect(QStyle::CC_ScrollBar64, &opt, tmp, q));
+}
+
+/*!
+    Initialize \a option with the values from this QScrollBar64. This method
+    is useful for subclasses when they need a QStyleOptionSlider64, but don't want
+    to fill in all the information themselves.
+
+    \sa QStyleOption::initFrom()
+*/
+void QScrollBar64::initStyleOption(QStyleOptionSlider64 *option) const
+{
+    if (!option)
+        return;
+
+    Q_D(const QScrollBar64);
+    option->initFrom(this);
+    option->subControls = QStyle::SC_None;
+    option->activeSubControls = QStyle::SC_None;
+    option->orientation = d->orientation;
+    option->minimum = d->minimum;
+    option->maximum = d->maximum;
+    option->sliderPosition = d->position;
+    option->sliderValue = d->value;
+    option->singleStep = d->singleStep;
+    option->pageStep = d->pageStep;
+    option->upsideDown = d->invertedAppearance;
+    if (d->orientation == Qt::Horizontal)
+        option->state |= QStyle::State_Horizontal;
+}
+
+
+#define HORIZONTAL (d_func()->orientation == Qt::Horizontal)
+#define VERTICAL !HORIZONTAL
+
+/*!
+    Constructs a vertical scroll bar.
+
+    The \a parent argument is sent to the QWidget constructor.
+
+    The \l {QAbstractSlider64::minimum} {minimum} defaults to 0, the
+    \l {QAbstractSlider64::maximum} {maximum} to 99, with a
+    \l {QAbstractSlider64::singleStep} {singleStep} size of 1 and a
+    \l {QAbstractSlider64::pageStep} {pageStep} size of 10, and an
+    initial \l {QAbstractSlider64::value} {value} of 0.
+*/
+QScrollBar64::QScrollBar64(QWidget *parent)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    d_func()->orientation = Qt::Vertical;
+    d_func()->init();
+}
+
+/*!
+    Constructs a scroll bar with the given \a orientation.
+
+    The \a parent argument is passed to the QWidget constructor.
+
+    The \l {QAbstractSlider64::minimum} {minimum} defaults to 0, the
+    \l {QAbstractSlider64::maximum} {maximum} to 99, with a
+    \l {QAbstractSlider64::singleStep} {singleStep} size of 1 and a
+    \l {QAbstractSlider64::pageStep} {pageStep} size of 10, and an
+    initial \l {QAbstractSlider64::value} {value} of 0.
+*/
+QScrollBar64::QScrollBar64(Qt::Orientation orientation, QWidget *parent)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    d_func()->orientation = orientation;
+    d_func()->init();
+}
+
+
+#ifdef QT3_SUPPORT
+/*!
+    Use one of the constructors that doesn't take the \a name
+    argument and then use setObjectName() instead.
+*/
+QScrollBar64::QScrollBar64(QWidget *parent, const char *name)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    setObjectName(QString::fromAscii(name));
+    d_func()->orientation = Qt::Vertical;
+    d_func()->init();
+}
+
+/*!
+    Use one of the constructors that doesn't take the \a name
+    argument and then use setObjectName() instead.
+*/
+QScrollBar64::QScrollBar64(Qt::Orientation orientation, QWidget *parent, const char *name)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    setObjectName(QString::fromAscii(name));
+    d_func()->orientation = orientation;
+    d_func()->init();
+}
+
+/*!
+    Use one of the constructors that doesn't take the \a name
+    argument and then use setObjectName() instead.
+*/
+QScrollBar64::QScrollBar64(qint64 minimum, qint64 maximum, qint64 lineStep, qint64 pageStep,
+                        qint64 value, Qt::Orientation orientation,
+                        QWidget *parent, const char *name)
+    : QAbstractSlider64(*new QScrollBar64Private, parent)
+{
+    Q_D(QScrollBar64);
+    setObjectName(QString::fromAscii(name));
+    d->minimum = minimum;
+    d->maximum = maximum;
+    d->singleStep = lineStep;
+    d->pageStep = pageStep;
+    d->value = value;
+    d->orientation = orientation;
+    d->init();
+}
+#endif // QT3_SUPPORT
+
+/*!
+    Destroys the scroll bar.
+*/
+QScrollBar64::~QScrollBar64()
+{
+}
+
+void QScrollBar64Private::init()
+{
+    Q_Q(QScrollBar64);
+    invertedControls = true;
+    pressedControl = hoverControl = QStyle::SC_None;
+    pointerOutsidePressedControl = false;
+    q->setFocusPolicy(Qt::NoFocus);
+    QSizePolicy sp(QSizePolicy::Minimum, QSizePolicy::Fixed, QSizePolicy::Slider);
+    if (orientation == Qt::Vertical)
+        sp.transpose();
+    q->setSizePolicy(sp);
+    q->setAttribute(Qt::WA_WState_OwnSizePolicy, false);
+    q->setAttribute(Qt::WA_OpaquePaintEvent);
+
+#if !defined(QT_NO_CONTEXTMENU) && defined(Q_WS_WINCE)
+    if (!q->style()->styleHint(QStyle::SH_ScrollBar_ContextMenu, 0, q)) {
+        q->setContextMenuPolicy(Qt::PreventContextMenu);
+    }
+#endif
+}
+
+#ifndef QT_NO_CONTEXTMENU
+/*! \reimp */
+void QScrollBar64::contextMenuEvent(QContextMenuEvent *event)
+{
+    if (!style()->styleHint(QStyle::SH_ScrollBar_ContextMenu, 0, this)) {
+        QAbstractSlider64::contextMenuEvent(event);
+        return ;
+    }
+
+#ifndef QT_NO_MENU
+    bool horiz = HORIZONTAL;
+    QPointer<QMenu> menu = new QMenu(this);
+    QAction *actScrollHere = menu->addAction(tr("Scroll here"));
+    menu->addSeparator();
+    QAction *actScrollTop =  menu->addAction(horiz ? tr("Left edge") : tr("Top"));
+    QAction *actScrollBottom = menu->addAction(horiz ? tr("Right edge") : tr("Bottom"));
+    menu->addSeparator();
+    QAction *actPageUp = menu->addAction(horiz ? tr("Page left") : tr("Page up"));
+    QAction *actPageDn = menu->addAction(horiz ? tr("Page right") : tr("Page down"));
+    menu->addSeparator();
+    QAction *actScrollUp = menu->addAction(horiz ? tr("Scroll left") : tr("Scroll up"));
+    QAction *actScrollDn = menu->addAction(horiz ? tr("Scroll right") : tr("Scroll down"));
+    QAction *actionSelected = menu->exec(event->globalPos());
+    delete menu;
+    if (actionSelected == 0)
+        /* do nothing */ ;
+    else if (actionSelected == actScrollHere)
+        setValue(d_func()->pixelPosToRangeValue(horiz ? event->pos().x() : event->pos().y()));
+    else if (actionSelected == actScrollTop)
+        triggerAction(QAbstractSlider64::SliderToMinimum);
+    else if (actionSelected == actScrollBottom)
+        triggerAction(QAbstractSlider64::SliderToMaximum);
+    else if (actionSelected == actPageUp)
+        triggerAction(QAbstractSlider64::SliderPageStepSub);
+    else if (actionSelected == actPageDn)
+        triggerAction(QAbstractSlider64::SliderPageStepAdd);
+    else if (actionSelected == actScrollUp)
+        triggerAction(QAbstractSlider64::SliderSingleStepSub);
+    else if (actionSelected == actScrollDn)
+        triggerAction(QAbstractSlider64::SliderSingleStepAdd);
+#endif // QT_NO_MENU
+}
+#endif // QT_NO_CONTEXTMENU
+
+
+/*! \reimp */
+QSize QScrollBar64::sizeHint() const
+{
+    ensurePolished();
+    QStyleOptionSlider64 opt;
+    initStyleOption(&opt);
+
+    int scrollBarExtent = style()->pixelMetric(QStyle::PM_ScrollBarExtent, &opt, this);
+    int scrollBarSliderMin = style()->pixelMetric(QStyle::PM_ScrollBarSliderMin, &opt, this);
+    QSize size;
+    if (opt.orientation == Qt::Horizontal)
+        size = QSize(scrollBarExtent * 2 + scrollBarSliderMin, scrollBarExtent);
+    else
+        size = QSize(scrollBarExtent, scrollBarExtent * 2 + scrollBarSliderMin);
+
+    return style()->sizeFromContents(QStyle::CT_ScrollBar, &opt, size, this)
+        .expandedTo(QApplication::globalStrut());
+ }
+
+/*!\reimp */
+void QScrollBar64::sliderChange(SliderChange change)
+{
+    QAbstractSlider64::sliderChange(change);
+}
+
+/*!
+    \reimp
+*/
+bool QScrollBar64::event(QEvent *event)
+{
+    switch(event->type()) {
+    case QEvent::HoverEnter:
+    case QEvent::HoverLeave:
+    case QEvent::HoverMove:
+    if (const QHoverEvent *he = static_cast<const QHoverEvent *>(event))
+        d_func()->updateHoverControl(he->pos());
+        break;
+#ifndef QT_NO_WHEELEVENT
+    case QEvent::Wheel: {
+        event->ignore();
+        // override wheel event without adding virtual function override
+        QWheelEvent *ev = static_cast<QWheelEvent *>(event);
+        int delta = ev->delta();
+        // scrollbar is a special case - in vertical mode it reaches minimum
+        // value in the upper position, however QSlider's minimum value is on
+        // the bottom. So we need to invert a value, but since the scrollbar is
+        // inverted by default, we need to inverse the delta value for the
+        // horizontal orientation.
+        if (ev->orientation() == Qt::Horizontal)
+            delta = -delta;
+        Q_D(QScrollBar64);
+        if (d->scrollByDelta(ev->orientation(), ev->modifiers(), delta))
+            event->accept();
+        return true;
+    }
+#endif
+    default:
+        break;
+    }
+    return QAbstractSlider64::event(event);
+}
+
+/*!
+    \reimp
+*/
+void QScrollBar64::paintEvent(QPaintEvent *)
+{
+    Q_D(QScrollBar64);
+    QPainter p(this);
+    QStyleOptionSlider64 opt;
+    initStyleOption(&opt);
+    opt.subControls = QStyle::SC_All;
+    if (d->pressedControl) {
+        opt.activeSubControls = (QStyle::SubControl)d->pressedControl;
+        if (!d->pointerOutsidePressedControl)
+            opt.state |= QStyle::State_Sunken;
+    } else {
+        opt.activeSubControls = (QStyle::SubControl)d->hoverControl;
+    }
+    style()->drawComplexControl(QStyle::CC_ScrollBar64, &opt, &p, this);
+}
+
+/*!
+    \reimp
+*/
+void QScrollBar64::mousePressEvent(QMouseEvent *e)
+{
+    Q_D(QScrollBar64);
+
+    if (d->repeatActionTimer.isActive())
+        d->stopRepeatAction();
+
+    bool midButtonAbsPos = style()->styleHint(QStyle::SH_ScrollBar_MiddleClickAbsolutePosition,
+                                             0, this);
+    QStyleOptionSlider64 opt;
+    initStyleOption(&opt);
+
+    if (d->maximum == d->minimum // no range
+        || (e->buttons() & (~e->button())) // another button was clicked before
+        || !(e->button() == Qt::LeftButton || (midButtonAbsPos && e->button() == Qt::MidButton)))
+        return;
+
+    d->pressedControl = style()->hitTestComplexControl(QStyle::CC_ScrollBar64, &opt, e->pos(), this);
+    d->pointerOutsidePressedControl = false;
+
+    QRect sr = style()->subControlRect(QStyle::CC_ScrollBar64, &opt,
+                                       QStyle::SC_ScrollBarSlider, this);
+    QPoint click = e->pos();
+    QPoint pressValue = click - sr.center() + sr.topLeft();
+    d->pressValue = d->orientation == Qt::Horizontal ? d->pixelPosToRangeValue(pressValue.x()) :
+        d->pixelPosToRangeValue(pressValue.y());
+    if (d->pressedControl == QStyle::SC_ScrollBarSlider) {
+        d->clickOffset = HORIZONTAL ? (click.x()-sr.x()) : (click.y()-sr.y());
+        d->snapBackPosition = d->position;
+    }
+
+    if ((d->pressedControl == QStyle::SC_ScrollBarAddPage
+          || d->pressedControl == QStyle::SC_ScrollBarSubPage)
+        && ((midButtonAbsPos && e->button() == Qt::MidButton)
+            || (style()->styleHint(QStyle::SH_ScrollBar_LeftClickAbsolutePosition, &opt, this)
+                && e->button() == Qt::LeftButton))) {
+        qint64 sliderLength = HORIZONTAL ? sr.width() : sr.height();
+        setSliderPosition(d->pixelPosToRangeValue((HORIZONTAL ? e->pos().x()
+                                                              : e->pos().y()) - sliderLength / 2));
+        d->pressedControl = QStyle::SC_ScrollBarSlider;
+        d->clickOffset = sliderLength / 2;
+    }
+    const int initialDelay = 500; // default threshold
+    d->activateControl(d->pressedControl, initialDelay);
+    QElapsedTimer time;
+    time.start();
+    repaint(style()->subControlRect(QStyle::CC_ScrollBar64, &opt, d->pressedControl, this));
+    if (time.elapsed() >= initialDelay && d->repeatActionTimer.isActive()) {
+        // It took more than 500ms (the initial timer delay) to process the repaint(), we
+        // therefore need to restart the timer in case we have a pending mouse release event;
+        // otherwise we'll get a timer event right before the release event,
+        // causing the repeat action to be invoked twice on a single mouse click.
+        // 50ms is the default repeat time (see activateControl/setRepeatAction).
+        d->repeatActionTimer.start(50, this);
+    }
+    if (d->pressedControl == QStyle::SC_ScrollBarSlider)
+        setSliderDown(true);
+}
+
+
+/*!
+    \reimp
+*/
+void QScrollBar64::mouseReleaseEvent(QMouseEvent *e)
+{
+    Q_D(QScrollBar64);
+    if (!d->pressedControl)
+        return;
+
+    if (e->buttons() & (~e->button())) // some other button is still pressed
+        return;
+
+    d->stopRepeatAction();
+}
+
+
+/*!
+    \reimp
+*/
+void QScrollBar64::mouseMoveEvent(QMouseEvent *e)
+{
+    Q_D(QScrollBar64);
+    if (!d->pressedControl)
+        return;
+
+    QStyleOptionSlider64 opt;
+    initStyleOption(&opt);
+    if (!(e->buttons() & Qt::LeftButton
+          ||  ((e->buttons() & Qt::MidButton)
+               && style()->styleHint(QStyle::SH_ScrollBar_MiddleClickAbsolutePosition, &opt, this))))
+        return;
+
+    if (d->pressedControl == QStyle::SC_ScrollBarSlider) {
+        QPoint click = e->pos();
+        qint64 newPosition = d->pixelPosToRangeValue((HORIZONTAL ? click.x() : click.y()) -d->clickOffset);
+        int m = style()->pixelMetric(QStyle::PM_MaximumDragDistance, &opt, this);
+        if (m >= 0) {
+            QRect r = rect();
+            r.adjust(-m, -m, m, m);
+            if (! r.contains(e->pos()))
+                newPosition = d->snapBackPosition;
+        }
+        setSliderPosition(newPosition);
+    } else if (!style()->styleHint(QStyle::SH_ScrollBar_ScrollWhenPointerLeavesControl, &opt, this)) {
+
+        if (style()->styleHint(QStyle::SH_ScrollBar_RollBetweenButtons, &opt, this)
+                && d->pressedControl & (QStyle::SC_ScrollBarAddLine | QStyle::SC_ScrollBarSubLine)) {
+            QStyle::SubControl newSc = style()->hitTestComplexControl(QStyle::CC_ScrollBar64, &opt, e->pos(), this);
+            if (newSc == d->pressedControl && !d->pointerOutsidePressedControl)
+                return; // nothing to do
+            if (newSc & (QStyle::SC_ScrollBarAddLine | QStyle::SC_ScrollBarSubLine)) {
+                d->pointerOutsidePressedControl = false;
+                QRect scRect = style()->subControlRect(QStyle::CC_ScrollBar64, &opt, newSc, this);
+                scRect |= style()->subControlRect(QStyle::CC_ScrollBar64, &opt, d->pressedControl, this);
+                d->pressedControl = newSc;
+                d->activateControl(d->pressedControl, 0);
+                update(scRect);
+                return;
+            }
+        }
+
+        // stop scrolling when the mouse pointer leaves a control
+        // similar to push buttons
+        QRect pr = style()->subControlRect(QStyle::CC_ScrollBar64, &opt, d->pressedControl, this);
+        if (pr.contains(e->pos()) == d->pointerOutsidePressedControl) {
+            if ((d->pointerOutsidePressedControl = !d->pointerOutsidePressedControl)) {
+                d->pointerOutsidePressedControl = true;
+                setRepeatAction(SliderNoAction);
+                repaint(pr);
+            } else  {
+                d->activateControl(d->pressedControl);
+            }
+        }
+    }
+}
+
+
+qint64 QScrollBar64Private::pixelPosToRangeValue(int pos) const
+{
+    Q_Q(const QScrollBar64);
+    QStyleOptionSlider64 opt;
+    q->initStyleOption(&opt);
+    QRect gr = q->style()->subControlRect(QStyle::CC_ScrollBar64, &opt,
+                                          QStyle::SC_ScrollBarGroove, q);
+    QRect sr = q->style()->subControlRect(QStyle::CC_ScrollBar64, &opt,
+                                          QStyle::SC_ScrollBarSlider, q);
+    qint64 sliderMin, sliderMax, sliderLength;
+
+    if (orientation == Qt::Horizontal) {
+        sliderLength = sr.width();
+        sliderMin = gr.x();
+        sliderMax = gr.right() - sliderLength + 1;
+        if (q->layoutDirection() == Qt::RightToLeft)
+            opt.upsideDown = !opt.upsideDown;
+    } else {
+        sliderLength = sr.height();
+        sliderMin = gr.y();
+        sliderMax = gr.bottom() - sliderLength + 1;
+    }
+
+    return  QStyle::sliderValueFromPosition(minimum, maximum, pos - sliderMin,
+                                            sliderMax - sliderMin, opt.upsideDown);
+}
+
+/*! \reimp
+*/
+void QScrollBar64::hideEvent(QHideEvent *)
+{
+    Q_D(QScrollBar64);
+    if (d->pressedControl) {
+        d->pressedControl = QStyle::SC_None;
+        setRepeatAction(SliderNoAction);
+    }
+}
+
+/*!
+    \fn bool QScrollBar64::draggingSlider()
+
+    Use isSliderDown() instead.
+*/
+
+/*! \internal
+    Returns the style option for scroll bar.
+*/
+Q_GUI_EXPORT QStyleOptionSlider64 qt_qscrollbarStyleOption(QScrollBar64 *scrollbar)
+{
+    QStyleOptionSlider64 opt;
+    scrollbar->initStyleOption(&opt);
+    return opt;
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_SCROLLBAR
diff --git a/src/widgets/widgets/qscrollbar64.h b/src/widgets/widgets/qscrollbar64.h
new file mode 100644
index 0000000..7ce971f
--- /dev/null
+++ b/src/widgets/widgets/qscrollbar64.h
@@ -0,0 +1,63 @@
+#ifndef QSCROLLBAR64_H
+#define QSCROLLBAR64_H
+
+#include <QtWidgets/qwidget.h>
+#include <QtWidgets/qabstractslider64.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Gui)
+
+#ifndef QT_NO_SCROLLBAR
+
+class QScrollBar64Private;
+class QStyleOptionSlider64;
+
+class Q_GUI_EXPORT QScrollBar64 : public QAbstractSlider64
+{
+    Q_OBJECT
+public:
+    explicit QScrollBar64(QWidget *parent=0);
+    explicit QScrollBar64(Qt::Orientation, QWidget *parent=0);
+    ~QScrollBar64();
+
+    QSize sizeHint() const;
+    bool event(QEvent *event);
+
+protected:
+    void paintEvent(QPaintEvent *);
+    void mousePressEvent(QMouseEvent *);
+    void mouseReleaseEvent(QMouseEvent *);
+    void mouseMoveEvent(QMouseEvent *);
+    void hideEvent(QHideEvent*);
+    void sliderChange(SliderChange change);
+#ifndef QT_NO_CONTEXTMENU
+    void contextMenuEvent(QContextMenuEvent *);
+#endif
+    void initStyleOption(QStyleOptionSlider64 *option) const;
+
+#ifdef QT3_SUPPORT
+public:
+    QT3_SUPPORT_CONSTRUCTOR QScrollBar64(QWidget *parent, const char* name);
+    QT3_SUPPORT_CONSTRUCTOR QScrollBar64(Qt::Orientation, QWidget *parent, const char* name);
+    QT3_SUPPORT_CONSTRUCTOR QScrollBar64(qint64 minValue, qint64 maxValue, qint64 lineStep, qint64 pageStep,
+                qint64 value, Qt::Orientation, QWidget *parent=0, const char* name = 0);
+    inline QT3_SUPPORT bool draggingSlider() { return isSliderDown(); }
+#endif
+
+private:
+    friend Q_GUI_EXPORT QStyleOptionSlider64 qt_qscrollbarStyleOption(QScrollBar64 *scrollBar);
+
+    Q_DISABLE_COPY(QScrollBar64)
+    Q_DECLARE_PRIVATE(QScrollBar64)
+};
+
+#endif // QT_NO_SCROLLBAR
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QSCROLLBAR64_H
diff --git a/src/widgets/widgets/widgets.pri b/src/widgets/widgets/widgets.pri
index a924ba9..22e361d 100644
--- a/src/widgets/widgets/widgets.pri
+++ b/src/widgets/widgets/widgets.pri
@@ -6,6 +6,8 @@ HEADERS += \
         widgets/qabstractbutton_p.h \
         widgets/qabstractslider.h \
         widgets/qabstractslider_p.h \
+        widgets/qabstractslider64.h \
+        widgets/qabstractslider64_p.h \
         widgets/qabstractspinbox.h \
         widgets/qabstractspinbox_p.h \
         widgets/qcalendartextnavigator_p.h \
@@ -48,6 +50,7 @@ HEADERS += \
         widgets/qradiobutton.h \
         widgets/qrubberband.h \
         widgets/qscrollbar.h \
+        widgets/qscrollbar64.h \
         widgets/qscrollbar_p.h \
         widgets/qscrollarea_p.h \
         widgets/qsizegrip.h \
@@ -87,6 +90,7 @@ HEADERS += \
 SOURCES += \
         widgets/qabstractbutton.cpp \
         widgets/qabstractslider.cpp \
+        widgets/qabstractslider64.cpp \
         widgets/qabstractspinbox.cpp \
         widgets/qcalendarwidget.cpp \
         widgets/qcheckbox.cpp \
@@ -117,6 +121,7 @@ SOURCES += \
         widgets/qradiobutton.cpp \
         widgets/qrubberband.cpp \
         widgets/qscrollbar.cpp \
+        widgets/qscrollbar64.cpp \
         widgets/qsizegrip.cpp \
         widgets/qslider.cpp \
         widgets/qspinbox.cpp \
-- 
2.5.1

