From 2ee407379baee750df1f0f65225a28f0ddfbe5e6 Mon Sep 17 00:00:00 2001
From: Remi Herilier <remi.herilier@picviz.com>
Date: Fri, 11 Sep 2015 17:30:47 +0200
Subject: [PATCH 6/6] Ratify things in Debian build system

---
 .pc/applied-patches                                |    1 +
 .pc/inendi.patch/include/QtWidgets/QtWidgets       |  130 +
 .pc/inendi.patch/include/QtWidgets/headers.pri     |    5 +
 .pc/inendi.patch/src/corelib/tools/qrect.cpp       | 2503 ++++++++
 .../src/widgets/graphicsview/qgraphicsscene.cpp    | 6475 ++++++++++++++++++++
 .../src/widgets/graphicsview/qgraphicsscene.h      |  326 +
 .../src/widgets/graphicsview/qgraphicsscene_p.h    |  360 ++
 .../src/widgets/styles/qcommonstyle.cpp            | 6151 +++++++++++++++++++
 .../src/widgets/styles/qfusionstyle.cpp            | 3699 +++++++++++
 .pc/inendi.patch/src/widgets/styles/qgtkstyle.cpp  | 4253 +++++++++++++
 .pc/inendi.patch/src/widgets/styles/qstyle.cpp     | 2397 ++++++++
 .pc/inendi.patch/src/widgets/styles/qstyle.h       |  839 +++
 .../src/widgets/styles/qstyleoption.cpp            | 4094 +++++++++++++
 .pc/inendi.patch/src/widgets/styles/qstyleoption.h |  752 +++
 .../src/widgets/widgets/qabstractslider64.cpp      |    0
 .../src/widgets/widgets/qabstractslider64.h        |    0
 .../src/widgets/widgets/qabstractslider64_p.h      |    0
 .../src/widgets/widgets/qscrollbar64.cpp           |    0
 .../src/widgets/widgets/qscrollbar64.h             |    0
 .pc/inendi.patch/src/widgets/widgets/widgets.pri   |  172 +
 debian/patches/inendi.patch                        | 6181 +++++++++++++++++++
 debian/patches/series                              |    1 +
 22 files changed, 38339 insertions(+)
 create mode 100644 .pc/inendi.patch/include/QtWidgets/QtWidgets
 create mode 100644 .pc/inendi.patch/include/QtWidgets/headers.pri
 create mode 100644 .pc/inendi.patch/src/corelib/tools/qrect.cpp
 create mode 100644 .pc/inendi.patch/src/widgets/graphicsview/qgraphicsscene.cpp
 create mode 100644 .pc/inendi.patch/src/widgets/graphicsview/qgraphicsscene.h
 create mode 100644 .pc/inendi.patch/src/widgets/graphicsview/qgraphicsscene_p.h
 create mode 100644 .pc/inendi.patch/src/widgets/styles/qcommonstyle.cpp
 create mode 100644 .pc/inendi.patch/src/widgets/styles/qfusionstyle.cpp
 create mode 100644 .pc/inendi.patch/src/widgets/styles/qgtkstyle.cpp
 create mode 100644 .pc/inendi.patch/src/widgets/styles/qstyle.cpp
 create mode 100644 .pc/inendi.patch/src/widgets/styles/qstyle.h
 create mode 100644 .pc/inendi.patch/src/widgets/styles/qstyleoption.cpp
 create mode 100644 .pc/inendi.patch/src/widgets/styles/qstyleoption.h
 create mode 100644 .pc/inendi.patch/src/widgets/widgets/qabstractslider64.cpp
 create mode 100644 .pc/inendi.patch/src/widgets/widgets/qabstractslider64.h
 create mode 100644 .pc/inendi.patch/src/widgets/widgets/qabstractslider64_p.h
 create mode 100644 .pc/inendi.patch/src/widgets/widgets/qscrollbar64.cpp
 create mode 100644 .pc/inendi.patch/src/widgets/widgets/qscrollbar64.h
 create mode 100644 .pc/inendi.patch/src/widgets/widgets/widgets.pri
 create mode 100644 debian/patches/inendi.patch

diff --git a/.pc/applied-patches b/.pc/applied-patches
index ed46f7c..e8d075b 100644
--- a/.pc/applied-patches
+++ b/.pc/applied-patches
@@ -7,3 +7,4 @@ fix_imagehandlers_cves.diff
 fix_sparc_atomics.patch
 remove_google_adsense.patch
 revert_upstream_bsymbolic_change.patch
+inendi.patch
diff --git a/.pc/inendi.patch/include/QtWidgets/QtWidgets b/.pc/inendi.patch/include/QtWidgets/QtWidgets
new file mode 100644
index 0000000..f0f7de2
--- /dev/null
+++ b/.pc/inendi.patch/include/QtWidgets/QtWidgets
@@ -0,0 +1,130 @@
+#ifndef QT_QTWIDGETS_MODULE_H
+#define QT_QTWIDGETS_MODULE_H
+#include <QtWidgets/QtWidgetsDepends>
+#include "qaccessiblewidget.h"
+#include "qcolordialog.h"
+#include "qdialog.h"
+#include "qerrormessage.h"
+#include "qfiledialog.h"
+#include "qfilesystemmodel.h"
+#include "qfontdialog.h"
+#include "qinputdialog.h"
+#include "qmessagebox.h"
+#include "qprogressdialog.h"
+#include "qwizard.h"
+#include "qgraphicseffect.h"
+#include "qgraphicsanchorlayout.h"
+#include "qgraphicsgridlayout.h"
+#include "qgraphicsitem.h"
+#include "qgraphicsitemanimation.h"
+#include "qgraphicslayout.h"
+#include "qgraphicslayoutitem.h"
+#include "qgraphicslinearlayout.h"
+#include "qgraphicsproxywidget.h"
+#include "qgraphicsscene.h"
+#include "qgraphicssceneevent.h"
+#include "qgraphicstransform.h"
+#include "qgraphicsview.h"
+#include "qgraphicswidget.h"
+#include "qabstractitemdelegate.h"
+#include "qabstractitemview.h"
+#include "qcolumnview.h"
+#include "qdatawidgetmapper.h"
+#include "qdirmodel.h"
+#include "qfileiconprovider.h"
+#include "qheaderview.h"
+#include "qitemdelegate.h"
+#include "qitemeditorfactory.h"
+#include "qlistview.h"
+#include "qlistwidget.h"
+#include "qstyleditemdelegate.h"
+#include "qtableview.h"
+#include "qtablewidget.h"
+#include "qtreeview.h"
+#include "qtreewidget.h"
+#include "qtreewidgetitemiterator.h"
+#include "qaction.h"
+#include "qactiongroup.h"
+#include "qapplication.h"
+#include "qboxlayout.h"
+#include "qdesktopwidget.h"
+#include "qformlayout.h"
+#include "qgesture.h"
+#include "qgesturerecognizer.h"
+#include "qgridlayout.h"
+#include "qlayout.h"
+#include "qlayoutitem.h"
+#include "qshortcut.h"
+#include "qsizepolicy.h"
+#include "qstackedlayout.h"
+#include "qtooltip.h"
+#include "qwhatsthis.h"
+#include "qwidget.h"
+#include "qwidgetaction.h"
+#include "qkeyeventtransition.h"
+#include "qmouseeventtransition.h"
+#include "qcommonstyle.h"
+#include "qdrawutil.h"
+#include "qproxystyle.h"
+#include "qstyle.h"
+#include "qstylefactory.h"
+#include "qstyleoption.h"
+#include "qstylepainter.h"
+#include "qstyleplugin.h"
+#include "qcolormap.h"
+#include "qcompleter.h"
+#include "qscroller.h"
+#include "qscrollerproperties.h"
+#include "qsystemtrayicon.h"
+#include "qundogroup.h"
+#include "qundostack.h"
+#include "qundoview.h"
+#include "qabstractbutton.h"
+#include "qabstractscrollarea.h"
+#include "qabstractslider.h"
+#include "qabstractspinbox.h"
+#include "qbuttongroup.h"
+#include "qcalendarwidget.h"
+#include "qcheckbox.h"
+#include "qcombobox.h"
+#include "qcommandlinkbutton.h"
+#include "qdatetimeedit.h"
+#include "qdial.h"
+#include "qdialogbuttonbox.h"
+#include "qdockwidget.h"
+#include "qfocusframe.h"
+#include "qfontcombobox.h"
+#include "qframe.h"
+#include "qgroupbox.h"
+#include "qkeysequenceedit.h"
+#include "qlabel.h"
+#include "qlcdnumber.h"
+#include "qlineedit.h"
+#include "qmainwindow.h"
+#include "qmdiarea.h"
+#include "qmdisubwindow.h"
+#include "qmenu.h"
+#include "qmenubar.h"
+#include "qplaintextedit.h"
+#include "qprogressbar.h"
+#include "qpushbutton.h"
+#include "qradiobutton.h"
+#include "qrubberband.h"
+#include "qscrollarea.h"
+#include "qscrollbar.h"
+#include "qsizegrip.h"
+#include "qslider.h"
+#include "qspinbox.h"
+#include "qsplashscreen.h"
+#include "qsplitter.h"
+#include "qstackedwidget.h"
+#include "qstatusbar.h"
+#include "qtabbar.h"
+#include "qtabwidget.h"
+#include "qtextbrowser.h"
+#include "qtextedit.h"
+#include "qtoolbar.h"
+#include "qtoolbox.h"
+#include "qtoolbutton.h"
+#include "qtwidgetsversion.h"
+#endif
diff --git a/.pc/inendi.patch/include/QtWidgets/headers.pri b/.pc/inendi.patch/include/QtWidgets/headers.pri
new file mode 100644
index 0000000..5daee6e
--- /dev/null
+++ b/.pc/inendi.patch/include/QtWidgets/headers.pri
@@ -0,0 +1,5 @@
+SYNCQT.HEADER_FILES = accessible/qaccessiblewidget.h dialogs/qcolordialog.h dialogs/qdialog.h dialogs/qerrormessage.h dialogs/qfiledialog.h dialogs/qfilesystemmodel.h dialogs/qfontdialog.h dialogs/qinputdialog.h dialogs/qmessagebox.h dialogs/qprogressdialog.h dialogs/qwizard.h effects/qgraphicseffect.h graphicsview/qgraphicsanchorlayout.h graphicsview/qgraphicsgridlayout.h graphicsview/qgraphicsitem.h graphicsview/qgraphicsitemanimation.h graphicsview/qgraphicslayout.h graphicsview/qgraphicslayoutitem.h graphicsview/qgraphicslinearlayout.h graphicsview/qgraphicsproxywidget.h graphicsview/qgraphicsscene.h graphicsview/qgraphicssceneevent.h graphicsview/qgraphicstransform.h graphicsview/qgraphicsview.h graphicsview/qgraphicswidget.h itemviews/qabstractitemdelegate.h itemviews/qabstractitemview.h itemviews/qcolumnview.h itemviews/qdatawidgetmapper.h itemviews/qdirmodel.h itemviews/qfileiconprovider.h itemviews/qheaderview.h itemviews/qitemdelegate.h itemviews/qitemeditorfactory.h itemviews/qlistview.h itemviews/qlistwidget.h itemviews/qstyleditemdelegate.h itemviews/qtableview.h itemviews/qtablewidget.h itemviews/qtreeview.h itemviews/qtreewidget.h itemviews/qtreewidgetitemiterator.h kernel/qaction.h kernel/qactiongroup.h kernel/qapplication.h kernel/qboxlayout.h kernel/qdesktopwidget.h kernel/qformlayout.h kernel/qgesture.h kernel/qgesturerecognizer.h kernel/qgridlayout.h kernel/qlayout.h kernel/qlayoutitem.h kernel/qshortcut.h kernel/qsizepolicy.h kernel/qstackedlayout.h kernel/qtooltip.h kernel/qwhatsthis.h kernel/qwidget.h kernel/qwidgetaction.h kernel/qwidgetsfunctions_wince.h statemachine/qkeyeventtransition.h statemachine/qmouseeventtransition.h styles/qcommonstyle.h styles/qdrawutil.h styles/qproxystyle.h styles/qstyle.h styles/qstylefactory.h styles/qstyleoption.h styles/qstylepainter.h styles/qstyleplugin.h util/qcolormap.h util/qcompleter.h util/qscroller.h util/qscrollerproperties.h util/qsystemtrayicon.h util/qundogroup.h util/qundostack.h util/qundoview.h widgets/qabstractbutton.h widgets/qabstractscrollarea.h widgets/qabstractslider.h widgets/qabstractspinbox.h widgets/qbuttongroup.h widgets/qcalendarwidget.h widgets/qcheckbox.h widgets/qcombobox.h widgets/qcommandlinkbutton.h widgets/qdatetimeedit.h widgets/qdial.h widgets/qdialogbuttonbox.h widgets/qdockwidget.h widgets/qfocusframe.h widgets/qfontcombobox.h widgets/qframe.h widgets/qgroupbox.h widgets/qkeysequenceedit.h widgets/qlabel.h widgets/qlcdnumber.h widgets/qlineedit.h widgets/qmaccocoaviewcontainer_mac.h widgets/qmacnativewidget_mac.h widgets/qmainwindow.h widgets/qmdiarea.h widgets/qmdisubwindow.h widgets/qmenu.h widgets/qmenubar.h widgets/qplaintextedit.h widgets/qprogressbar.h widgets/qpushbutton.h widgets/qradiobutton.h widgets/qrubberband.h widgets/qscrollarea.h widgets/qscrollbar.h widgets/qsizegrip.h widgets/qslider.h widgets/qspinbox.h widgets/qsplashscreen.h widgets/qsplitter.h widgets/qstackedwidget.h widgets/qstatusbar.h widgets/qtabbar.h widgets/qtabwidget.h widgets/qtextbrowser.h widgets/qtextedit.h widgets/qtoolbar.h widgets/qtoolbox.h widgets/qtoolbutton.h ../../include/QtWidgets/qtwidgetsversion.h ../../include/QtWidgets/QtWidgets 
+SYNCQT.HEADER_CLASSES = ../../include/QtWidgets/QAccessibleWidget ../../include/QtWidgets/QColorDialog ../../include/QtWidgets/QDialog ../../include/QtWidgets/QErrorMessage ../../include/QtWidgets/QFileDialog ../../include/QtWidgets/QFileSystemModel ../../include/QtWidgets/QFontDialog ../../include/QtWidgets/QInputDialog ../../include/QtWidgets/QMessageBox ../../include/QtWidgets/QProgressDialog ../../include/QtWidgets/QWizard ../../include/QtWidgets/QWizardPage ../../include/QtWidgets/QGraphicsEffect ../../include/QtWidgets/QGraphicsColorizeEffect ../../include/QtWidgets/QGraphicsBlurEffect ../../include/QtWidgets/QGraphicsDropShadowEffect ../../include/QtWidgets/QGraphicsOpacityEffect ../../include/QtWidgets/QGraphicsAnchor ../../include/QtWidgets/QGraphicsAnchorLayout ../../include/QtWidgets/QGraphicsGridLayout ../../include/QtWidgets/QGraphicsItem ../../include/QtWidgets/QGraphicsObject ../../include/QtWidgets/QAbstractGraphicsShapeItem ../../include/QtWidgets/QGraphicsPathItem ../../include/QtWidgets/QGraphicsRectItem ../../include/QtWidgets/QGraphicsEllipseItem ../../include/QtWidgets/QGraphicsPolygonItem ../../include/QtWidgets/QGraphicsLineItem ../../include/QtWidgets/QGraphicsPixmapItem ../../include/QtWidgets/QGraphicsTextItem ../../include/QtWidgets/QGraphicsSimpleTextItem ../../include/QtWidgets/QGraphicsItemGroup ../../include/QtWidgets/QGraphicsItemAnimation ../../include/QtWidgets/QGraphicsLayout ../../include/QtWidgets/QGraphicsLayoutItem ../../include/QtWidgets/QGraphicsLinearLayout ../../include/QtWidgets/QGraphicsProxyWidget ../../include/QtWidgets/QGraphicsScene ../../include/QtWidgets/QGraphicsSceneEvent ../../include/QtWidgets/QGraphicsSceneMouseEvent ../../include/QtWidgets/QGraphicsSceneWheelEvent ../../include/QtWidgets/QGraphicsSceneContextMenuEvent ../../include/QtWidgets/QGraphicsSceneHoverEvent ../../include/QtWidgets/QGraphicsSceneHelpEvent ../../include/QtWidgets/QGraphicsSceneDragDropEvent ../../include/QtWidgets/QGraphicsSceneResizeEvent ../../include/QtWidgets/QGraphicsSceneMoveEvent ../../include/QtWidgets/QGraphicsTransform ../../include/QtWidgets/QGraphicsScale ../../include/QtWidgets/QGraphicsRotation ../../include/QtWidgets/QGraphicsView ../../include/QtWidgets/QGraphicsWidget ../../include/QtWidgets/QAbstractItemDelegate ../../include/QtWidgets/QAbstractItemView ../../include/QtWidgets/QColumnView ../../include/QtWidgets/QDataWidgetMapper ../../include/QtWidgets/QDirModel ../../include/QtWidgets/QFileIconProvider ../../include/QtWidgets/QHeaderView ../../include/QtWidgets/QItemDelegate ../../include/QtWidgets/QItemEditorCreatorBase ../../include/QtWidgets/QItemEditorCreator ../../include/QtWidgets/QStandardItemEditorCreator ../../include/QtWidgets/QItemEditorFactory ../../include/QtWidgets/QListView ../../include/QtWidgets/QListWidgetItem ../../include/QtWidgets/QListWidget ../../include/QtWidgets/QStyledItemDelegate ../../include/QtWidgets/QTableView ../../include/QtWidgets/QTableWidgetSelectionRange ../../include/QtWidgets/QTableWidgetItem ../../include/QtWidgets/QTableWidget ../../include/QtWidgets/QTreeView ../../include/QtWidgets/QTreeWidgetItem ../../include/QtWidgets/QTreeWidget ../../include/QtWidgets/QTreeWidgetItemIterator ../../include/QtWidgets/QAction ../../include/QtWidgets/QActionGroup ../../include/QtWidgets/QApplication ../../include/QtWidgets/QBoxLayout ../../include/QtWidgets/QHBoxLayout ../../include/QtWidgets/QVBoxLayout ../../include/QtWidgets/QDesktopWidget ../../include/QtWidgets/QFormLayout ../../include/QtWidgets/QGesture ../../include/QtWidgets/QPanGesture ../../include/QtWidgets/QPinchGesture ../../include/QtWidgets/QSwipeGesture ../../include/QtWidgets/QTapGesture ../../include/QtWidgets/QTapAndHoldGesture ../../include/QtWidgets/QGestureEvent ../../include/QtWidgets/QGestureRecognizer ../../include/QtWidgets/QGridLayout ../../include/QtWidgets/QLayout ../../include/QtWidgets/QLayoutItem ../../include/QtWidgets/QSpacerItem ../../include/QtWidgets/QWidgetItem ../../include/QtWidgets/QWidgetItemV2 ../../include/QtWidgets/QShortcut ../../include/QtWidgets/QSizePolicy ../../include/QtWidgets/QStackedLayout ../../include/QtWidgets/QToolTip ../../include/QtWidgets/QWhatsThis ../../include/QtWidgets/QWidgetData ../../include/QtWidgets/QWidget ../../include/QtWidgets/QWidgetAction ../../include/QtWidgets/QKeyEventTransition ../../include/QtWidgets/QMouseEventTransition ../../include/QtWidgets/QCommonStyle ../../include/QtWidgets/QTileRules ../../include/QtWidgets/QProxyStyle ../../include/QtWidgets/QStyle ../../include/QtWidgets/QStyleFactory ../../include/QtWidgets/QStyleOption ../../include/QtWidgets/QStyleOptionFocusRect ../../include/QtWidgets/QStyleOptionFrame ../../include/QtWidgets/QStyleOptionFrameV2 ../../include/QtWidgets/QStyleOptionFrameV3 ../../include/QtWidgets/QStyleOptionTabWidgetFrame ../../include/QtWidgets/QStyleOptionTabWidgetFrameV2 ../../include/QtWidgets/QStyleOptionTabBarBase ../../include/QtWidgets/QStyleOptionTabBarBaseV2 ../../include/QtWidgets/QStyleOptionHeader ../../include/QtWidgets/QStyleOptionButton ../../include/QtWidgets/QStyleOptionTab ../../include/QtWidgets/QStyleOptionTabV2 ../../include/QtWidgets/QStyleOptionTabV3 ../../include/QtWidgets/QStyleOptionToolBar ../../include/QtWidgets/QStyleOptionProgressBar ../../include/QtWidgets/QStyleOptionProgressBarV2 ../../include/QtWidgets/QStyleOptionMenuItem ../../include/QtWidgets/QStyleOptionDockWidget ../../include/QtWidgets/QStyleOptionDockWidgetV2 ../../include/QtWidgets/QStyleOptionViewItem ../../include/QtWidgets/QStyleOptionViewItemV2 ../../include/QtWidgets/QStyleOptionViewItemV3 ../../include/QtWidgets/QStyleOptionViewItemV4 ../../include/QtWidgets/QStyleOptionToolBox ../../include/QtWidgets/QStyleOptionToolBoxV2 ../../include/QtWidgets/QStyleOptionRubberBand ../../include/QtWidgets/QStyleOptionComplex ../../include/QtWidgets/QStyleOptionSlider ../../include/QtWidgets/QStyleOptionSpinBox ../../include/QtWidgets/QStyleOptionToolButton ../../include/QtWidgets/QStyleOptionComboBox ../../include/QtWidgets/QStyleOptionTitleBar ../../include/QtWidgets/QStyleOptionGroupBox ../../include/QtWidgets/QStyleOptionSizeGrip ../../include/QtWidgets/QStyleOptionGraphicsItem ../../include/QtWidgets/QStyleHintReturn ../../include/QtWidgets/QStyleHintReturnMask ../../include/QtWidgets/QStyleHintReturnVariant ../../include/QtWidgets/QStylePainter ../../include/QtWidgets/QStylePlugin ../../include/QtWidgets/QColormap ../../include/QtWidgets/QCompleter ../../include/QtWidgets/QScroller ../../include/QtWidgets/QScrollerProperties ../../include/QtWidgets/QSystemTrayIcon ../../include/QtWidgets/QUndoGroup ../../include/QtWidgets/QUndoCommand ../../include/QtWidgets/QUndoStack ../../include/QtWidgets/QUndoView ../../include/QtWidgets/QAbstractButton ../../include/QtWidgets/QAbstractScrollArea ../../include/QtWidgets/QAbstractSlider ../../include/QtWidgets/QAbstractSpinBox ../../include/QtWidgets/QButtonGroup ../../include/QtWidgets/QCalendarWidget ../../include/QtWidgets/QCheckBox ../../include/QtWidgets/QComboBox ../../include/QtWidgets/QCommandLinkButton ../../include/QtWidgets/QDateTimeEdit ../../include/QtWidgets/QTimeEdit ../../include/QtWidgets/QDateEdit ../../include/QtWidgets/QDial ../../include/QtWidgets/QDialogButtonBox ../../include/QtWidgets/QDockWidget ../../include/QtWidgets/QFocusFrame ../../include/QtWidgets/QFontComboBox ../../include/QtWidgets/QFrame ../../include/QtWidgets/QGroupBox ../../include/QtWidgets/QKeySequenceEdit ../../include/QtWidgets/QLabel ../../include/QtWidgets/QLCDNumber ../../include/QtWidgets/QLineEdit ../../include/QtWidgets/QMacCocoaViewContainer ../../include/QtWidgets/QMacNativeWidget ../../include/QtWidgets/QMainWindow ../../include/QtWidgets/QMdiArea ../../include/QtWidgets/QMdiSubWindow ../../include/QtWidgets/QMenu ../../include/QtWidgets/QMenuBar ../../include/QtWidgets/QPlainTextEdit ../../include/QtWidgets/QPlainTextDocumentLayout ../../include/QtWidgets/QProgressBar ../../include/QtWidgets/QPushButton ../../include/QtWidgets/QRadioButton ../../include/QtWidgets/QRubberBand ../../include/QtWidgets/QScrollArea ../../include/QtWidgets/QScrollBar ../../include/QtWidgets/QSizeGrip ../../include/QtWidgets/QSlider ../../include/QtWidgets/QSpinBox ../../include/QtWidgets/QDoubleSpinBox ../../include/QtWidgets/QSplashScreen ../../include/QtWidgets/QSplitter ../../include/QtWidgets/QSplitterHandle ../../include/QtWidgets/QStackedWidget ../../include/QtWidgets/QStatusBar ../../include/QtWidgets/QTabBar ../../include/QtWidgets/QTabWidget ../../include/QtWidgets/QTextBrowser ../../include/QtWidgets/QTextEdit ../../include/QtWidgets/QToolBar ../../include/QtWidgets/QToolBox ../../include/QtWidgets/QToolButton ../../include/QtWidgets/QtWidgetsVersion 
+SYNCQT.PRIVATE_HEADER_FILES = dialogs/qcolordialog_p.h dialogs/qdialog_p.h dialogs/qfiledialog_p.h dialogs/qfileinfogatherer_p.h dialogs/qfilesystemmodel_p.h dialogs/qfontdialog_p.h dialogs/qfscompleter_p.h dialogs/qsidebar_p.h dialogs/qwizard_win_p.h effects/qgraphicseffect_p.h effects/qpixmapfilter_p.h graphicsview/qgraph_p.h graphicsview/qgraphicsanchorlayout_p.h graphicsview/qgraphicsgridlayoutengine_p.h graphicsview/qgraphicsitem_p.h graphicsview/qgraphicslayout_p.h graphicsview/qgraphicslayoutitem_p.h graphicsview/qgraphicslayoutstyleinfo_p.h graphicsview/qgraphicsproxywidget_p.h graphicsview/qgraphicsscene_bsp_p.h graphicsview/qgraphicsscene_p.h graphicsview/qgraphicsscenebsptreeindex_p.h graphicsview/qgraphicssceneindex_p.h graphicsview/qgraphicsscenelinearindex_p.h graphicsview/qgraphicstransform_p.h graphicsview/qgraphicsview_p.h graphicsview/qgraphicswidget_p.h graphicsview/qsimplex_p.h itemviews/qabstractitemview_p.h itemviews/qbsptree_p.h itemviews/qcolumnview_p.h itemviews/qcolumnviewgrip_p.h itemviews/qfileiconprovider_p.h itemviews/qheaderview_p.h itemviews/qitemeditorfactory_p.h itemviews/qlistview_p.h itemviews/qlistwidget_p.h itemviews/qtableview_p.h itemviews/qtablewidget_p.h itemviews/qtreeview_p.h itemviews/qtreewidget_p.h itemviews/qtreewidgetitemiterator_p.h itemviews/qwidgetitemdata_p.h kernel/qaction_p.h kernel/qapplication_p.h kernel/qdesktopwidget_qpa_p.h kernel/qgesture_p.h kernel/qgesturemanager_p.h kernel/qlayout_p.h kernel/qlayoutengine_p.h kernel/qmacgesturerecognizer_p.h kernel/qopenglwidget_p.h kernel/qstandardgestures_p.h kernel/qt_widgets_pch.h kernel/qwidget_p.h kernel/qwidgetaction_p.h kernel/qwidgetbackingstore_p.h kernel/qwidgetwindow_qpa_p.h kernel/qwindowcontainer_p.h statemachine/qbasickeyeventtransition_p.h statemachine/qbasicmouseeventtransition_p.h styles/qandroidstyle_p.h styles/qcommonstyle_p.h styles/qcommonstylepixmaps_p.h styles/qfusionstyle_p.h styles/qfusionstyle_p_p.h styles/qgtk2painter_p.h styles/qgtkglobal_p.h styles/qgtkpainter_p.h styles/qgtkstyle_p.h styles/qgtkstyle_p_p.h styles/qmacstyle_mac_p.h styles/qmacstyle_mac_p_p.h styles/qproxystyle_p.h styles/qstyle_p.h styles/qstyleanimation_p.h styles/qstylehelper_p.h styles/qstylesheetstyle_p.h styles/qwindowscestyle_p.h styles/qwindowscestyle_p_p.h styles/qwindowsmobilestyle_p.h styles/qwindowsmobilestyle_p_p.h styles/qwindowsstyle_p.h styles/qwindowsstyle_p_p.h styles/qwindowsvistastyle_p.h styles/qwindowsvistastyle_p_p.h styles/qwindowsxpstyle_p.h styles/qwindowsxpstyle_p_p.h util/qcompleter_p.h util/qflickgesture_p.h util/qscroller_p.h util/qscrollerproperties_p.h util/qsystemtrayicon_p.h util/qundostack_p.h widgets/qabstractbutton_p.h widgets/qabstractscrollarea_p.h widgets/qabstractslider_p.h widgets/qabstractspinbox_p.h widgets/qcalendartextnavigator_p.h widgets/qcombobox_p.h widgets/qdatetimeedit_p.h widgets/qdockarealayout_p.h widgets/qdockwidget_p.h widgets/qeffects_p.h widgets/qframe_p.h widgets/qkeysequenceedit_p.h widgets/qlabel_p.h widgets/qlineedit_p.h widgets/qmainwindowlayout_p.h widgets/qmdiarea_p.h widgets/qmdisubwindow_p.h widgets/qmenu_p.h widgets/qmenu_wince_resource_p.h widgets/qmenubar_p.h widgets/qplaintextedit_p.h widgets/qpushbutton_p.h widgets/qscrollarea_p.h widgets/qscrollbar_p.h widgets/qsplitter_p.h widgets/qtabbar_p.h widgets/qtextedit_p.h widgets/qtoolbar_p.h widgets/qtoolbararealayout_p.h widgets/qtoolbarextension_p.h widgets/qtoolbarlayout_p.h widgets/qtoolbarseparator_p.h widgets/qwidgetanimator_p.h widgets/qwidgetlinecontrol_p.h widgets/qwidgetresizehandler_p.h widgets/qwidgettextcontrol_p.h widgets/qwidgettextcontrol_p_p.h 
+SYNCQT.QPA_HEADER_FILES = 
+SYNCQT.INJECTIONS = 
diff --git a/.pc/inendi.patch/src/corelib/tools/qrect.cpp b/.pc/inendi.patch/src/corelib/tools/qrect.cpp
new file mode 100644
index 0000000..382793f
--- /dev/null
+++ b/.pc/inendi.patch/src/corelib/tools/qrect.cpp
@@ -0,0 +1,2503 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtCore module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qrect.h"
+#include "qdatastream.h"
+#include "qdebug.h"
+#include "qmath.h"
+
+#include <math.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QRect
+    \inmodule QtCore
+    \ingroup painting
+    \reentrant
+
+    \brief The QRect class defines a rectangle in the plane using
+    integer precision.
+
+    A rectangle is normally expressed as an upper-left corner and a
+    size.  The size (width and height) of a QRect is always equivalent
+    to the mathematical rectangle that forms the basis for its
+    rendering.
+
+    A QRect can be constructed with a set of left, top, width and
+    height integers, or from a QPoint and a QSize.  The following code
+    creates two identical rectangles.
+
+    \snippet code/src_corelib_tools_qrect.cpp 0
+
+    There is a third constructor that creates a QRect using the
+    top-left and bottom-right coordinates, but we recommend that you
+    avoid using it. The rationale is that for historical reasons the
+    values returned by the bottom() and right() functions deviate from
+    the true bottom-right corner of the rectangle.
+
+    The QRect class provides a collection of functions that return the
+    various rectangle coordinates, and enable manipulation of
+    these. QRect also provide functions to move the rectangle relative
+    to the various coordinates. In addition there is a moveTo()
+    function that moves the rectangle, leaving its top left corner at
+    the given coordinates. Alternatively, the translate() function
+    moves the rectangle the given offset relative to the current
+    position, and the translated() function returns a translated copy
+    of this rectangle.
+
+    The size() function returns the rectange's dimensions as a
+    QSize. The dimensions can also be retrieved separately using the
+    width() and height() functions. To manipulate the dimensions use
+    the setSize(), setWidth() or setHeight() functions. Alternatively,
+    the size can be changed by applying either of the functions
+    setting the rectangle coordinates, for example, setBottom() or
+    setRight().
+
+    The contains() function tells whether a given point is inside the
+    rectangle or not, and the intersects() function returns \c true if
+    this rectangle intersects with a given rectangle. The QRect class
+    also provides the intersected() function which returns the
+    intersection rectangle, and the united() function which returns the
+    rectangle that encloses the given rectangle and this:
+
+    \table
+    \row
+    \li \inlineimage qrect-intersect.png
+    \li \inlineimage qrect-unite.png
+    \row
+    \li intersected()
+    \li united()
+    \endtable
+
+    The isEmpty() function returns \c true if left() > right() or top() >
+    bottom(). Note that an empty rectangle is not valid: The isValid()
+    function returns \c true if left() <= right() \e and top() <=
+    bottom(). A null rectangle (isNull() == true) on the other hand,
+    has both width and height set to 0.
+
+    Note that due to the way QRect and QRectF are defined, an
+    empty QRect is defined in essentially the same way as QRectF.
+
+    Finally, QRect objects can be streamed as well as compared.
+
+    \tableofcontents
+
+    \section1 Rendering
+
+    When using an \l {QPainter::Antialiasing}{anti-aliased} painter,
+    the boundary line of a QRect will be rendered symmetrically on
+    both sides of the mathematical rectangle's boundary line. But when
+    using an aliased painter (the default) other rules apply.
+
+    Then, when rendering with a one pixel wide pen the QRect's boundary
+    line will be rendered to the right and below the mathematical
+    rectangle's boundary line.
+
+    When rendering with a two pixels wide pen the boundary line will
+    be split in the middle by the mathematical rectangle. This will be
+    the case whenever the pen is set to an even number of pixels,
+    while rendering with a pen with an odd number of pixels, the spare
+    pixel will be rendered to the right and below the mathematical
+    rectangle as in the one pixel case.
+
+    \table
+    \row
+        \li \inlineimage qrect-diagram-zero.png
+        \li \inlineimage qrect-diagram-one.png
+    \row
+        \li Logical representation
+        \li One pixel wide pen
+    \row
+        \li \inlineimage qrect-diagram-two.png
+        \li \inlineimage qrect-diagram-three.png
+    \row
+        \li Two pixel wide pen
+        \li Three pixel wide pen
+    \endtable
+
+    \section1 Coordinates
+
+    The QRect class provides a collection of functions that return the
+    various rectangle coordinates, and enable manipulation of
+    these. QRect also provide functions to move the rectangle relative
+    to the various coordinates.
+
+    For example the left(), setLeft() and moveLeft() functions as an
+    example: left() returns the x-coordinate of the rectangle's left
+    edge, setLeft() sets the left edge of the rectangle to the given x
+    coordinate (it may change the width, but will never change the
+    rectangle's right edge) and moveLeft() moves the entire rectangle
+    horizontally, leaving the rectangle's left edge at the given x
+    coordinate and its size unchanged.
+
+    \image qrect-coordinates.png
+
+    Note that for historical reasons the values returned by the
+    bottom() and right() functions deviate from the true bottom-right
+    corner of the rectangle: The right() function returns \e { left()
+    + width() - 1} and the bottom() function returns \e {top() +
+    height() - 1}. The same is the case for the point returned by the
+    bottomRight() convenience function. In addition, the x and y
+    coordinate of the topRight() and bottomLeft() functions,
+    respectively, contain the same deviation from the true right and
+    bottom edges.
+
+    We recommend that you use x() + width() and y() + height() to find
+    the true bottom-right corner, and avoid right() and
+    bottom(). Another solution is to use QRectF: The QRectF class
+    defines a rectangle in the plane using floating point accuracy for
+    coordinates, and the QRectF::right() and QRectF::bottom()
+    functions \e do return the right and bottom coordinates.
+
+    It is also possible to add offsets to this rectangle's coordinates
+    using the adjust() function, as well as retrieve a new rectangle
+    based on adjustments of the original one using the adjusted()
+    function. If either of the width and height is negative, use the
+    normalized() function to retrieve a rectangle where the corners
+    are swapped.
+
+    In addition, QRect provides the getCoords() function which extracts
+    the position of the rectangle's top-left and bottom-right corner,
+    and the getRect() function which extracts the rectangle's top-left
+    corner, width and height. Use the setCoords() and setRect()
+    function to manipulate the rectangle's coordinates and dimensions
+    in one go.
+
+    \section1 Constraints
+
+    QRect is limited to the minimum and maximum values for the \c int type.
+    Operations on a QRect that could potentially result in values outside this
+    range will result in undefined behavior.
+
+    \sa QRectF, QRegion
+*/
+
+/*****************************************************************************
+  QRect member functions
+ *****************************************************************************/
+
+/*!
+    \fn QRect::QRect()
+
+    Constructs a null rectangle.
+
+    \sa isNull()
+*/
+
+/*!
+    \fn QRect::QRect(const QPoint &topLeft, const QPoint &bottomRight)
+
+    Constructs a rectangle with the given \a topLeft and \a bottomRight corners.
+
+    \sa setTopLeft(), setBottomRight()
+*/
+
+
+/*!
+    \fn QRect::QRect(const QPoint &topLeft, const QSize &size)
+
+    Constructs a rectangle with the given \a topLeft corner and the
+    given \a size.
+
+    \sa setTopLeft(), setSize()
+*/
+
+
+/*!
+    \fn QRect::QRect(int x, int y, int width, int height)
+
+    Constructs a rectangle with (\a x, \a y) as its top-left corner
+    and the given \a width and \a height.
+
+    \sa setRect()
+*/
+
+
+/*!
+    \fn bool QRect::isNull() const
+
+    Returns \c true if the rectangle is a null rectangle, otherwise
+    returns \c false.
+
+    A null rectangle has both the width and the height set to 0 (i.e.,
+    right() == left() - 1 and bottom() == top() - 1). A null rectangle
+    is also empty, and hence is not valid.
+
+    \sa isEmpty(), isValid()
+*/
+
+/*!
+    \fn bool QRect::isEmpty() const
+
+    Returns \c true if the rectangle is empty, otherwise returns \c false.
+
+    An empty rectangle has a left() > right() or top() > bottom(). An
+    empty rectangle is not valid (i.e., isEmpty() == !isValid()).
+
+    Use the normalized() function to retrieve a rectangle where the
+    corners are swapped.
+
+    \sa isNull(), isValid(), normalized()
+*/
+
+/*!
+    \fn bool QRect::isValid() const
+
+    Returns \c true if the rectangle is valid, otherwise returns \c false.
+
+    A valid rectangle has a left() < right() and top() <
+    bottom(). Note that non-trivial operations like intersections are
+    not defined for invalid rectangles. A valid rectangle is not empty
+    (i.e., isValid() == !isEmpty()).
+
+    \sa isNull(), isEmpty(), normalized()
+*/
+
+
+/*!
+    Returns a normalized rectangle; i.e., a rectangle that has a
+    non-negative width and height.
+
+    If width() < 0 the function swaps the left and right corners, and
+    it swaps the top and bottom corners if height() < 0.
+
+    \sa isValid(), isEmpty()
+*/
+
+QRect QRect::normalized() const
+{
+    QRect r;
+    if (x2 < x1 - 1) {                                // swap bad x values
+        r.x1 = x2;
+        r.x2 = x1;
+    } else {
+        r.x1 = x1;
+        r.x2 = x2;
+    }
+    if (y2 < y1 - 1) {                                // swap bad y values
+        r.y1 = y2;
+        r.y2 = y1;
+    } else {
+        r.y1 = y1;
+        r.y2 = y2;
+    }
+    return r;
+}
+
+
+/*!
+    \fn int QRect::left() const
+
+    Returns the x-coordinate of the rectangle's left edge. Equivalent
+    to x().
+
+    \sa setLeft(), topLeft(), bottomLeft()
+*/
+
+/*!
+    \fn int QRect::top() const
+
+    Returns the y-coordinate of the rectangle's top edge.
+    Equivalent to y().
+
+    \sa setTop(), topLeft(), topRight()
+*/
+
+/*!
+    \fn int QRect::right() const
+
+    Returns the x-coordinate of the rectangle's right edge.
+
+    Note that for historical reasons this function returns left() +
+    width() - 1; use x() + width() to retrieve the true x-coordinate.
+
+    \sa setRight(), topRight(), bottomRight()
+*/
+
+/*!
+    \fn int QRect::bottom() const
+
+    Returns the y-coordinate of the rectangle's bottom edge.
+
+    Note that for historical reasons this function returns top() +
+    height() - 1; use y() + height() to retrieve the true y-coordinate.
+
+    \sa setBottom(), bottomLeft(), bottomRight()
+*/
+
+/*!
+    \fn int QRect::x() const
+
+    Returns the x-coordinate of the rectangle's left edge. Equivalent to left().
+
+    \sa setX(), y(), topLeft()
+*/
+
+/*!
+    \fn int QRect::y() const
+
+    Returns the y-coordinate of the rectangle's top edge. Equivalent to top().
+
+    \sa setY(), x(), topLeft()
+*/
+
+/*!
+    \fn void QRect::setLeft(int x)
+
+    Sets the left edge of the rectangle to the given \a x
+    coordinate. May change the width, but will never change the right
+    edge of the rectangle.
+
+    Equivalent to setX().
+
+    \sa left(), moveLeft()
+*/
+
+/*!
+    \fn void QRect::setTop(int y)
+
+    Sets the top edge of the rectangle to the given \a y
+    coordinate. May change the height, but will never change the
+    bottom edge of the rectangle.
+
+    Equivalent to setY().
+
+    \sa top(), moveTop()
+*/
+
+/*!
+    \fn void QRect::setRight(int x)
+
+    Sets the right edge of the rectangle to the given \a x
+    coordinate. May change the width, but will never change the left
+    edge of the rectangle.
+
+    \sa right(), moveRight()
+*/
+
+/*!
+    \fn void QRect::setBottom(int y)
+
+    Sets the bottom edge of the rectangle to the given \a y
+    coordinate. May change the height, but will never change the top
+    edge of the rectangle.
+
+    \sa bottom(), moveBottom(),
+*/
+
+/*!
+    \fn void QRect::setX(int x)
+
+    Sets the left edge of the rectangle to the given \a x
+    coordinate. May change the width, but will never change the right
+    edge of the rectangle.
+
+    Equivalent to setLeft().
+
+    \sa x(), setY(), setTopLeft()
+*/
+
+/*!
+    \fn void QRect::setY(int y)
+
+    Sets the top edge of the rectangle to the given \a y
+    coordinate. May change the height, but will never change the
+    bottom edge of the rectangle.
+
+    Equivalent to setTop().
+
+    \sa y(), setX(), setTopLeft()
+*/
+
+/*!
+    \fn void QRect::setTopLeft(const QPoint &position)
+
+    Set the top-left corner of the rectangle to the given \a
+    position. May change the size, but will never change the
+    bottom-right corner of the rectangle.
+
+    \sa topLeft(), moveTopLeft()
+*/
+
+/*!
+    \fn void QRect::setBottomRight(const QPoint &position)
+
+    Set the bottom-right corner of the rectangle to the given \a
+    position. May change the size, but will never change the
+    top-left corner of the rectangle.
+
+    \sa bottomRight(), moveBottomRight()
+*/
+
+/*!
+    \fn void QRect::setTopRight(const QPoint &position)
+
+    Set the top-right corner of the rectangle to the given \a
+    position. May change the size, but will never change the
+    bottom-left corner of the rectangle.
+
+    \sa topRight(), moveTopRight()
+*/
+
+/*!
+    \fn void QRect::setBottomLeft(const QPoint &position)
+
+    Set the bottom-left corner of the rectangle to the given \a
+    position. May change the size, but will never change the
+    top-right corner of the rectangle.
+
+    \sa bottomLeft(), moveBottomLeft()
+*/
+
+/*!
+    \fn QPoint QRect::topLeft() const
+
+    Returns the position of the rectangle's top-left corner.
+
+    \sa setTopLeft(), top(), left()
+*/
+
+/*!
+    \fn QPoint QRect::bottomRight() const
+
+    Returns the position of the rectangle's bottom-right corner.
+
+    Note that for historical reasons this function returns
+    QPoint(left() + width() -1, top() + height() - 1).
+
+    \sa setBottomRight(), bottom(), right()
+*/
+
+/*!
+    \fn QPoint QRect::topRight() const
+
+    Returns the position of the rectangle's top-right corner.
+
+    Note that for historical reasons this function returns
+    QPoint(left() + width() -1, top()).
+
+    \sa setTopRight(), top(), right()
+*/
+
+/*!
+    \fn QPoint QRect::bottomLeft() const
+
+    Returns the position of the rectangle's bottom-left corner. Note
+    that for historical reasons this function returns QPoint(left(),
+    top() + height() - 1).
+
+    \sa setBottomLeft(), bottom(), left()
+*/
+
+/*!
+    \fn QPoint QRect::center() const
+
+    Returns the center point of the rectangle.
+
+    \sa moveCenter()
+*/
+
+
+/*!
+    \fn void QRect::getRect(int *x, int *y, int *width, int *height) const
+
+    Extracts the position of the rectangle's top-left corner to *\a x
+    and *\a y, and its dimensions to *\a width and *\a height.
+
+    \sa setRect(), getCoords()
+*/
+
+
+/*!
+    \fn void QRect::getCoords(int *x1, int *y1, int *x2, int *y2) const
+
+    Extracts the position of the rectangle's top-left corner to *\a x1
+    and *\a y1, and the position of the bottom-right corner to *\a x2
+    and *\a y2.
+
+    \sa setCoords(), getRect()
+*/
+
+/*!
+    \fn void QRect::moveLeft(int x)
+
+    Moves the rectangle horizontally, leaving the rectangle's left
+    edge at the given \a x coordinate. The rectangle's size is
+    unchanged.
+
+    \sa left(), setLeft(), moveRight()
+*/
+
+/*!
+    \fn void QRect::moveTop(int y)
+
+    Moves the rectangle vertically, leaving the rectangle's top edge
+    at the given \a y coordinate. The rectangle's size is unchanged.
+
+    \sa top(), setTop(), moveBottom()
+*/
+
+
+/*!
+    \fn void QRect::moveRight(int x)
+
+    Moves the rectangle horizontally, leaving the rectangle's right
+    edge at the given \a x coordinate. The rectangle's size is
+    unchanged.
+
+    \sa right(), setRight(), moveLeft()
+*/
+
+
+/*!
+    \fn void QRect::moveBottom(int y)
+
+    Moves the rectangle vertically, leaving the rectangle's bottom
+    edge at the given \a y coordinate. The rectangle's size is
+    unchanged.
+
+    \sa bottom(), setBottom(), moveTop()
+*/
+
+
+/*!
+    \fn void QRect::moveTopLeft(const QPoint &position)
+
+    Moves the rectangle, leaving the top-left corner at the given \a
+    position. The rectangle's size is unchanged.
+
+    \sa setTopLeft(), moveTop(), moveLeft()
+*/
+
+
+/*!
+    \fn void QRect::moveBottomRight(const QPoint &position)
+
+    Moves the rectangle, leaving the bottom-right corner at the given
+    \a position. The rectangle's size is unchanged.
+
+    \sa setBottomRight(), moveRight(), moveBottom()
+*/
+
+
+/*!
+    \fn void QRect::moveTopRight(const QPoint &position)
+
+    Moves the rectangle, leaving the top-right corner at the given \a
+    position. The rectangle's size is unchanged.
+
+    \sa setTopRight(), moveTop(), moveRight()
+*/
+
+
+/*!
+    \fn void QRect::moveBottomLeft(const QPoint &position)
+
+    Moves the rectangle, leaving the bottom-left corner at the given
+    \a position. The rectangle's size is unchanged.
+
+    \sa setBottomLeft(), moveBottom(), moveLeft()
+*/
+
+
+/*!
+    \fn void QRect::moveCenter(const QPoint &position)
+
+    Moves the rectangle, leaving the center point at the given \a
+    position. The rectangle's size is unchanged.
+
+    \sa center()
+*/
+
+/*!
+    \fn void QRect::moveTo(int x, int y)
+
+    Moves the rectangle, leaving the top-left corner at the given
+    position (\a x, \a y).  The rectangle's size is unchanged.
+
+    \sa translate(), moveTopLeft()
+*/
+
+/*!
+    \fn void QRect::moveTo(const QPoint &position)
+
+    Moves the rectangle, leaving the top-left corner at the given \a
+    position.
+*/
+
+/*!
+    \fn void QRect::translate(int dx, int dy)
+
+    Moves the rectangle \a dx along the x axis and \a dy along the y
+    axis, relative to the current position. Positive values move the
+    rectangle to the right and down.
+
+    \sa moveTopLeft(), moveTo(), translated()
+*/
+
+
+/*!
+    \fn void QRect::translate(const QPoint &offset)
+    \overload
+
+    Moves the rectangle \a{offset}.\l{QPoint::x()}{x()} along the x
+    axis and \a{offset}.\l{QPoint::y()}{y()} along the y axis,
+    relative to the current position.
+*/
+
+
+/*!
+    \fn QRect QRect::translated(int dx, int dy) const
+
+    Returns a copy of the rectangle that is translated \a dx along the
+    x axis and \a dy along the y axis, relative to the current
+    position. Positive values move the rectangle to the right and
+    down.
+
+    \sa translate()
+
+*/
+
+
+/*!
+    \fn QRect QRect::translated(const QPoint &offset) const
+
+    \overload
+
+    Returns a copy of the rectangle that is translated
+    \a{offset}.\l{QPoint::x()}{x()} along the x axis and
+    \a{offset}.\l{QPoint::y()}{y()} along the y axis, relative to the
+    current position.
+*/
+
+
+/*!
+    \fn void QRect::setRect(int x, int y, int width, int height)
+
+    Sets the coordinates of the rectangle's top-left corner to (\a{x},
+    \a{y}), and its size to the given \a width and \a height.
+
+    \sa getRect(), setCoords()
+*/
+
+
+/*!
+    \fn void QRect::setCoords(int x1, int y1, int x2, int y2)
+
+    Sets the coordinates of the rectangle's top-left corner to (\a x1,
+    \a y1), and the coordinates of its bottom-right corner to (\a x2,
+    \a y2).
+
+    \sa getCoords(), setRect()
+*/
+
+
+/*! \fn QRect QRect::adjusted(int dx1, int dy1, int dx2, int dy2) const
+
+    Returns a new rectangle with \a dx1, \a dy1, \a dx2 and \a dy2
+    added respectively to the existing coordinates of this rectangle.
+
+    \sa adjust()
+*/
+
+/*! \fn void QRect::adjust(int dx1, int dy1, int dx2, int dy2)
+
+    Adds \a dx1, \a dy1, \a dx2 and \a dy2 respectively to the
+    existing coordinates of the rectangle.
+
+    \sa adjusted(), setRect()
+*/
+
+/*!
+    \fn QSize QRect::size() const
+
+    Returns the size of the rectangle.
+
+    \sa setSize(), width(), height()
+*/
+
+/*!
+    \fn int QRect::width() const
+
+    Returns the width of the rectangle.
+
+    \sa setWidth(), height(), size()
+*/
+
+/*!
+    \fn int QRect::height() const
+
+    Returns the height of the rectangle.
+
+    \sa setHeight(), width(), size()
+*/
+
+/*!
+    \fn void QRect::setWidth(int width)
+
+    Sets the width of the rectangle to the given \a width. The right
+    edge is changed, but not the left one.
+
+    \sa width(), setSize()
+*/
+
+
+/*!
+    \fn void QRect::setHeight(int height)
+
+    Sets the height of the rectangle to the given \a height. The bottom
+    edge is changed, but not the top one.
+
+    \sa height(), setSize()
+*/
+
+
+/*!
+    \fn void QRect::setSize(const QSize &size)
+
+    Sets the size of the rectangle to the given \a size. The top-left
+    corner is not moved.
+
+    \sa size(), setWidth(), setHeight()
+*/
+
+
+/*!
+    \fn bool QRect::contains(const QPoint &point, bool proper) const
+
+    Returns \c true if the given \a point is inside or on the edge of
+    the rectangle, otherwise returns \c false. If \a proper is true, this
+    function only returns \c true if the given \a point is \e inside the
+    rectangle (i.e., not on the edge).
+
+    \sa intersects()
+*/
+
+bool QRect::contains(const QPoint &p, bool proper) const
+{
+    int l, r;
+    if (x2 < x1 - 1) {
+        l = x2;
+        r = x1;
+    } else {
+        l = x1;
+        r = x2;
+    }
+    if (proper) {
+        if (p.x() <= l || p.x() >= r)
+            return false;
+    } else {
+        if (p.x() < l || p.x() > r)
+            return false;
+    }
+    int t, b;
+    if (y2 < y1 - 1) {
+        t = y2;
+        b = y1;
+    } else {
+        t = y1;
+        b = y2;
+    }
+    if (proper) {
+        if (p.y() <= t || p.y() >= b)
+            return false;
+    } else {
+        if (p.y() < t || p.y() > b)
+            return false;
+    }
+    return true;
+}
+
+
+/*!
+    \fn bool QRect::contains(int x, int y, bool proper) const
+    \overload
+
+    Returns \c true if the point (\a x, \a y) is inside or on the edge of
+    the rectangle, otherwise returns \c false. If \a proper is true, this
+    function only returns \c true if the point is entirely inside the
+    rectangle(not on the edge).
+*/
+
+/*!
+    \fn bool QRect::contains(int x, int y) const
+    \overload
+
+    Returns \c true if the point (\a x, \a y) is inside this rectangle,
+    otherwise returns \c false.
+*/
+
+/*!
+    \fn bool QRect::contains(const QRect &rectangle, bool proper) const
+    \overload
+
+    Returns \c true if the given \a rectangle is inside this rectangle.
+    otherwise returns \c false. If \a proper is true, this function only
+    returns \c true if the \a rectangle is entirely inside this
+    rectangle (not on the edge).
+*/
+
+bool QRect::contains(const QRect &r, bool proper) const
+{
+    if (isNull() || r.isNull())
+        return false;
+
+    int l1 = x1;
+    int r1 = x1;
+    if (x2 - x1 + 1 < 0)
+        l1 = x2;
+    else
+        r1 = x2;
+
+    int l2 = r.x1;
+    int r2 = r.x1;
+    if (r.x2 - r.x1 + 1 < 0)
+        l2 = r.x2;
+    else
+        r2 = r.x2;
+
+    if (proper) {
+        if (l2 <= l1 || r2 >= r1)
+            return false;
+    } else {
+        if (l2 < l1 || r2 > r1)
+            return false;
+    }
+
+    int t1 = y1;
+    int b1 = y1;
+    if (y2 - y1 + 1 < 0)
+        t1 = y2;
+    else
+        b1 = y2;
+
+    int t2 = r.y1;
+    int b2 = r.y1;
+    if (r.y2 - r.y1 + 1 < 0)
+        t2 = r.y2;
+    else
+        b2 = r.y2;
+
+    if (proper) {
+        if (t2 <= t1 || b2 >= b1)
+            return false;
+    } else {
+        if (t2 < t1 || b2 > b1)
+            return false;
+    }
+
+    return true;
+}
+
+/*!
+    \fn QRect& QRect::operator|=(const QRect &rectangle)
+
+    Unites this rectangle with the given \a rectangle.
+
+    \sa united(), operator|()
+*/
+
+/*!
+    \fn QRect& QRect::operator&=(const QRect &rectangle)
+
+    Intersects this rectangle with the given \a rectangle.
+
+    \sa intersected(), operator&()
+*/
+
+
+/*!
+    \fn QRect QRect::operator|(const QRect &rectangle) const
+
+    Returns the bounding rectangle of this rectangle and the given \a
+    rectangle.
+
+    \sa operator|=(), united()
+*/
+
+QRect QRect::operator|(const QRect &r) const
+{
+    if (isNull())
+        return r;
+    if (r.isNull())
+        return *this;
+
+    int l1 = x1;
+    int r1 = x1;
+    if (x2 - x1 + 1 < 0)
+        l1 = x2;
+    else
+        r1 = x2;
+
+    int l2 = r.x1;
+    int r2 = r.x1;
+    if (r.x2 - r.x1 + 1 < 0)
+        l2 = r.x2;
+    else
+        r2 = r.x2;
+
+    int t1 = y1;
+    int b1 = y1;
+    if (y2 - y1 + 1 < 0)
+        t1 = y2;
+    else
+        b1 = y2;
+
+    int t2 = r.y1;
+    int b2 = r.y1;
+    if (r.y2 - r.y1 + 1 < 0)
+        t2 = r.y2;
+    else
+        b2 = r.y2;
+
+    QRect tmp;
+    tmp.x1 = qMin(l1, l2);
+    tmp.x2 = qMax(r1, r2);
+    tmp.y1 = qMin(t1, t2);
+    tmp.y2 = qMax(b1, b2);
+    return tmp;
+}
+
+/*!
+    \fn QRect QRect::unite(const QRect &rectangle) const
+    \obsolete
+
+    Use united(\a rectangle) instead.
+*/
+
+/*!
+    \fn QRect QRect::united(const QRect &rectangle) const
+    \since 4.2
+
+    Returns the bounding rectangle of this rectangle and the given \a rectangle.
+
+    \image qrect-unite.png
+
+    \sa intersected()
+*/
+
+
+/*!
+    \fn QRect QRect::operator&(const QRect &rectangle) const
+
+    Returns the intersection of this rectangle and the given \a
+    rectangle. Returns an empty rectangle if there is no intersection.
+
+    \sa operator&=(), intersected()
+*/
+
+QRect QRect::operator&(const QRect &r) const
+{
+    if (isNull() || r.isNull())
+        return QRect();
+
+    int l1 = x1;
+    int r1 = x1;
+    if (x2 - x1 + 1 < 0)
+        l1 = x2;
+    else
+        r1 = x2;
+
+    int l2 = r.x1;
+    int r2 = r.x1;
+    if (r.x2 - r.x1 + 1 < 0)
+        l2 = r.x2;
+    else
+        r2 = r.x2;
+
+    if (l1 > r2 || l2 > r1)
+        return QRect();
+
+    int t1 = y1;
+    int b1 = y1;
+    if (y2 - y1 + 1 < 0)
+        t1 = y2;
+    else
+        b1 = y2;
+
+    int t2 = r.y1;
+    int b2 = r.y1;
+    if (r.y2 - r.y1 + 1 < 0)
+        t2 = r.y2;
+    else
+        b2 = r.y2;
+
+    if (t1 > b2 || t2 > b1)
+        return QRect();
+
+    QRect tmp;
+    tmp.x1 = qMax(l1, l2);
+    tmp.x2 = qMin(r1, r2);
+    tmp.y1 = qMax(t1, t2);
+    tmp.y2 = qMin(b1, b2);
+    return tmp;
+}
+
+/*!
+    \fn QRect QRect::intersect(const QRect &rectangle) const
+    \obsolete
+
+    Use intersected(\a rectangle) instead.
+*/
+
+/*!
+    \fn QRect QRect::intersected(const QRect &rectangle) const
+    \since 4.2
+
+    Returns the intersection of this rectangle and the given \a
+    rectangle. Note that \c{r.intersected(s)} is equivalent to \c{r & s}.
+
+    \image qrect-intersect.png
+
+    \sa intersects(), united(), operator&=()
+*/
+
+/*!
+    \fn bool QRect::intersects(const QRect &rectangle) const
+
+    Returns \c true if this rectangle intersects with the given \a
+    rectangle (i.e., there is at least one pixel that is within both
+    rectangles), otherwise returns \c false.
+
+    The intersection rectangle can be retrieved using the intersected()
+    function.
+
+    \sa contains()
+*/
+
+bool QRect::intersects(const QRect &r) const
+{
+    if (isNull() || r.isNull())
+        return false;
+
+    int l1 = x1;
+    int r1 = x1;
+    if (x2 - x1 + 1 < 0)
+        l1 = x2;
+    else
+        r1 = x2;
+
+    int l2 = r.x1;
+    int r2 = r.x1;
+    if (r.x2 - r.x1 + 1 < 0)
+        l2 = r.x2;
+    else
+        r2 = r.x2;
+
+    if (l1 > r2 || l2 > r1)
+        return false;
+
+    int t1 = y1;
+    int b1 = y1;
+    if (y2 - y1 + 1 < 0)
+        t1 = y2;
+    else
+        b1 = y2;
+
+    int t2 = r.y1;
+    int b2 = r.y1;
+    if (r.y2 - r.y1 + 1 < 0)
+        t2 = r.y2;
+    else
+        b2 = r.y2;
+
+    if (t1 > b2 || t2 > b1)
+        return false;
+
+    return true;
+}
+
+/*!
+    \fn bool operator==(const QRect &r1, const QRect &r2)
+    \relates QRect
+
+    Returns \c true if the rectangles \a r1 and \a r2 are equal,
+    otherwise returns \c false.
+*/
+
+
+/*!
+    \fn bool operator!=(const QRect &r1, const QRect &r2)
+    \relates QRect
+
+    Returns \c true if the rectangles \a r1 and \a r2 are different, otherwise
+    returns \c false.
+*/
+
+/*!
+    \fn QRect operator+(const QRect &rectangle, const QMargins &margins)
+    \relates QRect
+
+    Returns the \a rectangle grown by the \a margins.
+
+    \since 5.1
+*/
+
+/*!
+    \fn QRect operator+(const QMargins &margins, const QRect &rectangle)
+    \relates QRect
+    \overload
+
+    Returns the \a rectangle grown by the \a margins.
+
+    \since 5.1
+*/
+
+/*!
+    \fn QRect operator-(const QRect &lhs, const QMargins &rhs)
+    \relates QRect
+
+    Returns the \a lhs rectangle shrunken by the \a rhs margins.
+
+    \since 5.3
+*/
+
+/*!
+    \fn QRect QRect::marginsAdded(const QMargins &margins) const
+
+    Returns a rectangle grown by the \a margins.
+
+    \sa operator+=(), marginsRemoved(), operator-=()
+
+    \since 5.1
+*/
+
+/*!
+    \fn QRect QRect::operator+=(const QMargins &margins)
+
+    Adds the \a margins to the rectangle, growing it.
+
+    \sa marginsAdded(), marginsRemoved(), operator-=()
+
+    \since 5.1
+*/
+
+/*!
+    \fn QRect QRect::marginsRemoved(const QMargins &margins) const
+
+    Removes the \a margins from the rectangle, shrinking it.
+
+    \sa marginsAdded(), operator+=(), operator-=()
+
+    \since 5.1
+*/
+
+/*!
+    \fn QRect QRect::operator -=(const QMargins &margins)
+
+    Returns a rectangle shrunk by the \a margins.
+
+    \sa marginsRemoved(), operator+=(), marginsAdded()
+
+    \since 5.1
+*/
+
+
+/*****************************************************************************
+  QRect stream functions
+ *****************************************************************************/
+#ifndef QT_NO_DATASTREAM
+/*!
+    \fn QDataStream &operator<<(QDataStream &stream, const QRect &rectangle)
+    \relates QRect
+
+    Writes the given \a rectangle to the given \a stream, and returns
+    a reference to the stream.
+
+    \sa {Serializing Qt Data Types}
+*/
+
+QDataStream &operator<<(QDataStream &s, const QRect &r)
+{
+    if (s.version() == 1)
+        s << (qint16)r.left() << (qint16)r.top()
+          << (qint16)r.right() << (qint16)r.bottom();
+    else
+        s << (qint32)r.left() << (qint32)r.top()
+          << (qint32)r.right() << (qint32)r.bottom();
+    return s;
+}
+
+/*!
+    \fn QDataStream &operator>>(QDataStream &stream, QRect &rectangle)
+    \relates QRect
+
+    Reads a rectangle from the given \a stream into the given \a
+    rectangle, and returns a reference to the stream.
+
+    \sa {Serializing Qt Data Types}
+*/
+
+QDataStream &operator>>(QDataStream &s, QRect &r)
+{
+    if (s.version() == 1) {
+        qint16 x1, y1, x2, y2;
+        s >> x1; s >> y1; s >> x2; s >> y2;
+        r.setCoords(x1, y1, x2, y2);
+    }
+    else {
+        qint32 x1, y1, x2, y2;
+        s >> x1; s >> y1; s >> x2; s >> y2;
+        r.setCoords(x1, y1, x2, y2);
+    }
+    return s;
+}
+
+#endif // QT_NO_DATASTREAM
+
+
+#ifndef QT_NO_DEBUG_STREAM
+QDebug operator<<(QDebug dbg, const QRect &r) {
+    dbg.nospace() << "QRect(" << r.x() << ',' << r.y() << ' '
+                  << r.width() << 'x' << r.height() << ')';
+    return dbg.space();
+}
+#endif
+
+/*!
+    \class QRectF
+    \inmodule QtCore
+    \ingroup painting
+    \reentrant
+
+    \brief The QRectF class defines a rectangle in the plane using floating
+    point precision.
+
+    A rectangle is normally expressed as an upper-left corner and a
+    size.  The size (width and height) of a QRectF is always equivalent
+    to the mathematical rectangle that forms the basis for its
+    rendering.
+
+    A QRectF can be constructed with a set of left, top, width and
+    height integers, or from a QPoint and a QSize.  The following code
+    creates two identical rectangles.
+
+    \snippet code/src_corelib_tools_qrect.cpp 1
+
+    There is also a third constructor creating a QRectF from a QRect,
+    and a corresponding toRect() function that returns a QRect object
+    based on the values of this rectangle (note that the coordinates
+    in the returned rectangle are rounded to the nearest integer).
+
+    The QRectF class provides a collection of functions that return
+    the various rectangle coordinates, and enable manipulation of
+    these. QRectF also provide functions to move the rectangle
+    relative to the various coordinates. In addition there is a
+    moveTo() function that moves the rectangle, leaving its top left
+    corner at the given coordinates. Alternatively, the translate()
+    function moves the rectangle the given offset relative to the
+    current position, and the translated() function returns a
+    translated copy of this rectangle.
+
+    The size() function returns the rectange's dimensions as a
+    QSize. The dimensions can also be retrieved separately using the
+    width() and height() functions. To manipulate the dimensions use
+    the setSize(), setWidth() or setHeight() functions. Alternatively,
+    the size can be changed by applying either of the functions
+    setting the rectangle coordinates, for example, setBottom() or
+    setRight().
+
+    The contains() function tells whether a given point is inside the
+    rectangle or not, and the intersects() function returns \c true if
+    this rectangle intersects with a given rectangle (otherwise
+    false). The QRectF class also provides the intersected() function
+    which returns the intersection rectangle, and the united() function
+    which returns the rectangle that encloses the given rectangle and
+    this:
+
+    \table
+    \row
+    \li \inlineimage qrect-intersect.png
+    \li \inlineimage qrect-unite.png
+    \row
+    \li intersected()
+    \li united()
+    \endtable
+
+    The isEmpty() function returns \c true if the rectangle's width or
+    height is less than, or equal to, 0. Note that an empty rectangle
+    is not valid: The isValid() function returns \c true if both width
+    and height is larger than 0. A null rectangle (isNull() == true)
+    on the other hand, has both width and height set to 0.
+
+    Note that due to the way QRect and QRectF are defined, an
+    empty QRectF is defined in essentially the same way as QRect.
+
+    Finally, QRectF objects can be streamed as well as compared.
+
+    \tableofcontents
+
+    \section1 Rendering
+
+    When using an \l {QPainter::Antialiasing}{anti-aliased} painter,
+    the boundary line of a QRectF will be rendered symmetrically on both
+    sides of the mathematical rectangle's boundary line. But when
+    using an aliased painter (the default) other rules apply.
+
+    Then, when rendering with a one pixel wide pen the QRectF's boundary
+    line will be rendered to the right and below the mathematical
+    rectangle's boundary line.
+
+    When rendering with a two pixels wide pen the boundary line will
+    be split in the middle by the mathematical rectangle. This will be
+    the case whenever the pen is set to an even number of pixels,
+    while rendering with a pen with an odd number of pixels, the spare
+    pixel will be rendered to the right and below the mathematical
+    rectangle as in the one pixel case.
+
+    \table
+    \row
+        \li \inlineimage qrect-diagram-zero.png
+        \li \inlineimage qrectf-diagram-one.png
+    \row
+        \li Logical representation
+        \li One pixel wide pen
+    \row
+        \li \inlineimage qrectf-diagram-two.png
+        \li \inlineimage qrectf-diagram-three.png
+    \row
+        \li Two pixel wide pen
+        \li Three pixel wide pen
+    \endtable
+
+    \section1 Coordinates
+
+    The QRectF class provides a collection of functions that return
+    the various rectangle coordinates, and enable manipulation of
+    these. QRectF also provide functions to move the rectangle
+    relative to the various coordinates.
+
+    For example: the bottom(), setBottom() and moveBottom() functions:
+    bottom() returns the y-coordinate of the rectangle's bottom edge,
+    setBottom() sets the bottom edge of the rectangle to the given y
+    coordinate (it may change the height, but will never change the
+    rectangle's top edge) and moveBottom() moves the entire rectangle
+    vertically, leaving the rectangle's bottom edge at the given y
+    coordinate and its size unchanged.
+
+    \image qrectf-coordinates.png
+
+    It is also possible to add offsets to this rectangle's coordinates
+    using the adjust() function, as well as retrieve a new rectangle
+    based on adjustments of the original one using the adjusted()
+    function. If either of the width and height is negative, use the
+    normalized() function to retrieve a rectangle where the corners
+    are swapped.
+
+    In addition, QRectF provides the getCoords() function which extracts
+    the position of the rectangle's top-left and bottom-right corner,
+    and the getRect() function which extracts the rectangle's top-left
+    corner, width and height. Use the setCoords() and setRect()
+    function to manipulate the rectangle's coordinates and dimensions
+    in one go.
+
+    \sa QRect, QRegion
+*/
+
+/*****************************************************************************
+  QRectF member functions
+ *****************************************************************************/
+
+/*!
+    \fn QRectF::QRectF()
+
+    Constructs a null rectangle.
+
+    \sa isNull()
+*/
+
+/*!
+    \fn QRectF::QRectF(const QPointF &topLeft, const QSizeF &size)
+
+    Constructs a rectangle with the given \a topLeft corner and the given \a size.
+
+    \sa setTopLeft(), setSize()
+*/
+
+/*!
+    \fn QRectF::QRectF(const QPointF &topLeft, const QPointF &bottomRight)
+    \since 4.3
+
+    Constructs a rectangle with the given \a topLeft and \a bottomRight corners.
+
+    \sa setTopLeft(), setBottomRight()
+*/
+
+/*!
+    \fn QRectF::QRectF(qreal x, qreal y, qreal width, qreal height)
+
+    Constructs a rectangle with (\a x, \a y) as its top-left corner
+    and the given \a width and \a height.
+
+    \sa setRect()
+*/
+
+/*!
+    \fn QRectF::QRectF(const QRect &rectangle)
+
+    Constructs a QRectF rectangle from the given QRect \a rectangle.
+
+    \sa toRect()
+*/
+
+/*!
+    \fn bool QRectF::isNull() const
+
+    Returns \c true if the rectangle is a null rectangle, otherwise returns \c false.
+
+    A null rectangle has both the width and the height set to 0. A
+    null rectangle is also empty, and hence not valid.
+
+    \sa isEmpty(), isValid()
+*/
+
+/*!
+    \fn bool QRectF::isEmpty() const
+
+    Returns \c true if the rectangle is empty, otherwise returns \c false.
+
+    An empty rectangle has width() <= 0 or height() <= 0.  An empty
+    rectangle is not valid (i.e., isEmpty() == !isValid()).
+
+    Use the normalized() function to retrieve a rectangle where the
+    corners are swapped.
+
+    \sa isNull(), isValid(), normalized()
+*/
+
+/*!
+    \fn bool QRectF::isValid() const
+
+    Returns \c true if the rectangle is valid, otherwise returns \c false.
+
+    A valid rectangle has a width() > 0 and height() > 0. Note that
+    non-trivial operations like intersections are not defined for
+    invalid rectangles. A valid rectangle is not empty (i.e., isValid()
+    == !isEmpty()).
+
+    \sa isNull(), isEmpty(), normalized()
+*/
+
+
+/*!
+    Returns a normalized rectangle; i.e., a rectangle that has a
+    non-negative width and height.
+
+    If width() < 0 the function swaps the left and right corners, and
+    it swaps the top and bottom corners if height() < 0.
+
+    \sa isValid(), isEmpty()
+*/
+
+QRectF QRectF::normalized() const
+{
+    QRectF r = *this;
+    if (r.w < 0) {
+        r.xp += r.w;
+        r.w = -r.w;
+    }
+    if (r.h < 0) {
+        r.yp += r.h;
+        r.h = -r.h;
+    }
+    return r;
+}
+
+/*!
+    \fn qreal QRectF::x() const
+
+    Returns the x-coordinate of the rectangle's left edge. Equivalent
+    to left().
+
+
+    \sa setX(), y(), topLeft()
+*/
+
+/*!
+    \fn qreal QRectF::y() const
+
+    Returns the y-coordinate of the rectangle's top edge. Equivalent
+    to top().
+
+    \sa setY(), x(), topLeft()
+*/
+
+
+/*!
+    \fn void QRectF::setLeft(qreal x)
+
+    Sets the left edge of the rectangle to the given \a x
+    coordinate. May change the width, but will never change the right
+    edge of the rectangle.
+
+    Equivalent to setX().
+
+    \sa left(), moveLeft()
+*/
+
+/*!
+    \fn void QRectF::setTop(qreal y)
+
+    Sets the top edge of the rectangle to the given \a y coordinate. May
+    change the height, but will never change the bottom edge of the
+    rectangle.
+
+    Equivalent to setY().
+
+    \sa top(), moveTop()
+*/
+
+/*!
+    \fn void QRectF::setRight(qreal x)
+
+    Sets the right edge of the rectangle to the given \a x
+    coordinate. May change the width, but will never change the left
+    edge of the rectangle.
+
+    \sa right(), moveRight()
+*/
+
+/*!
+    \fn void QRectF::setBottom(qreal y)
+
+    Sets the bottom edge of the rectangle to the given \a y
+    coordinate. May change the height, but will never change the top
+    edge of the rectangle.
+
+    \sa bottom(), moveBottom()
+*/
+
+/*!
+    \fn void QRectF::setX(qreal x)
+
+    Sets the left edge of the rectangle to the given \a x
+    coordinate. May change the width, but will never change the right
+    edge of the rectangle.
+
+    Equivalent to setLeft().
+
+    \sa x(), setY(), setTopLeft()
+*/
+
+/*!
+    \fn void QRectF::setY(qreal y)
+
+    Sets the top edge of the rectangle to the given \a y
+    coordinate. May change the height, but will never change the
+    bottom edge of the rectangle.
+
+    Equivalent to setTop().
+
+    \sa y(), setX(), setTopLeft()
+*/
+
+/*!
+    \fn void QRectF::setTopLeft(const QPointF &position)
+
+    Set the top-left corner of the rectangle to the given \a
+    position. May change the size, but will never change the
+    bottom-right corner of the rectangle.
+
+    \sa topLeft(), moveTopLeft()
+*/
+
+/*!
+    \fn void QRectF::setBottomRight(const QPointF &position)
+
+    Set the bottom-right corner of the rectangle to the given \a
+    position. May change the size, but will never change the
+    top-left corner of the rectangle.
+
+    \sa bottomRight(), moveBottomRight()
+*/
+
+/*!
+    \fn void QRectF::setTopRight(const QPointF &position)
+
+    Set the top-right corner of the rectangle to the given \a
+    position. May change the size, but will never change the
+    bottom-left corner of the rectangle.
+
+    \sa topRight(), moveTopRight()
+*/
+
+/*!
+    \fn void QRectF::setBottomLeft(const QPointF &position)
+
+    Set the bottom-left corner of the rectangle to the given \a
+    position. May change the size, but will never change the
+    top-right corner of the rectangle.
+
+    \sa bottomLeft(), moveBottomLeft()
+*/
+
+/*!
+    \fn QPointF QRectF::center() const
+
+    Returns the center point of the rectangle.
+
+    \sa moveCenter()
+*/
+
+
+/*!
+    \fn void QRectF::getRect(qreal *x, qreal *y, qreal *width, qreal *height) const
+
+    Extracts the position of the rectangle's top-left corner to *\a x and
+    *\a y, and its dimensions to *\a width and *\a height.
+
+    \sa setRect(), getCoords()
+*/
+
+
+/*!
+    \fn void QRectF::getCoords(qreal *x1, qreal *y1, qreal *x2, qreal *y2) const
+
+    Extracts the position of the rectangle's top-left corner to *\a x1
+    and *\a y1, and the position of the bottom-right corner to *\a x2 and
+    *\a y2.
+
+    \sa setCoords(), getRect()
+*/
+
+/*!
+    \fn void QRectF::moveLeft(qreal x)
+
+    Moves the rectangle horizontally, leaving the rectangle's left
+    edge at the given \a x coordinate. The rectangle's size is
+    unchanged.
+
+    \sa left(), setLeft(), moveRight()
+*/
+
+/*!
+    \fn void QRectF::moveTop(qreal y)
+
+    Moves the rectangle vertically, leaving the rectangle's top line
+    at the given \a y coordinate. The rectangle's size is unchanged.
+
+    \sa top(), setTop(), moveBottom()
+*/
+
+
+/*!
+    \fn void QRectF::moveRight(qreal x)
+
+    Moves the rectangle horizontally, leaving the rectangle's right
+    edge at the given \a x coordinate. The rectangle's size is
+    unchanged.
+
+    \sa right(), setRight(), moveLeft()
+*/
+
+
+/*!
+    \fn void QRectF::moveBottom(qreal y)
+
+    Moves the rectangle vertically, leaving the rectangle's bottom
+    edge at the given \a y coordinate. The rectangle's size is
+    unchanged.
+
+    \sa bottom(), setBottom(), moveTop()
+*/
+
+
+/*!
+    \fn void QRectF::moveTopLeft(const QPointF &position)
+
+    Moves the rectangle, leaving the top-left corner at the given \a
+    position. The rectangle's size is unchanged.
+
+    \sa setTopLeft(), moveTop(), moveLeft()
+*/
+
+
+/*!
+    \fn void QRectF::moveBottomRight(const QPointF &position)
+
+    Moves the rectangle, leaving the bottom-right corner at the given
+    \a position. The rectangle's size is unchanged.
+
+    \sa setBottomRight(), moveBottom(), moveRight()
+*/
+
+
+/*!
+    \fn void QRectF::moveTopRight(const QPointF &position)
+
+    Moves the rectangle, leaving the top-right corner at the given
+    \a position. The rectangle's size is unchanged.
+
+    \sa setTopRight(), moveTop(), moveRight()
+*/
+
+
+/*!
+    \fn void QRectF::moveBottomLeft(const QPointF &position)
+
+    Moves the rectangle, leaving the bottom-left corner at the given
+    \a position. The rectangle's size is unchanged.
+
+    \sa setBottomLeft(), moveBottom(), moveLeft()
+*/
+
+
+/*!
+    \fn void QRectF::moveTo(qreal x, qreal y)
+
+    Moves the rectangle, leaving the top-left corner at the given
+    position (\a x, \a y). The rectangle's size is unchanged.
+
+    \sa translate(), moveTopLeft()
+*/
+
+/*!
+    \fn void QRectF::moveTo(const QPointF &position)
+    \overload
+
+    Moves the rectangle, leaving the top-left corner at the given \a
+    position.
+*/
+
+/*!
+    \fn void QRectF::translate(qreal dx, qreal dy)
+
+    Moves the rectangle \a dx along the x-axis and \a dy along the y-axis,
+    relative to the current position. Positive values move the rectangle to the
+    right and downwards.
+
+    \sa moveTopLeft(), moveTo(), translated()
+*/
+
+
+/*!
+    \fn void QRectF::translate(const QPointF &offset)
+    \overload
+
+    Moves the rectangle \a{offset}.\l{QPointF::x()}{x()} along the x
+    axis and \a{offset}.\l{QPointF::y()}{y()} along the y axis,
+    relative to the current position.
+*/
+
+
+/*!
+    \fn QRectF QRectF::translated(qreal dx, qreal dy) const
+
+    Returns a copy of the rectangle that is translated \a dx along the
+    x axis and \a dy along the y axis, relative to the current
+    position. Positive values move the rectangle to the right and
+    down.
+
+    \sa translate()
+*/
+
+
+/*!
+    \fn QRectF QRectF::translated(const QPointF &offset) const
+    \overload
+
+    Returns a copy of the rectangle that is translated
+    \a{offset}.\l{QPointF::x()}{x()} along the x axis and
+    \a{offset}.\l{QPointF::y()}{y()} along the y axis, relative to the
+    current position.
+*/
+
+
+/*!
+    \fn void QRectF::setRect(qreal x, qreal y, qreal width, qreal height)
+
+    Sets the coordinates of the rectangle's top-left corner to (\a x,
+    \a y), and its size to the given \a width and \a height.
+
+    \sa getRect(), setCoords()
+*/
+
+
+/*!
+    \fn void QRectF::setCoords(qreal x1, qreal y1, qreal x2, qreal y2)
+
+    Sets the coordinates of the rectangle's top-left corner to (\a x1,
+    \a y1), and the coordinates of its bottom-right corner to (\a x2,
+    \a y2).
+
+    \sa getCoords(), setRect()
+*/
+
+/*!
+    \fn QRectF QRectF::adjusted(qreal dx1, qreal dy1, qreal dx2, qreal dy2) const
+
+    Returns a new rectangle with \a dx1, \a dy1, \a dx2 and \a dy2
+    added respectively to the existing coordinates of this rectangle.
+
+    \sa adjust()
+*/
+
+/*! \fn void QRectF::adjust(qreal dx1, qreal dy1, qreal dx2, qreal dy2)
+
+    Adds \a dx1, \a dy1, \a dx2 and \a dy2 respectively to the
+    existing coordinates of the rectangle.
+
+    \sa adjusted(), setRect()
+*/
+/*!
+    \fn QSizeF QRectF::size() const
+
+    Returns the size of the rectangle.
+
+    \sa setSize(), width(), height()
+*/
+
+/*!
+    \fn qreal QRectF::width() const
+
+    Returns the width of the rectangle.
+
+    \sa setWidth(), height(), size()
+*/
+
+/*!
+    \fn qreal QRectF::height() const
+
+    Returns the height of the rectangle.
+
+    \sa setHeight(), width(), size()
+*/
+
+/*!
+    \fn void QRectF::setWidth(qreal width)
+
+    Sets the width of the rectangle to the given \a width. The right
+    edge is changed, but not the left one.
+
+    \sa width(), setSize()
+*/
+
+
+/*!
+    \fn void QRectF::setHeight(qreal height)
+
+    Sets the height of the rectangle to the given \a height. The bottom
+    edge is changed, but not the top one.
+
+    \sa height(), setSize()
+*/
+
+
+/*!
+    \fn void QRectF::setSize(const QSizeF &size)
+
+    Sets the size of the rectangle to the given \a size. The top-left
+    corner is not moved.
+
+    \sa size(), setWidth(), setHeight()
+*/
+
+
+/*!
+    \fn bool QRectF::contains(const QPointF &point) const
+
+    Returns \c true if the given \a point is inside or on the edge of the
+    rectangle; otherwise returns \c false.
+
+    \sa intersects()
+*/
+
+bool QRectF::contains(const QPointF &p) const
+{
+    qreal l = xp;
+    qreal r = xp;
+    if (w < 0)
+        l += w;
+    else
+        r += w;
+    if (l == r) // null rect
+        return false;
+
+    if (p.x() < l || p.x() > r)
+        return false;
+
+    qreal t = yp;
+    qreal b = yp;
+    if (h < 0)
+        t += h;
+    else
+        b += h;
+    if (t == b) // null rect
+        return false;
+
+    if (p.y() < t || p.y() > b)
+        return false;
+
+    return true;
+}
+
+
+/*!
+    \fn bool QRectF::contains(qreal x, qreal y) const
+    \overload
+
+    Returns \c true if the point (\a x, \a y) is inside or on the edge of
+    the rectangle; otherwise returns \c false.
+*/
+
+/*!
+    \fn bool QRectF::contains(const QRectF &rectangle) const
+    \overload
+
+    Returns \c true if the given \a rectangle is inside this rectangle;
+    otherwise returns \c false.
+*/
+
+bool QRectF::contains(const QRectF &r) const
+{
+    qreal l1 = xp;
+    qreal r1 = xp;
+    if (w < 0)
+        l1 += w;
+    else
+        r1 += w;
+    if (l1 == r1) // null rect
+        return false;
+
+    qreal l2 = r.xp;
+    qreal r2 = r.xp;
+    if (r.w < 0)
+        l2 += r.w;
+    else
+        r2 += r.w;
+    if (l2 == r2) // null rect
+        return false;
+
+    if (l2 < l1 || r2 > r1)
+        return false;
+
+    qreal t1 = yp;
+    qreal b1 = yp;
+    if (h < 0)
+        t1 += h;
+    else
+        b1 += h;
+    if (t1 == b1) // null rect
+        return false;
+
+    qreal t2 = r.yp;
+    qreal b2 = r.yp;
+    if (r.h < 0)
+        t2 += r.h;
+    else
+        b2 += r.h;
+    if (t2 == b2) // null rect
+        return false;
+
+    if (t2 < t1 || b2 > b1)
+        return false;
+
+    return true;
+}
+
+/*!
+    \fn qreal QRectF::left() const
+
+    Returns the x-coordinate of the rectangle's left edge. Equivalent
+    to x().
+
+    \sa setLeft(), topLeft(), bottomLeft()
+*/
+
+/*!
+    \fn qreal QRectF::top() const
+
+    Returns the y-coordinate of the rectangle's top edge. Equivalent
+    to y().
+
+    \sa setTop(), topLeft(), topRight()
+*/
+
+/*!
+    \fn qreal QRectF::right() const
+
+    Returns the x-coordinate of the rectangle's right edge.
+
+    \sa setRight(), topRight(), bottomRight()
+*/
+
+/*!
+    \fn qreal QRectF::bottom() const
+
+    Returns the y-coordinate of the rectangle's bottom edge.
+
+    \sa setBottom(), bottomLeft(), bottomRight()
+*/
+
+/*!
+    \fn QPointF QRectF::topLeft() const
+
+    Returns the position of the rectangle's top-left corner.
+
+    \sa setTopLeft(), top(), left()
+*/
+
+/*!
+    \fn QPointF QRectF::bottomRight() const
+
+    Returns the position of the rectangle's  bottom-right corner.
+
+    \sa setBottomRight(), bottom(), right()
+*/
+
+/*!
+    \fn QPointF QRectF::topRight() const
+
+    Returns the position of the rectangle's top-right corner.
+
+    \sa setTopRight(), top(), right()
+*/
+
+/*!
+    \fn QPointF QRectF::bottomLeft() const
+
+    Returns the position of the rectangle's  bottom-left corner.
+
+    \sa setBottomLeft(), bottom(), left()
+*/
+
+/*!
+    \fn QRectF& QRectF::operator|=(const QRectF &rectangle)
+
+    Unites this rectangle with the given \a rectangle.
+
+    \sa united(), operator|()
+*/
+
+/*!
+    \fn QRectF& QRectF::operator&=(const QRectF &rectangle)
+
+    Intersects this rectangle with the given \a rectangle.
+
+    \sa intersected(), operator|=()
+*/
+
+
+/*!
+    \fn QRectF QRectF::operator|(const QRectF &rectangle) const
+
+    Returns the bounding rectangle of this rectangle and the given \a rectangle.
+
+    \sa united(), operator|=()
+*/
+
+QRectF QRectF::operator|(const QRectF &r) const
+{
+    if (isNull())
+        return r;
+    if (r.isNull())
+        return *this;
+
+    qreal left = xp;
+    qreal right = xp;
+    if (w < 0)
+        left += w;
+    else
+        right += w;
+
+    if (r.w < 0) {
+        left = qMin(left, r.xp + r.w);
+        right = qMax(right, r.xp);
+    } else {
+        left = qMin(left, r.xp);
+        right = qMax(right, r.xp + r.w);
+    }
+
+    qreal top = yp;
+    qreal bottom = yp;
+    if (h < 0)
+        top += h;
+    else
+        bottom += h;
+
+    if (r.h < 0) {
+        top = qMin(top, r.yp + r.h);
+        bottom = qMax(bottom, r.yp);
+    } else {
+        top = qMin(top, r.yp);
+        bottom = qMax(bottom, r.yp + r.h);
+    }
+
+    return QRectF(left, top, right - left, bottom - top);
+}
+
+/*!
+    \fn QRectF QRectF::unite(const QRectF &rectangle) const
+    \obsolete
+
+    Use united(\a rectangle) instead.
+*/
+
+/*!
+    \fn QRectF QRectF::united(const QRectF &rectangle) const
+    \since 4.2
+
+    Returns the bounding rectangle of this rectangle and the given \a
+    rectangle.
+
+    \image qrect-unite.png
+
+    \sa intersected()
+*/
+
+
+/*!
+    \fn QRectF QRectF::operator &(const QRectF &rectangle) const
+
+    Returns the intersection of this rectangle and the given \a
+    rectangle. Returns an empty rectangle if there is no intersection.
+
+    \sa operator&=(), intersected()
+*/
+
+QRectF QRectF::operator&(const QRectF &r) const
+{
+    qreal l1 = xp;
+    qreal r1 = xp;
+    if (w < 0)
+        l1 += w;
+    else
+        r1 += w;
+    if (l1 == r1) // null rect
+        return QRectF();
+
+    qreal l2 = r.xp;
+    qreal r2 = r.xp;
+    if (r.w < 0)
+        l2 += r.w;
+    else
+        r2 += r.w;
+    if (l2 == r2) // null rect
+        return QRectF();
+
+    if (l1 >= r2 || l2 >= r1)
+        return QRectF();
+
+    qreal t1 = yp;
+    qreal b1 = yp;
+    if (h < 0)
+        t1 += h;
+    else
+        b1 += h;
+    if (t1 == b1) // null rect
+        return QRectF();
+
+    qreal t2 = r.yp;
+    qreal b2 = r.yp;
+    if (r.h < 0)
+        t2 += r.h;
+    else
+        b2 += r.h;
+    if (t2 == b2) // null rect
+        return QRectF();
+
+    if (t1 >= b2 || t2 >= b1)
+        return QRectF();
+
+    QRectF tmp;
+    tmp.xp = qMax(l1, l2);
+    tmp.yp = qMax(t1, t2);
+    tmp.w = qMin(r1, r2) - tmp.xp;
+    tmp.h = qMin(b1, b2) - tmp.yp;
+    return tmp;
+}
+
+/*!
+    \fn QRectF QRectF::intersect(const QRectF &rectangle) const
+    \obsolete
+
+    Use intersected(\a rectangle) instead.
+*/
+
+/*!
+    \fn QRectF QRectF::intersected(const QRectF &rectangle) const
+    \since 4.2
+
+    Returns the intersection of this rectangle and the given \a
+    rectangle. Note that \c {r.intersected(s)} is equivalent to \c
+    {r & s}.
+
+    \image qrect-intersect.png
+
+    \sa intersects(), united(), operator&=()
+*/
+
+/*!
+    \fn bool QRectF::intersects(const QRectF &rectangle) const
+
+    Returns \c true if this rectangle intersects with the given \a
+    rectangle (i.e. there is a non-empty area of overlap between
+    them), otherwise returns \c false.
+
+    The intersection rectangle can be retrieved using the intersected()
+    function.
+
+    \sa contains()
+*/
+
+bool QRectF::intersects(const QRectF &r) const
+{
+    qreal l1 = xp;
+    qreal r1 = xp;
+    if (w < 0)
+        l1 += w;
+    else
+        r1 += w;
+    if (l1 == r1) // null rect
+        return false;
+
+    qreal l2 = r.xp;
+    qreal r2 = r.xp;
+    if (r.w < 0)
+        l2 += r.w;
+    else
+        r2 += r.w;
+    if (l2 == r2) // null rect
+        return false;
+
+    if (l1 >= r2 || l2 >= r1)
+        return false;
+
+    qreal t1 = yp;
+    qreal b1 = yp;
+    if (h < 0)
+        t1 += h;
+    else
+        b1 += h;
+    if (t1 == b1) // null rect
+        return false;
+
+    qreal t2 = r.yp;
+    qreal b2 = r.yp;
+    if (r.h < 0)
+        t2 += r.h;
+    else
+        b2 += r.h;
+    if (t2 == b2) // null rect
+        return false;
+
+    if (t1 >= b2 || t2 >= b1)
+        return false;
+
+    return true;
+}
+
+/*!
+    \fn QRect QRectF::toRect() const
+
+    Returns a QRect based on the values of this rectangle.  Note that the
+    coordinates in the returned rectangle are rounded to the nearest integer.
+
+    \sa QRectF(), toAlignedRect()
+*/
+
+/*!
+    \fn QRect QRectF::toAlignedRect() const
+    \since 4.3
+
+    Returns a QRect based on the values of this rectangle that is the
+    smallest possible integer rectangle that completely contains this
+    rectangle.
+
+    \sa toRect()
+*/
+
+QRect QRectF::toAlignedRect() const
+{
+    int xmin = int(qFloor(xp));
+    int xmax = int(qCeil(xp + w));
+    int ymin = int(qFloor(yp));
+    int ymax = int(qCeil(yp + h));
+    return QRect(xmin, ymin, xmax - xmin, ymax - ymin);
+}
+
+/*!
+    \fn void QRectF::moveCenter(const QPointF &position)
+
+    Moves the rectangle, leaving the center point at the given \a
+    position. The rectangle's size is unchanged.
+
+    \sa center()
+*/
+
+/*!
+    \fn bool operator==(const QRectF &r1, const QRectF &r2)
+    \relates QRectF
+
+    Returns \c true if the rectangles \a r1 and \a r2 are equal,
+    otherwise returns \c false.
+*/
+
+
+/*!
+    \fn bool operator!=(const QRectF &r1, const QRectF &r2)
+    \relates QRectF
+
+    Returns \c true if the rectangles \a r1 and \a r2 are different, otherwise
+    returns \c false.
+*/
+
+/*!
+    \fn QRectF operator+(const QRectF &lhs, const QMarginsF &rhs)
+    \relates QRectF
+    \since 5.3
+
+    Returns the \a lhs rectangle grown by the \a rhs margins.
+*/
+
+/*!
+    \fn QRectF operator-(const QRectF &lhs, const QMarginsF &rhs)
+    \relates QRectF
+    \since 5.3
+
+    Returns the \a lhs rectangle grown by the \a rhs margins.
+*/
+
+/*!
+    \fn QRectF operator+(const QMarginsF &lhs, const QRectF &rhs)
+    \relates QRectF
+    \overload
+    \since 5.3
+
+    Returns the \a lhs rectangle grown by the \a rhs margins.
+*/
+
+/*!
+    \fn QRectF QRectF::marginsAdded(const QMarginsF &margins) const
+    \relates QRectF
+    \since 5.3
+
+    Returns a rectangle grown by the \a margins.
+
+    \sa operator+=(), marginsRemoved(), operator-=()
+*/
+
+/*!
+    \fn QRectF QRectF::marginsRemoved(const QMarginsF &margins) const
+    \relates QRectF
+    \since 5.3
+
+    Removes the \a margins from the rectangle, shrinking it.
+
+    \sa marginsAdded(), operator+=(), operator-=()
+*/
+
+/*!
+    \fn QRectF QRectF::operator+=(const QMarginsF &margins)
+    \relates QRectF
+    \since 5.3
+
+    Adds the \a margins to the rectangle, growing it.
+
+    \sa marginsAdded(), marginsRemoved(), operator-=()
+*/
+
+/*!
+    \fn QRectF QRectF::operator-=(const QMarginsF &margins)
+    \relates QRectF
+    \since 5.3
+
+    Returns a rectangle shrunk by the \a margins.
+
+    \sa marginsRemoved(), operator+=(), marginsAdded()
+*/
+
+/*****************************************************************************
+  QRectF stream functions
+ *****************************************************************************/
+#ifndef QT_NO_DATASTREAM
+/*!
+    \fn QDataStream &operator<<(QDataStream &stream, const QRectF &rectangle)
+
+    \relates QRectF
+
+    Writes the \a rectangle to the \a stream, and returns a reference to the
+    stream.
+
+    \sa {Serializing Qt Data Types}
+*/
+
+QDataStream &operator<<(QDataStream &s, const QRectF &r)
+{
+    s << double(r.x()) << double(r.y()) << double(r.width()) << double(r.height());
+    return s;
+}
+
+/*!
+    \fn QDataStream &operator>>(QDataStream &stream, QRectF &rectangle)
+
+    \relates QRectF
+
+    Reads a \a rectangle from the \a stream, and returns a reference to the
+    stream.
+
+    \sa {Serializing Qt Data Types}
+*/
+
+QDataStream &operator>>(QDataStream &s, QRectF &r)
+{
+    double x, y, w, h;
+    s >> x;
+    s >> y;
+    s >> w;
+    s >> h;
+    r.setRect(qreal(x), qreal(y), qreal(w), qreal(h));
+    return s;
+}
+
+#endif // QT_NO_DATASTREAM
+
+
+#ifndef QT_NO_DEBUG_STREAM
+QDebug operator<<(QDebug dbg, const QRectF &r) {
+    dbg.nospace() << "QRectF(" << r.x() << ',' << r.y() << ' '
+                  << r.width() << 'x' << r.height() << ')';
+    return dbg.space();
+}
+#endif
+
+QT_END_NAMESPACE
diff --git a/.pc/inendi.patch/src/widgets/graphicsview/qgraphicsscene.cpp b/.pc/inendi.patch/src/widgets/graphicsview/qgraphicsscene.cpp
new file mode 100644
index 0000000..bccdb1f
--- /dev/null
+++ b/.pc/inendi.patch/src/widgets/graphicsview/qgraphicsscene.cpp
@@ -0,0 +1,6475 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtWidgets module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+/*!
+    \class QGraphicsScene
+    \brief The QGraphicsScene class provides a surface for managing a large
+    number of 2D graphical items.
+    \since 4.2
+    \ingroup graphicsview-api
+    \inmodule QtWidgets
+
+    The class serves as a container for QGraphicsItems. It is used together
+    with QGraphicsView for visualizing graphical items, such as lines,
+    rectangles, text, or even custom items, on a 2D surface. QGraphicsScene is
+    part of the \l{Graphics View Framework}.
+
+    QGraphicsScene also provides functionality that lets you efficiently
+    determine both the location of items, and for determining what items are
+    visible within an arbitrary area on the scene. With the QGraphicsView
+    widget, you can either visualize the whole scene, or zoom in and view only
+    parts of the scene.
+
+    Example:
+
+    \snippet code/src_gui_graphicsview_qgraphicsscene.cpp 0
+
+    Note that QGraphicsScene has no visual appearance of its own; it only
+    manages the items. You need to create a QGraphicsView widget to visualize
+    the scene.
+
+    To add items to a scene, you start off by constructing a QGraphicsScene
+    object. Then, you have two options: either add your existing QGraphicsItem
+    objects by calling addItem(), or you can call one of the convenience
+    functions addEllipse(), addLine(), addPath(), addPixmap(), addPolygon(),
+    addRect(), or addText(), which all return a pointer to the newly added item.
+    The dimensions of the items added with these functions are relative to the
+    item's coordinate system, and the items position is initialized to (0,
+    0) in the scene.
+
+    You can then visualize the scene using QGraphicsView. When the scene
+    changes, (e.g., when an item moves or is transformed) QGraphicsScene
+    emits the changed() signal. To remove an item, call removeItem().
+
+    QGraphicsScene uses an indexing algorithm to manage the location of items
+    efficiently. By default, a BSP (Binary Space Partitioning) tree is used; an
+    algorithm suitable for large scenes where most items remain static (i.e.,
+    do not move around). You can choose to disable this index by calling
+    setItemIndexMethod(). For more information about the available indexing
+    algorithms, see the itemIndexMethod property.
+
+    The scene's bounding rect is set by calling setSceneRect(). Items can be
+    placed at any position on the scene, and the size of the scene is by
+    default unlimited. The scene rect is used only for internal bookkeeping,
+    maintaining the scene's item index. If the scene rect is unset,
+    QGraphicsScene will use the bounding area of all items, as returned by
+    itemsBoundingRect(), as the scene rect. However, itemsBoundingRect() is a
+    relatively time consuming function, as it operates by collecting
+    positional information for every item on the scene. Because of this, you
+    should always set the scene rect when operating on large scenes.
+
+    One of QGraphicsScene's greatest strengths is its ability to efficiently
+    determine the location of items. Even with millions of items on the scene,
+    the items() functions can determine the location of an item within a few
+    milliseconds. There are several overloads to items(): one that finds items
+    at a certain position, one that finds items inside or intersecting with a
+    polygon or a rectangle, and more. The list of returned items is sorted by
+    stacking order, with the topmost item being the first item in the list.
+    For convenience, there is also an itemAt() function that returns the
+    topmost item at a given position.
+
+    QGraphicsScene maintains selection information for the scene. To select
+    items, call setSelectionArea(), and to clear the current selection, call
+    clearSelection(). Call selectedItems() to get the list of all selected
+    items.
+
+    \section1 Event Handling and Propagation
+
+    Another responsibility that QGraphicsScene has, is to propagate events
+    from QGraphicsView. To send an event to a scene, you construct an event
+    that inherits QEvent, and then send it using, for example,
+    QApplication::sendEvent(). event() is responsible for dispatching
+    the event to the individual items. Some common events are handled by
+    convenience event handlers. For example, key press events are handled by
+    keyPressEvent(), and mouse press events are handled by mousePressEvent().
+
+    Key events are delivered to the \e {focus item}. To set the focus item,
+    you can either call setFocusItem(), passing an item that accepts focus, or
+    the item itself can call QGraphicsItem::setFocus().  Call focusItem() to
+    get the current focus item. For compatibility with widgets, the scene also
+    maintains its own focus information. By default, the scene does not have
+    focus, and all key events are discarded. If setFocus() is called, or if an
+    item on the scene gains focus, the scene automatically gains focus. If the
+    scene has focus, hasFocus() will return true, and key events will be
+    forwarded to the focus item, if any. If the scene loses focus, (i.e.,
+    someone calls clearFocus()) while an item has focus, the scene will
+    maintain its item focus information, and once the scene regains focus, it
+    will make sure the last focus item regains focus.
+
+    For mouse-over effects, QGraphicsScene dispatches \e {hover
+    events}. If an item accepts hover events (see
+    QGraphicsItem::acceptHoverEvents()), it will receive a \l
+    {QEvent::}{GraphicsSceneHoverEnter} event when the mouse enters
+    its area. As the mouse continues moving inside the item's area,
+    QGraphicsScene will send it \l {QEvent::}{GraphicsSceneHoverMove}
+    events. When the mouse leaves the item's area, the item will
+    receive a \l {QEvent::}{GraphicsSceneHoverLeave} event.
+
+    All mouse events are delivered to the current \e {mouse grabber}
+    item. An item becomes the scene's mouse grabber if it accepts
+    mouse events (see QGraphicsItem::acceptedMouseButtons()) and it
+    receives a mouse press. It stays the mouse grabber until it
+    receives a mouse release when no other mouse buttons are
+    pressed. You can call mouseGrabberItem() to determine what item is
+    currently grabbing the mouse.
+
+    \sa QGraphicsItem, QGraphicsView
+*/
+
+/*!
+    \enum QGraphicsScene::SceneLayer
+    \since 4.3
+
+    This enum describes the rendering layers in a QGraphicsScene. When
+    QGraphicsScene draws the scene contents, it renders each of these layers
+    separately, in order.
+
+    Each layer represents a flag that can be OR'ed together when calling
+    functions such as invalidate() or QGraphicsView::invalidateScene().
+
+    \value ItemLayer The item layer. QGraphicsScene renders all items are in
+    this layer by calling the virtual function drawItems(). The item layer is
+    drawn after the background layer, but before the foreground layer.
+
+    \value BackgroundLayer The background layer. QGraphicsScene renders the
+    scene's background in this layer by calling the virtual function
+    drawBackground(). The background layer is drawn first of all layers.
+
+    \value ForegroundLayer The foreground layer. QGraphicsScene renders the
+    scene's foreground in this layer by calling the virtual function
+    drawForeground().  The foreground layer is drawn last of all layers.
+
+    \value AllLayers All layers; this value represents a combination of all
+    three layers.
+
+    \sa invalidate(), QGraphicsView::invalidateScene()
+*/
+
+/*!
+    \enum QGraphicsScene::ItemIndexMethod
+
+    This enum describes the indexing algorithms QGraphicsScene provides for
+    managing positional information about items on the scene.
+
+    \value BspTreeIndex A Binary Space Partitioning tree is applied. All
+    QGraphicsScene's item location algorithms are of an order close to
+    logarithmic complexity, by making use of binary search. Adding, moving and
+    removing items is logarithmic. This approach is best for static scenes
+    (i.e., scenes where most items do not move).
+
+    \value NoIndex No index is applied. Item location is of linear complexity,
+    as all items on the scene are searched. Adding, moving and removing items,
+    however, is done in constant time. This approach is ideal for dynamic
+    scenes, where many items are added, moved or removed continuously.
+
+    \sa setItemIndexMethod(), bspTreeDepth
+*/
+
+#include "qgraphicsscene.h"
+
+#ifndef QT_NO_GRAPHICSVIEW
+
+#include "qgraphicsitem.h"
+#include "qgraphicsitem_p.h"
+#include "qgraphicslayout.h"
+#include "qgraphicsscene_p.h"
+#include "qgraphicssceneevent.h"
+#include "qgraphicsview.h"
+#include "qgraphicsview_p.h"
+#include "qgraphicswidget.h"
+#include "qgraphicswidget_p.h"
+#include "qgraphicssceneindex_p.h"
+#include "qgraphicsscenebsptreeindex_p.h"
+#include "qgraphicsscenelinearindex_p.h"
+
+#include <QtCore/qdebug.h>
+#include <QtCore/qlist.h>
+#include <QtCore/qmath.h>
+#include <QtCore/qrect.h>
+#include <QtCore/qset.h>
+#include <QtCore/qstack.h>
+#include <QtCore/qtimer.h>
+#include <QtCore/qvarlengtharray.h>
+#include <QtCore/QMetaMethod>
+#include <QtWidgets/qapplication.h>
+#include <QtWidgets/qdesktopwidget.h>
+#include <QtGui/qevent.h>
+#include <QtWidgets/qgraphicslayout.h>
+#include <QtWidgets/qgraphicsproxywidget.h>
+#include <QtWidgets/qgraphicswidget.h>
+#include <QtGui/qmatrix.h>
+#include <QtGui/qpaintengine.h>
+#include <QtGui/qpainter.h>
+#include <QtGui/qpixmapcache.h>
+#include <QtGui/qpolygon.h>
+#include <QtWidgets/qstyleoption.h>
+#include <QtWidgets/qtooltip.h>
+#include <QtGui/qtransform.h>
+#include <QtGui/qinputmethod.h>
+#include <QtWidgets/qgraphicseffect.h>
+#include <private/qapplication_p.h>
+#include <private/qobject_p.h>
+#include <private/qgraphicseffect_p.h>
+#include <private/qgesturemanager_p.h>
+#include <private/qpathclipper_p.h>
+
+// #define GESTURE_DEBUG
+#ifndef GESTURE_DEBUG
+# define DEBUG if (0) qDebug
+#else
+# define DEBUG qDebug
+#endif
+
+QT_BEGIN_NAMESPACE
+
+bool qt_sendSpontaneousEvent(QObject *receiver, QEvent *event);
+
+static void _q_hoverFromMouseEvent(QGraphicsSceneHoverEvent *hover, const QGraphicsSceneMouseEvent *mouseEvent)
+{
+    hover->setWidget(mouseEvent->widget());
+    hover->setPos(mouseEvent->pos());
+    hover->setScenePos(mouseEvent->scenePos());
+    hover->setScreenPos(mouseEvent->screenPos());
+    hover->setLastPos(mouseEvent->lastPos());
+    hover->setLastScenePos(mouseEvent->lastScenePos());
+    hover->setLastScreenPos(mouseEvent->lastScreenPos());
+    hover->setModifiers(mouseEvent->modifiers());
+    hover->setAccepted(mouseEvent->isAccepted());
+}
+
+/*!
+    \internal
+*/
+QGraphicsScenePrivate::QGraphicsScenePrivate()
+    : indexMethod(QGraphicsScene::BspTreeIndex),
+      index(0),
+      lastItemCount(0),
+      hasSceneRect(false),
+      dirtyGrowingItemsBoundingRect(true),
+      updateAll(false),
+      calledEmitUpdated(false),
+      processDirtyItemsEmitted(false),
+      needSortTopLevelItems(true),
+      holesInTopLevelSiblingIndex(false),
+      topLevelSequentialOrdering(true),
+      scenePosDescendantsUpdatePending(false),
+      stickyFocus(false),
+      hasFocus(false),
+      lastMouseGrabberItemHasImplicitMouseGrab(false),
+      allItemsIgnoreHoverEvents(true),
+      allItemsUseDefaultCursor(true),
+      painterStateProtection(true),
+      sortCacheEnabled(false),
+      allItemsIgnoreTouchEvents(true),
+      selectionChanging(0),
+      rectAdjust(2),
+      focusItem(0),
+      lastFocusItem(0),
+      passiveFocusItem(0),
+      tabFocusFirst(0),
+      activePanel(0),
+      lastActivePanel(0),
+      activationRefCount(0),
+      childExplicitActivation(0),
+      lastMouseGrabberItem(0),
+      dragDropItem(0),
+      enterWidget(0),
+      lastDropAction(Qt::IgnoreAction),
+      style(0)
+{
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::init()
+{
+    Q_Q(QGraphicsScene);
+
+    index = new QGraphicsSceneBspTreeIndex(q);
+
+    // Keep this index so we can check for connected slots later on.
+    changedSignalIndex = signalIndex("changed(QList<QRectF>)");
+    processDirtyItemsIndex = q->metaObject()->indexOfSlot("_q_processDirtyItems()");
+    polishItemsIndex = q->metaObject()->indexOfSlot("_q_polishItems()");
+
+    qApp->d_func()->scene_list.append(q);
+    q->update();
+}
+
+/*!
+    \internal
+*/
+QGraphicsScenePrivate *QGraphicsScenePrivate::get(QGraphicsScene *q)
+{
+    return q->d_func();
+}
+
+void QGraphicsScenePrivate::_q_emitUpdated()
+{
+    Q_Q(QGraphicsScene);
+    calledEmitUpdated = false;
+
+    if (dirtyGrowingItemsBoundingRect) {
+        if (!hasSceneRect) {
+            const QRectF oldGrowingItemsBoundingRect = growingItemsBoundingRect;
+            growingItemsBoundingRect |= q->itemsBoundingRect();
+            if (oldGrowingItemsBoundingRect != growingItemsBoundingRect)
+                emit q->sceneRectChanged(growingItemsBoundingRect);
+        }
+        dirtyGrowingItemsBoundingRect = false;
+    }
+
+    // Ensure all views are connected if anything is connected. This disables
+    // the optimization that items send updates directly to the views, but it
+    // needs to happen in order to keep compatibility with the behavior from
+    // Qt 4.4 and backward.
+    if (isSignalConnected(changedSignalIndex)) {
+        for (int i = 0; i < views.size(); ++i) {
+            QGraphicsView *view = views.at(i);
+            if (!view->d_func()->connectedToScene) {
+                view->d_func()->connectedToScene = true;
+                q->connect(q, SIGNAL(changed(QList<QRectF>)),
+                           views.at(i), SLOT(updateScene(QList<QRectF>)));
+            }
+        }
+    } else {
+        if (views.isEmpty()) {
+            updateAll = false;
+            return;
+        }
+        for (int i = 0; i < views.size(); ++i)
+            views.at(i)->d_func()->processPendingUpdates();
+        // It's important that we update all views before we dispatch, hence two for-loops.
+        for (int i = 0; i < views.size(); ++i)
+            views.at(i)->d_func()->dispatchPendingUpdateRequests();
+        return;
+    }
+
+    // Notify the changes to anybody interested.
+    QList<QRectF> oldUpdatedRects;
+    oldUpdatedRects = updateAll ? (QList<QRectF>() << q->sceneRect()) : updatedRects;
+    updateAll = false;
+    updatedRects.clear();
+    emit q->changed(oldUpdatedRects);
+}
+
+/*!
+    \internal
+
+    ### This function is almost identical to QGraphicsItemPrivate::addChild().
+*/
+void QGraphicsScenePrivate::registerTopLevelItem(QGraphicsItem *item)
+{
+    item->d_ptr->ensureSequentialSiblingIndex();
+    needSortTopLevelItems = true; // ### maybe false
+    item->d_ptr->siblingIndex = topLevelItems.size();
+    topLevelItems.append(item);
+}
+
+/*!
+    \internal
+
+    ### This function is almost identical to QGraphicsItemPrivate::removeChild().
+*/
+void QGraphicsScenePrivate::unregisterTopLevelItem(QGraphicsItem *item)
+{
+    if (!holesInTopLevelSiblingIndex)
+        holesInTopLevelSiblingIndex = item->d_ptr->siblingIndex != topLevelItems.size() - 1;
+    if (topLevelSequentialOrdering && !holesInTopLevelSiblingIndex)
+        topLevelItems.removeAt(item->d_ptr->siblingIndex);
+    else
+        topLevelItems.removeOne(item);
+    // NB! Do not use topLevelItems.removeAt(item->d_ptr->siblingIndex) because
+    // the item is not guaranteed to be at the index after the list is sorted
+    // (see ensureSortedTopLevelItems()).
+    item->d_ptr->siblingIndex = -1;
+    if (topLevelSequentialOrdering)
+        topLevelSequentialOrdering = !holesInTopLevelSiblingIndex;
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::_q_polishItems()
+{
+    if (unpolishedItems.isEmpty())
+        return;
+
+    const QVariant booleanTrueVariant(true);
+    QGraphicsItem *item = 0;
+    QGraphicsItemPrivate *itemd = 0;
+    const int oldUnpolishedCount = unpolishedItems.count();
+
+    for (int i = 0; i < oldUnpolishedCount; ++i) {
+        item = unpolishedItems.at(i);
+        if (!item)
+            continue;
+        itemd = item->d_ptr.data();
+        itemd->pendingPolish = false;
+        if (!itemd->explicitlyHidden) {
+            item->itemChange(QGraphicsItem::ItemVisibleChange, booleanTrueVariant);
+            item->itemChange(QGraphicsItem::ItemVisibleHasChanged, booleanTrueVariant);
+        }
+        if (itemd->isWidget) {
+            QEvent event(QEvent::Polish);
+            QApplication::sendEvent((QGraphicsWidget *)item, &event);
+        }
+    }
+
+    if (unpolishedItems.count() == oldUnpolishedCount) {
+        // No new items were added to the vector.
+        unpolishedItems.clear();
+    } else {
+        // New items were appended; keep them and remove the old ones.
+        unpolishedItems.remove(0, oldUnpolishedCount);
+        unpolishedItems.squeeze();
+        QMetaObject::invokeMethod(q_ptr, "_q_polishItems", Qt::QueuedConnection);
+    }
+}
+
+void QGraphicsScenePrivate::_q_processDirtyItems()
+{
+    processDirtyItemsEmitted = false;
+
+    if (updateAll) {
+        Q_ASSERT(calledEmitUpdated);
+        // No need for further processing (except resetting the dirty states).
+        // The growingItemsBoundingRect is updated in _q_emitUpdated.
+        for (int i = 0; i < topLevelItems.size(); ++i)
+            resetDirtyItem(topLevelItems.at(i), /*recursive=*/true);
+        return;
+    }
+
+    const bool wasPendingSceneUpdate = calledEmitUpdated;
+    const QRectF oldGrowingItemsBoundingRect = growingItemsBoundingRect;
+
+    // Process items recursively.
+    for (int i = 0; i < topLevelItems.size(); ++i)
+        processDirtyItemsRecursive(topLevelItems.at(i));
+
+    dirtyGrowingItemsBoundingRect = false;
+    if (!hasSceneRect && oldGrowingItemsBoundingRect != growingItemsBoundingRect)
+        emit q_func()->sceneRectChanged(growingItemsBoundingRect);
+
+    if (wasPendingSceneUpdate)
+        return;
+
+    for (int i = 0; i < views.size(); ++i)
+        views.at(i)->d_func()->processPendingUpdates();
+
+    if (calledEmitUpdated) {
+        // We did a compatibility QGraphicsScene::update in processDirtyItemsRecursive
+        // and we cannot wait for the control to reach the eventloop before the
+        // changed signal is emitted, so we emit it now.
+        _q_emitUpdated();
+    }
+
+    // Immediately dispatch all pending update requests on the views.
+    for (int i = 0; i < views.size(); ++i)
+        views.at(i)->d_func()->dispatchPendingUpdateRequests();
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::setScenePosItemEnabled(QGraphicsItem *item, bool enabled)
+{
+    QGraphicsItem *p = item->d_ptr->parent;
+    while (p) {
+        p->d_ptr->scenePosDescendants = enabled;
+        p = p->d_ptr->parent;
+    }
+    if (!enabled && !scenePosDescendantsUpdatePending) {
+        scenePosDescendantsUpdatePending = true;
+        QMetaObject::invokeMethod(q_func(), "_q_updateScenePosDescendants", Qt::QueuedConnection);
+    }
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::registerScenePosItem(QGraphicsItem *item)
+{
+    scenePosItems.insert(item);
+    setScenePosItemEnabled(item, true);
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::unregisterScenePosItem(QGraphicsItem *item)
+{
+    scenePosItems.remove(item);
+    setScenePosItemEnabled(item, false);
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::_q_updateScenePosDescendants()
+{
+    foreach (QGraphicsItem *item, scenePosItems) {
+        QGraphicsItem *p = item->d_ptr->parent;
+        while (p) {
+            p->d_ptr->scenePosDescendants = 1;
+            p = p->d_ptr->parent;
+        }
+    }
+    scenePosDescendantsUpdatePending = false;
+}
+
+/*!
+    \internal
+
+    Schedules an item for removal. This function leaves some stale indexes
+    around in the BSP tree if called from the item's destructor; these will
+    be cleaned up the next time someone triggers purgeRemovedItems().
+
+    Note: This function might get called from QGraphicsItem's destructor. \a item is
+    being destroyed, so we cannot call any pure virtual functions on it (such
+    as boundingRect()). Also, it is unnecessary to update the item's own state
+    in any way.
+*/
+void QGraphicsScenePrivate::removeItemHelper(QGraphicsItem *item)
+{
+    Q_Q(QGraphicsScene);
+
+    // Clear focus on the item to remove any reference in the focusWidget chain.
+    item->clearFocus();
+
+    markDirty(item, QRectF(), /*invalidateChildren=*/false, /*force=*/false,
+              /*ignoreOpacity=*/false, /*removingItemFromScene=*/true);
+
+    if (item->d_ptr->inDestructor) {
+        // The item is actually in its destructor, we call the special method in the index.
+        index->deleteItem(item);
+    } else {
+        // Can potentially call item->boundingRect() (virtual function), that's why
+        // we only can call this function if the item is not in its destructor.
+        index->removeItem(item);
+    }
+
+    item->d_ptr->clearSubFocus();
+
+    if (item->flags() & QGraphicsItem::ItemSendsScenePositionChanges)
+        unregisterScenePosItem(item);
+
+    QGraphicsScene *oldScene = item->d_func()->scene;
+    item->d_func()->scene = 0;
+
+    //We need to remove all children first because they might use their parent
+    //attributes (e.g. sceneTransform).
+    if (!item->d_ptr->inDestructor) {
+        // Remove all children recursively
+        for (int i = 0; i < item->d_ptr->children.size(); ++i)
+            q->removeItem(item->d_ptr->children.at(i));
+    }
+
+    if (!item->d_ptr->inDestructor && !item->parentItem() && item->isWidget()) {
+        QGraphicsWidget *widget = static_cast<QGraphicsWidget *>(item);
+        widget->d_func()->fixFocusChainBeforeReparenting(0, oldScene, 0);
+    }
+
+    // Unregister focus proxy.
+    item->d_ptr->resetFocusProxy();
+
+    // Remove from parent, or unregister from toplevels.
+    if (QGraphicsItem *parentItem = item->parentItem()) {
+        if (parentItem->scene()) {
+            Q_ASSERT_X(parentItem->scene() == q, "QGraphicsScene::removeItem",
+                       "Parent item's scene is different from this item's scene");
+            item->setParentItem(0);
+        }
+    } else {
+        unregisterTopLevelItem(item);
+    }
+
+    // Reset the mouse grabber and focus item data.
+    if (item == focusItem)
+        focusItem = 0;
+    if (item == lastFocusItem)
+        lastFocusItem = 0;
+    if (item == passiveFocusItem)
+        passiveFocusItem = 0;
+    if (item == activePanel) {
+        // ### deactivate...
+        activePanel = 0;
+    }
+    if (item == lastActivePanel)
+        lastActivePanel = 0;
+
+    // Change tabFocusFirst to the next widget in focus chain if removing the current one.
+    if (item == tabFocusFirst) {
+        QGraphicsWidgetPrivate *wd = tabFocusFirst->d_func();
+        if (wd->focusNext && wd->focusNext != tabFocusFirst && wd->focusNext->scene() == q)
+            tabFocusFirst = wd->focusNext;
+        else
+            tabFocusFirst = 0;
+    }
+
+    // Cancel active touches
+    {
+        QMap<int, QGraphicsItem *>::iterator it = itemForTouchPointId.begin();
+        while (it != itemForTouchPointId.end()) {
+            if (it.value() == item) {
+                sceneCurrentTouchPoints.remove(it.key());
+                it = itemForTouchPointId.erase(it);
+            } else {
+                ++it;
+            }
+        }
+    }
+
+    // Disable selectionChanged() for individual items
+    ++selectionChanging;
+    int oldSelectedItemsSize = selectedItems.size();
+
+    // Update selected & hovered item bookkeeping
+    selectedItems.remove(item);
+    hoverItems.removeAll(item);
+    cachedItemsUnderMouse.removeAll(item);
+    if (item->d_ptr->pendingPolish) {
+        const int unpolishedIndex = unpolishedItems.indexOf(item);
+        if (unpolishedIndex != -1)
+            unpolishedItems[unpolishedIndex] = 0;
+        item->d_ptr->pendingPolish = false;
+    }
+    resetDirtyItem(item);
+
+    //We remove all references of item from the sceneEventFilter arrays
+    QMultiMap<QGraphicsItem*, QGraphicsItem*>::iterator iterator = sceneEventFilters.begin();
+    while (iterator != sceneEventFilters.end()) {
+        if (iterator.value() == item || iterator.key() == item)
+            iterator = sceneEventFilters.erase(iterator);
+        else
+            ++iterator;
+    }
+
+    if (item->isPanel() && item->isVisible() && item->panelModality() != QGraphicsItem::NonModal)
+        leaveModal(item);
+
+    // Reset the mouse grabber and focus item data.
+    if (mouseGrabberItems.contains(item))
+        ungrabMouse(item, /* item is dying */ item->d_ptr->inDestructor);
+
+    // Reset the keyboard grabber
+    if (keyboardGrabberItems.contains(item))
+        ungrabKeyboard(item, /* item is dying */ item->d_ptr->inDestructor);
+
+    // Reset the last mouse grabber item
+    if (item == lastMouseGrabberItem)
+        lastMouseGrabberItem = 0;
+
+    // Reset the current drop item
+    if (item == dragDropItem)
+        dragDropItem = 0;
+
+    // Reenable selectionChanged() for individual items
+    --selectionChanging;
+    if (!selectionChanging && selectedItems.size() != oldSelectedItemsSize)
+        emit q->selectionChanged();
+
+#ifndef QT_NO_GESTURES
+    QHash<QGesture *, QGraphicsObject *>::iterator it;
+    for (it = gestureTargets.begin(); it != gestureTargets.end();) {
+        if (it.value() == item)
+            it = gestureTargets.erase(it);
+        else
+            ++it;
+    }
+
+    QGraphicsObject *dummy = static_cast<QGraphicsObject *>(item);
+    cachedTargetItems.removeOne(dummy);
+    cachedItemGestures.remove(dummy);
+    cachedAlreadyDeliveredGestures.remove(dummy);
+
+    foreach (Qt::GestureType gesture, item->d_ptr->gestureContext.keys())
+        ungrabGesture(item, gesture);
+#endif // QT_NO_GESTURES
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::setActivePanelHelper(QGraphicsItem *item, bool duringActivationEvent)
+{
+    Q_Q(QGraphicsScene);
+    if (item && item->scene() != q) {
+        qWarning("QGraphicsScene::setActivePanel: item %p must be part of this scene",
+                 item);
+        return;
+    }
+
+    // Ensure the scene has focus when we change panel activation.
+    q->setFocus(Qt::ActiveWindowFocusReason);
+
+    // Find the item's panel.
+    QGraphicsItem *panel = item ? item->panel() : 0;
+    lastActivePanel = panel ? activePanel : 0;
+    if (panel == activePanel || (!q->isActive() && !duringActivationEvent))
+        return;
+
+    QGraphicsItem *oldFocusItem = focusItem;
+
+    // Deactivate the last active panel.
+    if (activePanel) {
+        if (QGraphicsItem *fi = activePanel->focusItem()) {
+            // Remove focus from the current focus item.
+            if (fi == q->focusItem())
+                setFocusItemHelper(0, Qt::ActiveWindowFocusReason, /* emitFocusChanged = */ false);
+        }
+
+        QEvent event(QEvent::WindowDeactivate);
+        q->sendEvent(activePanel, &event);
+    } else if (panel && !duringActivationEvent) {
+        // Deactivate the scene if changing activation to a panel.
+        QEvent event(QEvent::WindowDeactivate);
+        foreach (QGraphicsItem *item, q->items()) {
+            if (item->isVisible() && !item->isPanel() && !item->parentItem())
+                q->sendEvent(item, &event);
+        }
+    }
+
+    // Update activate state.
+    activePanel = panel;
+    QEvent event(QEvent::ActivationChange);
+    QApplication::sendEvent(q, &event);
+
+    // Activate
+    if (panel) {
+        QEvent event(QEvent::WindowActivate);
+        q->sendEvent(panel, &event);
+
+        // Set focus on the panel's focus item, or itself if it's
+        // focusable, or on the first focusable item in the panel's
+        // focus chain as a last resort.
+        if (QGraphicsItem *focusItem = panel->focusItem()) {
+            setFocusItemHelper(focusItem, Qt::ActiveWindowFocusReason, /* emitFocusChanged = */ false);
+        } else if (panel->flags() & QGraphicsItem::ItemIsFocusable) {
+            setFocusItemHelper(panel, Qt::ActiveWindowFocusReason, /* emitFocusChanged = */ false);
+        } else if (panel->isWidget()) {
+            QGraphicsWidget *fw = static_cast<QGraphicsWidget *>(panel)->d_func()->focusNext;
+            do {
+                if (fw->focusPolicy() & Qt::TabFocus) {
+                    setFocusItemHelper(fw, Qt::ActiveWindowFocusReason, /* emitFocusChanged = */ false);
+                    break;
+                }
+                fw = fw->d_func()->focusNext;
+            } while (fw != panel);
+        }
+    } else if (q->isActive()) {
+        // Activate the scene
+        QEvent event(QEvent::WindowActivate);
+        foreach (QGraphicsItem *item, q->items()) {
+            if (item->isVisible() && !item->isPanel() && !item->parentItem())
+                q->sendEvent(item, &event);
+        }
+    }
+
+    emit q->focusItemChanged(focusItem, oldFocusItem, Qt::ActiveWindowFocusReason);
+}
+
+/*!
+    \internal
+
+    \a emitFocusChanged needs to be false when focus passes from one
+    item to another through setActivePanel(); i.e. when activation
+    passes from one panel to another, to avoid getting two focusChanged()
+    emissions; one focusChanged(0, lastFocus), then one
+    focusChanged(newFocus, 0). Instead setActivePanel() emits the signal
+    once itself: focusChanged(newFocus, oldFocus).
+*/
+void QGraphicsScenePrivate::setFocusItemHelper(QGraphicsItem *item,
+                                               Qt::FocusReason focusReason,
+                                               bool emitFocusChanged)
+{
+    Q_Q(QGraphicsScene);
+    if (item == focusItem)
+        return;
+
+    // Clear focus if asked to set focus on something that can't
+    // accept input focus.
+    if (item && (!(item->flags() & QGraphicsItem::ItemIsFocusable)
+                 || !item->isVisible() || !item->isEnabled())) {
+        item = 0;
+    }
+
+    // Set focus on the scene if an item requests focus.
+    if (item) {
+        q->setFocus(focusReason);
+        if (item == focusItem) {
+            if (emitFocusChanged)
+                emit q->focusItemChanged(focusItem, (QGraphicsItem *)0, focusReason);
+            return;
+        }
+    }
+
+    QGraphicsItem *oldFocusItem = focusItem;
+    if (focusItem) {
+        lastFocusItem = focusItem;
+
+#ifndef QT_NO_IM
+        if (lastFocusItem->flags() & QGraphicsItem::ItemAcceptsInputMethod) {
+            // Close any external input method panel. This happens
+            // automatically by removing WA_InputMethodEnabled on
+            // the views, but if we are changing focus, we have to
+            // do it ourselves.
+            if (qApp)
+                qApp->inputMethod()->commit();
+        }
+#endif //QT_NO_IM
+
+        focusItem = 0;
+        QFocusEvent event(QEvent::FocusOut, focusReason);
+        sendEvent(lastFocusItem, &event);
+    }
+
+    // This handles the case that the item has been removed from the
+    // scene in response to the FocusOut event.
+    if (item && item->scene() != q)
+        item = 0;
+
+    if (item)
+        focusItem = item;
+    updateInputMethodSensitivityInViews();
+
+    if (item) {
+        QFocusEvent event(QEvent::FocusIn, focusReason);
+        sendEvent(item, &event);
+    }
+
+    if (emitFocusChanged)
+        emit q->focusItemChanged(focusItem, oldFocusItem, focusReason);
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::addPopup(QGraphicsWidget *widget)
+{
+    Q_ASSERT(widget);
+    Q_ASSERT(!popupWidgets.contains(widget));
+    popupWidgets << widget;
+    if (QGraphicsWidget *focusWidget = widget->focusWidget()) {
+        focusWidget->setFocus(Qt::PopupFocusReason);
+    } else {
+        grabKeyboard((QGraphicsItem *)widget);
+        if (focusItem && popupWidgets.size() == 1) {
+            QFocusEvent event(QEvent::FocusOut, Qt::PopupFocusReason);
+            sendEvent(focusItem, &event);
+        }
+    }
+    grabMouse((QGraphicsItem *)widget);
+}
+
+/*!
+    \internal
+
+    Remove \a widget from the popup list. Important notes:
+
+    \a widget is guaranteed to be in the list of popups, but it might not be
+    the last entry; you can hide any item in the pop list before the others,
+    and this must cause all later mouse grabbers to lose the grab.
+*/
+void QGraphicsScenePrivate::removePopup(QGraphicsWidget *widget, bool itemIsDying)
+{
+    Q_ASSERT(widget);
+    int index = popupWidgets.indexOf(widget);
+    Q_ASSERT(index != -1);
+
+    for (int i = popupWidgets.size() - 1; i >= index; --i) {
+        QGraphicsWidget *widget = popupWidgets.takeLast();
+        ungrabMouse(widget, itemIsDying);
+        if (focusItem && popupWidgets.isEmpty()) {
+            QFocusEvent event(QEvent::FocusIn, Qt::PopupFocusReason);
+            sendEvent(focusItem, &event);
+        } else if (keyboardGrabberItems.contains(static_cast<QGraphicsItem *>(widget))) {
+            ungrabKeyboard(static_cast<QGraphicsItem *>(widget), itemIsDying);
+        }
+        if (!itemIsDying && widget->isVisible()) {
+            widget->QGraphicsItem::d_ptr->setVisibleHelper(false, /* explicit = */ false);
+        }
+    }
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::grabMouse(QGraphicsItem *item, bool implicit)
+{
+    // Append to list of mouse grabber items, and send a mouse grab event.
+    if (mouseGrabberItems.contains(item)) {
+        if (mouseGrabberItems.last() == item) {
+            Q_ASSERT(!implicit);
+            if (!lastMouseGrabberItemHasImplicitMouseGrab) {
+                qWarning("QGraphicsItem::grabMouse: already a mouse grabber");
+            } else {
+                // Upgrade to an explicit mouse grab
+                lastMouseGrabberItemHasImplicitMouseGrab = false;
+            }
+        } else {
+            qWarning("QGraphicsItem::grabMouse: already blocked by mouse grabber: %p",
+                     mouseGrabberItems.last());
+        }
+        return;
+    }
+
+    // Send ungrab event to the last grabber.
+    if (!mouseGrabberItems.isEmpty()) {
+        QGraphicsItem *last = mouseGrabberItems.last();
+        if (lastMouseGrabberItemHasImplicitMouseGrab) {
+            // Implicit mouse grab is immediately lost.
+            last->ungrabMouse();
+        } else {
+            // Just send ungrab event to current grabber.
+            QEvent ungrabEvent(QEvent::UngrabMouse);
+            sendEvent(last, &ungrabEvent);
+        }
+    }
+
+    mouseGrabberItems << item;
+    lastMouseGrabberItemHasImplicitMouseGrab = implicit;
+
+    // Send grab event to current grabber.
+    QEvent grabEvent(QEvent::GrabMouse);
+    sendEvent(item, &grabEvent);
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::ungrabMouse(QGraphicsItem *item, bool itemIsDying)
+{
+    int index = mouseGrabberItems.indexOf(item);
+    if (index == -1) {
+        qWarning("QGraphicsItem::ungrabMouse: not a mouse grabber");
+        return;
+    }
+
+    if (item != mouseGrabberItems.last()) {
+        // Recursively ungrab the next mouse grabber until we reach this item
+        // to ensure state consistency.
+        ungrabMouse(mouseGrabberItems.at(index + 1), itemIsDying);
+    }
+    if (!popupWidgets.isEmpty() && item == popupWidgets.last()) {
+        // If the item is a popup, go via removePopup to ensure state
+        // consistency and that it gets hidden correctly - beware that
+        // removePopup() reenters this function to continue removing the grab.
+        removePopup((QGraphicsWidget *)item, itemIsDying);
+        return;
+    }
+
+    // Send notification about mouse ungrab.
+    if (!itemIsDying) {
+        QEvent event(QEvent::UngrabMouse);
+        sendEvent(item, &event);
+    }
+
+    // Remove the item from the list of grabbers. Whenever this happens, we
+    // reset the implicitGrab (there can be only ever be one implicit grabber
+    // in a scene, and it is always the latest grabber; if the implicit grab
+    // is lost, it is not automatically regained.
+    mouseGrabberItems.takeLast();
+    lastMouseGrabberItemHasImplicitMouseGrab = false;
+
+    // Send notification about mouse regrab. ### It's unfortunate that all the
+    // items get a GrabMouse event, but this is a rare case with a simple
+    // implementation and it does ensure a consistent state.
+    if (!itemIsDying && !mouseGrabberItems.isEmpty()) {
+        QGraphicsItem *last = mouseGrabberItems.last();
+        QEvent event(QEvent::GrabMouse);
+        sendEvent(last, &event);
+    }
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::clearMouseGrabber()
+{
+    if (!mouseGrabberItems.isEmpty())
+        mouseGrabberItems.first()->ungrabMouse();
+    lastMouseGrabberItem = 0;
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::grabKeyboard(QGraphicsItem *item)
+{
+    if (keyboardGrabberItems.contains(item)) {
+        if (keyboardGrabberItems.last() == item)
+            qWarning("QGraphicsItem::grabKeyboard: already a keyboard grabber");
+        else
+            qWarning("QGraphicsItem::grabKeyboard: already blocked by keyboard grabber: %p",
+                     keyboardGrabberItems.last());
+        return;
+    }
+
+    // Send ungrab event to the last grabber.
+    if (!keyboardGrabberItems.isEmpty()) {
+        // Just send ungrab event to current grabber.
+        QEvent ungrabEvent(QEvent::UngrabKeyboard);
+        sendEvent(keyboardGrabberItems.last(), &ungrabEvent);
+    }
+
+    keyboardGrabberItems << item;
+
+    // Send grab event to current grabber.
+    QEvent grabEvent(QEvent::GrabKeyboard);
+    sendEvent(item, &grabEvent);
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::ungrabKeyboard(QGraphicsItem *item, bool itemIsDying)
+{
+    int index = keyboardGrabberItems.lastIndexOf(item);
+    if (index == -1) {
+        qWarning("QGraphicsItem::ungrabKeyboard: not a keyboard grabber");
+        return;
+    }
+    if (item != keyboardGrabberItems.last()) {
+        // Recursively ungrab the topmost keyboard grabber until we reach this
+        // item to ensure state consistency.
+        ungrabKeyboard(keyboardGrabberItems.at(index + 1), itemIsDying);
+    }
+
+    // Send notification about keyboard ungrab.
+    if (!itemIsDying) {
+        QEvent event(QEvent::UngrabKeyboard);
+        sendEvent(item, &event);
+    }
+
+    // Remove the item from the list of grabbers.
+    keyboardGrabberItems.takeLast();
+
+    // Send notification about mouse regrab.
+    if (!itemIsDying && !keyboardGrabberItems.isEmpty()) {
+        QGraphicsItem *last = keyboardGrabberItems.last();
+        QEvent event(QEvent::GrabKeyboard);
+        sendEvent(last, &event);
+    }
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::clearKeyboardGrabber()
+{
+    if (!keyboardGrabberItems.isEmpty())
+        ungrabKeyboard(keyboardGrabberItems.first());
+}
+
+void QGraphicsScenePrivate::enableMouseTrackingOnViews()
+{
+    foreach (QGraphicsView *view, views)
+        view->viewport()->setMouseTracking(true);
+}
+
+/*!
+    Returns all items for the screen position in \a event.
+*/
+QList<QGraphicsItem *> QGraphicsScenePrivate::itemsAtPosition(const QPoint &screenPos,
+                                                              const QPointF &scenePos,
+                                                              QWidget *widget) const
+{
+    Q_Q(const QGraphicsScene);
+    QGraphicsView *view = widget ? qobject_cast<QGraphicsView *>(widget->parentWidget()) : 0;
+    if (!view)
+        return q->items(scenePos, Qt::IntersectsItemShape, Qt::DescendingOrder, QTransform());
+
+    const QRectF pointRect(QPointF(widget->mapFromGlobal(screenPos)), QSizeF(1, 1));
+    if (!view->isTransformed())
+        return q->items(pointRect, Qt::IntersectsItemShape, Qt::DescendingOrder);
+
+    const QTransform viewTransform = view->viewportTransform();
+    if (viewTransform.type() <= QTransform::TxScale) {
+        return q->items(viewTransform.inverted().mapRect(pointRect), Qt::IntersectsItemShape,
+                        Qt::DescendingOrder, viewTransform);
+    }
+    return q->items(viewTransform.inverted().map(pointRect), Qt::IntersectsItemShape,
+                    Qt::DescendingOrder, viewTransform);
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::storeMouseButtonsForMouseGrabber(QGraphicsSceneMouseEvent *event)
+{
+    for (int i = 0x1; i <= 0x10; i <<= 1) {
+        if (event->buttons() & i) {
+            mouseGrabberButtonDownPos.insert(Qt::MouseButton(i),
+                                             mouseGrabberItems.last()->d_ptr->genericMapFromScene(event->scenePos(),
+                                                                                                  event->widget()));
+            mouseGrabberButtonDownScenePos.insert(Qt::MouseButton(i), event->scenePos());
+            mouseGrabberButtonDownScreenPos.insert(Qt::MouseButton(i), event->screenPos());
+        }
+    }
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::installSceneEventFilter(QGraphicsItem *watched, QGraphicsItem *filter)
+{
+    sceneEventFilters.insert(watched, filter);
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::removeSceneEventFilter(QGraphicsItem *watched, QGraphicsItem *filter)
+{
+    if (!sceneEventFilters.contains(watched))
+        return;
+
+    QMultiMap<QGraphicsItem *, QGraphicsItem *>::Iterator it = sceneEventFilters.lowerBound(watched);
+    QMultiMap<QGraphicsItem *, QGraphicsItem *>::Iterator end = sceneEventFilters.upperBound(watched);
+    do {
+        if (it.value() == filter)
+            it = sceneEventFilters.erase(it);
+        else
+            ++it;
+    } while (it != end);
+}
+
+/*!
+  \internal
+*/
+bool QGraphicsScenePrivate::filterDescendantEvent(QGraphicsItem *item, QEvent *event)
+{
+    if (item && (item->d_ptr->ancestorFlags & QGraphicsItemPrivate::AncestorFiltersChildEvents)) {
+        QGraphicsItem *parent = item->parentItem();
+        while (parent) {
+            if (parent->d_ptr->filtersDescendantEvents && parent->sceneEventFilter(item, event))
+                return true;
+            if (!(parent->d_ptr->ancestorFlags & QGraphicsItemPrivate::AncestorFiltersChildEvents))
+                return false;
+            parent = parent->parentItem();
+        }
+    }
+    return false;
+}
+
+/*!
+    \internal
+*/
+bool QGraphicsScenePrivate::filterEvent(QGraphicsItem *item, QEvent *event)
+{
+    if (item && !sceneEventFilters.contains(item))
+        return false;
+
+    QMultiMap<QGraphicsItem *, QGraphicsItem *>::Iterator it = sceneEventFilters.lowerBound(item);
+    QMultiMap<QGraphicsItem *, QGraphicsItem *>::Iterator end = sceneEventFilters.upperBound(item);
+    while (it != end) {
+        // ### The filterer and filteree might both be deleted.
+        if (it.value()->sceneEventFilter(it.key(), event))
+            return true;
+        ++it;
+    }
+    return false;
+}
+
+/*!
+    \internal
+
+    This is the final dispatch point for any events from the scene to the
+    item. It filters the event first - if the filter returns \c true, the event
+    is considered to have been eaten by the filter, and is therefore stopped
+    (the default filter returns \c false). Then/otherwise, if the item is
+    enabled, the event is sent; otherwise it is stopped.
+*/
+bool QGraphicsScenePrivate::sendEvent(QGraphicsItem *item, QEvent *event)
+{
+    if (QGraphicsObject *object = item->toGraphicsObject()) {
+#ifndef QT_NO_GESTURES
+        QGestureManager *gestureManager = QApplicationPrivate::instance()->gestureManager;
+        if (gestureManager) {
+            if (gestureManager->filterEvent(object, event))
+                return true;
+        }
+#endif // QT_NO_GESTURES
+    }
+
+    if (filterEvent(item, event))
+        return false;
+    if (filterDescendantEvent(item, event))
+        return false;
+    if (!item || !item->isEnabled())
+        return false;
+    if (QGraphicsObject *o = item->toGraphicsObject()) {
+        bool spont = event->spontaneous();
+        if (spont ? qt_sendSpontaneousEvent(o, event) : QApplication::sendEvent(o, event))
+            return true;
+        event->spont = spont;
+    }
+    return item->sceneEvent(event);
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::cloneDragDropEvent(QGraphicsSceneDragDropEvent *dest,
+                                               QGraphicsSceneDragDropEvent *source)
+{
+    dest->setWidget(source->widget());
+    dest->setPos(source->pos());
+    dest->setScenePos(source->scenePos());
+    dest->setScreenPos(source->screenPos());
+    dest->setButtons(source->buttons());
+    dest->setModifiers(source->modifiers());
+    dest->setPossibleActions(source->possibleActions());
+    dest->setProposedAction(source->proposedAction());
+    dest->setDropAction(source->dropAction());
+    dest->setSource(source->source());
+    dest->setMimeData(source->mimeData());
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::sendDragDropEvent(QGraphicsItem *item,
+                                              QGraphicsSceneDragDropEvent *dragDropEvent)
+{
+    dragDropEvent->setPos(item->d_ptr->genericMapFromScene(dragDropEvent->scenePos(), dragDropEvent->widget()));
+    sendEvent(item, dragDropEvent);
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::sendHoverEvent(QEvent::Type type, QGraphicsItem *item,
+                                           QGraphicsSceneHoverEvent *hoverEvent)
+{
+    QGraphicsSceneHoverEvent event(type);
+    event.setWidget(hoverEvent->widget());
+    event.setPos(item->d_ptr->genericMapFromScene(hoverEvent->scenePos(), hoverEvent->widget()));
+    event.setScenePos(hoverEvent->scenePos());
+    event.setScreenPos(hoverEvent->screenPos());
+    event.setLastPos(item->d_ptr->genericMapFromScene(hoverEvent->lastScenePos(), hoverEvent->widget()));
+    event.setLastScenePos(hoverEvent->lastScenePos());
+    event.setLastScreenPos(hoverEvent->lastScreenPos());
+    event.setModifiers(hoverEvent->modifiers());
+    sendEvent(item, &event);
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::sendMouseEvent(QGraphicsSceneMouseEvent *mouseEvent)
+{
+    if (mouseEvent->button() == 0 && mouseEvent->buttons() == 0 && lastMouseGrabberItemHasImplicitMouseGrab) {
+        // ### This is a temporary fix for until we get proper mouse
+        // grab events.
+        clearMouseGrabber();
+        return;
+    }
+
+    QGraphicsItem *item = mouseGrabberItems.last();
+    if (item->isBlockedByModalPanel())
+        return;
+
+    for (int i = 0x1; i <= 0x10; i <<= 1) {
+        Qt::MouseButton button = Qt::MouseButton(i);
+        mouseEvent->setButtonDownPos(button, mouseGrabberButtonDownPos.value(button, item->d_ptr->genericMapFromScene(mouseEvent->scenePos(), mouseEvent->widget())));
+        mouseEvent->setButtonDownScenePos(button, mouseGrabberButtonDownScenePos.value(button, mouseEvent->scenePos()));
+        mouseEvent->setButtonDownScreenPos(button, mouseGrabberButtonDownScreenPos.value(button, mouseEvent->screenPos()));
+    }
+    mouseEvent->setPos(item->d_ptr->genericMapFromScene(mouseEvent->scenePos(), mouseEvent->widget()));
+    mouseEvent->setLastPos(item->d_ptr->genericMapFromScene(mouseEvent->lastScenePos(), mouseEvent->widget()));
+    sendEvent(item, mouseEvent);
+}
+
+/*!
+    \internal
+*/
+void QGraphicsScenePrivate::mousePressEventHandler(QGraphicsSceneMouseEvent *mouseEvent)
+{
+    Q_Q(QGraphicsScene);
+
+    // Ignore by default, unless we find a mouse grabber that accepts it.
+    mouseEvent->ignore();
+
+    // Deliver to any existing mouse grabber.
+    if (!mouseGrabberItems.isEmpty()) {
+        if (mouseGrabberItems.last()->isBlockedByModalPanel())
+            return;
+        // The event is ignored by default, but we disregard the event's
+        // accepted state after delivery; the mouse is grabbed, after all.
+        sendMouseEvent(mouseEvent);
+        return;
+    }
+
+    // Start by determining the number of items at the current position.
+    // Reuse value from earlier calculations if possible.
+    if (cachedItemsUnderMouse.isEmpty()) {
+        cachedItemsUnderMouse = itemsAtPosition(mouseEvent->screenPos(),
+                                                mouseEvent->scenePos(),
+                                                mouseEvent->widget());
+    }
+
+    // Update window activation.
+    QGraphicsItem *topItem = cachedItemsUnderMouse.value(0);
+    QGraphicsWidget *newActiveWindow = topItem ? topItem->window() : 0;
+    if (newActiveWindow && newActiveWindow->isBlockedByModalPanel(&topItem)) {
+        // pass activation to the blocking modal window
+        newActiveWindow = topItem ? topItem->window() : 0;
+    }
+
+    if (newActiveWindow != q->activeWindow())
+        q->setActiveWindow(newActiveWindow);
+
+    // Set focus on the topmost enabled item that can take focus.
+    bool setFocus = false;
+
+    foreach (QGraphicsItem *item, cachedItemsUnderMouse) {
+        if (item->isBlockedByModalPanel()
+            || (item->d_ptr->flags & QGraphicsItem::ItemStopsFocusHandling)) {
+            // Make sure we don't clear focus.
+            setFocus = true;
+            break;
+        }
+        if (item->isEnabled() && ((item->flags() & QGraphicsItem::ItemIsFocusable))) {
+            if (!item->isWidget() || ((QGraphicsWidget *)item)->focusPolicy() & Qt::ClickFocus) {
+                setFocus = true;
+                if (item != q->focusItem() && item->d_ptr->mouseSetsFocus)
+                    q->setFocusItem(item, Qt::MouseFocusReason);
+                break;
+            }
+        }
+        if (item->isPanel())
+            break;
+        if (item->d_ptr->flags & QGraphicsItem::ItemStopsClickFocusPropagation)
+            break;
+    }
+
+    // Check for scene modality.
+    bool sceneModality = false;
+    for (int i = 0; i < modalPanels.size(); ++i) {
+        if (modalPanels.at(i)->panelModality() == QGraphicsItem::SceneModal) {
+            sceneModality = true;
+            break;
+        }
+    }
+
+    // If nobody could take focus, clear it.
+    if (!stickyFocus && !setFocus && !sceneModality)
+        q->setFocusItem(0, Qt::MouseFocusReason);
+
+    // Any item will do.
+    if (sceneModality && cachedItemsUnderMouse.isEmpty())
+        cachedItemsUnderMouse << modalPanels.first();
+
+    // Find a mouse grabber by sending mouse press events to all mouse grabber
+    // candidates one at a time, until the event is accepted. It's accepted by
+    // default, so the receiver has to explicitly ignore it for it to pass
+    // through.
+    foreach (QGraphicsItem *item, cachedItemsUnderMouse) {
+        if (!(item->acceptedMouseButtons() & mouseEvent->button())) {
+            // Skip items that don't accept the event's mouse button.
+            continue;
+        }
+
+        // Check if this item is blocked by a modal panel and deliver the mouse event to the
+        // blocking panel instead of this item if blocked.
+        (void) item->isBlockedByModalPanel(&item);
+
+        grabMouse(item, /* implicit = */ true);
+        mouseEvent->accept();
+
+        // check if the item we are sending to are disabled (before we send the event)
+        bool disabled = !item->isEnabled();
+        bool isPanel = item->isPanel();
+        if (mouseEvent->type() == QEvent::GraphicsSceneMouseDoubleClick
+            && item != lastMouseGrabberItem && lastMouseGrabberItem) {
+            // If this item is different from the item that received the last
+            // mouse event, and mouseEvent is a doubleclick event, then the
+            // event is converted to a press. Known limitation:
+            // Triple-clicking will not generate a doubleclick, though.
+            QGraphicsSceneMouseEvent mousePress(QEvent::GraphicsSceneMousePress);
+            mousePress.spont = mouseEvent->spont;
+            mousePress.accept();
+            mousePress.setButton(mouseEvent->button());
+            mousePress.setButtons(mouseEvent->buttons());
+            mousePress.setScreenPos(mouseEvent->screenPos());
+            mousePress.setScenePos(mouseEvent->scenePos());
+            mousePress.setModifiers(mouseEvent->modifiers());
+            mousePress.setWidget(mouseEvent->widget());
+            mousePress.setButtonDownPos(mouseEvent->button(),
+                                        mouseEvent->buttonDownPos(mouseEvent->button()));
+            mousePress.setButtonDownScenePos(mouseEvent->button(),
+                                             mouseEvent->buttonDownScenePos(mouseEvent->button()));
+            mousePress.setButtonDownScreenPos(mouseEvent->button(),
+                                              mouseEvent->buttonDownScreenPos(mouseEvent->button()));
+            sendMouseEvent(&mousePress);
+            mouseEvent->setAccepted(mousePress.isAccepted());
+        } else {
+            sendMouseEvent(mouseEvent);
+        }
+
+        bool dontSendUngrabEvents = mouseGrabberItems.isEmpty() || mouseGrabberItems.last() != item;
+        if (disabled) {
+            ungrabMouse(item, /* itemIsDying = */ dontSendUngrabEvents);
+            break;
+        }
+        if (mouseEvent->isAccepted()) {
+            if (!mouseGrabberItems.isEmpty())
+                storeMouseButtonsForMouseGrabber(mouseEvent);
+            lastMouseGrabberItem = item;
+            return;
+        }
+        ungrabMouse(item, /* itemIsDying = */ dontSendUngrabEvents);
+
+        // Don't propagate through panels.
+        if (isPanel)
+            break;
+    }
+
+    // Is the event still ignored? Then the mouse press goes to the scene.
+    // Reset the mouse grabber, clear the selection, clear focus, and leave
+    // the event ignored so that it can propagate through the originating
+    // view.
+    if (!mouseEvent->isAccepted()) {
+        clearMouseGrabber();
+
+        QGraphicsView *view = mouseEvent->widget() ? qobject_cast<QGraphicsView *>(mouseEvent->widget()->parentWidget()) : 0;
+        bool dontClearSelection = view && view->dragMode() == QGraphicsView::ScrollHandDrag;
+        if (!dontClearSelection) {
+            // Clear the selection if the originating view isn't in scroll
+            // hand drag mode. The view will clear the selection if no drag
+            // happened.
+            q->clearSelection();
+        }
+    }
+}
+
+/*!
+    \internal
+
+    Ensures that the list of toplevels is sorted by insertion order, and that
+    the siblingIndexes are packed (no gaps), and start at 0.
+
+    ### This function is almost identical to
+    QGraphicsItemPrivate::ensureSequentialSiblingIndex().
+*/
+void QGraphicsScenePrivate::ensureSequentialTopLevelSiblingIndexes()
+{
+    if (!topLevelSequentialOrdering) {
+        std::sort(topLevelItems.begin(), topLevelItems.end(), QGraphicsItemPrivate::insertionOrder);
+        topLevelSequentialOrdering = true;
+        needSortTopLevelItems = 1;
+    }
+    if (holesInTopLevelSiblingIndex) {
+        holesInTopLevelSiblingIndex = 0;
+        for (int i = 0; i < topLevelItems.size(); ++i)
+            topLevelItems[i]->d_ptr->siblingIndex = i;
+    }
+}
+
+/*!
+    \internal
+
+    Set the font and propagate the changes if the font is different from the
+    current font.
+*/
+void QGraphicsScenePrivate::setFont_helper(const QFont &font)
+{
+    if (this->font == font && this->font.resolve() == font.resolve())
+        return;
+    updateFont(font);
+}
+
+/*!
+    \internal
+
+    Resolve the scene's font against the application font, and propagate the
+    changes too all items in the scene.
+*/
+void QGraphicsScenePrivate::resolveFont()
+{
+    QFont naturalFont = QApplication::font();
+    naturalFont.resolve(0);
+    QFont resolvedFont = font.resolve(naturalFont);
+    updateFont(resolvedFont);
+}
+
+/*!
+    \internal
+
+    Update the font, and whether or not it has changed, reresolve all fonts in
+    the scene.
+*/
+void QGraphicsScenePrivate::updateFont(const QFont &font)
+{
+    Q_Q(QGraphicsScene);
+
+    // Update local font setting.
+    this->font = font;
+
+    // Resolve the fonts of all top-level widget items, or widget items
+    // whose parent is not a widget.
+    foreach (QGraphicsItem *item, q->items()) {
+        if (!item->parentItem()) {
+            // Resolvefont for an item is a noop operation, but
+            // every item can be a widget, or can have a widget
+            // childre.
+            item->d_ptr->resolveFont(font.resolve());
+        }
+    }
+
+    // Send the scene a FontChange event.
+    QEvent event(QEvent::FontChange);
+    QApplication::sendEvent(q, &event);
+}
+
+/*!
+    \internal
+
+    Set the palette and propagate the changes if the palette is different from
+    the current palette.
+*/
+void QGraphicsScenePrivate::setPalette_helper(const QPalette &palette)
+{
+    if (this->palette == palette && this->palette.resolve() == palette.resolve())
+        return;
+    updatePalette(palette);
+}
+
+/*!
+    \internal
+
+    Resolve the scene's palette against the application palette, and propagate
+    the changes too all items in the scene.
+*/
+void QGraphicsScenePrivate::resolvePalette()
+{
+    QPalette naturalPalette = QApplication::palette();
+    naturalPalette.resolve(0);
+    QPalette resolvedPalette = palette.resolve(naturalPalette);
+    updatePalette(resolvedPalette);
+}
+
+/*!
+    \internal
+
+    Update the palette, and whether or not it has changed, reresolve all
+    palettes in the scene.
+*/
+void QGraphicsScenePrivate::updatePalette(const QPalette &palette)
+{
+    Q_Q(QGraphicsScene);
+
+    // Update local palette setting.
+    this->palette = palette;
+
+    // Resolve the palettes of all top-level widget items, or widget items
+    // whose parent is not a widget.
+    foreach (QGraphicsItem *item, q->items()) {
+        if (!item->parentItem()) {
+            // Resolvefont for an item is a noop operation, but
+            // every item can be a widget, or can have a widget
+            // childre.
+            item->d_ptr->resolvePalette(palette.resolve());
+        }
+    }
+
+    // Send the scene a PaletteChange event.
+    QEvent event(QEvent::PaletteChange);
+    QApplication::sendEvent(q, &event);
+}
+
+/*!
+    Constructs a QGraphicsScene object. The \a parent parameter is
+    passed to QObject's constructor.
+*/
+QGraphicsScene::QGraphicsScene(QObject *parent)
+    : QObject(*new QGraphicsScenePrivate, parent)
+{
+    d_func()->init();
+}
+
+/*!
+    Constructs a QGraphicsScene object, using \a sceneRect for its
+    scene rectangle. The \a parent parameter is passed to QObject's
+    constructor.
+
+    \sa sceneRect
+*/
+QGraphicsScene::QGraphicsScene(const QRectF &sceneRect, QObject *parent)
+    : QObject(*new QGraphicsScenePrivate, parent)
+{
+    d_func()->init();
+    setSceneRect(sceneRect);
+}
+
+/*!
+    Constructs a QGraphicsScene object, using the rectangle specified
+    by (\a x, \a y), and the given \a width and \a height for its
+    scene rectangle. The \a parent parameter is passed to QObject's
+    constructor.
+
+    \sa sceneRect
+*/
+QGraphicsScene::QGraphicsScene(qreal x, qreal y, qreal width, qreal height, QObject *parent)
+    : QObject(*new QGraphicsScenePrivate, parent)
+{
+    d_func()->init();
+    setSceneRect(x, y, width, height);
+}
+
+/*!
+  Removes and deletes all items from the scene object
+  before destroying the scene object. The scene object
+  is removed from the application's global scene list,
+  and it is removed from all associated views.
+*/
+QGraphicsScene::~QGraphicsScene()
+{
+    Q_D(QGraphicsScene);
+
+    // Remove this scene from qApp's global scene list.
+    if (!QApplicationPrivate::is_app_closing)
+        qApp->d_func()->scene_list.removeAll(this);
+
+    clear();
+
+    // Remove this scene from all associated views.
+    for (int j = 0; j < d->views.size(); ++j)
+        d->views.at(j)->setScene(0);
+}
+
+/*!
+    \property QGraphicsScene::sceneRect
+    \brief the scene rectangle; the bounding rectangle of the scene
+
+    The scene rectangle defines the extent of the scene. It is
+    primarily used by QGraphicsView to determine the view's default
+    scrollable area, and by QGraphicsScene to manage item indexing.
+
+    If unset, or if set to a null QRectF, sceneRect() will return the largest
+    bounding rect of all items on the scene since the scene was created (i.e.,
+    a rectangle that grows when items are added to or moved in the scene, but
+    never shrinks).
+
+    \sa width(), height(), QGraphicsView::sceneRect
+*/
+QRectF QGraphicsScene::sceneRect() const
+{
+    Q_D(const QGraphicsScene);
+    if (d->hasSceneRect)
+        return d->sceneRect;
+
+    if (d->dirtyGrowingItemsBoundingRect) {
+        // Lazily update the growing items bounding rect
+        QGraphicsScenePrivate *thatd = const_cast<QGraphicsScenePrivate *>(d);
+        QRectF oldGrowingBoundingRect = thatd->growingItemsBoundingRect;
+        thatd->growingItemsBoundingRect |= itemsBoundingRect();
+        thatd->dirtyGrowingItemsBoundingRect = false;
+        if (oldGrowingBoundingRect != thatd->growingItemsBoundingRect)
+            emit const_cast<QGraphicsScene *>(this)->sceneRectChanged(thatd->growingItemsBoundingRect);
+    }
+    return d->growingItemsBoundingRect;
+}
+void QGraphicsScene::setSceneRect(const QRectF &rect)
+{
+    Q_D(QGraphicsScene);
+    if (rect != d->sceneRect) {
+        d->hasSceneRect = !rect.isNull();
+        d->sceneRect = rect;
+        emit sceneRectChanged(d->hasSceneRect ? rect : d->growingItemsBoundingRect);
+    }
+}
+
+/*!
+     \fn qreal QGraphicsScene::width() const
+
+     This convenience function is equivalent to calling sceneRect().width().
+
+     \sa height()
+*/
+
+/*!
+     \fn qreal QGraphicsScene::height() const
+
+     This convenience function is equivalent to calling \c sceneRect().height().
+
+     \sa width()
+*/
+
+/*!
+    Renders the \a source rect from scene into \a target, using \a painter. This
+    function is useful for capturing the contents of the scene onto a paint
+    device, such as a QImage (e.g., to take a screenshot), or for printing
+    with QPrinter. For example:
+
+    \snippet code/src_gui_graphicsview_qgraphicsscene.cpp 1
+
+    If \a source is a null rect, this function will use sceneRect() to
+    determine what to render. If \a target is a null rect, the dimensions of \a
+    painter's paint device will be used.
+
+    The source rect contents will be transformed according to \a
+    aspectRatioMode to fit into the target rect. By default, the aspect ratio
+    is kept, and \a source is scaled to fit in \a target.
+
+    \sa QGraphicsView::render()
+*/
+void QGraphicsScene::render(QPainter *painter, const QRectF &target, const QRectF &source,
+                            Qt::AspectRatioMode aspectRatioMode)
+{
+    // ### Switch to using the recursive rendering algorithm instead.
+
+    // Default source rect = scene rect
+    QRectF sourceRect = source;
+    if (sourceRect.isNull())
+        sourceRect = sceneRect();
+
+    // Default target rect = device rect
+    QRectF targetRect = target;
+    if (targetRect.isNull()) {
+        if (painter->device()->devType() == QInternal::Picture)
+            targetRect = sourceRect;
+        else
+            targetRect.setRect(0, 0, painter->device()->width(), painter->device()->height());
+    }
+
+    // Find the ideal x / y scaling ratio to fit \a source into \a target.
+    qreal xratio = targetRect.width() / sourceRect.width();
+    qreal yratio = targetRect.height() / sourceRect.height();
+
+    // Scale according to the aspect ratio mode.
+    switch (aspectRatioMode) {
+    case Qt::KeepAspectRatio:
+        xratio = yratio = qMin(xratio, yratio);
+        break;
+    case Qt::KeepAspectRatioByExpanding:
+        xratio = yratio = qMax(xratio, yratio);
+        break;
+    case Qt::IgnoreAspectRatio:
+        break;
+    }
+
+    // Find all items to draw, and reverse the list (we want to draw
+    // in reverse order).
+    QList<QGraphicsItem *> itemList = items(sourceRect, Qt::IntersectsItemBoundingRect);
+    QGraphicsItem **itemArray = new QGraphicsItem *[itemList.size()];
+    int numItems = itemList.size();
+    for (int i = 0; i < numItems; ++i)
+        itemArray[numItems - i - 1] = itemList.at(i);
+    itemList.clear();
+
+    painter->save();
+
+    // Transform the painter.
+    painter->setClipRect(targetRect, Qt::IntersectClip);
+    QTransform painterTransform;
+    painterTransform *= QTransform()
+                        .translate(targetRect.left(), targetRect.top())
+                        .scale(xratio, yratio)
+                        .translate(-sourceRect.left(), -sourceRect.top());
+    painter->setWorldTransform(painterTransform, true);
+
+    // Generate the style options
+    QStyleOptionGraphicsItem *styleOptionArray = new QStyleOptionGraphicsItem[numItems];
+    for (int i = 0; i < numItems; ++i)
+        itemArray[i]->d_ptr->initStyleOption(&styleOptionArray[i], painterTransform, targetRect.toRect());
+
+    // Render the scene.
+    drawBackground(painter, sourceRect);
+    drawItems(painter, numItems, itemArray, styleOptionArray);
+    drawForeground(painter, sourceRect);
+
+    delete [] itemArray;
+    delete [] styleOptionArray;
+
+    painter->restore();
+}
+
+/*!
+    \property QGraphicsScene::itemIndexMethod
+    \brief the item indexing method.
+
+    QGraphicsScene applies an indexing algorithm to the scene, to speed up
+    item discovery functions like items() and itemAt(). Indexing is most
+    efficient for static scenes (i.e., where items don't move around). For
+    dynamic scenes, or scenes with many animated items, the index bookkeeping
+    can outweight the fast lookup speeds.
+
+    For the common case, the default index method BspTreeIndex works fine.  If
+    your scene uses many animations and you are experiencing slowness, you can
+    disable indexing by calling \c setItemIndexMethod(NoIndex).
+
+    \sa bspTreeDepth
+*/
+QGraphicsScene::ItemIndexMethod QGraphicsScene::itemIndexMethod() const
+{
+    Q_D(const QGraphicsScene);
+    return d->indexMethod;
+}
+void QGraphicsScene::setItemIndexMethod(ItemIndexMethod method)
+{
+    Q_D(QGraphicsScene);
+    if (d->indexMethod == method)
+        return;
+
+    d->indexMethod = method;
+
+    QList<QGraphicsItem *> oldItems = d->index->items(Qt::DescendingOrder);
+    delete d->index;
+    if (method == BspTreeIndex)
+        d->index = new QGraphicsSceneBspTreeIndex(this);
+    else
+        d->index = new QGraphicsSceneLinearIndex(this);
+    for (int i = oldItems.size() - 1; i >= 0; --i)
+        d->index->addItem(oldItems.at(i));
+}
+
+/*!
+    \property QGraphicsScene::bspTreeDepth
+    \brief the depth of QGraphicsScene's BSP index tree
+    \since 4.3
+
+    This property has no effect when NoIndex is used.
+
+    This value determines the depth of QGraphicsScene's BSP tree. The depth
+    directly affects QGraphicsScene's performance and memory usage; the latter
+    growing exponentially with the depth of the tree. With an optimal tree
+    depth, QGraphicsScene can instantly determine the locality of items, even
+    for scenes with thousands or millions of items. This also greatly improves
+    rendering performance.
+
+    By default, the value is 0, in which case Qt will guess a reasonable
+    default depth based on the size, location and number of items in the
+    scene. If these parameters change frequently, however, you may experience
+    slowdowns as QGraphicsScene retunes the depth internally. You can avoid
+    potential slowdowns by fixating the tree depth through setting this
+    property.
+
+    The depth of the tree and the size of the scene rectangle decide the
+    granularity of the scene's partitioning. The size of each scene segment is
+    determined by the following algorithm:
+
+    \snippet code/src_gui_graphicsview_qgraphicsscene.cpp 2
+
+    The BSP tree has an optimal size when each segment contains between 0 and
+    10 items.
+
+    \sa itemIndexMethod
+*/
+int QGraphicsScene::bspTreeDepth() const
+{
+    Q_D(const QGraphicsScene);
+    QGraphicsSceneBspTreeIndex *bspTree = qobject_cast<QGraphicsSceneBspTreeIndex *>(d->index);
+    return bspTree ? bspTree->bspTreeDepth() : 0;
+}
+void QGraphicsScene::setBspTreeDepth(int depth)
+{
+    Q_D(QGraphicsScene);
+    if (depth < 0) {
+        qWarning("QGraphicsScene::setBspTreeDepth: invalid depth %d ignored; must be >= 0", depth);
+        return;
+    }
+
+    QGraphicsSceneBspTreeIndex *bspTree = qobject_cast<QGraphicsSceneBspTreeIndex *>(d->index);
+    if (!bspTree) {
+        qWarning("QGraphicsScene::setBspTreeDepth: can not apply if indexing method is not BSP");
+        return;
+    }
+    bspTree->setBspTreeDepth(depth);
+}
+
+/*!
+    \property QGraphicsScene::sortCacheEnabled
+    \brief whether sort caching is enabled
+    \since 4.5
+    \obsolete
+
+    Since Qt 4.6, this property has no effect.
+*/
+bool QGraphicsScene::isSortCacheEnabled() const
+{
+    Q_D(const QGraphicsScene);
+    return d->sortCacheEnabled;
+}
+void QGraphicsScene::setSortCacheEnabled(bool enabled)
+{
+    Q_D(QGraphicsScene);
+    if (d->sortCacheEnabled == enabled)
+        return;
+    d->sortCacheEnabled = enabled;
+}
+
+/*!
+    Calculates and returns the bounding rect of all items on the scene. This
+    function works by iterating over all items, and because of this, it can
+    be slow for large scenes.
+
+    \sa sceneRect()
+*/
+QRectF QGraphicsScene::itemsBoundingRect() const
+{
+    // Does not take untransformable items into account.
+    QRectF boundingRect;
+    foreach (QGraphicsItem *item, items())
+        boundingRect |= item->sceneBoundingRect();
+    return boundingRect;
+}
+
+/*!
+    Returns an ordered list of all items on the scene. \a order decides the
+    stacking order.
+
+    \sa addItem(), removeItem(), {QGraphicsItem#Sorting}{Sorting}
+*/
+QList<QGraphicsItem *> QGraphicsScene::items(Qt::SortOrder order) const
+{
+    Q_D(const QGraphicsScene);
+    return d->index->items(order);
+}
+
+/*!
+    \fn QList<QGraphicsItem *> QGraphicsScene::items(qreal x, qreal y, qreal w, qreal h, Qt::ItemSelectionMode mode) const
+    \obsolete
+    \since 4.3
+
+    This convenience function is equivalent to calling items(QRectF(\a x, \a y, \a w, \a h), \a mode).
+
+    This function is deprecated and returns incorrect results if the scene
+    contains items that ignore transformations. Use the overload that takes
+    a QTransform instead.
+*/
+
+/*!
+    \fn QList<QGraphicsItem *> QGraphicsScene::items(qreal x, qreal y, qreal w, qreal h, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &deviceTransform) const
+    \overload
+    \since 4.6
+
+    \brief Returns all visible items that, depending on \a mode, are
+    either inside or intersect with the rectangle defined by \a x, \a y,
+    \a w and \a h, in a list sorted using \a order. In this case, "visible" defines items for which:
+    isVisible() returns \c true, effectiveOpacity() returns a value greater than 0.0
+    (which is fully transparent) and the parent item does not clip it.
+
+    \a deviceTransform is the transformation that applies to the view, and needs to
+    be provided if the scene contains items that ignore transformations.
+*/
+
+/*!
+    \fn QList<QGraphicsItem *> QGraphicsScene::items(const QPointF &pos, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &deviceTransform) const
+    \since 4.6
+
+    \brief Returns all visible items that, depending on \a mode, are at
+    the specified \a pos in a list sorted using \a order. In this case, "visible" defines items for which:
+    isVisible() returns \c true, effectiveOpacity() returns a value greater than 0.0
+    (which is fully transparent) and the parent item does not clip it.
+
+    The default value for \a mode is Qt::IntersectsItemShape; all items whose
+    exact shape intersects with \a pos are returned.
+
+    \a deviceTransform is the transformation that applies to the view, and needs to
+    be provided if the scene contains items that ignore transformations.
+
+    \sa itemAt(), {QGraphicsItem#Sorting}{Sorting}
+*/
+QList<QGraphicsItem *> QGraphicsScene::items(const QPointF &pos, Qt::ItemSelectionMode mode,
+                                             Qt::SortOrder order, const QTransform &deviceTransform) const
+{
+    Q_D(const QGraphicsScene);
+    return d->index->items(pos, mode, order, deviceTransform);
+}
+
+/*!
+    \fn QList<QGraphicsItem *> QGraphicsScene::items(const QRectF &rect, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &deviceTransform) const
+    \overload
+    \since 4.6
+
+    \brief Returns all visible items that, depending on \a mode, are
+    either inside or intersect with the specified \a rect, in a
+    list sorted using \a order. In this case, "visible" defines items for which:
+    isVisible() returns \c true, effectiveOpacity() returns a value greater than 0.0
+    (which is fully transparent) and the parent item does not clip it.
+
+    The default value for \a mode is Qt::IntersectsItemShape; all items whose
+    exact shape intersects with or is contained by \a rect are returned.
+
+    \a deviceTransform is the transformation that applies to the view, and needs to
+    be provided if the scene contains items that ignore transformations.
+
+    \sa itemAt(), {QGraphicsItem#Sorting}{Sorting}
+*/
+QList<QGraphicsItem *> QGraphicsScene::items(const QRectF &rect, Qt::ItemSelectionMode mode,
+                                             Qt::SortOrder order, const QTransform &deviceTransform) const
+{
+    Q_D(const QGraphicsScene);
+    return d->index->items(rect, mode, order, deviceTransform);
+}
+
+/*!
+    \fn QList<QGraphicsItem *> QGraphicsScene::items(const QPolygonF &polygon, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &deviceTransform) const
+    \overload
+    \since 4.6
+
+    \brief Returns all visible items that, depending on \a mode, are
+    either inside or intersect with the specified \a polygon, in
+    a list sorted using \a order. In this case, "visible" defines items for which:
+    isVisible() returns \c true, effectiveOpacity() returns a value greater than 0.0
+    (which is fully transparent) and the parent item does not clip it.
+
+    The default value for \a mode is Qt::IntersectsItemShape; all items whose
+    exact shape intersects with or is contained by \a polygon are returned.
+
+    \a deviceTransform is the transformation that applies to the view, and needs to
+    be provided if the scene contains items that ignore transformations.
+
+    \sa itemAt(), {QGraphicsItem#Sorting}{Sorting}
+*/
+QList<QGraphicsItem *> QGraphicsScene::items(const QPolygonF &polygon, Qt::ItemSelectionMode mode,
+                                             Qt::SortOrder order, const QTransform &deviceTransform) const
+{
+    Q_D(const QGraphicsScene);
+    return d->index->items(polygon, mode, order, deviceTransform);
+}
+
+/*!
+    \fn QList<QGraphicsItem *> QGraphicsScene::items(const QPainterPath &path, Qt::ItemSelectionMode mode, Qt::SortOrder order, const QTransform &deviceTransform) const
+    \overload
+    \since 4.6
+
+    \brief Returns all visible items that, depending on \a mode, are
+    either inside or intersect with the specified \a path, in a
+    list sorted using \a order. In this case, "visible" defines items for which:
+    isVisible() returns \c true, effectiveOpacity() returns a value greater than 0.0
+    (which is fully transparent) and the parent item does not clip it.
+
+    The default value for \a mode is Qt::IntersectsItemShape; all items whose
+    exact shape intersects with or is contained by \a path are returned.
+
+    \a deviceTransform is the transformation that applies to the view, and needs to
+    be provided if the scene contains items that ignore transformations.
+
+    \sa itemAt(), {QGraphicsItem#Sorting}{Sorting}
+*/
+QList<QGraphicsItem *> QGraphicsScene::items(const QPainterPath &path, Qt::ItemSelectionMode mode,
+                                             Qt::SortOrder order, const QTransform &deviceTransform) const
+{
+    Q_D(const QGraphicsScene);
+    return d->index->items(path, mode, order, deviceTransform);
+}
+
+/*!
+    Returns a list of all items that collide with \a item. Collisions are
+    determined by calling QGraphicsItem::collidesWithItem(); the collision
+    detection is determined by \a mode. By default, all items whose shape
+    intersects \a item or is contained inside \a item's shape are returned.
+
+    The items are returned in descending stacking order (i.e., the first item
+    in the list is the uppermost item, and the last item is the lowermost
+    item).
+
+    \sa items(), itemAt(), QGraphicsItem::collidesWithItem(), {QGraphicsItem#Sorting}{Sorting}
+*/
+QList<QGraphicsItem *> QGraphicsScene::collidingItems(const QGraphicsItem *item,
+                                                      Qt::ItemSelectionMode mode) const
+{
+    Q_D(const QGraphicsScene);
+    if (!item) {
+        qWarning("QGraphicsScene::collidingItems: cannot find collisions for null item");
+        return QList<QGraphicsItem *>();
+    }
+
+    // Does not support ItemIgnoresTransformations.
+    QList<QGraphicsItem *> tmp;
+    foreach (QGraphicsItem *itemInVicinity, d->index->estimateItems(item->sceneBoundingRect(), Qt::DescendingOrder)) {
+        if (item != itemInVicinity && item->collidesWithItem(itemInVicinity, mode))
+            tmp << itemInVicinity;
+    }
+    return tmp;
+}
+
+/*!
+    \fn QGraphicsItem *QGraphicsScene::itemAt(const QPointF &position) const
+    \overload
+    \obsolete
+
+    Returns the topmost visible item at the specified \a position, or 0 if
+    there are no items at this position.
+
+    This function is deprecated and returns incorrect results if the scene
+    contains items that ignore transformations. Use the overload that takes
+    a QTransform instead.
+
+    Note: See items() for a definition of which items are considered visible by this function.
+
+    \sa items(), collidingItems(), {QGraphicsItem#Sorting}{Sorting}
+*/
+
+/*!
+    \since 4.6
+
+    Returns the topmost visible item at the specified \a position, or 0
+    if there are no items at this position.
+
+    \a deviceTransform is the transformation that applies to the view, and needs to
+    be provided if the scene contains items that ignore transformations.
+
+    Note: See items() for a definition of which items are considered visible by this function.
+
+    \sa items(), collidingItems(), {QGraphicsItem#Sorting}{Sorting}
+*/
+QGraphicsItem *QGraphicsScene::itemAt(const QPointF &position, const QTransform &deviceTransform) const
+{
+    QList<QGraphicsItem *> itemsAtPoint = items(position, Qt::IntersectsItemShape,
+                                                Qt::DescendingOrder, deviceTransform);
+    return itemsAtPoint.isEmpty() ? 0 : itemsAtPoint.first();
+}
+
+/*!
+    \fn QGraphicsScene::itemAt(qreal x, qreal y, const QTransform &deviceTransform) const
+    \overload
+    \since 4.6
+
+    Returns the topmost visible item at the position specified by (\a x, \a
+    y), or 0 if there are no items at this position.
+
+    \a deviceTransform is the transformation that applies to the view, and needs to
+    be provided if the scene contains items that ignore transformations.
+
+    This convenience function is equivalent to calling \c
+    {itemAt(QPointF(x, y), deviceTransform)}.
+
+    Note: See items() for a definition of which items are considered visible by this function.
+*/
+
+/*!
+    \fn QGraphicsScene::itemAt(qreal x, qreal y) const
+    \overload
+    \obsolete
+
+    Returns the topmost visible item at the position specified by (\a x, \a
+    y), or 0 if there are no items at this position.
+
+    This convenience function is equivalent to calling \c
+    {itemAt(QPointF(x, y))}.
+
+    This function is deprecated and returns incorrect results if the scene
+    contains items that ignore transformations. Use the overload that takes
+    a QTransform instead.
+
+    Note: See items() for a definition of which items are considered visible by this function.
+*/
+
+/*!
+    Returns a list of all currently selected items. The items are
+    returned in no particular order.
+
+    \sa setSelectionArea()
+*/
+QList<QGraphicsItem *> QGraphicsScene::selectedItems() const
+{
+    Q_D(const QGraphicsScene);
+
+    // Optimization: Lazily removes items that are not selected.
+    QGraphicsScene *that = const_cast<QGraphicsScene *>(this);
+    QSet<QGraphicsItem *> actuallySelectedSet;
+    foreach (QGraphicsItem *item, that->d_func()->selectedItems) {
+        if (item->isSelected())
+            actuallySelectedSet << item;
+    }
+
+    that->d_func()->selectedItems = actuallySelectedSet;
+
+    return d->selectedItems.values();
+}
+
+/*!
+    Returns the selection area that was previously set with
+    setSelectionArea(), or an empty QPainterPath if no selection area has been
+    set.
+
+    \sa setSelectionArea()
+*/
+QPainterPath QGraphicsScene::selectionArea() const
+{
+    Q_D(const QGraphicsScene);
+    return d->selectionArea;
+}
+
+/*!
+    \since 4.6
+
+    Sets the selection area to \a path. All items within this area are
+    immediately selected, and all items outside are unselected. You can get
+    the list of all selected items by calling selectedItems().
+
+    \a deviceTransform is the transformation that applies to the view, and needs to
+    be provided if the scene contains items that ignore transformations.
+
+    For an item to be selected, it must be marked as \e selectable
+    (QGraphicsItem::ItemIsSelectable).
+
+    \sa clearSelection(), selectionArea()
+*/
+void QGraphicsScene::setSelectionArea(const QPainterPath &path, const QTransform &deviceTransform)
+{
+    setSelectionArea(path, Qt::IntersectsItemShape, deviceTransform);
+}
+
+/*!
+    \overload
+    \since 4.6
+
+    Sets the selection area to \a path using \a mode to determine if items are
+    included in the selection area.
+
+    \a deviceTransform is the transformation that applies to the view, and needs to
+    be provided if the scene contains items that ignore transformations.
+
+    \sa clearSelection(), selectionArea()
+*/
+void QGraphicsScene::setSelectionArea(const QPainterPath &path, Qt::ItemSelectionMode mode,
+                                      const QTransform &deviceTransform)
+{
+    Q_D(QGraphicsScene);
+
+    // Note: with boolean path operations, we can improve performance here
+    // quite a lot by "growing" the old path instead of replacing it. That
+    // allows us to only check the intersect area for changes, instead of
+    // reevaluating the whole path over again.
+    d->selectionArea = path;
+
+    QSet<QGraphicsItem *> unselectItems = d->selectedItems;
+
+    // Disable emitting selectionChanged() for individual items.
+    ++d->selectionChanging;
+    bool changed = false;
+
+    // Set all items in path to selected.
+    foreach (QGraphicsItem *item, items(path, mode, Qt::DescendingOrder, deviceTransform)) {
+        if (item->flags() & QGraphicsItem::ItemIsSelectable) {
+            if (!item->isSelected())
+                changed = true;
+            unselectItems.remove(item);
+            item->setSelected(true);
+        }
+    }
+
+    // Unselect all items outside path.
+    foreach (QGraphicsItem *item, unselectItems) {
+        item->setSelected(false);
+        changed = true;
+    }
+
+    // Reenable emitting selectionChanged() for individual items.
+    --d->selectionChanging;
+
+    if (!d->selectionChanging && changed)
+        emit selectionChanged();
+}
+
+/*!
+   Clears the current selection.
+
+   \sa setSelectionArea(), selectedItems()
+*/
+void QGraphicsScene::clearSelection()
+{
+    Q_D(QGraphicsScene);
+
+    // Disable emitting selectionChanged
+    ++d->selectionChanging;
+    bool changed = !d->selectedItems.isEmpty();
+
+    foreach (QGraphicsItem *item, d->selectedItems)
+        item->setSelected(false);
+    d->selectedItems.clear();
+
+    // Reenable emitting selectionChanged() for individual items.
+    --d->selectionChanging;
+
+    if (!d->selectionChanging && changed)
+        emit selectionChanged();
+}
+
+/*!
+    \since 4.4
+
+    Removes and deletes all items from the scene, but otherwise leaves the
+    state of the scene unchanged.
+
+    \sa addItem()
+*/
+void QGraphicsScene::clear()
+{
+    Q_D(QGraphicsScene);
+    // NB! We have to clear the index before deleting items; otherwise the
+    // index might try to access dangling item pointers.
+    d->index->clear();
+    // NB! QGraphicsScenePrivate::unregisterTopLevelItem() removes items
+    while (!d->topLevelItems.isEmpty())
+        delete d->topLevelItems.first();
+    Q_ASSERT(d->topLevelItems.isEmpty());
+    d->lastItemCount = 0;
+    d->allItemsIgnoreHoverEvents = true;
+    d->allItemsUseDefaultCursor = true;
+    d->allItemsIgnoreTouchEvents = true;
+}
+
+/*!
+    Groups all items in \a items into a new QGraphicsItemGroup, and returns a
+    pointer to the group. The group is created with the common ancestor of \a
+    items as its parent, and with position (0, 0). The items are all
+    reparented to the group, and their positions and transformations are
+    mapped to the group. If \a items is empty, this function will return an
+    empty top-level QGraphicsItemGroup.
+
+    QGraphicsScene has ownership of the group item; you do not need to delete
+    it. To dismantle (ungroup) a group, call destroyItemGroup().
+
+    \sa destroyItemGroup(), QGraphicsItemGroup::addToGroup()
+*/
+QGraphicsItemGroup *QGraphicsScene::createItemGroup(const QList<QGraphicsItem *> &items)
+{
+    // Build a list of the first item's ancestors
+    QList<QGraphicsItem *> ancestors;
+    int n = 0;
+    if (!items.isEmpty()) {
+        QGraphicsItem *parent = items.at(n++);
+        while ((parent = parent->parentItem()))
+            ancestors.append(parent);
+    }
+
+    // Find the common ancestor for all items
+    QGraphicsItem *commonAncestor = 0;
+    if (!ancestors.isEmpty()) {
+        while (n < items.size()) {
+            int commonIndex = -1;
+            QGraphicsItem *parent = items.at(n++);
+            do {
+                int index = ancestors.indexOf(parent, qMax(0, commonIndex));
+                if (index != -1) {
+                    commonIndex = index;
+                    break;
+                }
+            } while ((parent = parent->parentItem()));
+
+            if (commonIndex == -1) {
+                commonAncestor = 0;
+                break;
+            }
+
+            commonAncestor = ancestors.at(commonIndex);
+        }
+    }
+
+    // Create a new group at that level
+    QGraphicsItemGroup *group = new QGraphicsItemGroup(commonAncestor);
+    if (!commonAncestor)
+        addItem(group);
+    foreach (QGraphicsItem *item, items)
+        group->addToGroup(item);
+    return group;
+}
+
+/*!
+    Reparents all items in \a group to \a group's parent item, then removes \a
+    group from the scene, and finally deletes it. The items' positions and
+    transformations are mapped from the group to the group's parent.
+
+    \sa createItemGroup(), QGraphicsItemGroup::removeFromGroup()
+*/
+void QGraphicsScene::destroyItemGroup(QGraphicsItemGroup *group)
+{
+    foreach (QGraphicsItem *item, group->childItems())
+        group->removeFromGroup(item);
+    removeItem(group);
+    delete group;
+}
+
+/*!
+    Adds or moves the \a item and all its childen to this scene.
+    This scene takes ownership of the \a item.
+
+    If the item is visible (i.e., QGraphicsItem::isVisible() returns
+    true), QGraphicsScene will emit changed() once control goes back
+    to the event loop.
+
+    If the item is already in a different scene, it will first be
+    removed from its old scene, and then added to this scene as a
+    top-level.
+
+    QGraphicsScene will send ItemSceneChange notifications to \a item
+    while it is added to the scene. If item does not currently belong
+    to a scene, only one notification is sent. If it does belong to
+    scene already (i.e., it is moved to this scene), QGraphicsScene
+    will send an addition notification as the item is removed from its
+    previous scene.
+
+    If the item is a panel, the scene is active, and there is no
+    active panel in the scene, then the item will be activated.
+
+    \sa removeItem(), addEllipse(), addLine(), addPath(), addPixmap(),
+    addRect(), addText(), addWidget(), {QGraphicsItem#Sorting}{Sorting}
+*/
+void QGraphicsScene::addItem(QGraphicsItem *item)
+{
+    Q_D(QGraphicsScene);
+    if (!item) {
+        qWarning("QGraphicsScene::addItem: cannot add null item");
+        return;
+    }
+    if (item->d_ptr->scene == this) {
+        qWarning("QGraphicsScene::addItem: item has already been added to this scene");
+        return;
+    }
+    // Remove this item from its existing scene
+    if (QGraphicsScene *oldScene = item->d_ptr->scene)
+        oldScene->removeItem(item);
+
+    // Notify the item that its scene is changing, and allow the item to
+    // react.
+    const QVariant newSceneVariant(item->itemChange(QGraphicsItem::ItemSceneChange,
+                                                    QVariant::fromValue<QGraphicsScene *>(this)));
+    QGraphicsScene *targetScene = qvariant_cast<QGraphicsScene *>(newSceneVariant);
+    if (targetScene != this) {
+        if (targetScene && item->d_ptr->scene != targetScene)
+            targetScene->addItem(item);
+        return;
+    }
+
+    // QDeclarativeItems do not rely on initial itemChanged message, as the componentComplete
+    // function allows far more opportunity for delayed-construction optimization.
+    if (!item->d_ptr->isDeclarativeItem) {
+        if (d->unpolishedItems.isEmpty()) {
+            QMetaMethod method = metaObject()->method(d->polishItemsIndex);
+            method.invoke(this, Qt::QueuedConnection);
+        }
+        d->unpolishedItems.append(item);
+        item->d_ptr->pendingPolish = true;
+    }
+
+    // Detach this item from its parent if the parent's scene is different
+    // from this scene.
+    if (QGraphicsItem *itemParent = item->d_ptr->parent) {
+        if (itemParent->d_ptr->scene != this)
+            item->setParentItem(0);
+    }
+
+    // Add the item to this scene
+    item->d_func()->scene = targetScene;
+
+    // Add the item in the index
+    d->index->addItem(item);
+
+    // Add to list of toplevels if this item is a toplevel.
+    if (!item->d_ptr->parent)
+        d->registerTopLevelItem(item);
+
+    // Add to list of items that require an update. We cannot assume that the
+    // item is fully constructed, so calling item->update() can lead to a pure
+    // virtual function call to boundingRect().
+    d->markDirty(item);
+    d->dirtyGrowingItemsBoundingRect = true;
+
+    // Disable selectionChanged() for individual items
+    ++d->selectionChanging;
+    int oldSelectedItemSize = d->selectedItems.size();
+
+    // Enable mouse tracking if the item accepts hover events or has a cursor set.
+    if (d->allItemsIgnoreHoverEvents && d->itemAcceptsHoverEvents_helper(item)) {
+        d->allItemsIgnoreHoverEvents = false;
+        d->enableMouseTrackingOnViews();
+    }
+#ifndef QT_NO_CURSOR
+    if (d->allItemsUseDefaultCursor && item->d_ptr->hasCursor) {
+        d->allItemsUseDefaultCursor = false;
+        if (d->allItemsIgnoreHoverEvents) // already enabled otherwise
+            d->enableMouseTrackingOnViews();
+    }
+#endif //QT_NO_CURSOR
+
+    // Enable touch events if the item accepts touch events.
+    if (d->allItemsIgnoreTouchEvents && item->d_ptr->acceptTouchEvents) {
+        d->allItemsIgnoreTouchEvents = false;
+        d->enableTouchEventsOnViews();
+    }
+
+#ifndef QT_NO_GESTURES
+    foreach (Qt::GestureType gesture, item->d_ptr->gestureContext.keys())
+        d->grabGesture(item, gesture);
+#endif
+
+    // Update selection lists
+    if (item->isSelected())
+        d->selectedItems << item;
+    if (item->isWidget() && item->isVisible() && static_cast<QGraphicsWidget *>(item)->windowType() == Qt::Popup)
+        d->addPopup(static_cast<QGraphicsWidget *>(item));
+    if (item->isPanel() && item->isVisible() && item->panelModality() != QGraphicsItem::NonModal)
+        d->enterModal(item);
+
+    // Update creation order focus chain. Make sure to leave the widget's
+    // internal tab order intact.
+    if (item->isWidget()) {
+        QGraphicsWidget *widget = static_cast<QGraphicsWidget *>(item);
+        if (!d->tabFocusFirst) {
+            // No first tab focus widget - make this the first tab focus
+            // widget.
+            d->tabFocusFirst = widget;
+        } else if (!widget->parentWidget() && !widget->isPanel()) {
+            // Adding a widget that is not part of a tab focus chain.
+            QGraphicsWidget *myNewPrev = d->tabFocusFirst->d_func()->focusPrev;
+            myNewPrev->d_func()->focusNext = widget;
+            widget->d_func()->focusPrev->d_func()->focusNext = d->tabFocusFirst;
+            d->tabFocusFirst->d_func()->focusPrev = widget->d_func()->focusPrev;
+            widget->d_func()->focusPrev = myNewPrev;
+        }
+    }
+
+    // Add all children recursively
+    item->d_ptr->ensureSortedChildren();
+    for (int i = 0; i < item->d_ptr->children.size(); ++i)
+        addItem(item->d_ptr->children.at(i));
+
+    // Resolve font and palette.
+    item->d_ptr->resolveFont(d->font.resolve());
+    item->d_ptr->resolvePalette(d->palette.resolve());
+
+
+    // Reenable selectionChanged() for individual items
+    --d->selectionChanging;
+    if (!d->selectionChanging && d->selectedItems.size() != oldSelectedItemSize)
+        emit selectionChanged();
+
+    // Deliver post-change notification
+    item->itemChange(QGraphicsItem::ItemSceneHasChanged, newSceneVariant);
+
+    // Update explicit activation
+    bool autoActivate = true;
+    if (!d->childExplicitActivation && item->d_ptr->explicitActivate)
+        d->childExplicitActivation = item->d_ptr->wantsActive ? 1 : 2;
+    if (d->childExplicitActivation && item->isPanel()) {
+        if (d->childExplicitActivation == 1)
+            setActivePanel(item);
+        else
+            autoActivate = false;
+        d->childExplicitActivation = 0;
+    } else if (!item->d_ptr->parent) {
+        d->childExplicitActivation = 0;
+    }
+
+    // Auto-activate this item's panel if nothing else has been activated
+    if (autoActivate) {
+        if (!d->lastActivePanel && !d->activePanel && item->isPanel()) {
+            if (isActive())
+                setActivePanel(item);
+            else
+                d->lastActivePanel = item;
+        }
+    }
+
+    if (item->d_ptr->flags & QGraphicsItem::ItemSendsScenePositionChanges)
+        d->registerScenePosItem(item);
+
+    // Ensure that newly added items that have subfocus set, gain
+    // focus automatically if there isn't a focus item already.
+    if (!d->focusItem && item != d->lastFocusItem && item->focusItem() == item)
+        item->focusItem()->setFocus();
+
+    d->updateInputMethodSensitivityInViews();
+}
+
+/*!
+    Creates and adds an ellipse item to the scene, and returns the item
+    pointer. The geometry of the ellipse is defined by \a rect, and its pen
+    and brush are initialized to \a pen and \a brush.
+
+    Note that the item's geometry is provided in item coordinates, and its
+    position is initialized to (0, 0).
+
+    If the item is visible (i.e., QGraphicsItem::isVisible() returns \c true),
+    QGraphicsScene will emit changed() once control goes back to the event
+    loop.
+
+    \sa addLine(), addPath(), addPixmap(), addRect(), addText(), addItem(),
+    addWidget()
+*/
+QGraphicsEllipseItem *QGraphicsScene::addEllipse(const QRectF &rect, const QPen &pen, const QBrush &brush)
+{
+    QGraphicsEllipseItem *item = new QGraphicsEllipseItem(rect);
+    item->setPen(pen);
+    item->setBrush(brush);
+    addItem(item);
+    return item;
+}
+
+/*!
+    \fn QGraphicsEllipseItem *QGraphicsScene::addEllipse(qreal x, qreal y, qreal w, qreal h, const QPen &pen, const QBrush &brush)
+    \since 4.3
+
+    This convenience function is equivalent to calling addEllipse(QRectF(\a x,
+    \a y, \a w, \a h), \a pen, \a brush).
+*/
+
+/*!
+    Creates and adds a line item to the scene, and returns the item
+    pointer. The geometry of the line is defined by \a line, and its pen
+    is initialized to \a pen.
+
+    Note that the item's geometry is provided in item coordinates, and its
+    position is initialized to (0, 0).
+
+    If the item is visible (i.e., QGraphicsItem::isVisible() returns \c true),
+    QGraphicsScene will emit changed() once control goes back to the event
+    loop.
+
+    \sa addEllipse(), addPath(), addPixmap(), addRect(), addText(), addItem(),
+    addWidget()
+*/
+QGraphicsLineItem *QGraphicsScene::addLine(const QLineF &line, const QPen &pen)
+{
+    QGraphicsLineItem *item = new QGraphicsLineItem(line);
+    item->setPen(pen);
+    addItem(item);
+    return item;
+}
+
+/*!
+    \fn QGraphicsLineItem *QGraphicsScene::addLine(qreal x1, qreal y1, qreal x2, qreal y2, const QPen &pen)
+    \since 4.3
+
+    This convenience function is equivalent to calling addLine(QLineF(\a x1,
+    \a y1, \a x2, \a y2), \a pen).
+*/
+
+/*!
+    Creates and adds a path item to the scene, and returns the item
+    pointer. The geometry of the path is defined by \a path, and its pen and
+    brush are initialized to \a pen and \a brush.
+
+    Note that the item's geometry is provided in item coordinates, and its
+    position is initialized to (0, 0).
+
+    If the item is visible (i.e., QGraphicsItem::isVisible() returns \c true),
+    QGraphicsScene will emit changed() once control goes back to the event
+    loop.
+
+    \sa addEllipse(), addLine(), addPixmap(), addRect(), addText(), addItem(),
+    addWidget()
+*/
+QGraphicsPathItem *QGraphicsScene::addPath(const QPainterPath &path, const QPen &pen, const QBrush &brush)
+{
+    QGraphicsPathItem *item = new QGraphicsPathItem(path);
+    item->setPen(pen);
+    item->setBrush(brush);
+    addItem(item);
+    return item;
+}
+
+/*!
+    Creates and adds a pixmap item to the scene, and returns the item
+    pointer. The pixmap is defined by \a pixmap.
+
+    Note that the item's geometry is provided in item coordinates, and its
+    position is initialized to (0, 0).
+
+    If the item is visible (i.e., QGraphicsItem::isVisible() returns \c true),
+    QGraphicsScene will emit changed() once control goes back to the event
+    loop.
+
+    \sa addEllipse(), addLine(), addPath(), addRect(), addText(), addItem(),
+    addWidget()
+*/
+QGraphicsPixmapItem *QGraphicsScene::addPixmap(const QPixmap &pixmap)
+{
+    QGraphicsPixmapItem *item = new QGraphicsPixmapItem(pixmap);
+    addItem(item);
+    return item;
+}
+
+/*!
+    Creates and adds a polygon item to the scene, and returns the item
+    pointer. The polygon is defined by \a polygon, and its pen and
+    brush are initialized to \a pen and \a brush.
+
+    Note that the item's geometry is provided in item coordinates, and its
+    position is initialized to (0, 0).
+
+    If the item is visible (i.e., QGraphicsItem::isVisible() returns \c true),
+    QGraphicsScene will emit changed() once control goes back to the event
+    loop.
+
+    \sa addEllipse(), addLine(), addPath(), addRect(), addText(), addItem(),
+    addWidget()
+*/
+QGraphicsPolygonItem *QGraphicsScene::addPolygon(const QPolygonF &polygon,
+                                                 const QPen &pen, const QBrush &brush)
+{
+    QGraphicsPolygonItem *item = new QGraphicsPolygonItem(polygon);
+    item->setPen(pen);
+    item->setBrush(brush);
+    addItem(item);
+    return item;
+}
+
+/*!
+    Creates and adds a rectangle item to the scene, and returns the item
+    pointer. The geometry of the rectangle is defined by \a rect, and its pen
+    and brush are initialized to \a pen and \a brush.
+
+    Note that the item's geometry is provided in item coordinates, and its
+    position is initialized to (0, 0). For example, if a QRect(50, 50, 100,
+    100) is added, its top-left corner will be at (50, 50) relative to the
+    origin in the items coordinate system.
+
+    If the item is visible (i.e., QGraphicsItem::isVisible() returns \c true),
+    QGraphicsScene will emit changed() once control goes back to the event
+    loop.
+
+    \sa addEllipse(), addLine(), addPixmap(), addPixmap(), addText(),
+    addItem(), addWidget()
+*/
+QGraphicsRectItem *QGraphicsScene::addRect(const QRectF &rect, const QPen &pen, const QBrush &brush)
+{
+    QGraphicsRectItem *item = new QGraphicsRectItem(rect);
+    item->setPen(pen);
+    item->setBrush(brush);
+    addItem(item);
+    return item;
+}
+
+/*!
+    \fn QGraphicsRectItem *QGraphicsScene::addRect(qreal x, qreal y, qreal w, qreal h, const QPen &pen, const QBrush &brush)
+    \since 4.3
+
+    This convenience function is equivalent to calling addRect(QRectF(\a x,
+    \a y, \a w, \a h), \a pen, \a brush).
+*/
+
+/*!
+    Creates and adds a text item to the scene, and returns the item
+    pointer. The text string is initialized to \a text, and its font
+    is initialized to \a font.
+
+    The item's position is initialized to (0, 0).
+
+    If the item is visible (i.e., QGraphicsItem::isVisible() returns \c true),
+    QGraphicsScene will emit changed() once control goes back to the event
+    loop.
+
+    \sa addEllipse(), addLine(), addPixmap(), addPixmap(), addRect(),
+    addItem(), addWidget()
+*/
+QGraphicsTextItem *QGraphicsScene::addText(const QString &text, const QFont &font)
+{
+    QGraphicsTextItem *item = new QGraphicsTextItem(text);
+    item->setFont(font);
+    addItem(item);
+    return item;
+}
+
+/*!
+    Creates and adds a QGraphicsSimpleTextItem to the scene, and returns the
+    item pointer. The text string is initialized to \a text, and its font is
+    initialized to \a font.
+
+    The item's position is initialized to (0, 0).
+
+    If the item is visible (i.e., QGraphicsItem::isVisible() returns \c true),
+    QGraphicsScene will emit changed() once control goes back to the event
+    loop.
+
+    \sa addEllipse(), addLine(), addPixmap(), addPixmap(), addRect(),
+    addItem(), addWidget()
+*/
+QGraphicsSimpleTextItem *QGraphicsScene::addSimpleText(const QString &text, const QFont &font)
+{
+    QGraphicsSimpleTextItem *item = new QGraphicsSimpleTextItem(text);
+    item->setFont(font);
+    addItem(item);
+    return item;
+}
+
+/*!
+    Creates a new QGraphicsProxyWidget for \a widget, adds it to the scene,
+    and returns a pointer to the proxy. \a wFlags set the default window flags
+    for the embedding proxy widget.
+
+    The item's position is initialized to (0, 0).
+
+    If the item is visible (i.e., QGraphicsItem::isVisible() returns \c true),
+    QGraphicsScene will emit changed() once control goes back to the event
+    loop.
+
+    Note that widgets with the Qt::WA_PaintOnScreen widget attribute
+    set and widgets that wrap an external application or controller
+    are not supported. Examples are QGLWidget and QAxWidget.
+
+    \sa addEllipse(), addLine(), addPixmap(), addPixmap(), addRect(),
+    addText(), addSimpleText(), addItem()
+*/
+QGraphicsProxyWidget *QGraphicsScene::addWidget(QWidget *widget, Qt::WindowFlags wFlags)
+{
+    QGraphicsProxyWidget *proxy = new QGraphicsProxyWidget(0, wFlags);
+    proxy->setWidget(widget);
+    addItem(proxy);
+    return proxy;
+}
+
+/*!
+    Removes the item \a item and all its children from the scene.  The
+    ownership of \a item is passed on to the caller (i.e.,
+    QGraphicsScene will no longer delete \a item when destroyed).
+
+    \sa addItem()
+*/
+void QGraphicsScene::removeItem(QGraphicsItem *item)
+{
+    // ### Refactoring: This function shares much functionality with _q_removeItemLater()
+    Q_D(QGraphicsScene);
+    if (!item) {
+        qWarning("QGraphicsScene::removeItem: cannot remove 0-item");
+        return;
+    }
+    if (item->scene() != this) {
+        qWarning("QGraphicsScene::removeItem: item %p's scene (%p)"
+                 " is different from this scene (%p)",
+                 item, item->scene(), this);
+        return;
+    }
+
+    // Notify the item that it's scene is changing to 0, allowing the item to
+    // react.
+    const QVariant newSceneVariant(item->itemChange(QGraphicsItem::ItemSceneChange,
+                                                    QVariant::fromValue<QGraphicsScene *>(0)));
+    QGraphicsScene *targetScene = qvariant_cast<QGraphicsScene *>(newSceneVariant);
+    if (targetScene != 0 && targetScene != this) {
+        targetScene->addItem(item);
+        return;
+    }
+
+    d->removeItemHelper(item);
+
+    // Deliver post-change notification
+    item->itemChange(QGraphicsItem::ItemSceneHasChanged, newSceneVariant);
+
+    d->updateInputMethodSensitivityInViews();
+}
+
+/*!
+    When the scene is active, this functions returns the scene's current focus
+    item, or 0 if no item currently has focus. When the scene is inactive, this
+    functions returns the item that will gain input focus when the scene becomes
+    active.
+
+    The focus item receives keyboard input when the scene receives a
+    key event.
+
+    \sa setFocusItem(), QGraphicsItem::hasFocus(), isActive()
+*/
+QGraphicsItem *QGraphicsScene::focusItem() const
+{
+    Q_D(const QGraphicsScene);
+    return isActive() ? d->focusItem : d->passiveFocusItem;
+}
+
+/*!
+    Sets the scene's focus item to \a item, with the focus reason \a
+    focusReason, after removing focus from any previous item that may have had
+    focus.
+
+    If \a item is 0, or if it either does not accept focus (i.e., it does not
+    have the QGraphicsItem::ItemIsFocusable flag enabled), or is not visible
+    or not enabled, this function only removes focus from any previous
+    focusitem.
+
+    If item is not 0, and the scene does not currently have focus (i.e.,
+    hasFocus() returns \c false), this function will call setFocus()
+    automatically.
+
+    \sa focusItem(), hasFocus(), setFocus()
+*/
+void QGraphicsScene::setFocusItem(QGraphicsItem *item, Qt::FocusReason focusReason)
+{
+    Q_D(QGraphicsScene);
+    if (item)
+        item->setFocus(focusReason);
+    else
+        d->setFocusItemHelper(item, focusReason);
+}
+
+/*!
+    Returns \c true if the scene has focus; otherwise returns \c false. If the scene
+    has focus, it will will forward key events from QKeyEvent to any item that
+    has focus.
+
+    \sa setFocus(), setFocusItem()
+*/
+bool QGraphicsScene::hasFocus() const
+{
+    Q_D(const QGraphicsScene);
+    return d->hasFocus;
+}
+
+/*!
+    Sets focus on the scene by sending a QFocusEvent to the scene, passing \a
+    focusReason as the reason. If the scene regains focus after having
+    previously lost it while an item had focus, the last focus item will
+    receive focus with \a focusReason as the reason.
+
+    If the scene already has focus, this function does nothing.
+
+    \sa hasFocus(), clearFocus(), setFocusItem()
+*/
+void QGraphicsScene::setFocus(Qt::FocusReason focusReason)
+{
+    Q_D(QGraphicsScene);
+    if (d->hasFocus || !isActive())
+        return;
+    QFocusEvent event(QEvent::FocusIn, focusReason);
+    QCoreApplication::sendEvent(this, &event);
+}
+
+/*!
+    Clears focus from the scene. If any item has focus when this function is
+    called, it will lose focus, and regain focus again once the scene regains
+    focus.
+
+    A scene that does not have focus ignores key events.
+
+    \sa hasFocus(), setFocus(), setFocusItem()
+*/
+void QGraphicsScene::clearFocus()
+{
+    Q_D(QGraphicsScene);
+    if (d->hasFocus) {
+        d->hasFocus = false;
+        d->passiveFocusItem = d->focusItem;
+        setFocusItem(0, Qt::OtherFocusReason);
+    }
+}
+
+/*!
+    \property QGraphicsScene::stickyFocus
+    \brief whether clicking into the scene background will clear focus
+
+    \since 4.6
+
+    In a QGraphicsScene with stickyFocus set to true, focus will remain
+    unchanged when the user clicks into the scene background or on an item
+    that does not accept focus. Otherwise, focus will be cleared.
+
+    By default, this property is \c false.
+
+    Focus changes in response to a mouse press. You can reimplement
+    mousePressEvent() in a subclass of QGraphicsScene to toggle this property
+    based on where the user has clicked.
+
+    \sa clearFocus(), setFocusItem()
+*/
+void QGraphicsScene::setStickyFocus(bool enabled)
+{
+    Q_D(QGraphicsScene);
+    d->stickyFocus = enabled;
+}
+bool QGraphicsScene::stickyFocus() const
+{
+    Q_D(const QGraphicsScene);
+    return d->stickyFocus;
+}
+
+/*!
+    Returns the current mouse grabber item, or 0 if no item is currently
+    grabbing the mouse. The mouse grabber item is the item that receives all
+    mouse events sent to the scene.
+
+    An item becomes a mouse grabber when it receives and accepts a
+    mouse press event, and it stays the mouse grabber until either of
+    the following events occur:
+
+    \list
+    \li If the item receives a mouse release event when there are no other
+    buttons pressed, it loses the mouse grab.
+    \li If the item becomes invisible (i.e., someone calls \c {item->setVisible(false)}),
+    or if it becomes disabled (i.e., someone calls \c {item->setEnabled(false)}),
+    it loses the mouse grab.
+    \li If the item is removed from the scene, it loses the mouse grab.
+    \endlist
+
+    If the item loses its mouse grab, the scene will ignore all mouse events
+    until a new item grabs the mouse (i.e., until a new item receives a mouse
+    press event).
+*/
+QGraphicsItem *QGraphicsScene::mouseGrabberItem() const
+{
+    Q_D(const QGraphicsScene);
+    return !d->mouseGrabberItems.isEmpty() ? d->mouseGrabberItems.last() : 0;
+}
+
+/*!
+    \property QGraphicsScene::backgroundBrush
+    \brief the background brush of the scene.
+
+    Set this property to changes the scene's background to a different color,
+    gradient or texture. The default background brush is Qt::NoBrush. The
+    background is drawn before (behind) the items.
+
+    Example:
+
+    \snippet code/src_gui_graphicsview_qgraphicsscene.cpp 3
+
+    QGraphicsScene::render() calls drawBackground() to draw the scene
+    background. For more detailed control over how the background is drawn,
+    you can reimplement drawBackground() in a subclass of QGraphicsScene.
+*/
+QBrush QGraphicsScene::backgroundBrush() const
+{
+    Q_D(const QGraphicsScene);
+    return d->backgroundBrush;
+}
+void QGraphicsScene::setBackgroundBrush(const QBrush &brush)
+{
+    Q_D(QGraphicsScene);
+    d->backgroundBrush = brush;
+    foreach (QGraphicsView *view, d->views) {
+        view->resetCachedContent();
+        view->viewport()->update();
+    }
+    update();
+}
+
+/*!
+    \property QGraphicsScene::foregroundBrush
+    \brief the foreground brush of the scene.
+
+    Change this property to set the scene's foreground to a different
+    color, gradient or texture.
+
+    The foreground is drawn after (on top of) the items. The default
+    foreground brush is Qt::NoBrush ( i.e. the foreground is not
+    drawn).
+
+    Example:
+
+    \snippet code/src_gui_graphicsview_qgraphicsscene.cpp 4
+
+    QGraphicsScene::render() calls drawForeground() to draw the scene
+    foreground. For more detailed control over how the foreground is
+    drawn, you can reimplement the drawForeground() function in a
+    QGraphicsScene subclass.
+*/
+QBrush QGraphicsScene::foregroundBrush() const
+{
+    Q_D(const QGraphicsScene);
+    return d->foregroundBrush;
+}
+void QGraphicsScene::setForegroundBrush(const QBrush &brush)
+{
+    Q_D(QGraphicsScene);
+    d->foregroundBrush = brush;
+    foreach (QGraphicsView *view, views())
+        view->viewport()->update();
+    update();
+}
+
+/*!
+    This method is used by input methods to query a set of properties of
+    the scene to be able to support complex input method operations as support
+    for surrounding text and reconversions.
+
+    The \a query parameter specifies which property is queried.
+
+    \sa QWidget::inputMethodQuery()
+*/
+QVariant QGraphicsScene::inputMethodQuery(Qt::InputMethodQuery query) const
+{
+    Q_D(const QGraphicsScene);
+    if (!d->focusItem || !(d->focusItem->flags() & QGraphicsItem::ItemAcceptsInputMethod))
+        return QVariant();
+    const QTransform matrix = d->focusItem->sceneTransform();
+    QVariant value = d->focusItem->inputMethodQuery(query);
+    if (value.type() == QVariant::RectF)
+        value = matrix.mapRect(value.toRectF());
+    else if (value.type() == QVariant::PointF)
+        value = matrix.map(value.toPointF());
+    else if (value.type() == QVariant::Rect)
+        value = matrix.mapRect(value.toRect());
+    else if (value.type() == QVariant::Point)
+        value = matrix.map(value.toPoint());
+    return value;
+}
+
+/*!
+    \fn void QGraphicsScene::update(const QRectF &rect)
+    Schedules a redraw of the area \a rect on the scene.
+
+    \sa sceneRect(), changed()
+*/
+void QGraphicsScene::update(const QRectF &rect)
+{
+    Q_D(QGraphicsScene);
+    if (d->updateAll || (rect.isEmpty() && !rect.isNull()))
+        return;
+
+    // Check if anyone's connected; if not, we can send updates directly to
+    // the views. Otherwise or if there are no views, use old behavior.
+    bool directUpdates = !(d->isSignalConnected(d->changedSignalIndex)) && !d->views.isEmpty();
+    if (rect.isNull()) {
+        d->updateAll = true;
+        d->updatedRects.clear();
+        if (directUpdates) {
+            // Update all views.
+            for (int i = 0; i < d->views.size(); ++i)
+                d->views.at(i)->d_func()->fullUpdatePending = true;
+        }
+    } else {
+        if (directUpdates) {
+            // Update all views.
+            for (int i = 0; i < d->views.size(); ++i) {
+                QGraphicsView *view = d->views.at(i);
+                if (view->isTransformed())
+                    view->d_func()->updateRectF(view->viewportTransform().mapRect(rect));
+                else
+                    view->d_func()->updateRectF(rect);
+            }
+        } else {
+            d->updatedRects << rect;
+        }
+    }
+
+    if (!d->calledEmitUpdated) {
+        d->calledEmitUpdated = true;
+        QMetaObject::invokeMethod(this, "_q_emitUpdated", Qt::QueuedConnection);
+    }
+}
+
+/*!
+    \fn void QGraphicsScene::update(qreal x, qreal y, qreal w, qreal h)
+    \overload
+    \since 4.3
+
+    This function is equivalent to calling update(QRectF(\a x, \a y, \a w,
+    \a h));
+*/
+
+/*!
+    Invalidates and schedules a redraw of the \a layers in \a rect on the
+    scene. Any cached content in \a layers is unconditionally invalidated and
+    redrawn.
+
+    You can use this function overload to notify QGraphicsScene of changes to
+    the background or the foreground of the scene. This function is commonly
+    used for scenes with tile-based backgrounds to notify changes when
+    QGraphicsView has enabled
+    \l{QGraphicsView::CacheBackground}{CacheBackground}.
+
+    Example:
+
+    \snippet code/src_gui_graphicsview_qgraphicsscene.cpp 5
+
+    Note that QGraphicsView currently supports background caching only (see
+    QGraphicsView::CacheBackground). This function is equivalent to calling
+    update() if any layer but BackgroundLayer is passed.
+
+    \sa QGraphicsView::resetCachedContent()
+*/
+void QGraphicsScene::invalidate(const QRectF &rect, SceneLayers layers)
+{
+    foreach (QGraphicsView *view, views())
+        view->invalidateScene(rect, layers);
+    update(rect);
+}
+
+/*!
+    \fn void QGraphicsScene::invalidate(qreal x, qreal y, qreal w, qreal h, SceneLayers layers)
+    \overload
+    \since 4.3
+
+    This convenience function is equivalent to calling invalidate(QRectF(\a x, \a
+    y, \a w, \a h), \a layers);
+*/
+
+/*!
+    Returns a list of all the views that display this scene.
+
+    \sa QGraphicsView::scene()
+*/
+QList <QGraphicsView *> QGraphicsScene::views() const
+{
+    Q_D(const QGraphicsScene);
+    return d->views;
+}
+
+/*!
+    This slot \e advances the scene by one step, by calling
+    QGraphicsItem::advance() for all items on the scene. This is done in two
+    phases: in the first phase, all items are notified that the scene is about
+    to change, and in the second phase all items are notified that they can
+    move. In the first phase, QGraphicsItem::advance() is called passing a
+    value of 0 as an argument, and 1 is passed in the second phase.
+
+    Note that you can also use the \l{The Animation Framework}{Animation
+    Framework} for animations.
+
+    \sa QGraphicsItem::advance(), QTimeLine
+*/
+void QGraphicsScene::advance()
+{
+    for (int i = 0; i < 2; ++i) {
+        foreach (QGraphicsItem *item, items())
+            item->advance(i);
+    }
+}
+
+/*!
+    Processes the event \a event, and dispatches it to the respective
+    event handlers.
+
+    In addition to calling the convenience event handlers, this
+    function is responsible for converting mouse move events to hover
+    events for when there is no mouse grabber item. Hover events are
+    delivered directly to items; there is no convenience function for
+    them.
+
+    Unlike QWidget, QGraphicsScene does not have the convenience functions
+    \l{QWidget::}{enterEvent()} and \l{QWidget::}{leaveEvent()}. Use this
+    function to obtain those events instead.
+
+    \sa contextMenuEvent(), keyPressEvent(), keyReleaseEvent(),
+    mousePressEvent(), mouseMoveEvent(), mouseReleaseEvent(),
+    mouseDoubleClickEvent(), focusInEvent(), focusOutEvent()
+*/
+bool QGraphicsScene::event(QEvent *event)
+{
+    Q_D(QGraphicsScene);
+
+    switch (event->type()) {
+    case QEvent::GraphicsSceneMousePress:
+    case QEvent::GraphicsSceneMouseMove:
+    case QEvent::GraphicsSceneMouseRelease:
+    case QEvent::GraphicsSceneMouseDoubleClick:
+    case QEvent::GraphicsSceneHoverEnter:
+    case QEvent::GraphicsSceneHoverLeave:
+    case QEvent::GraphicsSceneHoverMove:
+    case QEvent::TouchBegin:
+    case QEvent::TouchUpdate:
+    case QEvent::TouchEnd:
+        // Reset the under-mouse list to ensure that this event gets fresh
+        // item-under-mouse data. Be careful about this list; if people delete
+        // items from inside event handlers, this list can quickly end up
+        // having stale pointers in it. We need to clear it before dispatching
+        // events that use it.
+        // ### this should only be cleared if we received a new mouse move event,
+        // which relies on us fixing the replay mechanism in QGraphicsView.
+        d->cachedItemsUnderMouse.clear();
+    default:
+        break;
+    }
+
+    switch (event->type()) {
+    case QEvent::GraphicsSceneDragEnter:
+        dragEnterEvent(static_cast<QGraphicsSceneDragDropEvent *>(event));
+        break;
+    case QEvent::GraphicsSceneDragMove:
+        dragMoveEvent(static_cast<QGraphicsSceneDragDropEvent *>(event));
+        break;
+    case QEvent::GraphicsSceneDragLeave:
+        dragLeaveEvent(static_cast<QGraphicsSceneDragDropEvent *>(event));
+        break;
+    case QEvent::GraphicsSceneDrop:
+        dropEvent(static_cast<QGraphicsSceneDragDropEvent *>(event));
+        break;
+    case QEvent::GraphicsSceneContextMenu:
+        contextMenuEvent(static_cast<QGraphicsSceneContextMenuEvent *>(event));
+        break;
+    case QEvent::KeyPress:
+        if (!d->focusItem) {
+            QKeyEvent *k = static_cast<QKeyEvent *>(event);
+            if (k->key() == Qt::Key_Tab || k->key() == Qt::Key_Backtab) {
+                if (!(k->modifiers() & (Qt::ControlModifier | Qt::AltModifier))) {  //### Add MetaModifier?
+                    bool res = false;
+                    if (k->key() == Qt::Key_Backtab
+                        || (k->key() == Qt::Key_Tab && (k->modifiers() & Qt::ShiftModifier))) {
+                        res = focusNextPrevChild(false);
+                    } else if (k->key() == Qt::Key_Tab) {
+                        res = focusNextPrevChild(true);
+                    }
+                    if (!res)
+                        event->ignore();
+                    return true;
+                }
+            }
+        }
+        keyPressEvent(static_cast<QKeyEvent *>(event));
+        break;
+    case QEvent::KeyRelease:
+        keyReleaseEvent(static_cast<QKeyEvent *>(event));
+        break;
+    case QEvent::ShortcutOverride: {
+            QGraphicsItem *parent = focusItem();
+            while (parent) {
+                d->sendEvent(parent, event);
+                if (event->isAccepted())
+                    return true;
+                parent = parent->parentItem();
+            }
+        }
+        return false;
+    case QEvent::GraphicsSceneMouseMove:
+    {
+        QGraphicsSceneMouseEvent *mouseEvent = static_cast<QGraphicsSceneMouseEvent *>(event);
+        d->lastSceneMousePos = mouseEvent->scenePos();
+        mouseMoveEvent(mouseEvent);
+        break;
+    }
+    case QEvent::GraphicsSceneMousePress:
+        mousePressEvent(static_cast<QGraphicsSceneMouseEvent *>(event));
+        break;
+    case QEvent::GraphicsSceneMouseRelease:
+        mouseReleaseEvent(static_cast<QGraphicsSceneMouseEvent *>(event));
+        break;
+    case QEvent::GraphicsSceneMouseDoubleClick:
+        mouseDoubleClickEvent(static_cast<QGraphicsSceneMouseEvent *>(event));
+        break;
+    case QEvent::GraphicsSceneWheel:
+        wheelEvent(static_cast<QGraphicsSceneWheelEvent *>(event));
+        break;
+    case QEvent::FocusIn:
+        focusInEvent(static_cast<QFocusEvent *>(event));
+        break;
+    case QEvent::FocusOut:
+        focusOutEvent(static_cast<QFocusEvent *>(event));
+        break;
+    case QEvent::GraphicsSceneHoverEnter:
+    case QEvent::GraphicsSceneHoverLeave:
+    case QEvent::GraphicsSceneHoverMove:
+    {
+        QGraphicsSceneHoverEvent *hoverEvent = static_cast<QGraphicsSceneHoverEvent *>(event);
+        d->lastSceneMousePos = hoverEvent->scenePos();
+        d->dispatchHoverEvent(hoverEvent);
+        break;
+    }
+    case QEvent::Leave:
+        // hackieshly unpacking the viewport pointer from the leave event.
+        d->leaveScene(reinterpret_cast<QWidget *>(event->d));
+        break;
+    case QEvent::GraphicsSceneHelp:
+        helpEvent(static_cast<QGraphicsSceneHelpEvent *>(event));
+        break;
+    case QEvent::InputMethod:
+        inputMethodEvent(static_cast<QInputMethodEvent *>(event));
+        break;
+    case QEvent::WindowActivate:
+        if (!d->activationRefCount++) {
+            if (d->lastActivePanel) {
+                // Activate the last panel.
+                d->setActivePanelHelper(d->lastActivePanel, true);
+            } else if (d->tabFocusFirst && d->tabFocusFirst->isPanel()) {
+                // Activate the panel of the first item in the tab focus
+                // chain.
+                d->setActivePanelHelper(d->tabFocusFirst, true);
+            } else {
+                // Activate all toplevel items.
+                QEvent event(QEvent::WindowActivate);
+                foreach (QGraphicsItem *item, items()) {
+                    if (item->isVisible() && !item->isPanel() && !item->parentItem())
+                        sendEvent(item, &event);
+                }
+            }
+        }
+        break;
+    case QEvent::WindowDeactivate:
+        if (!--d->activationRefCount) {
+            if (d->activePanel) {
+                // Deactivate the active panel (but keep it so we can
+                // reactivate it later).
+                QGraphicsItem *lastActivePanel = d->activePanel;
+                d->setActivePanelHelper(0, true);
+                d->lastActivePanel = lastActivePanel;
+            } else {
+                // Activate all toplevel items.
+                QEvent event(QEvent::WindowDeactivate);
+                foreach (QGraphicsItem *item, items()) {
+                    if (item->isVisible() && !item->isPanel() && !item->parentItem())
+                        sendEvent(item, &event);
+                }
+            }
+        }
+        break;
+    case QEvent::ApplicationFontChange: {
+        // Resolve the existing scene font.
+        d->resolveFont();
+        break;
+    }
+    case QEvent::FontChange:
+        // Update the entire scene when the font changes.
+        update();
+        break;
+    case QEvent::ApplicationPaletteChange: {
+        // Resolve the existing scene palette.
+        d->resolvePalette();
+        break;
+    }
+    case QEvent::PaletteChange:
+        // Update the entire scene when the palette changes.
+        update();
+        break;
+    case QEvent::StyleChange:
+        // Reresolve all widgets' styles. Update all top-level widgets'
+        // geometries that do not have an explicit style set.
+        update();
+        break;
+    case QEvent::StyleAnimationUpdate:
+        // Because QGraphicsItem is not a QObject, QStyle driven
+        // animations are forced to update the whole scene
+        update();
+        break;
+    case QEvent::TouchBegin:
+    case QEvent::TouchUpdate:
+    case QEvent::TouchEnd:
+        d->touchEventHandler(static_cast<QTouchEvent *>(event));
+        break;
+#ifndef QT_NO_GESTURES
+    case QEvent::Gesture:
+    case QEvent::GestureOverride:
+        d->gestureEventHandler(static_cast<QGestureEvent *>(event));
+        break;
+#endif // QT_NO_GESTURES
+    default:
+        return QObject::event(event);
+    }
+    return true;
+}
+
+/*!
+    \reimp
+
+    QGraphicsScene filters QApplication's events to detect palette and font
+    changes.
+*/
+bool QGraphicsScene::eventFilter(QObject *watched, QEvent *event)
+{
+    if (watched != qApp)
+        return false;
+
+    switch (event->type()) {
+    case QEvent::ApplicationPaletteChange:
+        QApplication::postEvent(this, new QEvent(QEvent::ApplicationPaletteChange));
+        break;
+    case QEvent::ApplicationFontChange:
+        QApplication::postEvent(this, new QEvent(QEvent::ApplicationFontChange));
+        break;
+    default:
+        break;
+    }
+    return false;
+}
+
+/*!
+    This event handler, for event \a contextMenuEvent, can be reimplemented in
+    a subclass to receive context menu events. The default implementation
+    forwards the event to the topmost visible item that accepts context menu events at
+    the position of the event. If no items accept context menu events at this
+    position, the event is ignored.
+
+    Note: See items() for a definition of which items are considered visible by this function.
+
+    \sa QGraphicsItem::contextMenuEvent()
+*/
+void QGraphicsScene::contextMenuEvent(QGraphicsSceneContextMenuEvent *contextMenuEvent)
+{
+    Q_D(QGraphicsScene);
+    // Ignore by default.
+    contextMenuEvent->ignore();
+
+    // Send the event to all items at this position until one item accepts the
+    // event.
+    foreach (QGraphicsItem *item, d->itemsAtPosition(contextMenuEvent->screenPos(),
+                                                     contextMenuEvent->scenePos(),
+                                                     contextMenuEvent->widget())) {
+        contextMenuEvent->setPos(item->d_ptr->genericMapFromScene(contextMenuEvent->scenePos(),
+                                                                  contextMenuEvent->widget()));
+        contextMenuEvent->accept();
+        if (!d->sendEvent(item, contextMenuEvent))
+            break;
+
+        if (contextMenuEvent->isAccepted())
+            break;
+    }
+}
+
+/*!
+    This event handler, for event \a event, can be reimplemented in a subclass
+    to receive drag enter events for the scene.
+
+    The default implementation accepts the event and prepares the scene to
+    accept drag move events.
+
+    \sa QGraphicsItem::dragEnterEvent(), dragMoveEvent(), dragLeaveEvent(),
+    dropEvent()
+*/
+void QGraphicsScene::dragEnterEvent(QGraphicsSceneDragDropEvent *event)
+{
+    Q_D(QGraphicsScene);
+    d->dragDropItem = 0;
+    d->lastDropAction = Qt::IgnoreAction;
+    event->accept();
+}
+
+/*!
+    This event handler, for event \a event, can be reimplemented in a subclass
+    to receive drag move events for the scene.
+
+    Note: See items() for a definition of which items are considered visible by this function.
+
+    \sa QGraphicsItem::dragMoveEvent(), dragEnterEvent(), dragLeaveEvent(),
+    dropEvent()
+*/
+void QGraphicsScene::dragMoveEvent(QGraphicsSceneDragDropEvent *event)
+{
+    Q_D(QGraphicsScene);
+    event->ignore();
+
+    if (!d->mouseGrabberItems.isEmpty()) {
+        // Mouse grabbers that start drag events lose the mouse grab.
+        d->clearMouseGrabber();
+        d->mouseGrabberButtonDownPos.clear();
+        d->mouseGrabberButtonDownScenePos.clear();
+        d->mouseGrabberButtonDownScreenPos.clear();
+    }
+
+    bool eventDelivered = false;
+
+    // Find the topmost enabled items under the cursor. They are all
+    // candidates for accepting drag & drop events.
+    foreach (QGraphicsItem *item, d->itemsAtPosition(event->screenPos(),
+                                                     event->scenePos(),
+                                                     event->widget())) {
+        if (!item->isEnabled() || !item->acceptDrops())
+            continue;
+
+        if (item != d->dragDropItem) {
+            // Enter the new drag drop item. If it accepts the event, we send
+            // the leave to the parent item.
+            QGraphicsSceneDragDropEvent dragEnter(QEvent::GraphicsSceneDragEnter);
+            d->cloneDragDropEvent(&dragEnter, event);
+            dragEnter.setDropAction(event->proposedAction());
+            d->sendDragDropEvent(item, &dragEnter);
+            event->setAccepted(dragEnter.isAccepted());
+            event->setDropAction(dragEnter.dropAction());
+            if (!event->isAccepted()) {
+                // Propagate to the item under
+                continue;
+            }
+
+            d->lastDropAction = event->dropAction();
+
+            if (d->dragDropItem) {
+                // Leave the last drag drop item. A perfect implementation
+                // would set the position of this event to the point where
+                // this event and the last event intersect with the item's
+                // shape, but that's not easy to do. :-)
+                QGraphicsSceneDragDropEvent dragLeave(QEvent::GraphicsSceneDragLeave);
+                d->cloneDragDropEvent(&dragLeave, event);
+                d->sendDragDropEvent(d->dragDropItem, &dragLeave);
+            }
+
+            // We've got a new drag & drop item
+            d->dragDropItem = item;
+        }
+
+        // Send the move event.
+        event->setDropAction(d->lastDropAction);
+        event->accept();
+        d->sendDragDropEvent(item, event);
+        if (event->isAccepted())
+            d->lastDropAction = event->dropAction();
+        eventDelivered = true;
+        break;
+    }
+
+    if (!eventDelivered) {
+        if (d->dragDropItem) {
+            // Leave the last drag drop item
+            QGraphicsSceneDragDropEvent dragLeave(QEvent::GraphicsSceneDragLeave);
+            d->cloneDragDropEvent(&dragLeave, event);
+            d->sendDragDropEvent(d->dragDropItem, &dragLeave);
+            d->dragDropItem = 0;
+        }
+        // Propagate
+        event->setDropAction(Qt::IgnoreAction);
+    }
+}
+
+/*!
+    This event handler, for event \a event, can be reimplemented in a subclass
+    to receive drag leave events for the scene.
+
+    \sa QGraphicsItem::dragLeaveEvent(), dragEnterEvent(), dragMoveEvent(),
+    dropEvent()
+*/
+void QGraphicsScene::dragLeaveEvent(QGraphicsSceneDragDropEvent *event)
+{
+    Q_D(QGraphicsScene);
+    if (d->dragDropItem) {
+        // Leave the last drag drop item
+        d->sendDragDropEvent(d->dragDropItem, event);
+        d->dragDropItem = 0;
+    }
+}
+
+/*!
+    This event handler, for event \a event, can be reimplemented in a subclass
+    to receive drop events for the scene.
+
+    \sa QGraphicsItem::dropEvent(), dragEnterEvent(), dragMoveEvent(),
+    dragLeaveEvent()
+*/
+void QGraphicsScene::dropEvent(QGraphicsSceneDragDropEvent *event)
+{
+    Q_UNUSED(event);
+    Q_D(QGraphicsScene);
+    if (d->dragDropItem) {
+        // Drop on the last drag drop item
+        d->sendDragDropEvent(d->dragDropItem, event);
+        d->dragDropItem = 0;
+    }
+}
+
+/*!
+    This event handler, for event \a focusEvent, can be reimplemented in a
+    subclass to receive focus in events.
+
+    The default implementation sets focus on the scene, and then on the last
+    focus item.
+
+    \sa QGraphicsItem::focusOutEvent()
+*/
+void QGraphicsScene::focusInEvent(QFocusEvent *focusEvent)
+{
+    Q_D(QGraphicsScene);
+
+    d->hasFocus = true;
+    switch (focusEvent->reason()) {
+    case Qt::TabFocusReason:
+        if (!focusNextPrevChild(true))
+            focusEvent->ignore();
+        break;
+    case Qt::BacktabFocusReason:
+        if (!focusNextPrevChild(false))
+            focusEvent->ignore();
+        break;
+    default:
+        if (d->passiveFocusItem) {
+            // Set focus on the last focus item
+            setFocusItem(d->passiveFocusItem, focusEvent->reason());
+        }
+        break;
+    }
+}
+
+/*!
+    This event handler, for event \a focusEvent, can be reimplemented in a
+    subclass to receive focus out events.
+
+    The default implementation removes focus from any focus item, then removes
+    focus from the scene.
+
+    \sa QGraphicsItem::focusInEvent()
+*/
+void QGraphicsScene::focusOutEvent(QFocusEvent *focusEvent)
+{
+    Q_D(QGraphicsScene);
+    d->hasFocus = false;
+    d->passiveFocusItem = d->focusItem;
+    setFocusItem(0, focusEvent->reason());
+
+    // Remove all popups when the scene loses focus.
+    if (!d->popupWidgets.isEmpty())
+        d->removePopup(d->popupWidgets.first());
+}
+
+/*!
+    This event handler, for event \a helpEvent, can be
+    reimplemented in a subclass to receive help events. The events
+    are of type QEvent::ToolTip, which are created when a tooltip is
+    requested.
+
+    The default implementation shows the tooltip of the topmost
+    visible item, i.e., the item with the highest z-value, at the mouse
+    cursor position. If no item has a tooltip set, this function
+    does nothing.
+
+    Note: See items() for a definition of which items are considered visible by this function.
+
+    \sa QGraphicsItem::toolTip(), QGraphicsSceneHelpEvent
+*/
+void QGraphicsScene::helpEvent(QGraphicsSceneHelpEvent *helpEvent)
+{
+#ifdef QT_NO_TOOLTIP
+    Q_UNUSED(helpEvent);
+#else
+    // Find the first item that does tooltips
+    Q_D(QGraphicsScene);
+    QList<QGraphicsItem *> itemsAtPos = d->itemsAtPosition(helpEvent->screenPos(),
+                                                           helpEvent->scenePos(),
+                                                           helpEvent->widget());
+    QGraphicsItem *toolTipItem = 0;
+    for (int i = 0; i < itemsAtPos.size(); ++i) {
+        QGraphicsItem *tmp = itemsAtPos.at(i);
+        if (tmp->d_func()->isProxyWidget()) {
+            // if the item is a proxy widget, the event is forwarded to it
+            sendEvent(tmp, helpEvent);
+            if (helpEvent->isAccepted())
+                return;
+        }
+        if (!tmp->toolTip().isEmpty()) {
+            toolTipItem = tmp;
+            break;
+        }
+    }
+
+    // Show or hide the tooltip
+    QString text;
+    QPoint point;
+    if (toolTipItem && !toolTipItem->toolTip().isEmpty()) {
+        text = toolTipItem->toolTip();
+        point = helpEvent->screenPos();
+    }
+    QToolTip::showText(point, text, helpEvent->widget());
+    helpEvent->setAccepted(!text.isEmpty());
+#endif
+}
+
+bool QGraphicsScenePrivate::itemAcceptsHoverEvents_helper(const QGraphicsItem *item) const
+{
+    return (item->d_ptr->acceptsHover
+            || (item->d_ptr->isWidget
+                && static_cast<const QGraphicsWidget *>(item)->d_func()->hasDecoration()))
+           && !item->isBlockedByModalPanel();
+}
+
+/*!
+    This event handler, for event \a hoverEvent, can be reimplemented in a
+    subclass to receive hover enter events. The default implementation
+    forwards the event to the topmost visible item that accepts hover events at the
+    scene position from the event.
+
+    Note: See items() for a definition of which items are considered visible by this function.
+
+    \sa QGraphicsItem::hoverEvent(), QGraphicsItem::setAcceptHoverEvents()
+*/
+bool QGraphicsScenePrivate::dispatchHoverEvent(QGraphicsSceneHoverEvent *hoverEvent)
+{
+    if (allItemsIgnoreHoverEvents)
+        return false;
+
+    // Find the first item that accepts hover events, reusing earlier
+    // calculated data is possible.
+    if (cachedItemsUnderMouse.isEmpty()) {
+        cachedItemsUnderMouse = itemsAtPosition(hoverEvent->screenPos(),
+                                                hoverEvent->scenePos(),
+                                                hoverEvent->widget());
+    }
+
+    QGraphicsItem *item = 0;
+    for (int i = 0; i < cachedItemsUnderMouse.size(); ++i) {
+        QGraphicsItem *tmp = cachedItemsUnderMouse.at(i);
+        if (itemAcceptsHoverEvents_helper(tmp)) {
+            item = tmp;
+            break;
+        }
+    }
+
+    // Find the common ancestor item for the new topmost hoverItem and the
+    // last item in the hoverItem list.
+    QGraphicsItem *commonAncestorItem = (item && !hoverItems.isEmpty()) ? item->commonAncestorItem(hoverItems.last()) : 0;
+    while (commonAncestorItem && !itemAcceptsHoverEvents_helper(commonAncestorItem))
+        commonAncestorItem = commonAncestorItem->parentItem();
+    if (commonAncestorItem && commonAncestorItem->panel() != item->panel()) {
+        // The common ancestor isn't in the same panel as the two hovered
+        // items.
+        commonAncestorItem = 0;
+    }
+
+    // Check if the common ancestor item is known.
+    int index = commonAncestorItem ? hoverItems.indexOf(commonAncestorItem) : -1;
+    // Send hover leaves to any existing hovered children of the common
+    // ancestor item.
+    for (int i = hoverItems.size() - 1; i > index; --i) {
+        QGraphicsItem *lastItem = hoverItems.takeLast();
+        if (itemAcceptsHoverEvents_helper(lastItem))
+            sendHoverEvent(QEvent::GraphicsSceneHoverLeave, lastItem, hoverEvent);
+    }
+
+    // Item is a child of a known item. Generate enter events for the
+    // missing links.
+    QList<QGraphicsItem *> parents;
+    QGraphicsItem *parent = item;
+    while (parent && parent != commonAncestorItem) {
+        parents.prepend(parent);
+        if (parent->isPanel()) {
+            // Stop at the panel - we don't deliver beyond this point.
+            break;
+        }
+        parent = parent->parentItem();
+    }
+    for (int i = 0; i < parents.size(); ++i) {
+        parent = parents.at(i);
+        hoverItems << parent;
+        if (itemAcceptsHoverEvents_helper(parent))
+            sendHoverEvent(QEvent::GraphicsSceneHoverEnter, parent, hoverEvent);
+    }
+
+    // Generate a move event for the item itself
+    if (item
+        && !hoverItems.isEmpty()
+        && item == hoverItems.last()) {
+        sendHoverEvent(QEvent::GraphicsSceneHoverMove, item, hoverEvent);
+        return true;
+    }
+    return false;
+}
+
+/*!
+    \internal
+
+    Handles all actions necessary to clean up the scene when the mouse leaves
+    the view.
+*/
+void QGraphicsScenePrivate::leaveScene(QWidget *viewport)
+{
+#ifndef QT_NO_TOOLTIP
+    QToolTip::hideText();
+#endif
+    QGraphicsView *view = qobject_cast<QGraphicsView *>(viewport->parent());
+    // Send HoverLeave events to all existing hover items, topmost first.
+    QGraphicsSceneHoverEvent hoverEvent;
+    hoverEvent.setWidget(viewport);
+
+    if (view) {
+        QPoint cursorPos = QCursor::pos();
+        hoverEvent.setScenePos(view->mapToScene(viewport->mapFromGlobal(cursorPos)));
+        hoverEvent.setLastScenePos(hoverEvent.scenePos());
+        hoverEvent.setScreenPos(cursorPos);
+        hoverEvent.setLastScreenPos(hoverEvent.screenPos());
+    }
+
+    while (!hoverItems.isEmpty()) {
+        QGraphicsItem *lastItem = hoverItems.takeLast();
+        if (itemAcceptsHoverEvents_helper(lastItem))
+            sendHoverEvent(QEvent::GraphicsSceneHoverLeave, lastItem, &hoverEvent);
+    }
+}
+
+/*!
+    This event handler, for event \a keyEvent, can be reimplemented in a
+    subclass to receive keypress events. The default implementation forwards
+    the event to current focus item.
+
+    \sa QGraphicsItem::keyPressEvent(), focusItem()
+*/
+void QGraphicsScene::keyPressEvent(QKeyEvent *keyEvent)
+{
+    // ### Merge this function with keyReleaseEvent; they are identical
+    // ### (except this comment).
+    Q_D(QGraphicsScene);
+    QGraphicsItem *item = !d->keyboardGrabberItems.isEmpty() ? d->keyboardGrabberItems.last() : 0;
+    if (!item)
+        item = focusItem();
+    if (item) {
+        QGraphicsItem *p = item;
+        do {
+            // Accept the event by default
+            keyEvent->accept();
+            // Send it; QGraphicsItem::keyPressEvent ignores it.  If the event
+            // is filtered out, stop propagating it.
+            if (p->isBlockedByModalPanel())
+                break;
+            if (!d->sendEvent(p, keyEvent))
+                break;
+        } while (!keyEvent->isAccepted() && !p->isPanel() && (p = p->parentItem()));
+    } else {
+        keyEvent->ignore();
+    }
+}
+
+/*!
+    This event handler, for event \a keyEvent, can be reimplemented in a
+    subclass to receive key release events. The default implementation
+    forwards the event to current focus item.
+
+    \sa QGraphicsItem::keyReleaseEvent(), focusItem()
+*/
+void QGraphicsScene::keyReleaseEvent(QKeyEvent *keyEvent)
+{
+    // ### Merge this function with keyPressEvent; they are identical (except
+    // ### this comment).
+    Q_D(QGraphicsScene);
+    QGraphicsItem *item = !d->keyboardGrabberItems.isEmpty() ? d->keyboardGrabberItems.last() : 0;
+    if (!item)
+        item = focusItem();
+    if (item) {
+        QGraphicsItem *p = item;
+        do {
+            // Accept the event by default
+            keyEvent->accept();
+            // Send it; QGraphicsItem::keyPressEvent ignores it.  If the event
+            // is filtered out, stop propagating it.
+            if (p->isBlockedByModalPanel())
+                break;
+            if (!d->sendEvent(p, keyEvent))
+                break;
+        } while (!keyEvent->isAccepted() && !p->isPanel() && (p = p->parentItem()));
+    } else {
+        keyEvent->ignore();
+    }
+}
+
+/*!
+    This event handler, for event \a mouseEvent, can be reimplemented
+    in a subclass to receive mouse press events for the scene.
+
+    The default implementation depends on the state of the scene. If
+    there is a mouse grabber item, then the event is sent to the mouse
+    grabber. Otherwise, it is forwarded to the topmost visible item that
+    accepts mouse events at the scene position from the event, and
+    that item promptly becomes the mouse grabber item.
+
+    If there is no item at the given position on the scene, the
+    selection area is reset, any focus item loses its input focus, and
+    the event is then ignored.
+
+    Note: See items() for a definition of which items are considered visible by this function.
+
+    \sa QGraphicsItem::mousePressEvent(),
+    QGraphicsItem::setAcceptedMouseButtons()
+*/
+void QGraphicsScene::mousePressEvent(QGraphicsSceneMouseEvent *mouseEvent)
+{
+    Q_D(QGraphicsScene);
+    if (d->mouseGrabberItems.isEmpty()) {
+        // Dispatch hover events
+        QGraphicsSceneHoverEvent hover;
+        _q_hoverFromMouseEvent(&hover, mouseEvent);
+        d->dispatchHoverEvent(&hover);
+    }
+
+    d->mousePressEventHandler(mouseEvent);
+}
+
+/*!
+    This event handler, for event \a mouseEvent, can be reimplemented
+    in a subclass to receive mouse move events for the scene.
+
+    The default implementation depends on the mouse grabber state. If there is
+    a mouse grabber item, the event is sent to the mouse grabber.  If there
+    are any items that accept hover events at the current position, the event
+    is translated into a hover event and accepted; otherwise it's ignored.
+
+    \sa QGraphicsItem::mousePressEvent(), QGraphicsItem::mouseReleaseEvent(),
+    QGraphicsItem::mouseDoubleClickEvent(), QGraphicsItem::setAcceptedMouseButtons()
+*/
+void QGraphicsScene::mouseMoveEvent(QGraphicsSceneMouseEvent *mouseEvent)
+{
+    Q_D(QGraphicsScene);
+    if (d->mouseGrabberItems.isEmpty()) {
+        if (mouseEvent->buttons())
+            return;
+        QGraphicsSceneHoverEvent hover;
+        _q_hoverFromMouseEvent(&hover, mouseEvent);
+        mouseEvent->setAccepted(d->dispatchHoverEvent(&hover));
+        return;
+    }
+
+    // Forward the event to the mouse grabber
+    d->sendMouseEvent(mouseEvent);
+    mouseEvent->accept();
+}
+
+/*!
+    This event handler, for event \a mouseEvent, can be reimplemented
+    in a subclass to receive mouse release events for the scene.
+
+    The default implementation depends on the mouse grabber state.  If
+    there is no mouse grabber, the event is ignored.  Otherwise, if
+    there is a mouse grabber item, the event is sent to the mouse
+    grabber. If this mouse release represents the last pressed button
+    on the mouse, the mouse grabber item then loses the mouse grab.
+
+    \sa QGraphicsItem::mousePressEvent(), QGraphicsItem::mouseMoveEvent(),
+    QGraphicsItem::mouseDoubleClickEvent(), QGraphicsItem::setAcceptedMouseButtons()
+*/
+void QGraphicsScene::mouseReleaseEvent(QGraphicsSceneMouseEvent *mouseEvent)
+{
+    Q_D(QGraphicsScene);
+    if (d->mouseGrabberItems.isEmpty()) {
+        mouseEvent->ignore();
+        return;
+    }
+
+    // Forward the event to the mouse grabber
+    d->sendMouseEvent(mouseEvent);
+    mouseEvent->accept();
+
+    // Reset the mouse grabber when the last mouse button has been released.
+    if (!mouseEvent->buttons()) {
+        if (!d->mouseGrabberItems.isEmpty()) {
+            d->lastMouseGrabberItem = d->mouseGrabberItems.last();
+            if (d->lastMouseGrabberItemHasImplicitMouseGrab)
+                d->mouseGrabberItems.last()->ungrabMouse();
+        } else {
+            d->lastMouseGrabberItem = 0;
+        }
+
+        // Generate a hoverevent
+        QGraphicsSceneHoverEvent hoverEvent;
+        _q_hoverFromMouseEvent(&hoverEvent, mouseEvent);
+        d->dispatchHoverEvent(&hoverEvent);
+    }
+}
+
+/*!
+    This event handler, for event \a mouseEvent, can be reimplemented
+    in a subclass to receive mouse doubleclick events for the scene.
+
+    If someone doubleclicks on the scene, the scene will first receive
+    a mouse press event, followed by a release event (i.e., a click),
+    then a doubleclick event, and finally a release event. If the
+    doubleclick event is delivered to a different item than the one
+    that received the first press and release, it will be delivered as
+    a press event. However, tripleclick events are not delivered as
+    doubleclick events in this case.
+
+    The default implementation is similar to mousePressEvent().
+
+    Note: See items() for a definition of which items are considered visible by this function.
+
+    \sa QGraphicsItem::mousePressEvent(), QGraphicsItem::mouseMoveEvent(),
+    QGraphicsItem::mouseReleaseEvent(), QGraphicsItem::setAcceptedMouseButtons()
+*/
+void QGraphicsScene::mouseDoubleClickEvent(QGraphicsSceneMouseEvent *mouseEvent)
+{
+    Q_D(QGraphicsScene);
+    d->mousePressEventHandler(mouseEvent);
+}
+
+/*!
+    This event handler, for event \a wheelEvent, can be reimplemented in a
+    subclass to receive mouse wheel events for the scene.
+
+    By default, the event is delivered to the topmost visible item under the
+    cursor. If ignored, the event propagates to the item beneath, and again
+    until the event is accepted, or it reaches the scene. If no items accept
+    the event, it is ignored.
+
+    Note: See items() for a definition of which items are considered visible by this function.
+
+    \sa QGraphicsItem::wheelEvent()
+*/
+void QGraphicsScene::wheelEvent(QGraphicsSceneWheelEvent *wheelEvent)
+{
+    Q_D(QGraphicsScene);
+    QList<QGraphicsItem *> wheelCandidates = d->itemsAtPosition(wheelEvent->screenPos(),
+                                                                wheelEvent->scenePos(),
+                                                                wheelEvent->widget());
+
+#ifdef Q_WS_MAC
+    // On Mac, ignore the event if the first item under the mouse is not the last opened
+    // popup (or one of its descendant)
+    if (!d->popupWidgets.isEmpty() && !wheelCandidates.isEmpty() && wheelCandidates.first() != d->popupWidgets.back() && !d->popupWidgets.back()->isAncestorOf(wheelCandidates.first())) {
+        wheelEvent->accept();
+        return;
+    }
+#else
+    // Find the first popup under the mouse (including the popup's descendants) starting from the last.
+    // Remove all popups after the one found, or all or them if no popup is under the mouse.
+    // Then continue with the event.
+    QList<QGraphicsWidget *>::const_iterator iter = d->popupWidgets.constEnd();
+    while (--iter >= d->popupWidgets.constBegin() && !wheelCandidates.isEmpty()) {
+        if (wheelCandidates.first() == *iter || (*iter)->isAncestorOf(wheelCandidates.first()))
+            break;
+        d->removePopup(*iter);
+    }
+#endif
+
+    bool hasSetFocus = false;
+    foreach (QGraphicsItem *item, wheelCandidates) {
+        if (!hasSetFocus && item->isEnabled()
+            && ((item->flags() & QGraphicsItem::ItemIsFocusable) && item->d_ptr->mouseSetsFocus)) {
+            if (item->isWidget() && static_cast<QGraphicsWidget *>(item)->focusPolicy() == Qt::WheelFocus) {
+                hasSetFocus = true;
+                if (item != focusItem())
+                    setFocusItem(item, Qt::MouseFocusReason);
+            }
+        }
+
+        wheelEvent->setPos(item->d_ptr->genericMapFromScene(wheelEvent->scenePos(),
+                                                            wheelEvent->widget()));
+        wheelEvent->accept();
+        bool isPanel = item->isPanel();
+        bool ret = d->sendEvent(item, wheelEvent);
+
+        if (ret && (isPanel || wheelEvent->isAccepted()))
+            break;
+    }
+}
+
+/*!
+    This event handler, for event \a event, can be reimplemented in a
+    subclass to receive input method events for the scene.
+
+    The default implementation forwards the event to the focusItem().
+    If no item currently has focus or the current focus item does not
+    accept input methods, this function does nothing.
+
+    \sa QGraphicsItem::inputMethodEvent()
+*/
+void QGraphicsScene::inputMethodEvent(QInputMethodEvent *event)
+{
+    Q_D(QGraphicsScene);
+    if (d->focusItem && (d->focusItem->flags() & QGraphicsItem::ItemAcceptsInputMethod))
+        d->sendEvent(d->focusItem, event);
+}
+
+/*!
+    Draws the background of the scene using \a painter, before any items and
+    the foreground are drawn. Reimplement this function to provide a custom
+    background for the scene.
+
+    All painting is done in \e scene coordinates. The \a rect
+    parameter is the exposed rectangle.
+
+    If all you want is to define a color, texture, or gradient for the
+    background, you can call setBackgroundBrush() instead.
+
+    \sa drawForeground(), drawItems()
+*/
+void QGraphicsScene::drawBackground(QPainter *painter, const QRectF &rect)
+{
+    Q_D(QGraphicsScene);
+
+    if (d->backgroundBrush.style() != Qt::NoBrush) {
+        if (d->painterStateProtection)
+            painter->save();
+        painter->setBrushOrigin(0, 0);
+        painter->fillRect(rect, backgroundBrush());
+        if (d->painterStateProtection)
+            painter->restore();
+    }
+}
+
+/*!
+    Draws the foreground of the scene using \a painter, after the background
+    and all items have been drawn. Reimplement this function to provide a
+    custom foreground for the scene.
+
+    All painting is done in \e scene coordinates. The \a rect
+    parameter is the exposed rectangle.
+
+    If all you want is to define a color, texture or gradient for the
+    foreground, you can call setForegroundBrush() instead.
+
+    \sa drawBackground(), drawItems()
+*/
+void QGraphicsScene::drawForeground(QPainter *painter, const QRectF &rect)
+{
+    Q_D(QGraphicsScene);
+
+    if (d->foregroundBrush.style() != Qt::NoBrush) {
+        if (d->painterStateProtection)
+            painter->save();
+        painter->setBrushOrigin(0, 0);
+        painter->fillRect(rect, foregroundBrush());
+        if (d->painterStateProtection)
+            painter->restore();
+    }
+}
+
+static void _q_paintItem(QGraphicsItem *item, QPainter *painter,
+                         const QStyleOptionGraphicsItem *option, QWidget *widget,
+                         bool useWindowOpacity, bool painterStateProtection)
+{
+    if (!item->isWidget()) {
+        item->paint(painter, option, widget);
+        return;
+    }
+    QGraphicsWidget *widgetItem = static_cast<QGraphicsWidget *>(item);
+    QGraphicsProxyWidget *proxy = qobject_cast<QGraphicsProxyWidget *>(widgetItem);
+    const qreal windowOpacity = (proxy && proxy->widget() && useWindowOpacity)
+                                ? proxy->widget()->windowOpacity() : 1.0;
+    const qreal oldPainterOpacity = painter->opacity();
+
+    if (qFuzzyIsNull(windowOpacity))
+        return;
+    // Set new painter opacity.
+    if (windowOpacity < 1.0)
+        painter->setOpacity(oldPainterOpacity * windowOpacity);
+
+    // set layoutdirection on the painter
+    Qt::LayoutDirection oldLayoutDirection = painter->layoutDirection();
+    painter->setLayoutDirection(widgetItem->layoutDirection());
+
+    if (widgetItem->isWindow() && widgetItem->windowType() != Qt::Popup && widgetItem->windowType() != Qt::ToolTip
+        && !(widgetItem->windowFlags() & Qt::FramelessWindowHint)) {
+        if (painterStateProtection)
+            painter->save();
+        widgetItem->paintWindowFrame(painter, option, widget);
+        if (painterStateProtection)
+            painter->restore();
+    } else if (widgetItem->autoFillBackground()) {
+        painter->fillRect(option->exposedRect, widgetItem->palette().window());
+    }
+
+    widgetItem->paint(painter, option, widget);
+
+    // Restore layoutdirection on the painter.
+    painter->setLayoutDirection(oldLayoutDirection);
+    // Restore painter opacity.
+    if (windowOpacity < 1.0)
+        painter->setOpacity(oldPainterOpacity);
+}
+
+static void _q_paintIntoCache(QPixmap *pix, QGraphicsItem *item, const QRegion &pixmapExposed,
+                              const QTransform &itemToPixmap, QPainter::RenderHints renderHints,
+                              const QStyleOptionGraphicsItem *option, bool painterStateProtection)
+{
+    QPixmap subPix;
+    QPainter pixmapPainter;
+    QRect br = pixmapExposed.boundingRect();
+
+    // Don't use subpixmap if we get a full update.
+    if (pixmapExposed.isEmpty() || (pixmapExposed.rectCount() == 1 && br.contains(pix->rect()))) {
+        pix->fill(Qt::transparent);
+        pixmapPainter.begin(pix);
+    } else {
+        subPix = QPixmap(br.size());
+        subPix.fill(Qt::transparent);
+        pixmapPainter.begin(&subPix);
+        pixmapPainter.translate(-br.topLeft());
+        if (!pixmapExposed.isEmpty()) {
+            // Applied to subPix; paint is adjusted to the coordinate space is
+            // correct.
+            pixmapPainter.setClipRegion(pixmapExposed);
+        }
+    }
+
+    pixmapPainter.setRenderHints(pixmapPainter.renderHints(), false);
+    pixmapPainter.setRenderHints(renderHints, true);
+    pixmapPainter.setWorldTransform(itemToPixmap, true);
+
+    // Render.
+    _q_paintItem(item, &pixmapPainter, option, 0, false, painterStateProtection);
+    pixmapPainter.end();
+
+    if (!subPix.isNull()) {
+        // Blit the subpixmap into the main pixmap.
+        pixmapPainter.begin(pix);
+        pixmapPainter.setCompositionMode(QPainter::CompositionMode_Source);
+        pixmapPainter.setClipRegion(pixmapExposed);
+        pixmapPainter.drawPixmap(br.topLeft(), subPix);
+        pixmapPainter.end();
+    }
+}
+
+// Copied from qpaintengine_vg.cpp
+// Returns \c true for 90, 180, and 270 degree rotations.
+static inline bool transformIsSimple(const QTransform& transform)
+{
+    QTransform::TransformationType type = transform.type();
+    if (type <= QTransform::TxScale) {
+        return true;
+    } else if (type == QTransform::TxRotate) {
+        // Check for 90, and 270 degree rotations.
+        qreal m11 = transform.m11();
+        qreal m12 = transform.m12();
+        qreal m21 = transform.m21();
+        qreal m22 = transform.m22();
+        if (m11 == 0.0f && m22 == 0.0f) {
+            if (m12 == 1.0f && m21 == -1.0f)
+                return true; // 90 degrees.
+            else if (m12 == -1.0f && m21 == 1.0f)
+                return true; // 270 degrees.
+            else if (m12 == -1.0f && m21 == -1.0f)
+                return true; // 90 degrees inverted y.
+            else if (m12 == 1.0f && m21 == 1.0f)
+                return true; // 270 degrees inverted y.
+        }
+    }
+    return false;
+}
+
+/*!
+    \internal
+
+    Draws items directly, or using cache.
+*/
+void QGraphicsScenePrivate::drawItemHelper(QGraphicsItem *item, QPainter *painter,
+                                           const QStyleOptionGraphicsItem *option, QWidget *widget,
+                                           bool painterStateProtection)
+{
+    QGraphicsItemPrivate *itemd = item->d_ptr.data();
+    QGraphicsItem::CacheMode cacheMode = QGraphicsItem::CacheMode(itemd->cacheMode);
+
+    // Render directly, using no cache.
+    if (cacheMode == QGraphicsItem::NoCache
+#ifdef Q_WS_X11
+        || !X11->use_xrender
+#endif
+        ) {
+        _q_paintItem(static_cast<QGraphicsWidget *>(item), painter, option, widget, true, painterStateProtection);
+        return;
+    }
+
+    const qreal oldPainterOpacity = painter->opacity();
+    qreal newPainterOpacity = oldPainterOpacity;
+    QGraphicsProxyWidget *proxy = item->isWidget() ? qobject_cast<QGraphicsProxyWidget *>(static_cast<QGraphicsWidget *>(item)) : 0;
+    if (proxy && proxy->widget()) {
+        const qreal windowOpacity = proxy->widget()->windowOpacity();
+        if (windowOpacity < 1.0)
+            newPainterOpacity *= windowOpacity;
+    }
+
+    // Item's (local) bounding rect
+    QRectF brect = item->boundingRect();
+    QRectF adjustedBrect(brect);
+    _q_adjustRect(&adjustedBrect);
+    if (adjustedBrect.isEmpty())
+        return;
+
+    // Fetch the off-screen transparent buffer and exposed area info.
+    QPixmapCache::Key pixmapKey;
+    QPixmap pix;
+    bool pixmapFound;
+    QGraphicsItemCache *itemCache = itemd->extraItemCache();
+    if (cacheMode == QGraphicsItem::ItemCoordinateCache) {
+        pixmapKey = itemCache->key;
+    } else {
+        pixmapKey = itemCache->deviceData.value(widget).key;
+    }
+
+    // Find pixmap in cache.
+    pixmapFound = QPixmapCache::find(pixmapKey, &pix);
+
+    // Render using item coordinate cache mode.
+    if (cacheMode == QGraphicsItem::ItemCoordinateCache) {
+        QSize pixmapSize;
+        bool fixedCacheSize = false;
+        QRect br = brect.toAlignedRect();
+        if ((fixedCacheSize = itemCache->fixedSize.isValid())) {
+            pixmapSize = itemCache->fixedSize;
+        } else {
+            pixmapSize = br.size();
+        }
+
+        // Create or recreate the pixmap.
+        int adjust = itemCache->fixedSize.isValid() ? 0 : 2;
+        QSize adjustSize(adjust*2, adjust*2);
+        br.adjust(-adjust, -adjust, adjust, adjust);
+        if (pix.isNull() || (!fixedCacheSize && (pixmapSize + adjustSize) != pix.size())) {
+            pix = QPixmap(pixmapSize + adjustSize);
+            itemCache->boundingRect = br;
+            itemCache->exposed.clear();
+            itemCache->allExposed = true;
+        } else if (itemCache->boundingRect != br) {
+            itemCache->boundingRect = br;
+            itemCache->exposed.clear();
+            itemCache->allExposed = true;
+        }
+
+        // Redraw any newly exposed areas.
+        if (itemCache->allExposed || !itemCache->exposed.isEmpty()) {
+
+            //We know that we will modify the pixmap, removing it from the cache
+            //will detach the one we have and avoid a deep copy
+            if (pixmapFound)
+                QPixmapCache::remove(pixmapKey);
+
+            // Fit the item's bounding rect into the pixmap's coordinates.
+            QTransform itemToPixmap;
+            if (fixedCacheSize) {
+                const QPointF scale(pixmapSize.width() / brect.width(), pixmapSize.height() / brect.height());
+                itemToPixmap.scale(scale.x(), scale.y());
+            }
+            itemToPixmap.translate(-br.x(), -br.y());
+
+            // Generate the item's exposedRect and map its list of expose
+            // rects to device coordinates.
+            styleOptionTmp = *option;
+            QRegion pixmapExposed;
+            QRectF exposedRect;
+            if (!itemCache->allExposed) {
+                for (int i = 0; i < itemCache->exposed.size(); ++i) {
+                    QRectF r = itemCache->exposed.at(i);
+                    exposedRect |= r;
+                    pixmapExposed += itemToPixmap.mapRect(r).toAlignedRect();
+                }
+            } else {
+                exposedRect = brect;
+            }
+            styleOptionTmp.exposedRect = exposedRect;
+
+            // Render.
+            _q_paintIntoCache(&pix, item, pixmapExposed, itemToPixmap, painter->renderHints(),
+                              &styleOptionTmp, painterStateProtection);
+
+            // insert this pixmap into the cache.
+            itemCache->key = QPixmapCache::insert(pix);
+
+            // Reset expose data.
+            itemCache->allExposed = false;
+            itemCache->exposed.clear();
+        }
+
+        // Redraw the exposed area using the transformed painter. Depending on
+        // the hardware, this may be a server-side operation, or an expensive
+        // qpixmap-image-transform-pixmap roundtrip.
+        if (newPainterOpacity != oldPainterOpacity) {
+            painter->setOpacity(newPainterOpacity);
+            painter->drawPixmap(br.topLeft(), pix);
+            painter->setOpacity(oldPainterOpacity);
+        } else {
+            painter->drawPixmap(br.topLeft(), pix);
+        }
+        return;
+    }
+
+    // Render using device coordinate cache mode.
+    if (cacheMode == QGraphicsItem::DeviceCoordinateCache) {
+        // Find the item's bounds in device coordinates.
+        QRectF deviceBounds = painter->worldTransform().mapRect(brect);
+        QRect deviceRect = deviceBounds.toRect().adjusted(-1, -1, 1, 1);
+        if (deviceRect.isEmpty())
+            return;
+        QRect viewRect = widget ? widget->rect() : QRect();
+        if (widget && !viewRect.intersects(deviceRect))
+            return;
+
+        // Resort to direct rendering if the device rect exceeds the
+        // (optional) maximum bounds. (QGraphicsSvgItem uses this).
+        QSize maximumCacheSize =
+            itemd->extra(QGraphicsItemPrivate::ExtraMaxDeviceCoordCacheSize).toSize();
+        if (!maximumCacheSize.isEmpty()
+            && (deviceRect.width() > maximumCacheSize.width()
+                || deviceRect.height() > maximumCacheSize.height())) {
+            _q_paintItem(static_cast<QGraphicsWidget *>(item), painter, option, widget,
+                         oldPainterOpacity != newPainterOpacity, painterStateProtection);
+            return;
+        }
+
+        // Create or reuse offscreen pixmap, possibly scroll/blit from the old one.
+        // If the world transform is rotated we always recreate the cache to avoid
+        // wrong blending.
+        bool pixModified = false;
+        QGraphicsItemCache::DeviceData *deviceData = &itemCache->deviceData[widget];
+        bool invertable = true;
+        QTransform diff = deviceData->lastTransform.inverted(&invertable);
+        if (invertable)
+            diff *= painter->worldTransform();
+        deviceData->lastTransform = painter->worldTransform();
+        bool allowPartialCacheExposure = false;
+        bool simpleTransform = invertable && diff.type() <= QTransform::TxTranslate
+                               && transformIsSimple(painter->worldTransform());
+        if (!simpleTransform) {
+            pixModified = true;
+            itemCache->allExposed = true;
+            itemCache->exposed.clear();
+            deviceData->cacheIndent = QPoint();
+            pix = QPixmap();
+        } else if (!viewRect.isNull()) {
+            allowPartialCacheExposure = deviceData->cacheIndent != QPoint();
+        }
+
+        // Allow partial cache exposure if the device rect isn't fully contained and
+        // deviceRect is 20% taller or wider than the viewRect.
+        if (!allowPartialCacheExposure && !viewRect.isNull() && !viewRect.contains(deviceRect)) {
+            allowPartialCacheExposure = (viewRect.width() * 1.2 < deviceRect.width())
+                                         || (viewRect.height() * 1.2 < deviceRect.height());
+        }
+
+        QRegion scrollExposure;
+        if (allowPartialCacheExposure) {
+            // Part of pixmap is drawn. Either device contains viewrect (big
+            // item covers whole screen) or parts of device are outside the
+            // viewport. In either case the device rect must be the intersect
+            // between the two.
+            int dx = deviceRect.left() < viewRect.left() ? viewRect.left() - deviceRect.left() : 0;
+            int dy = deviceRect.top() < viewRect.top() ? viewRect.top() - deviceRect.top() : 0;
+            QPoint newCacheIndent(dx, dy);
+            deviceRect &= viewRect;
+
+            if (pix.isNull()) {
+                deviceData->cacheIndent = QPoint();
+                itemCache->allExposed = true;
+                itemCache->exposed.clear();
+                pixModified = true;
+            }
+
+            // Copy / "scroll" the old pixmap onto the new ole and calculate
+            // scrolled exposure.
+            if (newCacheIndent != deviceData->cacheIndent || deviceRect.size() != pix.size()) {
+                QPoint diff = newCacheIndent - deviceData->cacheIndent;
+                QPixmap newPix(deviceRect.size());
+                // ### Investigate removing this fill (test with Plasma and
+                // graphicssystem raster).
+                newPix.fill(Qt::transparent);
+                if (!pix.isNull()) {
+                    QPainter newPixPainter(&newPix);
+                    newPixPainter.drawPixmap(-diff, pix);
+                    newPixPainter.end();
+                }
+                QRegion exposed;
+                exposed += newPix.rect();
+                if (!pix.isNull())
+                    exposed -= QRect(-diff, pix.size());
+                scrollExposure = exposed;
+
+                pix = newPix;
+                pixModified = true;
+            }
+            deviceData->cacheIndent = newCacheIndent;
+        } else {
+            // Full pixmap is drawn.
+            deviceData->cacheIndent = QPoint();
+
+            // Auto-adjust the pixmap size.
+            if (deviceRect.size() != pix.size()) {
+                // exposed needs to cover the whole pixmap
+                pix = QPixmap(deviceRect.size());
+                pixModified = true;
+                itemCache->allExposed = true;
+                itemCache->exposed.clear();
+            }
+        }
+
+        // Check for newly invalidated areas.
+        if (itemCache->allExposed || !itemCache->exposed.isEmpty() || !scrollExposure.isEmpty()) {
+            //We know that we will modify the pixmap, removing it from the cache
+            //will detach the one we have and avoid a deep copy
+            if (pixmapFound)
+                QPixmapCache::remove(pixmapKey);
+
+            // Construct an item-to-pixmap transform.
+            QPointF p = deviceRect.topLeft();
+            QTransform itemToPixmap = painter->worldTransform();
+            if (!p.isNull())
+                itemToPixmap *= QTransform::fromTranslate(-p.x(), -p.y());
+
+            // Map the item's logical expose to pixmap coordinates.
+            QRegion pixmapExposed = scrollExposure;
+            if (!itemCache->allExposed) {
+                const QVector<QRectF> &exposed = itemCache->exposed;
+                for (int i = 0; i < exposed.size(); ++i)
+                    pixmapExposed += itemToPixmap.mapRect(exposed.at(i)).toRect().adjusted(-1, -1, 1, 1);
+            }
+
+            // Calculate the style option's exposedRect.
+            QRectF br;
+            if (itemCache->allExposed) {
+                br = item->boundingRect();
+            } else {
+                const QVector<QRectF> &exposed = itemCache->exposed;
+                for (int i = 0; i < exposed.size(); ++i)
+                    br |= exposed.at(i);
+                QTransform pixmapToItem = itemToPixmap.inverted();
+                foreach (const QRect &r, scrollExposure.rects())
+                    br |= pixmapToItem.mapRect(r);
+            }
+            styleOptionTmp = *option;
+            styleOptionTmp.exposedRect = br.adjusted(-1, -1, 1, 1);
+
+            // Render the exposed areas.
+            _q_paintIntoCache(&pix, item, pixmapExposed, itemToPixmap, painter->renderHints(),
+                              &styleOptionTmp, painterStateProtection);
+
+            // Reset expose data.
+            pixModified = true;
+            itemCache->allExposed = false;
+            itemCache->exposed.clear();
+        }
+
+        if (pixModified) {
+            // Insert this pixmap into the cache.
+            deviceData->key = QPixmapCache::insert(pix);
+        }
+
+        // Redraw the exposed area using an untransformed painter. This
+        // effectively becomes a bitblit that does not transform the cache.
+        QTransform restoreTransform = painter->worldTransform();
+        painter->setWorldTransform(QTransform());
+        if (newPainterOpacity != oldPainterOpacity) {
+            painter->setOpacity(newPainterOpacity);
+            painter->drawPixmap(deviceRect.topLeft(), pix);
+            painter->setOpacity(oldPainterOpacity);
+        } else {
+            painter->drawPixmap(deviceRect.topLeft(), pix);
+        }
+        painter->setWorldTransform(restoreTransform);
+        return;
+    }
+}
+
+void QGraphicsScenePrivate::drawItems(QPainter *painter, const QTransform *const viewTransform,
+                                      QRegion *exposedRegion, QWidget *widget)
+{
+    // Make sure we don't have unpolished items before we draw.
+    if (!unpolishedItems.isEmpty())
+        _q_polishItems();
+
+    updateAll = false;
+    QRectF exposedSceneRect;
+    if (exposedRegion && indexMethod != QGraphicsScene::NoIndex) {
+        exposedSceneRect = exposedRegion->boundingRect().adjusted(-1, -1, 1, 1);
+        if (viewTransform)
+            exposedSceneRect = viewTransform->inverted().mapRect(exposedSceneRect);
+    }
+    const QList<QGraphicsItem *> tli = index->estimateTopLevelItems(exposedSceneRect, Qt::AscendingOrder);
+    for (int i = 0; i < tli.size(); ++i)
+        drawSubtreeRecursive(tli.at(i), painter, viewTransform, exposedRegion, widget);
+}
+
+void QGraphicsScenePrivate::drawSubtreeRecursive(QGraphicsItem *item, QPainter *painter,
+                                                 const QTransform *const viewTransform,
+                                                 QRegion *exposedRegion, QWidget *widget,
+                                                 qreal parentOpacity, const QTransform *const effectTransform)
+{
+    Q_ASSERT(item);
+
+    if (!item->d_ptr->visible)
+        return;
+
+    const bool itemHasContents = !(item->d_ptr->flags & QGraphicsItem::ItemHasNoContents);
+    const bool itemHasChildren = !item->d_ptr->children.isEmpty();
+    if (!itemHasContents && !itemHasChildren)
+        return; // Item has neither contents nor children!(?)
+
+    const qreal opacity = item->d_ptr->combineOpacityFromParent(parentOpacity);
+    const bool itemIsFullyTransparent = QGraphicsItemPrivate::isOpacityNull(opacity);
+    if (itemIsFullyTransparent && (!itemHasChildren || item->d_ptr->childrenCombineOpacity()))
+        return;
+
+    QTransform transform(Qt::Uninitialized);
+    QTransform *transformPtr = 0;
+    bool translateOnlyTransform = false;
+#define ENSURE_TRANSFORM_PTR \
+    if (!transformPtr) { \
+        Q_ASSERT(!itemIsUntransformable); \
+        if (viewTransform) { \
+            transform = item->d_ptr->sceneTransform; \
+            transform *= *viewTransform; \
+            transformPtr = &transform; \
+        } else { \
+            transformPtr = &item->d_ptr->sceneTransform; \
+            translateOnlyTransform = item->d_ptr->sceneTransformTranslateOnly; \
+        } \
+    }
+
+    // Update the item's scene transform if the item is transformable;
+    // otherwise calculate the full transform,
+    bool wasDirtyParentSceneTransform = false;
+    const bool itemIsUntransformable = item->d_ptr->itemIsUntransformable();
+    if (itemIsUntransformable) {
+        transform = item->deviceTransform(viewTransform ? *viewTransform : QTransform());
+        transformPtr = &transform;
+    } else if (item->d_ptr->dirtySceneTransform) {
+        item->d_ptr->updateSceneTransformFromParent();
+        Q_ASSERT(!item->d_ptr->dirtySceneTransform);
+        wasDirtyParentSceneTransform = true;
+    }
+
+    const bool itemClipsChildrenToShape = (item->d_ptr->flags & QGraphicsItem::ItemClipsChildrenToShape);
+    bool drawItem = itemHasContents && !itemIsFullyTransparent;
+    if (drawItem) {
+        const QRectF brect = adjustedItemEffectiveBoundingRect(item);
+        ENSURE_TRANSFORM_PTR
+        QRect viewBoundingRect = translateOnlyTransform ? brect.translated(transformPtr->dx(), transformPtr->dy()).toAlignedRect()
+                                                        : transformPtr->mapRect(brect).toAlignedRect();
+        viewBoundingRect.adjust(-int(rectAdjust), -int(rectAdjust), rectAdjust, rectAdjust);
+        if (widget)
+            item->d_ptr->paintedViewBoundingRects.insert(widget, viewBoundingRect);
+        drawItem = exposedRegion ? exposedRegion->intersects(viewBoundingRect)
+                                 : !viewBoundingRect.normalized().isEmpty();
+        if (!drawItem) {
+            if (!itemHasChildren)
+                return;
+            if (itemClipsChildrenToShape) {
+                if (wasDirtyParentSceneTransform)
+                    item->d_ptr->invalidateChildrenSceneTransform();
+                return;
+            }
+        }
+    } // else we know for sure this item has children we must process.
+
+    if (itemHasChildren && itemClipsChildrenToShape)
+        ENSURE_TRANSFORM_PTR;
+
+#ifndef QT_NO_GRAPHICSEFFECT
+    if (item->d_ptr->graphicsEffect && item->d_ptr->graphicsEffect->isEnabled()) {
+        ENSURE_TRANSFORM_PTR;
+        QGraphicsItemPaintInfo info(viewTransform, transformPtr, effectTransform, exposedRegion, widget, &styleOptionTmp,
+                                    painter, opacity, wasDirtyParentSceneTransform, itemHasContents && !itemIsFullyTransparent);
+        QGraphicsEffectSource *source = item->d_ptr->graphicsEffect->d_func()->source;
+        QGraphicsItemEffectSourcePrivate *sourced = static_cast<QGraphicsItemEffectSourcePrivate *>
+                                                    (source->d_func());
+        sourced->info = &info;
+        const QTransform restoreTransform = painter->worldTransform();
+        if (effectTransform)
+            painter->setWorldTransform(*transformPtr * *effectTransform);
+        else
+            painter->setWorldTransform(*transformPtr);
+        painter->setOpacity(opacity);
+
+        if (sourced->currentCachedSystem() != Qt::LogicalCoordinates
+            && sourced->lastEffectTransform != painter->worldTransform())
+        {
+            if (sourced->lastEffectTransform.type() <= QTransform::TxTranslate
+                && painter->worldTransform().type() <= QTransform::TxTranslate)
+            {
+                QRectF sourceRect = sourced->boundingRect(Qt::DeviceCoordinates);
+                QRect effectRect = sourced->paddedEffectRect(Qt::DeviceCoordinates, sourced->currentCachedMode(), sourceRect);
+
+                sourced->setCachedOffset(effectRect.topLeft());
+            } else {
+                sourced->invalidateCache(QGraphicsEffectSourcePrivate::TransformChanged);
+            }
+
+            sourced->lastEffectTransform = painter->worldTransform();
+        }
+
+        item->d_ptr->graphicsEffect->draw(painter);
+        painter->setWorldTransform(restoreTransform);
+        sourced->info = 0;
+    } else
+#endif //QT_NO_GRAPHICSEFFECT
+    {
+        draw(item, painter, viewTransform, transformPtr, exposedRegion, widget, opacity,
+             effectTransform, wasDirtyParentSceneTransform, drawItem);
+    }
+}
+
+static inline void setClip(QPainter *painter, QGraphicsItem *item)
+{
+    painter->save();
+    QRectF clipRect;
+    const QPainterPath clipPath(item->shape());
+    if (QPathClipper::pathToRect(clipPath, &clipRect))
+        painter->setClipRect(clipRect, Qt::IntersectClip);
+    else
+        painter->setClipPath(clipPath, Qt::IntersectClip);
+}
+
+static inline void setWorldTransform(QPainter *painter, const QTransform *const transformPtr,
+                                     const QTransform *effectTransform)
+{
+    Q_ASSERT(transformPtr);
+    if (effectTransform)
+        painter->setWorldTransform(*transformPtr * *effectTransform);
+    else
+        painter->setWorldTransform(*transformPtr);
+}
+
+void QGraphicsScenePrivate::draw(QGraphicsItem *item, QPainter *painter, const QTransform *const viewTransform,
+                                 const QTransform *const transformPtr, QRegion *exposedRegion, QWidget *widget,
+                                 qreal opacity, const QTransform *effectTransform,
+                                 bool wasDirtyParentSceneTransform, bool drawItem)
+{
+    const bool itemIsFullyTransparent = QGraphicsItemPrivate::isOpacityNull(opacity);
+    const bool itemClipsChildrenToShape = (item->d_ptr->flags & QGraphicsItem::ItemClipsChildrenToShape);
+    const bool itemHasChildren = !item->d_ptr->children.isEmpty();
+    bool setChildClip = itemClipsChildrenToShape;
+    bool itemHasChildrenStackedBehind = false;
+
+    int i = 0;
+    if (itemHasChildren) {
+        if (itemClipsChildrenToShape)
+            setWorldTransform(painter, transformPtr, effectTransform);
+
+        item->d_ptr->ensureSortedChildren();
+        // Items with the 'ItemStacksBehindParent' flag are put in front of the list
+        // so all we have to do is to check the first item.
+        itemHasChildrenStackedBehind = (item->d_ptr->children.at(0)->d_ptr->flags
+                                        & QGraphicsItem::ItemStacksBehindParent);
+
+        if (itemHasChildrenStackedBehind) {
+            if (itemClipsChildrenToShape) {
+                setClip(painter, item);
+                setChildClip = false;
+            }
+
+            // Draw children behind
+            for (i = 0; i < item->d_ptr->children.size(); ++i) {
+                QGraphicsItem *child = item->d_ptr->children.at(i);
+                if (wasDirtyParentSceneTransform)
+                    child->d_ptr->dirtySceneTransform = 1;
+                if (!(child->d_ptr->flags & QGraphicsItem::ItemStacksBehindParent))
+                    break;
+                if (itemIsFullyTransparent && !(child->d_ptr->flags & QGraphicsItem::ItemIgnoresParentOpacity))
+                    continue;
+                drawSubtreeRecursive(child, painter, viewTransform, exposedRegion, widget, opacity, effectTransform);
+            }
+        }
+    }
+
+    // Draw item
+    if (drawItem) {
+        Q_ASSERT(!itemIsFullyTransparent);
+        Q_ASSERT(!(item->d_ptr->flags & QGraphicsItem::ItemHasNoContents));
+        Q_ASSERT(transformPtr);
+        item->d_ptr->initStyleOption(&styleOptionTmp, *transformPtr, exposedRegion
+                                     ? *exposedRegion : QRegion(), exposedRegion == 0);
+
+        const bool itemClipsToShape = item->d_ptr->flags & QGraphicsItem::ItemClipsToShape;
+        bool restorePainterClip = false;
+
+        if (!itemHasChildren || !itemClipsChildrenToShape) {
+            // Item does not have children or clip children to shape.
+            setWorldTransform(painter, transformPtr, effectTransform);
+            if ((restorePainterClip = itemClipsToShape))
+                setClip(painter, item);
+        } else if (itemHasChildrenStackedBehind){
+            // Item clips children to shape and has children stacked behind, which means
+            // the painter is already clipped to the item's shape.
+            if (itemClipsToShape) {
+                // The clip is already correct. Ensure correct world transform.
+                setWorldTransform(painter, transformPtr, effectTransform);
+            } else {
+                // Remove clip (this also ensures correct world transform).
+                painter->restore();
+                setChildClip = true;
+            }
+        } else if (itemClipsToShape) {
+            // Item clips children and itself to shape. It does not have hildren stacked
+            // behind, which means the clip has not yet been set. We set it now and re-use it
+            // for the children.
+            setClip(painter, item);
+            setChildClip = false;
+        }
+
+        if (painterStateProtection && !restorePainterClip)
+            painter->save();
+
+        painter->setOpacity(opacity);
+        if (!item->d_ptr->cacheMode && !item->d_ptr->isWidget)
+            item->paint(painter, &styleOptionTmp, widget);
+        else
+            drawItemHelper(item, painter, &styleOptionTmp, widget, painterStateProtection);
+
+        if (painterStateProtection || restorePainterClip)
+            painter->restore();
+
+        static int drawRect = qgetenv("QT_DRAW_SCENE_ITEM_RECTS").toInt();
+        if (drawRect) {
+            QPen oldPen = painter->pen();
+            QBrush oldBrush = painter->brush();
+            quintptr ptr = reinterpret_cast<quintptr>(item);
+            const QColor color = QColor::fromHsv(ptr % 255, 255, 255);
+            painter->setPen(color);
+            painter->setBrush(Qt::NoBrush);
+            painter->drawRect(adjustedItemBoundingRect(item));
+            painter->setPen(oldPen);
+            painter->setBrush(oldBrush);
+        }
+    }
+
+    // Draw children in front
+    if (itemHasChildren) {
+        if (setChildClip)
+            setClip(painter, item);
+
+        for (; i < item->d_ptr->children.size(); ++i) {
+            QGraphicsItem *child = item->d_ptr->children.at(i);
+            if (wasDirtyParentSceneTransform)
+                child->d_ptr->dirtySceneTransform = 1;
+            if (itemIsFullyTransparent && !(child->d_ptr->flags & QGraphicsItem::ItemIgnoresParentOpacity))
+                continue;
+            drawSubtreeRecursive(child, painter, viewTransform, exposedRegion, widget, opacity, effectTransform);
+        }
+
+        // Restore child clip
+        if (itemClipsChildrenToShape)
+            painter->restore();
+    }
+}
+
+void QGraphicsScenePrivate::markDirty(QGraphicsItem *item, const QRectF &rect, bool invalidateChildren,
+                                      bool force, bool ignoreOpacity, bool removingItemFromScene,
+                                      bool updateBoundingRect)
+{
+    Q_ASSERT(item);
+    if (updateAll)
+        return;
+
+    if (removingItemFromScene && !ignoreOpacity && !item->d_ptr->ignoreOpacity) {
+        // If any of the item's ancestors ignore opacity, it means that the opacity
+        // was set to 0 (and the update request has not yet been processed). That
+        // also means that we have to ignore the opacity for the item itself; otherwise
+        // things like: parent->setOpacity(0); scene->removeItem(child) won't work.
+        // Note that we only do this when removing items from the scene. In all other
+        // cases the ignoreOpacity bit propagates properly in processDirtyItems, but
+        // since the item is removed immediately it won't be processed there.
+        QGraphicsItem *p = item->d_ptr->parent;
+        while (p) {
+            if (p->d_ptr->ignoreOpacity) {
+                item->d_ptr->ignoreOpacity = true;
+                break;
+            }
+            p = p->d_ptr->parent;
+        }
+    }
+
+    if (item->d_ptr->discardUpdateRequest(/*ignoreVisibleBit=*/force,
+                                          /*ignoreDirtyBit=*/removingItemFromScene || invalidateChildren,
+                                          /*ignoreOpacity=*/ignoreOpacity)) {
+        if (item->d_ptr->dirty) {
+            // The item is already marked as dirty and will be processed later. However,
+            // we have to make sure ignoreVisible and ignoreOpacity are set properly;
+            // otherwise things like: item->update(); item->hide() (force is now true)
+            // won't work as expected.
+            if (force)
+                item->d_ptr->ignoreVisible = 1;
+            if (ignoreOpacity)
+                item->d_ptr->ignoreOpacity = 1;
+        }
+        return;
+    }
+
+    const bool fullItemUpdate = rect.isNull();
+    if (!fullItemUpdate && rect.isEmpty())
+        return;
+
+    if (!processDirtyItemsEmitted) {
+        QMetaMethod method = q_ptr->metaObject()->method(processDirtyItemsIndex);
+        method.invoke(q_ptr, Qt::QueuedConnection);
+//        QMetaObject::invokeMethod(q_ptr, "_q_processDirtyItems", Qt::QueuedConnection);
+        processDirtyItemsEmitted = true;
+    }
+
+    if (removingItemFromScene) {
+        // Note that this function can be called from the item's destructor, so
+        // do NOT call any virtual functions on it within this block.
+        if (isSignalConnected(changedSignalIndex) || views.isEmpty()) {
+            // This block of code is kept for compatibility. Since 4.5, by default
+            // QGraphicsView does not connect the signal and we use the below
+            // method of delivering updates.
+            q_func()->update();
+            return;
+        }
+
+        for (int i = 0; i < views.size(); ++i) {
+            QGraphicsViewPrivate *viewPrivate = views.at(i)->d_func();
+            QRect rect = item->d_ptr->paintedViewBoundingRects.value(viewPrivate->viewport);
+            rect.translate(viewPrivate->dirtyScrollOffset);
+            viewPrivate->updateRect(rect);
+        }
+        return;
+    }
+
+    bool hasNoContents = item->d_ptr->flags & QGraphicsItem::ItemHasNoContents;
+    if (!hasNoContents) {
+        item->d_ptr->dirty = 1;
+        if (fullItemUpdate)
+            item->d_ptr->fullUpdatePending = 1;
+        else if (!item->d_ptr->fullUpdatePending)
+            item->d_ptr->needsRepaint |= rect;
+    } else if (item->d_ptr->graphicsEffect) {
+        invalidateChildren = true;
+    }
+
+    if (invalidateChildren) {
+        item->d_ptr->allChildrenDirty = 1;
+        item->d_ptr->dirtyChildren = 1;
+    }
+
+    if (force)
+        item->d_ptr->ignoreVisible = 1;
+    if (ignoreOpacity)
+        item->d_ptr->ignoreOpacity = 1;
+
+    if (!updateBoundingRect)
+        item->d_ptr->markParentDirty();
+}
+
+static inline bool updateHelper(QGraphicsViewPrivate *view, QGraphicsItemPrivate *item,
+                                const QRectF &rect, bool itemIsUntransformable)
+{
+    Q_ASSERT(view);
+    Q_ASSERT(item);
+
+    QGraphicsItem *itemq = static_cast<QGraphicsItem *>(item->q_ptr);
+    QGraphicsView *viewq = static_cast<QGraphicsView *>(view->q_ptr);
+
+    if (itemIsUntransformable) {
+        const QTransform xform = itemq->deviceTransform(viewq->viewportTransform());
+        if (!item->hasBoundingRegionGranularity)
+            return view->updateRectF(xform.mapRect(rect));
+        return view->updateRegion(rect, xform);
+    }
+
+    if (item->sceneTransformTranslateOnly && view->identityMatrix) {
+        const qreal dx = item->sceneTransform.dx();
+        const qreal dy = item->sceneTransform.dy();
+        QRectF r(rect);
+        r.translate(dx - view->horizontalScroll(), dy - view->verticalScroll());
+        return view->updateRectF(r);
+    }
+
+    if (!viewq->isTransformed()) {
+        if (!item->hasBoundingRegionGranularity)
+            return view->updateRectF(item->sceneTransform.mapRect(rect));
+        return view->updateRegion(rect, item->sceneTransform);
+    }
+
+    QTransform xform = item->sceneTransform;
+    xform *= viewq->viewportTransform();
+    if (!item->hasBoundingRegionGranularity)
+        return view->updateRectF(xform.mapRect(rect));
+    return view->updateRegion(rect, xform);
+}
+
+void QGraphicsScenePrivate::processDirtyItemsRecursive(QGraphicsItem *item, bool dirtyAncestorContainsChildren,
+                                                       qreal parentOpacity)
+{
+    Q_Q(QGraphicsScene);
+    Q_ASSERT(item);
+    Q_ASSERT(!updateAll);
+
+    if (!item->d_ptr->dirty && !item->d_ptr->dirtyChildren) {
+        resetDirtyItem(item);
+        return;
+    }
+
+    const bool itemIsHidden = !item->d_ptr->ignoreVisible && !item->d_ptr->visible;
+    if (itemIsHidden) {
+        resetDirtyItem(item, /*recursive=*/true);
+        return;
+    }
+
+    bool itemHasContents = !(item->d_ptr->flags & QGraphicsItem::ItemHasNoContents);
+    const bool itemHasChildren = !item->d_ptr->children.isEmpty();
+    if (!itemHasContents) {
+        if (!itemHasChildren) {
+            resetDirtyItem(item);
+            return; // Item has neither contents nor children!(?)
+        }
+        if (item->d_ptr->graphicsEffect)
+            itemHasContents = true;
+    }
+
+    const qreal opacity = item->d_ptr->combineOpacityFromParent(parentOpacity);
+    const bool itemIsFullyTransparent = !item->d_ptr->ignoreOpacity
+                                        && QGraphicsItemPrivate::isOpacityNull(opacity);
+    if (itemIsFullyTransparent && (!itemHasChildren || item->d_ptr->childrenCombineOpacity())) {
+        resetDirtyItem(item, /*recursive=*/itemHasChildren);
+        return;
+    }
+
+    bool wasDirtyParentSceneTransform = item->d_ptr->dirtySceneTransform;
+    const bool itemIsUntransformable = item->d_ptr->itemIsUntransformable();
+    if (wasDirtyParentSceneTransform && !itemIsUntransformable) {
+        item->d_ptr->updateSceneTransformFromParent();
+        Q_ASSERT(!item->d_ptr->dirtySceneTransform);
+    }
+
+    const bool wasDirtyParentViewBoundingRects = item->d_ptr->paintedViewBoundingRectsNeedRepaint;
+    if (itemIsFullyTransparent || !itemHasContents || dirtyAncestorContainsChildren) {
+        // Make sure we don't process invisible items or items with no content.
+        item->d_ptr->dirty = 0;
+        item->d_ptr->fullUpdatePending = 0;
+        // Might have a dirty view bounding rect otherwise.
+        if (itemIsFullyTransparent || !itemHasContents)
+            item->d_ptr->paintedViewBoundingRectsNeedRepaint = 0;
+    }
+
+    if (!hasSceneRect && item->d_ptr->geometryChanged && item->d_ptr->visible) {
+        // Update growingItemsBoundingRect.
+        if (item->d_ptr->sceneTransformTranslateOnly) {
+            growingItemsBoundingRect |= item->boundingRect().translated(item->d_ptr->sceneTransform.dx(),
+                                                                        item->d_ptr->sceneTransform.dy());
+        } else {
+            growingItemsBoundingRect |= item->d_ptr->sceneTransform.mapRect(item->boundingRect());
+        }
+    }
+
+    // Process item.
+    if (item->d_ptr->dirty || item->d_ptr->paintedViewBoundingRectsNeedRepaint) {
+        const bool useCompatUpdate = views.isEmpty() || isSignalConnected(changedSignalIndex);
+        const QRectF itemBoundingRect = adjustedItemEffectiveBoundingRect(item);
+
+        if (useCompatUpdate && !itemIsUntransformable && qFuzzyIsNull(item->boundingRegionGranularity())) {
+            // This block of code is kept for compatibility. Since 4.5, by default
+            // QGraphicsView does not connect the signal and we use the below
+            // method of delivering updates.
+            if (item->d_ptr->sceneTransformTranslateOnly) {
+                q->update(itemBoundingRect.translated(item->d_ptr->sceneTransform.dx(),
+                                                      item->d_ptr->sceneTransform.dy()));
+            } else {
+                QRectF rect = item->d_ptr->sceneTransform.mapRect(itemBoundingRect);
+                if (!rect.isEmpty())
+                    q->update(rect);
+            }
+        } else {
+            QRectF dirtyRect;
+            bool uninitializedDirtyRect = true;
+
+            for (int j = 0; j < views.size(); ++j) {
+                QGraphicsView *view = views.at(j);
+                QGraphicsViewPrivate *viewPrivate = view->d_func();
+                QRect &paintedViewBoundingRect = item->d_ptr->paintedViewBoundingRects[viewPrivate->viewport];
+                if (viewPrivate->fullUpdatePending
+                    || viewPrivate->viewportUpdateMode == QGraphicsView::NoViewportUpdate) {
+                    // Okay, if we have a full update pending or no viewport update, this item's
+                    // paintedViewBoundingRect  will be updated correctly in the next paintEvent if
+                    // it is inside the viewport, but for now we can pretend that it is outside.
+                    paintedViewBoundingRect = QRect(-1, -1, -1, -1);
+                    continue;
+                }
+
+                if (item->d_ptr->paintedViewBoundingRectsNeedRepaint) {
+                    paintedViewBoundingRect.translate(viewPrivate->dirtyScrollOffset);
+                    if (!viewPrivate->updateRect(paintedViewBoundingRect))
+                        paintedViewBoundingRect = QRect(-1, -1, -1, -1); // Outside viewport.
+                }
+
+                if (!item->d_ptr->dirty)
+                    continue;
+
+                if (!item->d_ptr->paintedViewBoundingRectsNeedRepaint
+                    && paintedViewBoundingRect.x() == -1 && paintedViewBoundingRect.y() == -1
+                    && paintedViewBoundingRect.width() == -1 && paintedViewBoundingRect.height() == -1) {
+                    continue; // Outside viewport.
+                }
+
+                if (uninitializedDirtyRect) {
+                    dirtyRect = itemBoundingRect;
+                    if (!item->d_ptr->fullUpdatePending) {
+                        _q_adjustRect(&item->d_ptr->needsRepaint);
+                        dirtyRect &= item->d_ptr->needsRepaint;
+                    }
+                    uninitializedDirtyRect = false;
+                }
+
+                if (dirtyRect.isEmpty())
+                    continue; // Discard updates outside the bounding rect.
+
+                if (!updateHelper(viewPrivate, item->d_ptr.data(), dirtyRect, itemIsUntransformable)
+                    && item->d_ptr->paintedViewBoundingRectsNeedRepaint) {
+                    paintedViewBoundingRect = QRect(-1, -1, -1, -1); // Outside viewport.
+                }
+            }
+        }
+    }
+
+    // Process children.
+    if (itemHasChildren && item->d_ptr->dirtyChildren) {
+        const bool itemClipsChildrenToShape = item->d_ptr->flags & QGraphicsItem::ItemClipsChildrenToShape;
+        // Items with no content are threated as 'dummy' items which means they are never drawn and
+        // 'processed', so the painted view bounding rect is never up-to-date. This means that whenever
+        // such an item changes geometry, its children have to take care of the update regardless
+        // of whether the item clips children to shape or not.
+        const bool bypassUpdateClip = !itemHasContents && wasDirtyParentViewBoundingRects;
+        if (itemClipsChildrenToShape && !bypassUpdateClip) {
+            // Make sure child updates are clipped to the item's bounding rect.
+            for (int i = 0; i < views.size(); ++i)
+                views.at(i)->d_func()->setUpdateClip(item);
+        }
+        if (!dirtyAncestorContainsChildren) {
+            dirtyAncestorContainsChildren = item->d_ptr->fullUpdatePending
+                                            && itemClipsChildrenToShape;
+        }
+        const bool allChildrenDirty = item->d_ptr->allChildrenDirty;
+        const bool parentIgnoresVisible = item->d_ptr->ignoreVisible;
+        const bool parentIgnoresOpacity = item->d_ptr->ignoreOpacity;
+        for (int i = 0; i < item->d_ptr->children.size(); ++i) {
+            QGraphicsItem *child = item->d_ptr->children.at(i);
+            if (wasDirtyParentSceneTransform)
+                child->d_ptr->dirtySceneTransform = 1;
+            if (wasDirtyParentViewBoundingRects)
+                child->d_ptr->paintedViewBoundingRectsNeedRepaint = 1;
+            if (parentIgnoresVisible)
+                child->d_ptr->ignoreVisible = 1;
+            if (parentIgnoresOpacity)
+                child->d_ptr->ignoreOpacity = 1;
+            if (allChildrenDirty) {
+                child->d_ptr->dirty = 1;
+                child->d_ptr->fullUpdatePending = 1;
+                child->d_ptr->dirtyChildren = 1;
+                child->d_ptr->allChildrenDirty = 1;
+            }
+            processDirtyItemsRecursive(child, dirtyAncestorContainsChildren, opacity);
+        }
+
+        if (itemClipsChildrenToShape) {
+            // Reset updateClip.
+            for (int i = 0; i < views.size(); ++i)
+                views.at(i)->d_func()->setUpdateClip(0);
+        }
+    } else if (wasDirtyParentSceneTransform) {
+        item->d_ptr->invalidateChildrenSceneTransform();
+    }
+
+    resetDirtyItem(item);
+}
+
+/*!
+    \obsolete
+
+    Paints the given \a items using the provided \a painter, after the
+    background has been drawn, and before the foreground has been
+    drawn.  All painting is done in \e scene coordinates. Before
+    drawing each item, the painter must be transformed using
+    QGraphicsItem::sceneTransform().
+
+    The \a options parameter is the list of style option objects for
+    each item in \a items. The \a numItems parameter is the number of
+    items in \a items and options in \a options. The \a widget
+    parameter is optional; if specified, it should point to the widget
+    that is being painted on.
+
+    The default implementation prepares the painter matrix, and calls
+    QGraphicsItem::paint() on all items. Reimplement this function to
+    provide custom painting of all items for the scene; gaining
+    complete control over how each item is drawn. In some cases this
+    can increase drawing performance significantly.
+
+    Example:
+
+    \snippet graphicssceneadditemsnippet.cpp 0
+
+    Since Qt 4.6, this function is not called anymore unless
+    the QGraphicsView::IndirectPainting flag is given as an Optimization
+    flag.
+
+    \sa drawBackground(), drawForeground()
+*/
+void QGraphicsScene::drawItems(QPainter *painter,
+                               int numItems,
+                               QGraphicsItem *items[],
+                               const QStyleOptionGraphicsItem options[], QWidget *widget)
+{
+    Q_D(QGraphicsScene);
+    // Make sure we don't have unpolished items before we draw.
+    if (!d->unpolishedItems.isEmpty())
+        d->_q_polishItems();
+
+    const qreal opacity = painter->opacity();
+    QTransform viewTransform = painter->worldTransform();
+    Q_UNUSED(options);
+
+    // Determine view, expose and flags.
+    QGraphicsView *view = widget ? qobject_cast<QGraphicsView *>(widget->parentWidget()) : 0;
+    QRegion *expose = 0;
+    const quint32 oldRectAdjust = d->rectAdjust;
+    if (view) {
+        d->updateAll = false;
+        expose = &view->d_func()->exposedRegion;
+        if (view->d_func()->optimizationFlags & QGraphicsView::DontAdjustForAntialiasing)
+            d->rectAdjust = 1;
+        else
+            d->rectAdjust = 2;
+    }
+
+    // Find all toplevels, they are already sorted.
+    QList<QGraphicsItem *> topLevelItems;
+    for (int i = 0; i < numItems; ++i) {
+        QGraphicsItem *item = items[i]->topLevelItem();
+        if (!item->d_ptr->itemDiscovered) {
+            topLevelItems << item;
+            item->d_ptr->itemDiscovered = 1;
+            d->drawSubtreeRecursive(item, painter, &viewTransform, expose, widget);
+        }
+    }
+
+    d->rectAdjust = oldRectAdjust;
+    // Reset discovery bits.
+    for (int i = 0; i < topLevelItems.size(); ++i)
+        topLevelItems.at(i)->d_ptr->itemDiscovered = 0;
+
+    painter->setWorldTransform(viewTransform);
+    painter->setOpacity(opacity);
+}
+
+/*!
+    \since 4.4
+
+    Finds a new widget to give the keyboard focus to, as appropriate for Tab
+    and Shift+Tab, and returns \c true if it can find a new widget, or false if
+    it cannot. If \a next is true, this function searches forward; if \a next
+    is false, it searches backward.
+
+    You can reimplement this function in a subclass of QGraphicsScene to
+    provide fine-grained control over how tab focus passes inside your
+    scene. The default implementation is based on the tab focus chain defined
+    by QGraphicsWidget::setTabOrder().
+*/
+bool QGraphicsScene::focusNextPrevChild(bool next)
+{
+    Q_D(QGraphicsScene);
+
+    QGraphicsItem *item = focusItem();
+    if (item && !item->isWidget()) {
+        // Tab out of the scene.
+        return false;
+    }
+    if (!item) {
+        if (d->lastFocusItem && !d->lastFocusItem->isWidget()) {
+            // Restore focus to the last focusable non-widget item that had
+            // focus.
+            setFocusItem(d->lastFocusItem, next ? Qt::TabFocusReason : Qt::BacktabFocusReason);
+            return true;
+        }
+        if (d->activePanel) {
+            if (d->activePanel->flags() & QGraphicsItem::ItemIsFocusable) {
+                setFocusItem(d->activePanel, next ? Qt::TabFocusReason : Qt::BacktabFocusReason);
+                return true;
+            }
+            if (d->activePanel->isWidget()) {
+                QGraphicsWidget *fw = static_cast<QGraphicsWidget *>(d->activePanel)->d_func()->focusNext;
+                do {
+                    if (fw->focusPolicy() & Qt::TabFocus) {
+                        setFocusItem(fw, next ? Qt::TabFocusReason : Qt::BacktabFocusReason);
+                        return true;
+                    }
+                } while (fw != d->activePanel);
+            }
+        }
+    }
+    if (!item && !d->tabFocusFirst) {
+        // No widgets...
+        return false;
+    }
+
+    // The item must be a widget.
+    QGraphicsWidget *widget = 0;
+    if (!item) {
+        widget = next ? d->tabFocusFirst : d->tabFocusFirst->d_func()->focusPrev;
+    } else {
+        QGraphicsWidget *test = static_cast<QGraphicsWidget *>(item);
+        widget = next ? test->d_func()->focusNext : test->d_func()->focusPrev;
+        if (!widget->panel() && ((next && widget == d->tabFocusFirst) || (!next && widget == d->tabFocusFirst->d_func()->focusPrev))) {
+            // Tab out of the scene.
+            return false;
+        }
+    }
+    QGraphicsWidget *widgetThatHadFocus = widget;
+
+    // Run around the focus chain until we find a widget that can take tab focus.
+    do {
+        if (widget->flags() & QGraphicsItem::ItemIsFocusable
+            && widget->isEnabled() && widget->isVisibleTo(0)
+            && (widget->focusPolicy() & Qt::TabFocus)
+            && (!item || !item->isPanel() || item->isAncestorOf(widget))
+            ) {
+            setFocusItem(widget, next ? Qt::TabFocusReason : Qt::BacktabFocusReason);
+            return true;
+        }
+        widget = next ? widget->d_func()->focusNext : widget->d_func()->focusPrev;
+        if ((next && widget == d->tabFocusFirst) || (!next && widget == d->tabFocusFirst->d_func()->focusPrev))
+            return false;
+    } while (widget != widgetThatHadFocus);
+
+    return false;
+}
+
+/*!
+    \fn QGraphicsScene::changed(const QList<QRectF> &region)
+
+    This signal is emitted by QGraphicsScene when control reaches the
+    event loop, if the scene content changes. The \a region parameter
+    contains a list of scene rectangles that indicate the area that
+    has been changed.
+
+    \sa QGraphicsView::updateScene()
+*/
+
+/*!
+    \fn QGraphicsScene::sceneRectChanged(const QRectF &rect)
+
+    This signal is emitted by QGraphicsScene whenever the scene rect changes.
+    The \a rect parameter is the new scene rectangle.
+
+    \sa QGraphicsView::updateSceneRect()
+*/
+
+/*!
+    \fn QGraphicsScene::selectionChanged()
+    \since 4.3
+
+    This signal is emitted by QGraphicsScene whenever the selection
+    changes. You can call selectedItems() to get the new list of selected
+    items.
+
+    The selection changes whenever an item is selected or unselected, a
+    selection area is set, cleared or otherwise changed, if a preselected item
+    is added to the scene, or if a selected item is removed from the scene.
+
+    QGraphicsScene emits this signal only once for group selection operations.
+    For example, if you set a selection area, select or unselect a
+    QGraphicsItemGroup, or if you add or remove from the scene a parent item
+    that contains several selected items, selectionChanged() is emitted only
+    once after the operation has completed (instead of once for each item).
+
+    \sa setSelectionArea(), selectedItems(), QGraphicsItem::setSelected()
+*/
+
+/*!
+    \fn QGraphicsScene::focusItemChanged(QGraphicsItem *newFocusItem, QGraphicsItem *oldFocusItem, Qt::FocusReason reason)
+
+    This signal is emitted by QGraphicsScene whenever focus changes in the
+    scene (i.e., when an item gains or loses input focus, or when focus
+    passes from one item to another). You can connect to this signal if you
+    need to keep track of when other items gain input focus. It is
+    particularly useful for implementing virtual keyboards, input methods,
+    and cursor items.
+
+    \a oldFocusItem is a pointer to the item that previously had focus, or
+    0 if no item had focus before the signal was emitted. \a newFocusItem
+    is a pointer to the item that gained input focus, or 0 if focus was lost.
+    \a reason is the reason for the focus change (e.g., if the scene was
+    deactivated while an input field had focus, \a oldFocusItem would point
+    to the input field item, \a newFocusItem would be 0, and \a reason would be
+    Qt::ActiveWindowFocusReason.
+*/
+
+/*!
+    \since 4.4
+
+    Returns the scene's style, or the same as QApplication::style() if the
+    scene has not been explicitly assigned a style.
+
+    \sa setStyle()
+*/
+QStyle *QGraphicsScene::style() const
+{
+    Q_D(const QGraphicsScene);
+    // ### This function, and the use of styles in general, is non-reentrant.
+    return d->style ? d->style : QApplication::style();
+}
+
+/*!
+    \since 4.4
+
+    Sets or replaces the style of the scene to \a style, and reparents the
+    style to this scene. Any previously assigned style is deleted. The scene's
+    style defaults to QApplication::style(), and serves as the default for all
+    QGraphicsWidget items in the scene.
+
+    Changing the style, either directly by calling this function, or
+    indirectly by calling QApplication::setStyle(), will automatically update
+    the style for all widgets in the scene that do not have a style explicitly
+    assigned to them.
+
+    If \a style is 0, QGraphicsScene will revert to QApplication::style().
+
+    \sa style()
+*/
+void QGraphicsScene::setStyle(QStyle *style)
+{
+    Q_D(QGraphicsScene);
+    // ### This function, and the use of styles in general, is non-reentrant.
+    if (style == d->style)
+        return;
+
+    // Delete the old style,
+    delete d->style;
+    if ((d->style = style))
+        d->style->setParent(this);
+
+    // Notify the scene.
+    QEvent event(QEvent::StyleChange);
+    QApplication::sendEvent(this, &event);
+
+    // Notify all widgets that don't have a style explicitly set.
+    foreach (QGraphicsItem *item, items()) {
+        if (item->isWidget()) {
+            QGraphicsWidget *widget = static_cast<QGraphicsWidget *>(item);
+            if (!widget->testAttribute(Qt::WA_SetStyle))
+                QApplication::sendEvent(widget, &event);
+        }
+    }
+}
+
+/*!
+    \property QGraphicsScene::font
+    \since 4.4
+    \brief the scene's default font
+
+    This property provides the scene's font. The scene font defaults to,
+    and resolves all its entries from, QApplication::font.
+
+    If the scene's font changes, either directly through setFont() or
+    indirectly when the application font changes, QGraphicsScene first
+    sends itself a \l{QEvent::FontChange}{FontChange} event, and it then
+    sends \l{QEvent::FontChange}{FontChange} events to all top-level
+    widget items in the scene. These items respond by resolving their own
+    fonts to the scene, and they then notify their children, who again
+    notify their children, and so on, until all widget items have updated
+    their fonts.
+
+    Changing the scene font, (directly or indirectly through
+    QApplication::setFont(),) automatically schedules a redraw the entire
+    scene.
+
+    \sa QWidget::font, QApplication::setFont(), palette, style()
+*/
+QFont QGraphicsScene::font() const
+{
+    Q_D(const QGraphicsScene);
+    return d->font;
+}
+void QGraphicsScene::setFont(const QFont &font)
+{
+    Q_D(QGraphicsScene);
+    QFont naturalFont = QApplication::font();
+    naturalFont.resolve(0);
+    QFont resolvedFont = font.resolve(naturalFont);
+    d->setFont_helper(resolvedFont);
+}
+
+/*!
+    \property QGraphicsScene::palette
+    \since 4.4
+    \brief the scene's default palette
+
+    This property provides the scene's palette. The scene palette defaults to,
+    and resolves all its entries from, QApplication::palette.
+
+    If the scene's palette changes, either directly through setPalette() or
+    indirectly when the application palette changes, QGraphicsScene first
+    sends itself a \l{QEvent::PaletteChange}{PaletteChange} event, and it then
+    sends \l{QEvent::PaletteChange}{PaletteChange} events to all top-level
+    widget items in the scene. These items respond by resolving their own
+    palettes to the scene, and they then notify their children, who again
+    notify their children, and so on, until all widget items have updated
+    their palettes.
+
+    Changing the scene palette, (directly or indirectly through
+    QApplication::setPalette(),) automatically schedules a redraw the entire
+    scene.
+
+    \sa QWidget::palette, QApplication::setPalette(), font, style()
+*/
+QPalette QGraphicsScene::palette() const
+{
+    Q_D(const QGraphicsScene);
+    return d->palette;
+}
+void QGraphicsScene::setPalette(const QPalette &palette)
+{
+    Q_D(QGraphicsScene);
+    QPalette naturalPalette = QApplication::palette();
+    naturalPalette.resolve(0);
+    QPalette resolvedPalette = palette.resolve(naturalPalette);
+    d->setPalette_helper(resolvedPalette);
+}
+
+/*!
+    \since 4.6
+
+    Returns \c true if the scene is active (e.g., it's viewed by
+    at least one QGraphicsView that is active); otherwise returns \c false.
+
+    \sa QGraphicsItem::isActive(), QWidget::isActiveWindow()
+*/
+bool QGraphicsScene::isActive() const
+{
+    Q_D(const QGraphicsScene);
+    return d->activationRefCount > 0;
+}
+
+/*!
+    \since 4.6
+    Returns the current active panel, or 0 if no panel is currently active.
+
+    \sa QGraphicsScene::setActivePanel()
+*/
+QGraphicsItem *QGraphicsScene::activePanel() const
+{
+    Q_D(const QGraphicsScene);
+    return d->activePanel;
+}
+
+/*!
+    \since 4.6
+    Activates \a item, which must be an item in this scene. You
+    can also pass 0 for \a item, in which case QGraphicsScene will
+    deactivate any currently active panel.
+
+    If the scene is currently inactive, \a item remains inactive until the
+    scene becomes active (or, ir \a item is 0, no item will be activated).
+
+    \sa activePanel(), isActive(), QGraphicsItem::isActive()
+*/
+void QGraphicsScene::setActivePanel(QGraphicsItem *item)
+{
+    Q_D(QGraphicsScene);
+    d->setActivePanelHelper(item, false);
+}
+
+/*!
+    \since 4.4
+
+    Returns the current active window, or 0 if no window is currently
+    active.
+
+    \sa QGraphicsScene::setActiveWindow()
+*/
+QGraphicsWidget *QGraphicsScene::activeWindow() const
+{
+    Q_D(const QGraphicsScene);
+    if (d->activePanel && d->activePanel->isWindow())
+        return static_cast<QGraphicsWidget *>(d->activePanel);
+    return 0;
+}
+
+/*!
+    \since 4.4
+    Activates \a widget, which must be a widget in this scene. You can also
+    pass 0 for \a widget, in which case QGraphicsScene will deactivate any
+    currently active window.
+
+    \sa activeWindow(), QGraphicsWidget::isActiveWindow()
+*/
+void QGraphicsScene::setActiveWindow(QGraphicsWidget *widget)
+{
+    if (widget && widget->scene() != this) {
+        qWarning("QGraphicsScene::setActiveWindow: widget %p must be part of this scene",
+                 widget);
+        return;
+    }
+
+    // Activate the widget's panel (all windows are panels).
+    QGraphicsItem *panel = widget ? widget->panel() : 0;
+    setActivePanel(panel);
+
+    // Raise
+    if (panel) {
+        QList<QGraphicsItem *> siblingWindows;
+        QGraphicsItem *parent = panel->parentItem();
+        // Raise ### inefficient for toplevels
+        foreach (QGraphicsItem *sibling, parent ? parent->childItems() : items()) {
+            if (sibling != panel && sibling->isWindow())
+                siblingWindows << sibling;
+        }
+
+        // Find the highest z value.
+        qreal z = panel->zValue();
+        for (int i = 0; i < siblingWindows.size(); ++i)
+            z = qMax(z, siblingWindows.at(i)->zValue());
+
+        // This will probably never overflow.
+        const qreal litt = qreal(0.001);
+        panel->setZValue(z + litt);
+    }
+}
+
+/*!
+    \since 4.6
+
+    Sends event \a event to item \a item through possible event filters.
+
+    The event is sent only if the item is enabled.
+
+    Returns \c false if the event was filtered or if the item is disabled.
+    Otherwise returns the value that was returned from the event handler.
+
+    \sa QGraphicsItem::sceneEvent(), QGraphicsItem::sceneEventFilter()
+*/
+bool QGraphicsScene::sendEvent(QGraphicsItem *item, QEvent *event)
+{
+    Q_D(QGraphicsScene);
+    if (!item) {
+        qWarning("QGraphicsScene::sendEvent: cannot send event to a null item");
+        return false;
+    }
+    if (item->scene() != this) {
+        qWarning("QGraphicsScene::sendEvent: item %p's scene (%p)"
+                 " is different from this scene (%p)",
+                 item, item->scene(), this);
+        return false;
+    }
+    return d->sendEvent(item, event);
+}
+
+void QGraphicsScenePrivate::addView(QGraphicsView *view)
+{
+    views << view;
+#ifndef QT_NO_GESTURES
+    foreach (Qt::GestureType gesture, grabbedGestures.keys())
+        view->viewport()->grabGesture(gesture);
+#endif
+}
+
+void QGraphicsScenePrivate::removeView(QGraphicsView *view)
+{
+    views.removeAll(view);
+}
+
+void QGraphicsScenePrivate::updateTouchPointsForItem(QGraphicsItem *item, QTouchEvent *touchEvent)
+{
+    QList<QTouchEvent::TouchPoint> touchPoints = touchEvent->touchPoints();
+    for (int i = 0; i < touchPoints.count(); ++i) {
+        QTouchEvent::TouchPoint &touchPoint = touchPoints[i];
+        touchPoint.setRect(item->mapFromScene(touchPoint.sceneRect()).boundingRect());
+        touchPoint.setStartPos(item->d_ptr->genericMapFromScene(touchPoint.startScenePos(), static_cast<QWidget *>(touchEvent->target())));
+        touchPoint.setLastPos(item->d_ptr->genericMapFromScene(touchPoint.lastScenePos(), static_cast<QWidget *>(touchEvent->target())));
+    }
+    touchEvent->setTouchPoints(touchPoints);
+}
+
+int QGraphicsScenePrivate::findClosestTouchPointId(const QPointF &scenePos)
+{
+    int closestTouchPointId = -1;
+    qreal closestDistance = qreal(0.);
+    foreach (const QTouchEvent::TouchPoint &touchPoint, sceneCurrentTouchPoints) {
+        qreal distance = QLineF(scenePos, touchPoint.scenePos()).length();
+        if (closestTouchPointId == -1|| distance < closestDistance) {
+            closestTouchPointId = touchPoint.id();
+            closestDistance = distance;
+        }
+    }
+    return closestTouchPointId;
+}
+
+void QGraphicsScenePrivate::touchEventHandler(QTouchEvent *sceneTouchEvent)
+{
+    typedef QPair<Qt::TouchPointStates, QList<QTouchEvent::TouchPoint> > StatesAndTouchPoints;
+    QHash<QGraphicsItem *, StatesAndTouchPoints> itemsNeedingEvents;
+
+    for (int i = 0; i < sceneTouchEvent->touchPoints().count(); ++i) {
+        const QTouchEvent::TouchPoint &touchPoint = sceneTouchEvent->touchPoints().at(i);
+
+        // update state
+        QGraphicsItem *item = 0;
+        if (touchPoint.state() == Qt::TouchPointPressed) {
+            if (sceneTouchEvent->device()->type() == QTouchDevice::TouchPad) {
+                // on touch-pad devices, send all touch points to the same item
+                item = itemForTouchPointId.isEmpty()
+                       ? 0
+                       : itemForTouchPointId.constBegin().value();
+            }
+
+            if (!item) {
+                // determine which item this touch point will go to
+                cachedItemsUnderMouse = itemsAtPosition(touchPoint.screenPos().toPoint(),
+                                                        touchPoint.scenePos(),
+                                                        static_cast<QWidget *>(sceneTouchEvent->target()));
+                item = cachedItemsUnderMouse.isEmpty() ? 0 : cachedItemsUnderMouse.first();
+            }
+
+            if (sceneTouchEvent->device()->type() == QTouchDevice::TouchScreen) {
+                // on touch-screens, combine this touch point with the closest one we find
+                int closestTouchPointId = findClosestTouchPointId(touchPoint.scenePos());
+                QGraphicsItem *closestItem = itemForTouchPointId.value(closestTouchPointId);
+                if (!item || (closestItem && cachedItemsUnderMouse.contains(closestItem)))
+                    item = closestItem;
+            }
+            if (!item)
+                continue;
+
+            itemForTouchPointId.insert(touchPoint.id(), item);
+            sceneCurrentTouchPoints.insert(touchPoint.id(), touchPoint);
+        } else if (touchPoint.state() == Qt::TouchPointReleased) {
+            item = itemForTouchPointId.take(touchPoint.id());
+            if (!item)
+                continue;
+
+            sceneCurrentTouchPoints.remove(touchPoint.id());
+        } else {
+            item = itemForTouchPointId.value(touchPoint.id());
+            if (!item)
+                continue;
+            Q_ASSERT(sceneCurrentTouchPoints.contains(touchPoint.id()));
+            sceneCurrentTouchPoints[touchPoint.id()] = touchPoint;
+        }
+
+        StatesAndTouchPoints &statesAndTouchPoints = itemsNeedingEvents[item];
+        statesAndTouchPoints.first |= touchPoint.state();
+        statesAndTouchPoints.second.append(touchPoint);
+    }
+
+    if (itemsNeedingEvents.isEmpty()) {
+        sceneTouchEvent->ignore();
+        return;
+    }
+
+    bool ignoreSceneTouchEvent = true;
+    QHash<QGraphicsItem *, StatesAndTouchPoints>::ConstIterator it = itemsNeedingEvents.constBegin();
+    const QHash<QGraphicsItem *, StatesAndTouchPoints>::ConstIterator end = itemsNeedingEvents.constEnd();
+    for (; it != end; ++it) {
+        QGraphicsItem *item = it.key();
+
+        (void) item->isBlockedByModalPanel(&item);
+
+        // determine event type from the state mask
+        QEvent::Type eventType;
+        switch (it.value().first) {
+        case Qt::TouchPointPressed:
+            // all touch points have pressed state
+            eventType = QEvent::TouchBegin;
+            break;
+        case Qt::TouchPointReleased:
+            // all touch points have released state
+            eventType = QEvent::TouchEnd;
+            break;
+        case Qt::TouchPointStationary:
+            // don't send the event if nothing changed
+            continue;
+        default:
+            // all other combinations
+            eventType = QEvent::TouchUpdate;
+            break;
+        }
+
+        QTouchEvent touchEvent(eventType);
+        touchEvent.setWindow(sceneTouchEvent->window());
+        touchEvent.setTarget(sceneTouchEvent->target());
+        touchEvent.setDevice(sceneTouchEvent->device());
+        touchEvent.setModifiers(sceneTouchEvent->modifiers());
+        touchEvent.setTouchPointStates(it.value().first);
+        touchEvent.setTouchPoints(it.value().second);
+        touchEvent.setTimestamp(sceneTouchEvent->timestamp());
+
+        switch (touchEvent.type()) {
+        case QEvent::TouchBegin:
+        {
+            // if the TouchBegin handler recurses, we assume that means the event
+            // has been implicitly accepted and continue to send touch events
+            item->d_ptr->acceptedTouchBeginEvent = true;
+            bool res = sendTouchBeginEvent(item, &touchEvent)
+                       && touchEvent.isAccepted();
+            if (!res) {
+                // forget about these touch points, we didn't handle them
+                for (int i = 0; i < touchEvent.touchPoints().count(); ++i) {
+                    const QTouchEvent::TouchPoint &touchPoint = touchEvent.touchPoints().at(i);
+                    itemForTouchPointId.remove(touchPoint.id());
+                    sceneCurrentTouchPoints.remove(touchPoint.id());
+                }
+                ignoreSceneTouchEvent = false;
+            }
+            break;
+        }
+        default:
+            if (item->d_ptr->acceptedTouchBeginEvent) {
+                updateTouchPointsForItem(item, &touchEvent);
+                (void) sendEvent(item, &touchEvent);
+                ignoreSceneTouchEvent = false;
+            }
+            break;
+        }
+    }
+    sceneTouchEvent->setAccepted(ignoreSceneTouchEvent);
+}
+
+bool QGraphicsScenePrivate::sendTouchBeginEvent(QGraphicsItem *origin, QTouchEvent *touchEvent)
+{
+    Q_Q(QGraphicsScene);
+
+    if (cachedItemsUnderMouse.isEmpty() || cachedItemsUnderMouse.first() != origin) {
+        const QTouchEvent::TouchPoint &firstTouchPoint = touchEvent->touchPoints().first();
+        cachedItemsUnderMouse = itemsAtPosition(firstTouchPoint.screenPos().toPoint(),
+                                                firstTouchPoint.scenePos(),
+                                                static_cast<QWidget *>(touchEvent->target()));
+    }
+
+    // Set focus on the topmost enabled item that can take focus.
+    bool setFocus = false;
+
+    foreach (QGraphicsItem *item, cachedItemsUnderMouse) {
+        if (item->isEnabled() && ((item->flags() & QGraphicsItem::ItemIsFocusable) && item->d_ptr->mouseSetsFocus)) {
+            if (!item->isWidget() || ((QGraphicsWidget *)item)->focusPolicy() & Qt::ClickFocus) {
+                setFocus = true;
+                if (item != q->focusItem())
+                    q->setFocusItem(item, Qt::MouseFocusReason);
+                break;
+            }
+        }
+        if (item->isPanel())
+            break;
+        if (item->d_ptr->flags & QGraphicsItem::ItemStopsClickFocusPropagation)
+            break;
+        if (item->d_ptr->flags & QGraphicsItem::ItemStopsFocusHandling) {
+            // Make sure we don't clear focus.
+            setFocus = true;
+            break;
+        }
+    }
+
+    // If nobody could take focus, clear it.
+    if (!stickyFocus && !setFocus)
+        q->setFocusItem(0, Qt::MouseFocusReason);
+
+    bool res = false;
+    bool eventAccepted = touchEvent->isAccepted();
+    foreach (QGraphicsItem *item, cachedItemsUnderMouse) {
+        // first, try to deliver the touch event
+        updateTouchPointsForItem(item, touchEvent);
+        bool acceptTouchEvents = item->acceptTouchEvents();
+        touchEvent->setAccepted(acceptTouchEvents);
+        res = acceptTouchEvents && sendEvent(item, touchEvent);
+        eventAccepted = touchEvent->isAccepted();
+        if (itemForTouchPointId.value(touchEvent->touchPoints().first().id()) == 0) {
+            // item was deleted
+            item = 0;
+        } else {
+            item->d_ptr->acceptedTouchBeginEvent = (res && eventAccepted);
+        }
+        touchEvent->spont = false;
+        if (res && eventAccepted) {
+            // the first item to accept the TouchBegin gets an implicit grab.
+            for (int i = 0; i < touchEvent->touchPoints().count(); ++i) {
+                const QTouchEvent::TouchPoint &touchPoint = touchEvent->touchPoints().at(i);
+                itemForTouchPointId[touchPoint.id()] = item; // can be zero
+            }
+            break;
+        }
+        if (item && item->isPanel())
+            break;
+    }
+
+    touchEvent->setAccepted(eventAccepted);
+    return res;
+}
+
+void QGraphicsScenePrivate::enableTouchEventsOnViews()
+{
+    foreach (QGraphicsView *view, views)
+        view->viewport()->setAttribute(Qt::WA_AcceptTouchEvents, true);
+}
+
+void QGraphicsScenePrivate::updateInputMethodSensitivityInViews()
+{
+    for (int i = 0; i < views.size(); ++i)
+        views.at(i)->d_func()->updateInputMethodSensitivity();
+}
+
+void QGraphicsScenePrivate::enterModal(QGraphicsItem *panel, QGraphicsItem::PanelModality previousModality)
+{
+    Q_Q(QGraphicsScene);
+    Q_ASSERT(panel && panel->isPanel());
+
+    QGraphicsItem::PanelModality panelModality = panel->d_ptr->panelModality;
+    if (previousModality != QGraphicsItem::NonModal) {
+        // the panel is changing from one modality type to another... temporarily set it back so
+        // that blockedPanels is populated correctly
+        panel->d_ptr->panelModality = previousModality;
+    }
+
+    QSet<QGraphicsItem *> blockedPanels;
+    QList<QGraphicsItem *> items = q->items(); // ### store panels separately
+    for (int i = 0; i < items.count(); ++i) {
+        QGraphicsItem *item = items.at(i);
+        if (item->isPanel() && item->isBlockedByModalPanel())
+            blockedPanels.insert(item);
+    }
+    // blockedPanels contains all currently blocked panels
+
+    if (previousModality != QGraphicsItem::NonModal) {
+        // reset the modality to the proper value, since we changed it above
+        panel->d_ptr->panelModality = panelModality;
+        // remove this panel so that it will be reinserted at the front of the stack
+        modalPanels.removeAll(panel);
+    }
+
+    modalPanels.prepend(panel);
+
+    if (!hoverItems.isEmpty()) {
+        // send GraphicsSceneHoverLeave events to newly blocked hoverItems
+        QGraphicsSceneHoverEvent hoverEvent;
+        hoverEvent.setScenePos(lastSceneMousePos);
+        dispatchHoverEvent(&hoverEvent);
+    }
+
+    if (!mouseGrabberItems.isEmpty() && lastMouseGrabberItemHasImplicitMouseGrab) {
+        QGraphicsItem *item = mouseGrabberItems.last();
+        if (item->isBlockedByModalPanel())
+            ungrabMouse(item, /*itemIsDying =*/ false);
+    }
+
+    QEvent windowBlockedEvent(QEvent::WindowBlocked);
+    QEvent windowUnblockedEvent(QEvent::WindowUnblocked);
+    for (int i = 0; i < items.count(); ++i) {
+        QGraphicsItem *item = items.at(i);
+        if (item->isPanel()) {
+            if (!blockedPanels.contains(item) && item->isBlockedByModalPanel()) {
+                // send QEvent::WindowBlocked to newly blocked panels
+                sendEvent(item, &windowBlockedEvent);
+            } else if (blockedPanels.contains(item) && !item->isBlockedByModalPanel()) {
+                // send QEvent::WindowUnblocked to unblocked panels when downgrading
+                // a panel from SceneModal to PanelModal
+                sendEvent(item, &windowUnblockedEvent);
+            }
+        }
+    }
+}
+
+void QGraphicsScenePrivate::leaveModal(QGraphicsItem *panel)
+{
+    Q_Q(QGraphicsScene);
+    Q_ASSERT(panel && panel->isPanel());
+
+    QSet<QGraphicsItem *> blockedPanels;
+    QList<QGraphicsItem *> items = q->items(); // ### same as above
+    for (int i = 0; i < items.count(); ++i) {
+        QGraphicsItem *item = items.at(i);
+        if (item->isPanel() && item->isBlockedByModalPanel())
+            blockedPanels.insert(item);
+    }
+
+    modalPanels.removeAll(panel);
+
+    QEvent e(QEvent::WindowUnblocked);
+    for (int i = 0; i < items.count(); ++i) {
+        QGraphicsItem *item = items.at(i);
+        if (item->isPanel() && blockedPanels.contains(item) && !item->isBlockedByModalPanel())
+            sendEvent(item, &e);
+    }
+
+    // send GraphicsSceneHoverEnter events to newly unblocked items
+    QGraphicsSceneHoverEvent hoverEvent;
+    hoverEvent.setScenePos(lastSceneMousePos);
+    dispatchHoverEvent(&hoverEvent);
+}
+
+#ifndef QT_NO_GESTURES
+void QGraphicsScenePrivate::gestureTargetsAtHotSpots(const QSet<QGesture *> &gestures,
+                                              Qt::GestureFlag flag,
+                                              QHash<QGraphicsObject *, QSet<QGesture *> > *targets,
+                                              QSet<QGraphicsObject *> *itemsSet,
+                                              QSet<QGesture *> *normal,
+                                              QSet<QGesture *> *conflicts)
+{
+    QSet<QGesture *> normalGestures; // that are not in conflicted state.
+    foreach (QGesture *gesture, gestures) {
+        if (!gesture->hasHotSpot())
+            continue;
+        const Qt::GestureType gestureType = gesture->gestureType();
+        QList<QGraphicsItem *> items = itemsAtPosition(QPoint(), gesture->d_func()->sceneHotSpot, 0);
+        for (int j = 0; j < items.size(); ++j) {
+            QGraphicsItem *item = items.at(j);
+
+            // Check if the item is blocked by a modal panel and use it as
+            // a target instead of this item.
+            (void) item->isBlockedByModalPanel(&item);
+
+            if (QGraphicsObject *itemobj = item->toGraphicsObject()) {
+                QGraphicsItemPrivate *d = item->QGraphicsItem::d_func();
+                QMap<Qt::GestureType, Qt::GestureFlags>::const_iterator it =
+                        d->gestureContext.constFind(gestureType);
+                if (it != d->gestureContext.constEnd() && (!flag || (it.value() & flag))) {
+                    if (normalGestures.contains(gesture)) {
+                        normalGestures.remove(gesture);
+                        if (conflicts)
+                            conflicts->insert(gesture);
+                    } else {
+                        normalGestures.insert(gesture);
+                    }
+                    if (targets)
+                        (*targets)[itemobj].insert(gesture);
+                    if (itemsSet)
+                        (*itemsSet).insert(itemobj);
+                }
+            }
+            // Don't propagate through panels.
+            if (item->isPanel())
+                break;
+        }
+    }
+    if (normal)
+        *normal = normalGestures;
+}
+
+void QGraphicsScenePrivate::gestureEventHandler(QGestureEvent *event)
+{
+    QWidget *viewport = event->widget();
+    if (!viewport)
+        return;
+    QGraphicsView *graphicsView = qobject_cast<QGraphicsView *>(viewport->parent());
+    if (!graphicsView)
+        return;
+
+    QList<QGesture *> allGestures = event->gestures();
+    DEBUG() << "QGraphicsScenePrivate::gestureEventHandler:"
+            << "Gestures:" <<  allGestures;
+
+    QSet<QGesture *> startedGestures;
+    QPoint delta = viewport->mapFromGlobal(QPoint());
+    QTransform toScene = QTransform::fromTranslate(delta.x(), delta.y())
+                         * graphicsView->viewportTransform().inverted();
+    foreach (QGesture *gesture, allGestures) {
+        // cache scene coordinates of the hot spot
+        if (gesture->hasHotSpot()) {
+            gesture->d_func()->sceneHotSpot = toScene.map(gesture->hotSpot());
+        } else {
+            gesture->d_func()->sceneHotSpot = QPointF();
+        }
+
+        QGraphicsObject *target = gestureTargets.value(gesture, 0);
+        if (!target) {
+            // when we are not in started mode but don't have a target
+            // then the only one interested in gesture is the view/scene
+            if (gesture->state() == Qt::GestureStarted)
+                startedGestures.insert(gesture);
+        }
+    }
+
+    if (!startedGestures.isEmpty()) {
+        QSet<QGesture *> normalGestures; // that have just one target
+        QSet<QGesture *> conflictedGestures; // that have multiple possible targets
+        gestureTargetsAtHotSpots(startedGestures, Qt::GestureFlag(0), &cachedItemGestures, 0,
+                                 &normalGestures, &conflictedGestures);
+        cachedTargetItems = cachedItemGestures.keys();
+        std::sort(cachedTargetItems.begin(), cachedTargetItems.end(), qt_closestItemFirst);
+        DEBUG() << "QGraphicsScenePrivate::gestureEventHandler:"
+                << "Normal gestures:" << normalGestures
+                << "Conflicting gestures:" << conflictedGestures;
+
+        // deliver conflicted gestures as override events AND remember
+        // initial gesture targets
+        if (!conflictedGestures.isEmpty()) {
+            for (int i = 0; i < cachedTargetItems.size(); ++i) {
+                QPointer<QGraphicsObject> item = cachedTargetItems.at(i);
+
+                // get gestures to deliver to the current item
+                QSet<QGesture *> gestures = conflictedGestures & cachedItemGestures.value(item.data());
+                if (gestures.isEmpty())
+                    continue;
+
+                DEBUG() << "QGraphicsScenePrivate::gestureEventHandler:"
+                        << "delivering override to"
+                        << item.data() << gestures;
+                // send gesture override
+                QGestureEvent ev(gestures.toList());
+                ev.t = QEvent::GestureOverride;
+                ev.setWidget(event->widget());
+                // mark event and individual gestures as ignored
+                ev.ignore();
+                foreach(QGesture *g, gestures)
+                    ev.setAccepted(g, false);
+                sendEvent(item.data(), &ev);
+                // mark all accepted gestures to deliver them as normal gesture events
+                foreach (QGesture *g, gestures) {
+                    if (ev.isAccepted() || ev.isAccepted(g)) {
+                        conflictedGestures.remove(g);
+                        // mark the item as a gesture target
+                        if (item) {
+                            gestureTargets.insert(g, item.data());
+                            QHash<QGraphicsObject *, QSet<QGesture *> >::iterator it, e;
+                            it = cachedItemGestures.begin();
+                            e = cachedItemGestures.end();
+                            for(; it != e; ++it)
+                                it.value().remove(g);
+                            cachedItemGestures[item.data()].insert(g);
+                        }
+                        DEBUG() << "QGraphicsScenePrivate::gestureEventHandler:"
+                                << "override was accepted:"
+                                << g << item.data();
+                    }
+                    // remember the first item that received the override event
+                    // as it most likely become a target if no one else accepts
+                    // the override event
+                    if (!gestureTargets.contains(g) && item)
+                        gestureTargets.insert(g, item.data());
+
+                }
+                if (conflictedGestures.isEmpty())
+                    break;
+            }
+        }
+        // remember the initial target item for each gesture that was not in
+        // the conflicted state.
+        if (!normalGestures.isEmpty()) {
+            for (int i = 0; i < cachedTargetItems.size() && !normalGestures.isEmpty(); ++i) {
+                QGraphicsObject *item = cachedTargetItems.at(i);
+
+                // get gestures to deliver to the current item
+                foreach (QGesture *g, cachedItemGestures.value(item)) {
+                    if (!gestureTargets.contains(g)) {
+                        gestureTargets.insert(g, item);
+                        normalGestures.remove(g);
+                    }
+                }
+            }
+        }
+    }
+
+
+    // deliver all gesture events
+    QSet<QGesture *> undeliveredGestures;
+    QSet<QGesture *> parentPropagatedGestures;
+    foreach (QGesture *gesture, allGestures) {
+        if (QGraphicsObject *target = gestureTargets.value(gesture, 0)) {
+            cachedItemGestures[target].insert(gesture);
+            cachedTargetItems.append(target);
+            undeliveredGestures.insert(gesture);
+            QGraphicsItemPrivate *d = target->QGraphicsItem::d_func();
+            const Qt::GestureFlags flags = d->gestureContext.value(gesture->gestureType());
+            if (flags & Qt::IgnoredGesturesPropagateToParent)
+                parentPropagatedGestures.insert(gesture);
+        } else {
+            DEBUG() << "QGraphicsScenePrivate::gestureEventHandler:"
+                    << "no target for" << gesture << "at"
+                    << gesture->hotSpot() << gesture->d_func()->sceneHotSpot;
+        }
+    }
+    std::sort(cachedTargetItems.begin(), cachedTargetItems.end(), qt_closestItemFirst);
+    for (int i = 0; i < cachedTargetItems.size(); ++i) {
+        QPointer<QGraphicsObject> receiver = cachedTargetItems.at(i);
+        QSet<QGesture *> gestures =
+                undeliveredGestures & cachedItemGestures.value(receiver.data());
+        gestures -= cachedAlreadyDeliveredGestures.value(receiver.data());
+
+        if (gestures.isEmpty())
+            continue;
+
+        cachedAlreadyDeliveredGestures[receiver.data()] += gestures;
+        const bool isPanel = receiver.data()->isPanel();
+
+        DEBUG() << "QGraphicsScenePrivate::gestureEventHandler:"
+                << "delivering to"
+                << receiver.data() << gestures;
+        QGestureEvent ev(gestures.toList());
+        ev.setWidget(event->widget());
+        sendEvent(receiver.data(), &ev);
+        QSet<QGesture *> ignoredGestures;
+        foreach (QGesture *g, gestures) {
+            if (!ev.isAccepted() && !ev.isAccepted(g)) {
+                // if the gesture was ignored by its target, we will update the
+                // targetItems list with a possible target items (items that
+                // want to receive partial gestures).
+                // ### won't work if the target was destroyed in the event
+                //     we will just stop delivering it.
+                if (receiver && receiver.data() == gestureTargets.value(g, 0))
+                    ignoredGestures.insert(g);
+            } else {
+                if (receiver && g->state() == Qt::GestureStarted) {
+                    // someone accepted the propagated initial GestureStarted
+                    // event, let it be the new target for all following events.
+                    gestureTargets[g] = receiver.data();
+                }
+                undeliveredGestures.remove(g);
+            }
+        }
+        if (undeliveredGestures.isEmpty())
+            break;
+
+        // ignoredGestures list is only filled when delivering to the gesture
+        // target item, so it is safe to assume item == target.
+        if (!ignoredGestures.isEmpty() && !isPanel) {
+            // look for new potential targets for gestures that were ignored
+            // and should be propagated.
+
+            QSet<QGraphicsObject *> targetsSet = cachedTargetItems.toSet();
+
+            if (receiver) {
+                // first if the gesture should be propagated to parents only
+                for (QSet<QGesture *>::iterator it = ignoredGestures.begin();
+                     it != ignoredGestures.end();) {
+                    if (parentPropagatedGestures.contains(*it)) {
+                        QGesture *gesture = *it;
+                        const Qt::GestureType gestureType = gesture->gestureType();
+                        QGraphicsItem *item = receiver.data();
+                        while (item) {
+                            if (QGraphicsObject *obj = item->toGraphicsObject()) {
+                                if (item->d_func()->gestureContext.contains(gestureType)) {
+                                    targetsSet.insert(obj);
+                                    cachedItemGestures[obj].insert(gesture);
+                                }
+                            }
+                            if (item->isPanel())
+                                break;
+                            item = item->parentItem();
+                        }
+
+                        it = ignoredGestures.erase(it);
+                        continue;
+                    }
+                    ++it;
+                }
+            }
+
+            gestureTargetsAtHotSpots(ignoredGestures, Qt::ReceivePartialGestures,
+                                     &cachedItemGestures, &targetsSet, 0, 0);
+
+            cachedTargetItems = targetsSet.toList();
+            std::sort(cachedTargetItems.begin(), cachedTargetItems.end(), qt_closestItemFirst);
+            DEBUG() << "QGraphicsScenePrivate::gestureEventHandler:"
+                    << "new targets:" << cachedTargetItems;
+            i = -1; // start delivery again
+            continue;
+        }
+    }
+
+    foreach (QGesture *g, startedGestures) {
+        if (g->gestureCancelPolicy() == QGesture::CancelAllInContext) {
+            DEBUG() << "lets try to cancel some";
+            // find gestures in context in Qt::GestureStarted or Qt::GestureUpdated state and cancel them
+            cancelGesturesForChildren(g);
+        }
+    }
+
+    // forget about targets for gestures that have ended
+    foreach (QGesture *g, allGestures) {
+        switch (g->state()) {
+        case Qt::GestureFinished:
+        case Qt::GestureCanceled:
+            gestureTargets.remove(g);
+            break;
+        default:
+            break;
+        }
+    }
+
+    cachedTargetItems.clear();
+    cachedItemGestures.clear();
+    cachedAlreadyDeliveredGestures.clear();
+}
+
+void QGraphicsScenePrivate::cancelGesturesForChildren(QGesture *original)
+{
+    Q_ASSERT(original);
+    QGraphicsItem *originalItem = gestureTargets.value(original);
+    if (originalItem == 0) // we only act on accepted gestures, which implies it has a target.
+        return;
+
+    // iterate over all active gestures and for each find the owner
+    // if the owner is part of our sub-hierarchy, cancel it.
+
+    QSet<QGesture *> canceledGestures;
+    QHash<QGesture *, QGraphicsObject *>::Iterator iter = gestureTargets.begin();
+    while (iter != gestureTargets.end()) {
+        QGraphicsObject *item = iter.value();
+        // note that we don't touch the gestures for our originalItem
+        if (item != originalItem && originalItem->isAncestorOf(item)) {
+            DEBUG() << "  found a gesture to cancel" << iter.key();
+            iter.key()->d_func()->state = Qt::GestureCanceled;
+            canceledGestures << iter.key();
+        }
+        ++iter;
+    }
+
+    // sort them per target item by cherry picking from almostCanceledGestures and delivering
+    QSet<QGesture *> almostCanceledGestures = canceledGestures;
+    QSet<QGesture *>::Iterator setIter;
+    while (!almostCanceledGestures.isEmpty()) {
+        QGraphicsObject *target = 0;
+        QSet<QGesture*> gestures;
+        setIter = almostCanceledGestures.begin();
+        // sort per target item
+        while (setIter != almostCanceledGestures.end()) {
+            QGraphicsObject *item = gestureTargets.value(*setIter);
+            if (target == 0)
+                target = item;
+            if (target == item) {
+                gestures << *setIter;
+                setIter = almostCanceledGestures.erase(setIter);
+            } else {
+                ++setIter;
+            }
+        }
+        Q_ASSERT(target);
+
+        QList<QGesture *> list = gestures.toList();
+        QGestureEvent ev(list);
+        sendEvent(target, &ev);
+
+        foreach (QGesture *g, list) {
+            if (ev.isAccepted() || ev.isAccepted(g))
+                gestures.remove(g);
+        }
+
+        foreach (QGesture *g, gestures) {
+            if (!g->hasHotSpot())
+                continue;
+
+            QList<QGraphicsItem *> items = itemsAtPosition(QPoint(), g->d_func()->sceneHotSpot, 0);
+            for (int j = 0; j < items.size(); ++j) {
+                QGraphicsObject *item = items.at(j)->toGraphicsObject();
+                if (!item)
+                    continue;
+                QGraphicsItemPrivate *d = item->QGraphicsItem::d_func();
+                if (d->gestureContext.contains(g->gestureType())) {
+                    QList<QGesture *> list;
+                    list << g;
+                    QGestureEvent ev(list);
+                    sendEvent(item, &ev);
+                    if (ev.isAccepted() || ev.isAccepted(g))
+                        break; // successfully delivered
+                }
+            }
+        }
+    }
+
+    QGestureManager *gestureManager = QApplicationPrivate::instance()->gestureManager;
+    Q_ASSERT(gestureManager); // it would be very odd if we got called without a manager.
+    for (setIter = canceledGestures.begin(); setIter != canceledGestures.end(); ++setIter) {
+        gestureManager->recycle(*setIter);
+        gestureTargets.remove(*setIter);
+    }
+}
+
+void QGraphicsScenePrivate::grabGesture(QGraphicsItem *, Qt::GestureType gesture)
+{
+    (void)QGestureManager::instance(); // create a gesture manager
+    if (!grabbedGestures[gesture]++) {
+        foreach (QGraphicsView *view, views)
+            view->viewport()->grabGesture(gesture);
+    }
+}
+
+void QGraphicsScenePrivate::ungrabGesture(QGraphicsItem *item, Qt::GestureType gesture)
+{
+    // we know this can only be an object
+    Q_ASSERT(item->d_ptr->isObject);
+    QGraphicsObject *obj = static_cast<QGraphicsObject *>(item);
+    QGestureManager::instance()->cleanupCachedGestures(obj, gesture);
+    if (!--grabbedGestures[gesture]) {
+        foreach (QGraphicsView *view, views)
+            view->viewport()->ungrabGesture(gesture);
+    }
+}
+#endif // QT_NO_GESTURES
+
+QT_END_NAMESPACE
+
+#include "moc_qgraphicsscene.cpp"
+
+#endif // QT_NO_GRAPHICSVIEW
diff --git a/.pc/inendi.patch/src/widgets/graphicsview/qgraphicsscene.h b/.pc/inendi.patch/src/widgets/graphicsview/qgraphicsscene.h
new file mode 100644
index 0000000..cde0eda
--- /dev/null
+++ b/.pc/inendi.patch/src/widgets/graphicsview/qgraphicsscene.h
@@ -0,0 +1,326 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtWidgets module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QGRAPHICSSCENE_H
+#define QGRAPHICSSCENE_H
+
+#include <QtCore/qobject.h>
+#include <QtCore/qpoint.h>
+#include <QtCore/qrect.h>
+#include <QtGui/qbrush.h>
+#include <QtGui/qfont.h>
+#include <QtGui/qtransform.h>
+#include <QtGui/qmatrix.h>
+#include <QtGui/qpen.h>
+
+QT_BEGIN_NAMESPACE
+
+
+#if !defined(QT_NO_GRAPHICSVIEW)
+
+template<typename T> class QList;
+class QFocusEvent;
+class QFont;
+class QFontMetrics;
+class QGraphicsEllipseItem;
+class QGraphicsItem;
+class QGraphicsItemGroup;
+class QGraphicsLineItem;
+class QGraphicsPathItem;
+class QGraphicsPixmapItem;
+class QGraphicsPolygonItem;
+class QGraphicsProxyWidget;
+class QGraphicsRectItem;
+class QGraphicsSceneContextMenuEvent;
+class QGraphicsSceneDragDropEvent;
+class QGraphicsSceneEvent;
+class QGraphicsSceneHelpEvent;
+class QGraphicsSceneHoverEvent;
+class QGraphicsSceneMouseEvent;
+class QGraphicsSceneWheelEvent;
+class QGraphicsSimpleTextItem;
+class QGraphicsTextItem;
+class QGraphicsView;
+class QGraphicsWidget;
+class QGraphicsSceneIndex;
+class QHelpEvent;
+class QInputMethodEvent;
+class QKeyEvent;
+class QLineF;
+class QPainterPath;
+class QPixmap;
+class QPointF;
+class QPolygonF;
+class QRectF;
+class QSizeF;
+class QStyle;
+class QStyleOptionGraphicsItem;
+
+class QGraphicsScenePrivate;
+class Q_WIDGETS_EXPORT QGraphicsScene : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(QBrush backgroundBrush READ backgroundBrush WRITE setBackgroundBrush)
+    Q_PROPERTY(QBrush foregroundBrush READ foregroundBrush WRITE setForegroundBrush)
+    Q_PROPERTY(ItemIndexMethod itemIndexMethod READ itemIndexMethod WRITE setItemIndexMethod)
+    Q_PROPERTY(QRectF sceneRect READ sceneRect WRITE setSceneRect)
+    Q_PROPERTY(int bspTreeDepth READ bspTreeDepth WRITE setBspTreeDepth)
+    Q_PROPERTY(QPalette palette READ palette WRITE setPalette)
+    Q_PROPERTY(QFont font READ font WRITE setFont)
+    Q_PROPERTY(bool sortCacheEnabled READ isSortCacheEnabled WRITE setSortCacheEnabled)
+    Q_PROPERTY(bool stickyFocus READ stickyFocus WRITE setStickyFocus)
+
+public:
+    enum ItemIndexMethod {
+        BspTreeIndex,
+        NoIndex = -1
+    };
+
+    enum SceneLayer {
+        ItemLayer = 0x1,
+        BackgroundLayer = 0x2,
+        ForegroundLayer = 0x4,
+        AllLayers = 0xffff
+    };
+    Q_DECLARE_FLAGS(SceneLayers, SceneLayer)
+
+    QGraphicsScene(QObject *parent = 0);
+    QGraphicsScene(const QRectF &sceneRect, QObject *parent = 0);
+    QGraphicsScene(qreal x, qreal y, qreal width, qreal height, QObject *parent = 0);
+    virtual ~QGraphicsScene();
+
+    QRectF sceneRect() const;
+    inline qreal width() const { return sceneRect().width(); }
+    inline qreal height() const { return sceneRect().height(); }
+    void setSceneRect(const QRectF &rect);
+    inline void setSceneRect(qreal x, qreal y, qreal w, qreal h)
+    { setSceneRect(QRectF(x, y, w, h)); }
+
+    void render(QPainter *painter,
+                const QRectF &target = QRectF(), const QRectF &source = QRectF(),
+                Qt::AspectRatioMode aspectRatioMode = Qt::KeepAspectRatio);
+
+    ItemIndexMethod itemIndexMethod() const;
+    void setItemIndexMethod(ItemIndexMethod method);
+
+    bool isSortCacheEnabled() const;
+    void setSortCacheEnabled(bool enabled);
+
+    int bspTreeDepth() const;
+    void setBspTreeDepth(int depth);
+
+    QRectF itemsBoundingRect() const;
+
+    QList<QGraphicsItem *> items(Qt::SortOrder order = Qt::DescendingOrder) const;
+
+    QList<QGraphicsItem *> items(const QPointF &pos, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, Qt::SortOrder order = Qt::DescendingOrder, const QTransform &deviceTransform = QTransform()) const;
+    QList<QGraphicsItem *> items(const QRectF &rect, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, Qt::SortOrder order = Qt::DescendingOrder, const QTransform &deviceTransform = QTransform()) const;
+    QList<QGraphicsItem *> items(const QPolygonF &polygon, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, Qt::SortOrder order = Qt::DescendingOrder, const QTransform &deviceTransform = QTransform()) const;
+    QList<QGraphicsItem *> items(const QPainterPath &path, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, Qt::SortOrder order = Qt::DescendingOrder, const QTransform &deviceTransform = QTransform()) const;
+
+    QList<QGraphicsItem *> collidingItems(const QGraphicsItem *item, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const;
+#if QT_DEPRECATED_SINCE(5, 0)
+    QT_DEPRECATED inline QGraphicsItem *itemAt(const QPointF &position) const {
+        QList<QGraphicsItem *> itemsAtPoint = items(position);
+        return itemsAtPoint.isEmpty() ? 0 : itemsAtPoint.first();
+    }
+#endif
+    QGraphicsItem *itemAt(const QPointF &pos, const QTransform &deviceTransform) const;
+#if QT_DEPRECATED_SINCE(5, 0)
+    QT_DEPRECATED inline QList<QGraphicsItem *> items(qreal x, qreal y, qreal w, qreal h, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape) const
+    { return items(QRectF(x, y, w, h), mode); }
+#endif
+    inline QList<QGraphicsItem *> items(qreal x, qreal y, qreal w, qreal h, Qt::ItemSelectionMode mode, Qt::SortOrder order,
+                                        const QTransform &deviceTransform = QTransform()) const
+    { return items(QRectF(x, y, w, h), mode, order, deviceTransform); }
+#if QT_DEPRECATED_SINCE(5, 0)
+    QT_DEPRECATED inline QGraphicsItem *itemAt(qreal x, qreal y) const {
+        QList<QGraphicsItem *> itemsAtPoint = items(QPointF(x, y));
+        return itemsAtPoint.isEmpty() ? 0 : itemsAtPoint.first();
+    }
+#endif
+    inline QGraphicsItem *itemAt(qreal x, qreal y, const QTransform &deviceTransform) const
+    { return itemAt(QPointF(x, y), deviceTransform); }
+
+    QList<QGraphicsItem *> selectedItems() const;
+    QPainterPath selectionArea() const;
+    void setSelectionArea(const QPainterPath &path, const QTransform &deviceTransform);
+    void setSelectionArea(const QPainterPath &path, Qt::ItemSelectionMode mode = Qt::IntersectsItemShape, const QTransform &deviceTransform = QTransform());
+
+    QGraphicsItemGroup *createItemGroup(const QList<QGraphicsItem *> &items);
+    void destroyItemGroup(QGraphicsItemGroup *group);
+
+    void addItem(QGraphicsItem *item);
+    QGraphicsEllipseItem *addEllipse(const QRectF &rect, const QPen &pen = QPen(), const QBrush &brush = QBrush());
+    QGraphicsLineItem *addLine(const QLineF &line, const QPen &pen = QPen());
+    QGraphicsPathItem *addPath(const QPainterPath &path, const QPen &pen = QPen(), const QBrush &brush = QBrush());
+    QGraphicsPixmapItem *addPixmap(const QPixmap &pixmap);
+    QGraphicsPolygonItem *addPolygon(const QPolygonF &polygon, const QPen &pen = QPen(), const QBrush &brush = QBrush());
+    QGraphicsRectItem *addRect(const QRectF &rect, const QPen &pen = QPen(), const QBrush &brush = QBrush());
+    QGraphicsTextItem *addText(const QString &text, const QFont &font = QFont());
+    QGraphicsSimpleTextItem *addSimpleText(const QString &text, const QFont &font = QFont());
+    QGraphicsProxyWidget *addWidget(QWidget *widget, Qt::WindowFlags wFlags = 0);
+    inline QGraphicsEllipseItem *addEllipse(qreal x, qreal y, qreal w, qreal h, const QPen &pen = QPen(), const QBrush &brush = QBrush())
+    { return addEllipse(QRectF(x, y, w, h), pen, brush); }
+    inline QGraphicsLineItem *addLine(qreal x1, qreal y1, qreal x2, qreal y2, const QPen &pen = QPen())
+    { return addLine(QLineF(x1, y1, x2, y2), pen); }
+    inline QGraphicsRectItem *addRect(qreal x, qreal y, qreal w, qreal h, const QPen &pen = QPen(), const QBrush &brush = QBrush())
+    { return addRect(QRectF(x, y, w, h), pen, brush); }
+    void removeItem(QGraphicsItem *item);
+
+    QGraphicsItem *focusItem() const;
+    void setFocusItem(QGraphicsItem *item, Qt::FocusReason focusReason = Qt::OtherFocusReason);
+    bool hasFocus() const;
+    void setFocus(Qt::FocusReason focusReason = Qt::OtherFocusReason);
+    void clearFocus();
+
+    void setStickyFocus(bool enabled);
+    bool stickyFocus() const;
+
+    QGraphicsItem *mouseGrabberItem() const;
+
+    QBrush backgroundBrush() const;
+    void setBackgroundBrush(const QBrush &brush);
+
+    QBrush foregroundBrush() const;
+    void setForegroundBrush(const QBrush &brush);
+
+    virtual QVariant inputMethodQuery(Qt::InputMethodQuery query) const;
+
+    QList <QGraphicsView *> views() const;
+
+    inline void update(qreal x, qreal y, qreal w, qreal h)
+    { update(QRectF(x, y, w, h)); }
+    inline void invalidate(qreal x, qreal y, qreal w, qreal h, SceneLayers layers = AllLayers)
+    { invalidate(QRectF(x, y, w, h), layers); }
+
+    QStyle *style() const;
+    void setStyle(QStyle *style);
+
+    QFont font() const;
+    void setFont(const QFont &font);
+
+    QPalette palette() const;
+    void setPalette(const QPalette &palette);
+
+    bool isActive() const;
+    QGraphicsItem *activePanel() const;
+    void setActivePanel(QGraphicsItem *item);
+    QGraphicsWidget *activeWindow() const;
+    void setActiveWindow(QGraphicsWidget *widget);
+
+    bool sendEvent(QGraphicsItem *item, QEvent *event);
+
+public Q_SLOTS:
+    void update(const QRectF &rect = QRectF());
+    void invalidate(const QRectF &rect = QRectF(), SceneLayers layers = AllLayers);
+    void advance();
+    void clearSelection();
+    void clear();
+
+protected:
+    bool event(QEvent *event);
+    bool eventFilter(QObject *watched, QEvent *event);
+    virtual void contextMenuEvent(QGraphicsSceneContextMenuEvent *event);
+    virtual void dragEnterEvent(QGraphicsSceneDragDropEvent *event);
+    virtual void dragMoveEvent(QGraphicsSceneDragDropEvent *event);
+    virtual void dragLeaveEvent(QGraphicsSceneDragDropEvent *event);
+    virtual void dropEvent(QGraphicsSceneDragDropEvent *event);
+    virtual void focusInEvent(QFocusEvent *event);
+    virtual void focusOutEvent(QFocusEvent *event);
+    virtual void helpEvent(QGraphicsSceneHelpEvent *event);
+    virtual void keyPressEvent(QKeyEvent *event);
+    virtual void keyReleaseEvent(QKeyEvent *event);
+    virtual void mousePressEvent(QGraphicsSceneMouseEvent *event);
+    virtual void mouseMoveEvent(QGraphicsSceneMouseEvent *event);
+    virtual void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);
+    virtual void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event);
+    virtual void wheelEvent(QGraphicsSceneWheelEvent *event);
+    virtual void inputMethodEvent(QInputMethodEvent *event);
+
+    virtual void drawBackground(QPainter *painter, const QRectF &rect);
+    virtual void drawForeground(QPainter *painter, const QRectF &rect);
+    virtual void drawItems(QPainter *painter, int numItems,
+                           QGraphicsItem *items[],
+                           const QStyleOptionGraphicsItem options[],
+                           QWidget *widget = 0);
+
+protected Q_SLOTS:
+    bool focusNextPrevChild(bool next);
+
+Q_SIGNALS:
+    void changed(const QList<QRectF> &region);
+    void sceneRectChanged(const QRectF &rect);
+    void selectionChanged();
+    void focusItemChanged(QGraphicsItem *newFocus, QGraphicsItem *oldFocus, Qt::FocusReason reason);
+
+private:
+    Q_DECLARE_PRIVATE(QGraphicsScene)
+    Q_DISABLE_COPY(QGraphicsScene)
+    Q_PRIVATE_SLOT(d_func(), void _q_emitUpdated())
+    Q_PRIVATE_SLOT(d_func(), void _q_polishItems())
+    Q_PRIVATE_SLOT(d_func(), void _q_processDirtyItems())
+    Q_PRIVATE_SLOT(d_func(), void _q_updateScenePosDescendants())
+    friend class QGraphicsItem;
+    friend class QGraphicsItemPrivate;
+    friend class QGraphicsObject;
+    friend class QGraphicsView;
+    friend class QGraphicsViewPrivate;
+    friend class QGraphicsWidget;
+    friend class QGraphicsWidgetPrivate;
+    friend class QGraphicsEffect;
+    friend class QGraphicsSceneIndex;
+    friend class QGraphicsSceneIndexPrivate;
+    friend class QGraphicsSceneBspTreeIndex;
+    friend class QGraphicsSceneBspTreeIndexPrivate;
+    friend class QGraphicsItemEffectSourcePrivate;
+#ifndef QT_NO_GESTURES
+    friend class QGesture;
+#endif
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QGraphicsScene::SceneLayers)
+
+#endif // QT_NO_GRAPHICSVIEW
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/.pc/inendi.patch/src/widgets/graphicsview/qgraphicsscene_p.h b/.pc/inendi.patch/src/widgets/graphicsview/qgraphicsscene_p.h
new file mode 100644
index 0000000..9e5bcec
--- /dev/null
+++ b/.pc/inendi.patch/src/widgets/graphicsview/qgraphicsscene_p.h
@@ -0,0 +1,360 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtWidgets module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QGRAPHICSSCENE_P_H
+#define QGRAPHICSSCENE_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists for the convenience
+// of other Qt classes.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qgraphicsscene.h"
+
+#if !defined(QT_NO_GRAPHICSVIEW)
+
+#include "qgraphicssceneevent.h"
+#include "qgraphicsview.h"
+#include "qgraphicsview_p.h"
+#include "qgraphicsitem_p.h"
+
+#include <private/qobject_p.h>
+#include <QtCore/qbitarray.h>
+#include <QtCore/qlist.h>
+#include <QtCore/qmap.h>
+#include <QtCore/qset.h>
+#include <QtGui/qfont.h>
+#include <QtGui/qpalette.h>
+#include <QtWidgets/qstyle.h>
+#include <QtWidgets/qstyleoption.h>
+
+QT_BEGIN_NAMESPACE
+
+class QGraphicsSceneIndex;
+class QGraphicsView;
+class QGraphicsWidget;
+
+class Q_AUTOTEST_EXPORT QGraphicsScenePrivate : public QObjectPrivate
+{
+    Q_DECLARE_PUBLIC(QGraphicsScene)
+public:
+    QGraphicsScenePrivate();
+    void init();
+
+    static QGraphicsScenePrivate *get(QGraphicsScene *q);
+
+    int changedSignalIndex;
+    int processDirtyItemsIndex;
+    int polishItemsIndex;
+
+    QGraphicsScene::ItemIndexMethod indexMethod;
+    QGraphicsSceneIndex *index;
+
+    int lastItemCount;
+
+    QRectF sceneRect;
+
+    quint32 hasSceneRect : 1;
+    quint32 dirtyGrowingItemsBoundingRect : 1;
+    quint32 updateAll : 1;
+    quint32 calledEmitUpdated : 1;
+    quint32 processDirtyItemsEmitted : 1;
+    quint32 needSortTopLevelItems : 1;
+    quint32 holesInTopLevelSiblingIndex : 1;
+    quint32 topLevelSequentialOrdering : 1;
+    quint32 scenePosDescendantsUpdatePending : 1;
+    quint32 stickyFocus : 1;
+    quint32 hasFocus : 1;
+    quint32 lastMouseGrabberItemHasImplicitMouseGrab : 1;
+    quint32 allItemsIgnoreHoverEvents : 1;
+    quint32 allItemsUseDefaultCursor : 1;
+    quint32 painterStateProtection : 1;
+    quint32 sortCacheEnabled : 1; // for compatibility
+    quint32 allItemsIgnoreTouchEvents : 1;
+    quint32 padding : 15;
+
+    QRectF growingItemsBoundingRect;
+
+    void _q_emitUpdated();
+    QList<QRectF> updatedRects;
+
+    QPainterPath selectionArea;
+    int selectionChanging;
+    QSet<QGraphicsItem *> selectedItems;
+    QVector<QGraphicsItem *> unpolishedItems;
+    QList<QGraphicsItem *> topLevelItems;
+
+    QHash<QGraphicsItem *, QPointF> movingItemsInitialPositions;
+    void registerTopLevelItem(QGraphicsItem *item);
+    void unregisterTopLevelItem(QGraphicsItem *item);
+    void _q_updateLater();
+    void _q_polishItems();
+
+    void _q_processDirtyItems();
+
+    QSet<QGraphicsItem *> scenePosItems;
+    void setScenePosItemEnabled(QGraphicsItem *item, bool enabled);
+    void registerScenePosItem(QGraphicsItem *item);
+    void unregisterScenePosItem(QGraphicsItem *item);
+    void _q_updateScenePosDescendants();
+
+    void removeItemHelper(QGraphicsItem *item);
+
+    QBrush backgroundBrush;
+    QBrush foregroundBrush;
+
+    quint32 rectAdjust;
+    QGraphicsItem *focusItem;
+    QGraphicsItem *lastFocusItem;
+    QGraphicsItem *passiveFocusItem;
+    QGraphicsWidget *tabFocusFirst;
+    QGraphicsItem *activePanel;
+    QGraphicsItem *lastActivePanel;
+    int activationRefCount;
+    int childExplicitActivation;
+    void setActivePanelHelper(QGraphicsItem *item, bool duringActivationEvent);
+    void setFocusItemHelper(QGraphicsItem *item, Qt::FocusReason focusReason,
+                            bool emitFocusChanged = true);
+
+    QList<QGraphicsWidget *> popupWidgets;
+    void addPopup(QGraphicsWidget *widget);
+    void removePopup(QGraphicsWidget *widget, bool itemIsDying = false);
+
+    QGraphicsItem *lastMouseGrabberItem;
+    QList<QGraphicsItem *> mouseGrabberItems;
+    void grabMouse(QGraphicsItem *item, bool implicit = false);
+    void ungrabMouse(QGraphicsItem *item, bool itemIsDying = false);
+    void clearMouseGrabber();
+
+    QList<QGraphicsItem *> keyboardGrabberItems;
+    void grabKeyboard(QGraphicsItem *item);
+    void ungrabKeyboard(QGraphicsItem *item, bool itemIsDying = false);
+    void clearKeyboardGrabber();
+
+    QGraphicsItem *dragDropItem;
+    QGraphicsWidget *enterWidget;
+    Qt::DropAction lastDropAction;
+    QList<QGraphicsItem *> cachedItemsUnderMouse;
+    QList<QGraphicsItem *> hoverItems;
+    QPointF lastSceneMousePos;
+    void enableMouseTrackingOnViews();
+    QMap<Qt::MouseButton, QPointF> mouseGrabberButtonDownPos;
+    QMap<Qt::MouseButton, QPointF> mouseGrabberButtonDownScenePos;
+    QMap<Qt::MouseButton, QPoint> mouseGrabberButtonDownScreenPos;
+    QList<QGraphicsItem *> itemsAtPosition(const QPoint &screenPos,
+                                           const QPointF &scenePos,
+                                           QWidget *widget) const;
+    void storeMouseButtonsForMouseGrabber(QGraphicsSceneMouseEvent *event);
+
+    QList<QGraphicsView *> views;
+    void addView(QGraphicsView *view);
+    void removeView(QGraphicsView *view);
+
+    QMultiMap<QGraphicsItem *, QGraphicsItem *> sceneEventFilters;
+    void installSceneEventFilter(QGraphicsItem *watched, QGraphicsItem *filter);
+    void removeSceneEventFilter(QGraphicsItem *watched, QGraphicsItem *filter);
+    bool filterDescendantEvent(QGraphicsItem *item, QEvent *event);
+    bool filterEvent(QGraphicsItem *item, QEvent *event);
+    bool sendEvent(QGraphicsItem *item, QEvent *event);
+
+    bool dispatchHoverEvent(QGraphicsSceneHoverEvent *hoverEvent);
+    bool itemAcceptsHoverEvents_helper(const QGraphicsItem *item) const;
+    void leaveScene(QWidget *viewport);
+
+    void cloneDragDropEvent(QGraphicsSceneDragDropEvent *dest,
+                           QGraphicsSceneDragDropEvent *source);
+    void sendDragDropEvent(QGraphicsItem *item,
+                           QGraphicsSceneDragDropEvent *dragDropEvent);
+    void sendHoverEvent(QEvent::Type type, QGraphicsItem *item,
+                        QGraphicsSceneHoverEvent *hoverEvent);
+    void sendMouseEvent(QGraphicsSceneMouseEvent *mouseEvent);
+    void mousePressEventHandler(QGraphicsSceneMouseEvent *mouseEvent);
+    QGraphicsWidget *windowForItem(const QGraphicsItem *item) const;
+
+    void drawItemHelper(QGraphicsItem *item, QPainter *painter,
+                        const QStyleOptionGraphicsItem *option, QWidget *widget,
+                        bool painterStateProtection);
+
+    void drawItems(QPainter *painter, const QTransform *const viewTransform,
+                   QRegion *exposedRegion, QWidget *widget);
+
+    void drawSubtreeRecursive(QGraphicsItem *item, QPainter *painter, const QTransform *const,
+                              QRegion *exposedRegion, QWidget *widget, qreal parentOpacity = qreal(1.0),
+                              const QTransform *const effectTransform = 0);
+    void draw(QGraphicsItem *, QPainter *, const QTransform *const, const QTransform *const,
+              QRegion *, QWidget *, qreal, const QTransform *const, bool, bool);
+
+    void markDirty(QGraphicsItem *item, const QRectF &rect = QRectF(), bool invalidateChildren = false,
+                   bool force = false, bool ignoreOpacity = false, bool removingItemFromScene = false,
+                   bool updateBoundingRect = false);
+    void processDirtyItemsRecursive(QGraphicsItem *item, bool dirtyAncestorContainsChildren = false,
+                                    qreal parentOpacity = qreal(1.0));
+
+    inline void resetDirtyItem(QGraphicsItem *item, bool recursive = false)
+    {
+        Q_ASSERT(item);
+        item->d_ptr->dirty = 0;
+        item->d_ptr->paintedViewBoundingRectsNeedRepaint = 0;
+        item->d_ptr->geometryChanged = 0;
+        if (!item->d_ptr->dirtyChildren)
+            recursive = false;
+        item->d_ptr->dirtyChildren = 0;
+        item->d_ptr->needsRepaint = QRectF();
+        item->d_ptr->allChildrenDirty = 0;
+        item->d_ptr->fullUpdatePending = 0;
+        item->d_ptr->ignoreVisible = 0;
+        item->d_ptr->ignoreOpacity = 0;
+#ifndef QT_NO_GRAPHICSEFFECT
+        QGraphicsEffect::ChangeFlags flags;
+        if (item->d_ptr->notifyBoundingRectChanged) {
+            flags |= QGraphicsEffect::SourceBoundingRectChanged;
+            item->d_ptr->notifyBoundingRectChanged = 0;
+        }
+        if (item->d_ptr->notifyInvalidated) {
+            flags |= QGraphicsEffect::SourceInvalidated;
+            item->d_ptr->notifyInvalidated = 0;
+        }
+#endif //QT_NO_GRAPHICSEFFECT
+        if (recursive) {
+            for (int i = 0; i < item->d_ptr->children.size(); ++i)
+                resetDirtyItem(item->d_ptr->children.at(i), recursive);
+        }
+#ifndef QT_NO_GRAPHICSEFFECT
+        if (flags && item->d_ptr->graphicsEffect)
+            item->d_ptr->graphicsEffect->sourceChanged(flags);
+#endif //QT_NO_GRAPHICSEFFECT
+    }
+
+    inline void ensureSortedTopLevelItems()
+    {
+        if (needSortTopLevelItems) {
+            std::sort(topLevelItems.begin(), topLevelItems.end(), qt_notclosestLeaf);
+            topLevelSequentialOrdering = false;
+            needSortTopLevelItems = false;
+        }
+    }
+
+    void ensureSequentialTopLevelSiblingIndexes();
+
+    QStyle *style;
+    QFont font;
+    void setFont_helper(const QFont &font);
+    void resolveFont();
+    void updateFont(const QFont &font);
+    QPalette palette;
+    void setPalette_helper(const QPalette &palette);
+    void resolvePalette();
+    void updatePalette(const QPalette &palette);
+
+    QStyleOptionGraphicsItem styleOptionTmp;
+
+    QMap<int, QTouchEvent::TouchPoint> sceneCurrentTouchPoints;
+    QMap<int, QGraphicsItem *> itemForTouchPointId;
+    static void updateTouchPointsForItem(QGraphicsItem *item, QTouchEvent *touchEvent);
+    int findClosestTouchPointId(const QPointF &scenePos);
+    void touchEventHandler(QTouchEvent *touchEvent);
+    bool sendTouchBeginEvent(QGraphicsItem *item, QTouchEvent *touchEvent);
+    void enableTouchEventsOnViews();
+
+    QList<QGraphicsObject *> cachedTargetItems;
+#ifndef QT_NO_GESTURES
+    QHash<QGraphicsObject *, QSet<QGesture *> > cachedItemGestures;
+    QHash<QGraphicsObject *, QSet<QGesture *> > cachedAlreadyDeliveredGestures;
+    QHash<QGesture *, QGraphicsObject *> gestureTargets;
+    QHash<Qt::GestureType, int>  grabbedGestures;
+    void gestureEventHandler(QGestureEvent *event);
+    void gestureTargetsAtHotSpots(const QSet<QGesture *> &gestures,
+                           Qt::GestureFlag flag,
+                           QHash<QGraphicsObject *, QSet<QGesture *> > *targets,
+                           QSet<QGraphicsObject *> *itemsSet = 0,
+                           QSet<QGesture *> *normal = 0,
+                           QSet<QGesture *> *conflicts = 0);
+    void cancelGesturesForChildren(QGesture *original);
+    void grabGesture(QGraphicsItem *, Qt::GestureType gesture);
+    void ungrabGesture(QGraphicsItem *, Qt::GestureType gesture);
+#endif // QT_NO_GESTURES
+
+    void updateInputMethodSensitivityInViews();
+
+    QList<QGraphicsItem *> modalPanels;
+    void enterModal(QGraphicsItem *item,
+                    QGraphicsItem::PanelModality panelModality = QGraphicsItem::NonModal);
+    void leaveModal(QGraphicsItem *item);
+};
+
+// QRectF::intersects() returns false always if either the source or target
+// rectangle's width or height are 0. This works around that problem.
+static inline void _q_adjustRect(QRectF *rect)
+{
+    Q_ASSERT(rect);
+    if (!rect->width())
+        rect->adjust(qreal(-0.00001), 0, qreal(0.00001), 0);
+    if (!rect->height())
+        rect->adjust(0, qreal(-0.00001), 0, qreal(0.00001));
+}
+
+static inline QRectF adjustedItemBoundingRect(const QGraphicsItem *item)
+{
+    Q_ASSERT(item);
+    QRectF boundingRect(item->boundingRect());
+    _q_adjustRect(&boundingRect);
+    return boundingRect;
+}
+
+static inline QRectF adjustedItemEffectiveBoundingRect(const QGraphicsItem *item)
+{
+    Q_ASSERT(item);
+    QRectF boundingRect(QGraphicsItemPrivate::get(item)->effectiveBoundingRect());
+    _q_adjustRect(&boundingRect);
+    return boundingRect;
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_GRAPHICSVIEW
+
+#endif
diff --git a/.pc/inendi.patch/src/widgets/styles/qcommonstyle.cpp b/.pc/inendi.patch/src/widgets/styles/qcommonstyle.cpp
new file mode 100644
index 0000000..27fef46
--- /dev/null
+++ b/.pc/inendi.patch/src/widgets/styles/qcommonstyle.cpp
@@ -0,0 +1,6151 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtWidgets module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qcommonstyle.h"
+#include "qcommonstyle_p.h"
+
+#include <qfile.h>
+#include <qapplication.h>
+#include <private/qguiapplication_p.h>
+#include <qpa/qplatformtheme.h>
+#include <qbitmap.h>
+#include <qcache.h>
+#include <qdockwidget.h>
+#include <qdrawutil.h>
+#include <qdialogbuttonbox.h>
+#include <qformlayout.h>
+#include <qgroupbox.h>
+#include <qmath.h>
+#include <qmenu.h>
+#include <qpainter.h>
+#include <qpaintengine.h>
+#include <qpainterpath.h>
+#include <qslider.h>
+#include <qstyleoption.h>
+#include <qtabbar.h>
+#include <qtabwidget.h>
+#include <qtoolbar.h>
+#include <qtoolbutton.h>
+#include <qrubberband.h>
+#include "qtreeview.h"
+#include <private/qcommonstylepixmaps_p.h>
+#include <private/qmath_p.h>
+#include <qdebug.h>
+#include <qtextformat.h>
+#include <qwizard.h>
+#include <qfileinfo.h>
+#include <qdir.h>
+#include <qsettings.h>
+#include <qvariant.h>
+#include <qpixmapcache.h>
+#include <private/qstyleanimation_p.h>
+
+#include <limits.h>
+
+#ifndef QT_NO_ITEMVIEWS
+#   include "private/qtextengine_p.h"
+#endif
+
+#include <private/qstylehelper_p.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QCommonStyle
+    \brief The QCommonStyle class encapsulates the common Look and Feel of a GUI.
+
+    \ingroup appearance
+    \inmodule QtWidgets
+
+    This abstract class implements some of the widget's look and feel
+    that is common to all GUI styles provided and shipped as part of
+    Qt.
+
+    Since QCommonStyle inherits QStyle, all of its functions are fully documented
+    in the QStyle documentation.
+    \omit
+    , although the
+    extra functions that QCommonStyle provides, e.g.
+    drawComplexControl(), drawControl(), drawPrimitive(),
+    hitTestComplexControl(), subControlRect(), sizeFromContents(), and
+    subElementRect() are documented here.
+    \endomit
+
+    \sa QStyle, QProxyStyle
+*/
+
+/*!
+    Constructs a QCommonStyle.
+*/
+QCommonStyle::QCommonStyle()
+    : QStyle(*new QCommonStylePrivate)
+{ }
+
+/*! \internal
+*/
+QCommonStyle::QCommonStyle(QCommonStylePrivate &dd)
+    : QStyle(dd)
+{ }
+
+/*!
+    Destroys the style.
+*/
+QCommonStyle::~QCommonStyle()
+{ }
+
+
+/*!
+    \reimp
+*/
+void QCommonStyle::drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
+                                 const QWidget *widget) const
+{
+    Q_D(const QCommonStyle);
+    switch (pe) {
+    case PE_FrameButtonBevel:
+    case PE_FrameButtonTool:
+        qDrawShadeRect(p, opt->rect, opt->palette,
+                       opt->state & (State_Sunken | State_On), 1, 0);
+        break;
+    case PE_PanelButtonCommand:
+    case PE_PanelButtonBevel:
+    case PE_PanelButtonTool:
+    case PE_IndicatorButtonDropDown:
+        qDrawShadePanel(p, opt->rect, opt->palette,
+                        opt->state & (State_Sunken | State_On), 1,
+                        &opt->palette.brush(QPalette::Button));
+        break;
+    case PE_IndicatorViewItemCheck:
+        proxy()->drawPrimitive(PE_IndicatorCheckBox, opt, p, widget);
+        break;
+    case PE_IndicatorCheckBox:
+        if (opt->state & State_NoChange) {
+            p->setPen(opt->palette.foreground().color());
+            p->fillRect(opt->rect, opt->palette.brush(QPalette::Button));
+            p->drawRect(opt->rect);
+            p->drawLine(opt->rect.topLeft(), opt->rect.bottomRight());
+        } else {
+            qDrawShadePanel(p, opt->rect.x(), opt->rect.y(), opt->rect.width(), opt->rect.height(),
+                            opt->palette, opt->state & (State_Sunken | State_On), 1,
+                            &opt->palette.brush(QPalette::Button));
+        }
+        break;
+    case PE_IndicatorRadioButton: {
+        QRect ir = opt->rect;
+        p->setPen(opt->palette.dark().color());
+        p->drawArc(opt->rect, 0, 5760);
+        if (opt->state & (State_Sunken | State_On)) {
+            ir.adjust(2, 2, -2, -2);
+            p->setBrush(opt->palette.foreground());
+            bool oldQt4CompatiblePainting = p->testRenderHint(QPainter::Qt4CompatiblePainting);
+            p->setRenderHint(QPainter::Qt4CompatiblePainting);
+            p->drawEllipse(ir);
+            p->setRenderHint(QPainter::Qt4CompatiblePainting, oldQt4CompatiblePainting);
+        }
+        break; }
+    case PE_FrameFocusRect:
+        if (const QStyleOptionFocusRect *fropt = qstyleoption_cast<const QStyleOptionFocusRect *>(opt)) {
+            QColor bg = fropt->backgroundColor;
+            QPen oldPen = p->pen();
+            if (bg.isValid()) {
+                int h, s, v;
+                bg.getHsv(&h, &s, &v);
+                if (v >= 128)
+                    p->setPen(Qt::black);
+                else
+                    p->setPen(Qt::white);
+            } else {
+                p->setPen(opt->palette.foreground().color());
+            }
+            QRect focusRect = opt->rect.adjusted(1, 1, -1, -1);
+            p->drawRect(focusRect.adjusted(0, 0, -1, -1)); //draw pen inclusive
+            p->setPen(oldPen);
+        }
+        break;
+    case PE_IndicatorMenuCheckMark: {
+        const int markW = opt->rect.width() > 7 ? 7 : opt->rect.width();
+        const int markH = markW;
+        int posX = opt->rect.x() + (opt->rect.width() - markW)/2 + 1;
+        int posY = opt->rect.y() + (opt->rect.height() - markH)/2;
+
+        QVector<QLineF> a;
+        a.reserve(markH);
+
+        int i, xx, yy;
+        xx = posX;
+        yy = 3 + posY;
+        for (i = 0; i < markW/2; ++i) {
+            a << QLineF(xx, yy, xx, yy + 2);
+            ++xx;
+            ++yy;
+        }
+        yy -= 2;
+        for (; i < markH; ++i) {
+            a << QLineF(xx, yy, xx, yy + 2);
+            ++xx;
+            --yy;
+        }
+        if (!(opt->state & State_Enabled) && !(opt->state & State_On)) {
+            p->save();
+            p->translate(1, 1);
+            p->setPen(opt->palette.light().color());
+            p->drawLines(a);
+            p->restore();
+        }
+        p->setPen((opt->state & State_On) ? opt->palette.highlightedText().color() : opt->palette.text().color());
+        p->drawLines(a);
+        break; }
+    case PE_Frame:
+    case PE_FrameMenu:
+        if (const QStyleOptionFrame *frame = qstyleoption_cast<const QStyleOptionFrame *>(opt)) {
+            if (pe == PE_FrameMenu || (frame->state & State_Sunken) || (frame->state & State_Raised)) {
+                qDrawShadePanel(p, frame->rect, frame->palette, frame->state & State_Sunken,
+                                frame->lineWidth);
+            } else {
+                qDrawPlainRect(p, frame->rect, frame->palette.foreground().color(), frame->lineWidth);
+            }
+        }
+        break;
+#ifndef QT_NO_TOOLBAR
+    case PE_PanelMenuBar:
+        if (widget && qobject_cast<QToolBar *>(widget->parentWidget()))
+            break;
+        if (const QStyleOptionFrame *frame = qstyleoption_cast<const QStyleOptionFrame *>(opt)){
+            qDrawShadePanel(p, frame->rect, frame->palette, false, frame->lineWidth,
+                            &frame->palette.brush(QPalette::Button));
+
+        }
+        else if (const QStyleOptionToolBar *frame = qstyleoption_cast<const QStyleOptionToolBar *>(opt)){
+            qDrawShadePanel(p, frame->rect, frame->palette, false, frame->lineWidth,
+                            &frame->palette.brush(QPalette::Button));
+        }
+
+        break;
+   case PE_PanelMenu:
+        break;
+    case PE_PanelToolBar:
+       break;
+#endif // QT_NO_TOOLBAR
+#ifndef QT_NO_PROGRESSBAR
+    case PE_IndicatorProgressChunk:
+        {
+            bool vertical = false;
+            if (const QStyleOptionProgressBarV2 *pb2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(opt))
+                vertical = (pb2->orientation == Qt::Vertical);
+            if (!vertical) {
+                p->fillRect(opt->rect.x(), opt->rect.y() + 3, opt->rect.width() -2, opt->rect.height() - 6,
+                            opt->palette.brush(QPalette::Highlight));
+            } else {
+                p->fillRect(opt->rect.x() + 2, opt->rect.y(), opt->rect.width() -6, opt->rect.height() - 2,
+                            opt->palette.brush(QPalette::Highlight));
+            }
+        }
+        break;
+#endif // QT_NO_PROGRESSBAR
+    case PE_IndicatorBranch: {
+        static const int decoration_size = 9;
+        int mid_h = opt->rect.x() + opt->rect.width() / 2;
+        int mid_v = opt->rect.y() + opt->rect.height() / 2;
+        int bef_h = mid_h;
+        int bef_v = mid_v;
+        int aft_h = mid_h;
+        int aft_v = mid_v;
+        if (opt->state & State_Children) {
+            int delta = decoration_size / 2;
+            bef_h -= delta;
+            bef_v -= delta;
+            aft_h += delta;
+            aft_v += delta;
+            p->drawLine(bef_h + 2, bef_v + 4, bef_h + 6, bef_v + 4);
+            if (!(opt->state & State_Open))
+                p->drawLine(bef_h + 4, bef_v + 2, bef_h + 4, bef_v + 6);
+            QPen oldPen = p->pen();
+            p->setPen(opt->palette.dark().color());
+            p->drawRect(bef_h, bef_v, decoration_size - 1, decoration_size - 1);
+            p->setPen(oldPen);
+        }
+        QBrush brush(opt->palette.dark().color(), Qt::Dense4Pattern);
+        if (opt->state & State_Item) {
+            if (opt->direction == Qt::RightToLeft)
+                p->fillRect(opt->rect.left(), mid_v, bef_h - opt->rect.left(), 1, brush);
+            else
+                p->fillRect(aft_h, mid_v, opt->rect.right() - aft_h + 1, 1, brush);
+        }
+        if (opt->state & State_Sibling)
+            p->fillRect(mid_h, aft_v, 1, opt->rect.bottom() - aft_v + 1, brush);
+        if (opt->state & (State_Open | State_Children | State_Item | State_Sibling))
+            p->fillRect(mid_h, opt->rect.y(), 1, bef_v - opt->rect.y(), brush);
+        break; }
+    case PE_FrameStatusBarItem:
+        qDrawShadeRect(p, opt->rect, opt->palette, true, 1, 0, 0);
+        break;
+    case PE_IndicatorHeaderArrow:
+        if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(opt)) {
+            QPen oldPen = p->pen();
+            if (header->sortIndicator & QStyleOptionHeader::SortUp) {
+                QPolygon pa(3);
+                p->setPen(QPen(opt->palette.light(), 0));
+                p->drawLine(opt->rect.x() + opt->rect.width(), opt->rect.y(),
+                            opt->rect.x() + opt->rect.width() / 2, opt->rect.y() + opt->rect.height());
+                p->setPen(QPen(opt->palette.dark(), 0));
+                pa.setPoint(0, opt->rect.x() + opt->rect.width() / 2, opt->rect.y() + opt->rect.height());
+                pa.setPoint(1, opt->rect.x(), opt->rect.y());
+                pa.setPoint(2, opt->rect.x() + opt->rect.width(), opt->rect.y());
+                p->drawPolyline(pa);
+            } else if (header->sortIndicator & QStyleOptionHeader::SortDown) {
+                QPolygon pa(3);
+                p->setPen(QPen(opt->palette.light(), 0));
+                pa.setPoint(0, opt->rect.x(), opt->rect.y() + opt->rect.height());
+                pa.setPoint(1, opt->rect.x() + opt->rect.width(), opt->rect.y() + opt->rect.height());
+                pa.setPoint(2, opt->rect.x() + opt->rect.width() / 2, opt->rect.y());
+                p->drawPolyline(pa);
+                p->setPen(QPen(opt->palette.dark(), 0));
+                p->drawLine(opt->rect.x(), opt->rect.y() + opt->rect.height(),
+                            opt->rect.x() + opt->rect.width() / 2, opt->rect.y());
+            }
+            p->setPen(oldPen);
+        }
+        break;
+#ifndef QT_NO_TABBAR
+    case PE_FrameTabBarBase:
+        if (const QStyleOptionTabBarBase *tbb
+                = qstyleoption_cast<const QStyleOptionTabBarBase *>(opt)) {
+            p->save();
+            switch (tbb->shape) {
+            case QTabBar::RoundedNorth:
+            case QTabBar::TriangularNorth:
+                p->setPen(QPen(tbb->palette.light(), 0));
+                p->drawLine(tbb->rect.topLeft(), tbb->rect.topRight());
+                break;
+            case QTabBar::RoundedWest:
+            case QTabBar::TriangularWest:
+                p->setPen(QPen(tbb->palette.light(), 0));
+                p->drawLine(tbb->rect.topLeft(), tbb->rect.bottomLeft());
+                break;
+            case QTabBar::RoundedSouth:
+            case QTabBar::TriangularSouth:
+                p->setPen(QPen(tbb->palette.shadow(), 0));
+                p->drawLine(tbb->rect.left(), tbb->rect.bottom(),
+                            tbb->rect.right(), tbb->rect.bottom());
+                p->setPen(QPen(tbb->palette.dark(), 0));
+                p->drawLine(tbb->rect.left(), tbb->rect.bottom() - 1,
+                            tbb->rect.right() - 1, tbb->rect.bottom() - 1);
+                break;
+            case QTabBar::RoundedEast:
+            case QTabBar::TriangularEast:
+                p->setPen(QPen(tbb->palette.dark(), 0));
+                p->drawLine(tbb->rect.topRight(), tbb->rect.bottomRight());
+                break;
+            }
+            p->restore();
+        }
+        break;
+    case PE_IndicatorTabClose: {
+        if (d->tabBarcloseButtonIcon.isNull()) {
+            d->tabBarcloseButtonIcon.addPixmap(QPixmap(
+                        QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-closetab-16.png")),
+                        QIcon::Normal, QIcon::Off);
+            d->tabBarcloseButtonIcon.addPixmap(QPixmap(
+                        QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-closetab-down-16.png")),
+                        QIcon::Normal, QIcon::On);
+            d->tabBarcloseButtonIcon.addPixmap(QPixmap(
+                        QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-closetab-hover-16.png")),
+                        QIcon::Active, QIcon::Off);
+        }
+
+        int size = proxy()->pixelMetric(QStyle::PM_SmallIconSize);
+        QIcon::Mode mode = opt->state & State_Enabled ?
+                            (opt->state & State_Raised ? QIcon::Active : QIcon::Normal)
+                            : QIcon::Disabled;
+        if (!(opt->state & State_Raised)
+            && !(opt->state & State_Sunken)
+            && !(opt->state & QStyle::State_Selected))
+            mode = QIcon::Disabled;
+
+        QIcon::State state = opt->state & State_Sunken ? QIcon::On : QIcon::Off;
+        QPixmap pixmap = d->tabBarcloseButtonIcon.pixmap(size, mode, state);
+        proxy()->drawItemPixmap(p, opt->rect, Qt::AlignCenter, pixmap);
+        break;
+    }
+#endif // QT_NO_TABBAR
+    case PE_FrameTabWidget:
+    case PE_FrameWindow:
+        qDrawWinPanel(p, opt->rect, opt->palette, false, 0);
+        break;
+    case PE_FrameLineEdit:
+        proxy()->drawPrimitive(PE_Frame, opt, p, widget);
+        break;
+#ifndef QT_NO_GROUPBOX
+    case PE_FrameGroupBox:
+        if (const QStyleOptionFrame *frame = qstyleoption_cast<const QStyleOptionFrame *>(opt)) {
+            const QStyleOptionFrameV2 *frame2 = qstyleoption_cast<const QStyleOptionFrameV2 *>(opt);
+            if (frame2 && (frame2->features & QStyleOptionFrameV2::Flat)) {
+                QRect fr = frame->rect;
+                QPoint p1(fr.x(), fr.y() + 1);
+                QPoint p2(fr.x() + fr.width(), p1.y());
+                qDrawShadeLine(p, p1, p2, frame->palette, true,
+                               frame->lineWidth, frame->midLineWidth);
+            } else {
+                qDrawShadeRect(p, frame->rect.x(), frame->rect.y(), frame->rect.width(),
+                               frame->rect.height(), frame->palette, true,
+                               frame->lineWidth, frame->midLineWidth);
+            }
+        }
+        break;
+#endif // QT_NO_GROUPBOX
+#ifndef QT_NO_DOCKWIDGET
+    case PE_FrameDockWidget:
+        if (const QStyleOptionFrame *frame = qstyleoption_cast<const QStyleOptionFrame *>(opt)) {
+            int lw = frame->lineWidth;
+            if (lw <= 0)
+                lw = proxy()->pixelMetric(PM_DockWidgetFrameWidth);
+
+            qDrawShadePanel(p, frame->rect, frame->palette, false, lw);
+        }
+        break;
+#endif // QT_NO_DOCKWIDGET
+#ifndef QT_NO_TOOLBAR
+    case PE_IndicatorToolBarHandle:
+        p->save();
+        p->translate(opt->rect.x(), opt->rect.y());
+        if (opt->state & State_Horizontal) {
+            int x = opt->rect.width() / 3;
+            if (opt->direction == Qt::RightToLeft)
+                x -= 2;
+            if (opt->rect.height() > 4) {
+                qDrawShadePanel(p, x, 2, 3, opt->rect.height() - 4,
+                                opt->palette, false, 1, 0);
+                qDrawShadePanel(p, x+3, 2, 3, opt->rect.height() - 4,
+                                opt->palette, false, 1, 0);
+            }
+        } else {
+            if (opt->rect.width() > 4) {
+                int y = opt->rect.height() / 3;
+                qDrawShadePanel(p, 2, y, opt->rect.width() - 4, 3,
+                                opt->palette, false, 1, 0);
+                qDrawShadePanel(p, 2, y+3, opt->rect.width() - 4, 3,
+                                opt->palette, false, 1, 0);
+            }
+        }
+        p->restore();
+        break;
+    case PE_IndicatorToolBarSeparator:
+        {
+            QPoint p1, p2;
+            if (opt->state & State_Horizontal) {
+                p1 = QPoint(opt->rect.width()/2, 0);
+                p2 = QPoint(p1.x(), opt->rect.height());
+            } else {
+                p1 = QPoint(0, opt->rect.height()/2);
+                p2 = QPoint(opt->rect.width(), p1.y());
+            }
+            qDrawShadeLine(p, p1, p2, opt->palette, 1, 1, 0);
+            break;
+        }
+#endif // QT_NO_TOOLBAR
+#ifndef QT_NO_SPINBOX
+    case PE_IndicatorSpinPlus:
+    case PE_IndicatorSpinMinus: {
+        QRect r = opt->rect;
+        int fw = proxy()->pixelMetric(PM_DefaultFrameWidth, opt, widget);
+        QRect br = r.adjusted(fw, fw, -fw, -fw);
+
+        int offset = (opt->state & State_Sunken) ? 1 : 0;
+        int step = (br.width() + 4) / 5;
+        p->fillRect(br.x() + offset, br.y() + offset +br.height() / 2 - step / 2,
+                    br.width(), step,
+                    opt->palette.buttonText());
+        if (pe == PE_IndicatorSpinPlus)
+            p->fillRect(br.x() + br.width() / 2 - step / 2 + offset, br.y() + offset,
+                        step, br.height(),
+                        opt->palette.buttonText());
+
+        break; }
+    case PE_IndicatorSpinUp:
+    case PE_IndicatorSpinDown: {
+        QRect r = opt->rect;
+        int fw = proxy()->pixelMetric(PM_DefaultFrameWidth, opt, widget);
+        // QRect br = r.adjusted(fw, fw, -fw, -fw);
+        int x = r.x(), y = r.y(), w = r.width(), h = r.height();
+        int sw = w-4;
+        if (sw < 3)
+            break;
+        else if (!(sw & 1))
+            sw--;
+        sw -= (sw / 7) * 2;        // Empty border
+        int sh = sw/2 + 2;      // Must have empty row at foot of arrow
+
+        int sx = x + w / 2 - sw / 2;
+        int sy = y + h / 2 - sh / 2;
+
+        if (pe == PE_IndicatorSpinUp && fw)
+            --sy;
+
+        QPolygon a;
+        if (pe == PE_IndicatorSpinDown)
+            a.setPoints(3, 0, 1,  sw-1, 1,  sh-2, sh-1);
+        else
+            a.setPoints(3, 0, sh-1,  sw-1, sh-1,  sh-2, 1);
+        int bsx = 0;
+        int bsy = 0;
+        if (opt->state & State_Sunken) {
+            bsx = proxy()->pixelMetric(PM_ButtonShiftHorizontal);
+            bsy = proxy()->pixelMetric(PM_ButtonShiftVertical);
+        }
+        p->save();
+        p->translate(sx + bsx, sy + bsy);
+        p->setPen(opt->palette.buttonText().color());
+        p->setBrush(opt->palette.buttonText());
+        p->setRenderHint(QPainter::Qt4CompatiblePainting);
+        p->drawPolygon(a);
+        p->restore();
+        break; }
+#endif // QT_NO_SPINBOX
+    case PE_PanelTipLabel: {
+        QBrush oldBrush = p->brush();
+        QPen oldPen = p->pen();
+        p->setPen(QPen(opt->palette.toolTipText(), 0));
+        p->setBrush(opt->palette.toolTipBase());
+        p->drawRect(opt->rect.adjusted(0, 0, -1, -1));
+        p->setPen(oldPen);
+        p->setBrush(oldBrush);
+        break;
+    }
+#ifndef QT_NO_TABBAR
+    case PE_IndicatorTabTear:
+        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(opt)) {
+            bool rtl = tab->direction == Qt::RightToLeft;
+            QRect rect = tab->rect;
+            QPainterPath path;
+
+            rect.setTop(rect.top() + ((tab->state & State_Selected) ? 1 : 3));
+            rect.setBottom(rect.bottom() - ((tab->state & State_Selected) ? 0 : 2));
+
+            path.moveTo(QPoint(rtl ? rect.right() : rect.left(), rect.top()));
+            int count = 4;
+            for(int jags = 1; jags <= count; ++jags, rtl = !rtl)
+                path.lineTo(QPoint(rtl ? rect.left() : rect.right(), rect.top() + jags * rect.height()/count));
+
+            p->setPen(QPen(tab->palette.light(), qreal(.8)));
+            p->setBrush(tab->palette.background());
+            p->setRenderHint(QPainter::Antialiasing);
+            p->drawPath(path);
+        }
+        break;
+#endif // QT_NO_TABBAR
+#ifndef QT_NO_LINEEDIT
+    case PE_PanelLineEdit:
+        if (const QStyleOptionFrame *panel = qstyleoption_cast<const QStyleOptionFrame *>(opt)) {
+            p->fillRect(panel->rect.adjusted(panel->lineWidth, panel->lineWidth, -panel->lineWidth, -panel->lineWidth),
+                        panel->palette.brush(QPalette::Base));
+
+            if (panel->lineWidth > 0)
+                proxy()->drawPrimitive(PE_FrameLineEdit, panel, p, widget);
+        }
+        break;
+#endif // QT_NO_LINEEDIT
+#ifndef QT_NO_COLUMNVIEW
+    case PE_IndicatorColumnViewArrow: {
+    if (const QStyleOptionViewItem *viewOpt = qstyleoption_cast<const QStyleOptionViewItem *>(opt)) {
+        bool reverse = (viewOpt->direction == Qt::RightToLeft);
+        p->save();
+        QPainterPath path;
+        int x = viewOpt->rect.x() + 1;
+        int offset = (viewOpt->rect.height() / 3);
+        int height = (viewOpt->rect.height()) - offset * 2;
+        if (height % 2 == 1)
+            --height;
+        int x2 = x + height - 1;
+        if (reverse) {
+            x = viewOpt->rect.x() + viewOpt->rect.width() - 1;
+            x2 = x - height + 1;
+        }
+        path.moveTo(x, viewOpt->rect.y() + offset);
+        path.lineTo(x, viewOpt->rect.y() + offset + height);
+        path.lineTo(x2, viewOpt->rect.y() + offset+height/2);
+        path.closeSubpath();
+        if (viewOpt->state & QStyle::State_Selected ) {
+            if (viewOpt->showDecorationSelected) {
+                QColor color = viewOpt->palette.color(QPalette::Active, QPalette::HighlightedText);
+                p->setPen(color);
+                p->setBrush(color);
+            } else {
+                QColor color = viewOpt->palette.color(QPalette::Active, QPalette::WindowText);
+                p->setPen(color);
+                p->setBrush(color);
+            }
+
+        } else {
+            QColor color = viewOpt->palette.color(QPalette::Active, QPalette::Mid);
+            p->setPen(color);
+            p->setBrush(color);
+        }
+        p->drawPath(path);
+
+        // draw the vertical and top triangle line
+        if (!(viewOpt->state & QStyle::State_Selected)) {
+            QPainterPath lines;
+            lines.moveTo(x, viewOpt->rect.y() + offset);
+            lines.lineTo(x, viewOpt->rect.y() + offset + height);
+            lines.moveTo(x, viewOpt->rect.y() + offset);
+            lines.lineTo(x2, viewOpt->rect.y() + offset+height/2);
+            QColor color = viewOpt->palette.color(QPalette::Active, QPalette::Dark);
+            p->setPen(color);
+            p->drawPath(lines);
+        }
+        p->restore();
+    }
+    break; }
+#endif //QT_NO_COLUMNVIEW
+    case PE_IndicatorItemViewItemDrop: {
+        QRect rect = opt->rect;
+        if (opt->rect.height() == 0)
+            p->drawLine(rect.topLeft(), rect.topRight());
+        else
+            p->drawRect(rect);
+        break; }
+#ifndef QT_NO_ITEMVIEWS
+    case PE_PanelItemViewRow:
+        if (const QStyleOptionViewItem *vopt = qstyleoption_cast<const QStyleOptionViewItem *>(opt)) {
+            QPalette::ColorGroup cg = (widget ? widget->isEnabled() : (vopt->state & QStyle::State_Enabled))
+                                      ? QPalette::Normal : QPalette::Disabled;
+            if (cg == QPalette::Normal && !(vopt->state & QStyle::State_Active))
+                cg = QPalette::Inactive;
+
+            if ((vopt->state & QStyle::State_Selected) &&  proxy()->styleHint(QStyle::SH_ItemView_ShowDecorationSelected, opt, widget))
+                p->fillRect(vopt->rect, vopt->palette.brush(cg, QPalette::Highlight));
+            else if (vopt->features & QStyleOptionViewItem::Alternate)
+                p->fillRect(vopt->rect, vopt->palette.brush(cg, QPalette::AlternateBase));
+        }
+        break;
+    case PE_PanelItemViewItem:
+        if (const QStyleOptionViewItem *vopt = qstyleoption_cast<const QStyleOptionViewItem *>(opt)) {
+            QPalette::ColorGroup cg = (widget ? widget->isEnabled() : (vopt->state & QStyle::State_Enabled))
+                                      ? QPalette::Normal : QPalette::Disabled;
+            if (cg == QPalette::Normal && !(vopt->state & QStyle::State_Active))
+                cg = QPalette::Inactive;
+
+            if (vopt->showDecorationSelected && (vopt->state & QStyle::State_Selected)) {
+                p->fillRect(vopt->rect, vopt->palette.brush(cg, QPalette::Highlight));
+            } else {
+                if (vopt->backgroundBrush.style() != Qt::NoBrush) {
+                    QPointF oldBO = p->brushOrigin();
+                    p->setBrushOrigin(vopt->rect.topLeft());
+                    p->fillRect(vopt->rect, vopt->backgroundBrush);
+                    p->setBrushOrigin(oldBO);
+                }
+
+                if (vopt->state & QStyle::State_Selected) {
+                    QRect textRect = subElementRect(QStyle::SE_ItemViewItemText,  opt, widget);
+                    p->fillRect(textRect, vopt->palette.brush(cg, QPalette::Highlight));
+                }
+            }
+        }
+        break;
+#endif //QT_NO_ITEMVIEWS
+    case PE_PanelScrollAreaCorner: {
+        const QBrush brush(opt->palette.brush(QPalette::Window));
+        p->fillRect(opt->rect, brush);
+        } break;
+    case PE_IndicatorArrowUp:
+    case PE_IndicatorArrowDown:
+    case PE_IndicatorArrowRight:
+    case PE_IndicatorArrowLeft:
+        {
+            if (opt->rect.width() <= 1 || opt->rect.height() <= 1)
+                break;
+            QRect r = opt->rect;
+            int size = qMin(r.height(), r.width());
+            QPixmap pixmap;
+            QString pixmapName = QStyleHelper::uniqueName(QLatin1String("$qt_ia-")
+                                                          % QLatin1String(metaObject()->className()), opt, QSize(size, size))
+                                 % HexString<uint>(pe);
+            if (!QPixmapCache::find(pixmapName, pixmap)) {
+                int border = size/5;
+                int sqsize = 2*(size/2);
+                QImage image(sqsize, sqsize, QImage::Format_ARGB32_Premultiplied);
+                image.fill(0);
+                QPainter imagePainter(&image);
+
+                QPolygon a;
+                switch (pe) {
+                    case PE_IndicatorArrowUp:
+                        a.setPoints(3, border, sqsize/2,  sqsize/2, border,  sqsize - border, sqsize/2);
+                        break;
+                    case PE_IndicatorArrowDown:
+                        a.setPoints(3, border, sqsize/2,  sqsize/2, sqsize - border,  sqsize - border, sqsize/2);
+                        break;
+                    case PE_IndicatorArrowRight:
+                        a.setPoints(3, sqsize - border, sqsize/2,  sqsize/2, border,  sqsize/2, sqsize - border);
+                        break;
+                    case PE_IndicatorArrowLeft:
+                        a.setPoints(3, border, sqsize/2,  sqsize/2, border,  sqsize/2, sqsize - border);
+                        break;
+                    default:
+                        break;
+                }
+
+                int bsx = 0;
+                int bsy = 0;
+
+                if (opt->state & State_Sunken) {
+                    bsx = proxy()->pixelMetric(PM_ButtonShiftHorizontal, opt, widget);
+                    bsy = proxy()->pixelMetric(PM_ButtonShiftVertical, opt, widget);
+                }
+
+                QRect bounds = a.boundingRect();
+                int sx = sqsize / 2 - bounds.center().x() - 1;
+                int sy = sqsize / 2 - bounds.center().y() - 1;
+                imagePainter.translate(sx + bsx, sy + bsy);
+                imagePainter.setPen(opt->palette.buttonText().color());
+                imagePainter.setBrush(opt->palette.buttonText());
+                imagePainter.setRenderHint(QPainter::Qt4CompatiblePainting);
+
+                if (!(opt->state & State_Enabled)) {
+                    imagePainter.translate(1, 1);
+                    imagePainter.setBrush(opt->palette.light().color());
+                    imagePainter.setPen(opt->palette.light().color());
+                    imagePainter.drawPolygon(a);
+                    imagePainter.translate(-1, -1);
+                    imagePainter.setBrush(opt->palette.mid().color());
+                    imagePainter.setPen(opt->palette.mid().color());
+                }
+
+                imagePainter.drawPolygon(a);
+                imagePainter.end();
+                pixmap = QPixmap::fromImage(image);
+                QPixmapCache::insert(pixmapName, pixmap);
+            }
+            int xOffset = r.x() + (r.width() - size)/2;
+            int yOffset = r.y() + (r.height() - size)/2;
+            p->drawPixmap(xOffset, yOffset, pixmap);
+        }
+        break;
+    default:
+        break;
+    }
+}
+
+#ifndef QT_NO_TOOLBUTTON
+static void drawArrow(const QStyle *style, const QStyleOptionToolButton *toolbutton,
+                      const QRect &rect, QPainter *painter, const QWidget *widget = 0)
+{
+    QStyle::PrimitiveElement pe;
+    switch (toolbutton->arrowType) {
+    case Qt::LeftArrow:
+        pe = QStyle::PE_IndicatorArrowLeft;
+        break;
+    case Qt::RightArrow:
+        pe = QStyle::PE_IndicatorArrowRight;
+        break;
+    case Qt::UpArrow:
+        pe = QStyle::PE_IndicatorArrowUp;
+        break;
+    case Qt::DownArrow:
+        pe = QStyle::PE_IndicatorArrowDown;
+        break;
+    default:
+        return;
+    }
+    QStyleOption arrowOpt;
+    arrowOpt.rect = rect;
+    arrowOpt.palette = toolbutton->palette;
+    arrowOpt.state = toolbutton->state;
+    style->drawPrimitive(pe, &arrowOpt, painter, widget);
+}
+#endif // QT_NO_TOOLBUTTON
+
+#ifndef QT_NO_ITEMVIEWS
+
+static QSizeF viewItemTextLayout(QTextLayout &textLayout, int lineWidth)
+{
+    qreal height = 0;
+    qreal widthUsed = 0;
+    textLayout.beginLayout();
+    while (true) {
+        QTextLine line = textLayout.createLine();
+        if (!line.isValid())
+            break;
+        line.setLineWidth(lineWidth);
+        line.setPosition(QPointF(0, height));
+        height += line.height();
+        widthUsed = qMax(widthUsed, line.naturalTextWidth());
+    }
+    textLayout.endLayout();
+    return QSizeF(widthUsed, height);
+}
+
+QSize QCommonStylePrivate::viewItemSize(const QStyleOptionViewItem *option, int role) const
+{
+    const QWidget *widget = option->widget;
+    switch (role) {
+    case Qt::CheckStateRole:
+        if (option->features & QStyleOptionViewItem::HasCheckIndicator)
+            return QSize(proxyStyle->pixelMetric(QStyle::PM_IndicatorWidth, option, widget),
+                         proxyStyle->pixelMetric(QStyle::PM_IndicatorHeight, option, widget));
+        break;
+    case Qt::DisplayRole:
+        if (option->features & QStyleOptionViewItem::HasDisplay) {
+            QTextOption textOption;
+            textOption.setWrapMode(QTextOption::WordWrap);
+            QTextLayout textLayout(option->text, option->font);
+            textLayout.setTextOption(textOption);
+            const bool wrapText = option->features & QStyleOptionViewItem::WrapText;
+            const int textMargin = proxyStyle->pixelMetric(QStyle::PM_FocusFrameHMargin, option, widget) + 1;
+            QRect bounds = option->rect;
+            switch (option->decorationPosition) {
+            case QStyleOptionViewItem::Left:
+            case QStyleOptionViewItem::Right:
+                bounds.setWidth(wrapText && bounds.isValid() ? bounds.width() - 2 * textMargin : QFIXED_MAX);
+                break;
+            case QStyleOptionViewItem::Top:
+            case QStyleOptionViewItem::Bottom:
+                if (wrapText)
+                    bounds.setWidth(bounds.isValid() ? bounds.width() - 2 * textMargin : option->decorationSize.width());
+                else
+                    bounds.setWidth(QFIXED_MAX);
+                break;
+            default:
+                break;
+            }
+
+            const int lineWidth = bounds.width();
+            const QSizeF size = viewItemTextLayout(textLayout, lineWidth);
+            return QSize(qCeil(size.width()) + 2 * textMargin, qCeil(size.height()));
+        }
+        break;
+    case Qt::DecorationRole:
+        if (option->features & QStyleOptionViewItem::HasDecoration) {
+            return option->decorationSize;
+        }
+        break;
+    default:
+        break;
+    }
+
+    return QSize(0, 0);
+}
+
+void QCommonStylePrivate::viewItemDrawText(QPainter *p, const QStyleOptionViewItem *option, const QRect &rect) const
+{
+    const QWidget *widget = option->widget;
+    const int textMargin = proxyStyle->pixelMetric(QStyle::PM_FocusFrameHMargin, 0, widget) + 1;
+
+    QRect textRect = rect.adjusted(textMargin, 0, -textMargin, 0); // remove width padding
+    const bool wrapText = option->features & QStyleOptionViewItem::WrapText;
+    QTextOption textOption;
+    textOption.setWrapMode(wrapText ? QTextOption::WordWrap : QTextOption::ManualWrap);
+    textOption.setTextDirection(option->direction);
+    textOption.setAlignment(QStyle::visualAlignment(option->direction, option->displayAlignment));
+    QTextLayout textLayout(option->text, option->font);
+    textLayout.setTextOption(textOption);
+
+    viewItemTextLayout(textLayout, textRect.width());
+
+    QString elidedText;
+    qreal height = 0;
+    qreal width = 0;
+    int elidedIndex = -1;
+    const int lineCount = textLayout.lineCount();
+    for (int j = 0; j < lineCount; ++j) {
+        const QTextLine line = textLayout.lineAt(j);
+        if (j + 1 <= lineCount - 1) {
+            const QTextLine nextLine = textLayout.lineAt(j + 1);
+            if ((nextLine.y() + nextLine.height()) > textRect.height()) {
+                int start = line.textStart();
+                int length = line.textLength() + nextLine.textLength();
+                const QStackTextEngine engine(textLayout.text().mid(start, length), option->font);
+                elidedText = engine.elidedText(option->textElideMode, textRect.width());
+                height += line.height();
+                width = textRect.width();
+                elidedIndex = j;
+                break;
+            }
+        }
+        if (line.naturalTextWidth() > textRect.width()) {
+            int start = line.textStart();
+            int length = line.textLength();
+            const QStackTextEngine engine(textLayout.text().mid(start, length), option->font);
+            elidedText = engine.elidedText(option->textElideMode, textRect.width());
+            height += line.height();
+            width = textRect.width();
+            elidedIndex = j;
+            break;
+        }
+        width = qMax<qreal>(width, line.width());
+        height += line.height();
+    }
+
+    const QRect layoutRect = QStyle::alignedRect(option->direction, option->displayAlignment,
+                                                 QSize(int(width), int(height)), textRect);
+    const QPointF position = layoutRect.topLeft();
+    for (int i = 0; i < lineCount; ++i) {
+        const QTextLine line = textLayout.lineAt(i);
+        if (i == elidedIndex) {
+            qreal x = position.x() + line.x();
+            qreal y = position.y() + line.y() + line.ascent();
+            p->save();
+            p->setFont(option->font);
+            p->drawText(QPointF(x, y), elidedText);
+            p->restore();
+            break;
+        }
+        line.draw(p, position);
+    }
+}
+
+/*! \internal
+    compute the position for the different component of an item (pixmap, text, checkbox)
+
+    Set sizehint to false to layout the elements inside opt->rect. Set sizehint to true to ignore
+   opt->rect and return rectangles in infinite space
+
+    Code duplicated in QItemDelegate::doLayout
+*/
+void QCommonStylePrivate::viewItemLayout(const QStyleOptionViewItem *opt,  QRect *checkRect,
+                                         QRect *pixmapRect, QRect *textRect, bool sizehint) const
+{
+    Q_ASSERT(checkRect && pixmapRect && textRect);
+    *pixmapRect = QRect(QPoint(0, 0), viewItemSize(opt, Qt::DecorationRole));
+    *textRect = QRect(QPoint(0, 0), viewItemSize(opt, Qt::DisplayRole));
+    *checkRect = QRect(QPoint(0, 0), viewItemSize(opt, Qt::CheckStateRole));
+
+    const QWidget *widget = opt->widget;
+    const bool hasCheck = checkRect->isValid();
+    const bool hasPixmap = pixmapRect->isValid();
+    const bool hasText = textRect->isValid();
+    const int textMargin = hasText ? proxyStyle->pixelMetric(QStyle::PM_FocusFrameHMargin, opt, widget) + 1 : 0;
+    const int pixmapMargin = hasPixmap ? proxyStyle->pixelMetric(QStyle::PM_FocusFrameHMargin, opt, widget) + 1 : 0;
+    const int checkMargin = hasCheck ? proxyStyle->pixelMetric(QStyle::PM_FocusFrameHMargin, opt, widget) + 1 : 0;
+    int x = opt->rect.left();
+    int y = opt->rect.top();
+    int w, h;
+
+    if (textRect->height() == 0 && (!hasPixmap || !sizehint)) {
+        //if there is no text, we still want to have a decent height for the item sizeHint and the editor size
+        textRect->setHeight(opt->fontMetrics.height());
+    }
+
+    QSize pm(0, 0);
+    if (hasPixmap) {
+        pm = pixmapRect->size();
+        pm.rwidth() += 2 * pixmapMargin;
+    }
+    if (sizehint) {
+        h = qMax(checkRect->height(), qMax(textRect->height(), pm.height()));
+        if (opt->decorationPosition == QStyleOptionViewItem::Left
+            || opt->decorationPosition == QStyleOptionViewItem::Right) {
+            w = textRect->width() + pm.width();
+        } else {
+            w = qMax(textRect->width(), pm.width());
+        }
+    } else {
+        w = opt->rect.width();
+        h = opt->rect.height();
+    }
+
+    int cw = 0;
+    QRect check;
+    if (hasCheck) {
+        cw = checkRect->width() + 2 * checkMargin;
+        if (sizehint) w += cw;
+        if (opt->direction == Qt::RightToLeft) {
+            check.setRect(x + w - cw, y, cw, h);
+        } else {
+            check.setRect(x, y, cw, h);
+        }
+    }
+
+    QRect display;
+    QRect decoration;
+    switch (opt->decorationPosition) {
+    case QStyleOptionViewItem::Top: {
+        if (hasPixmap)
+            pm.setHeight(pm.height() + pixmapMargin); // add space
+        h = sizehint ? textRect->height() : h - pm.height();
+
+        if (opt->direction == Qt::RightToLeft) {
+            decoration.setRect(x, y, w - cw, pm.height());
+            display.setRect(x, y + pm.height(), w - cw, h);
+        } else {
+            decoration.setRect(x + cw, y, w - cw, pm.height());
+            display.setRect(x + cw, y + pm.height(), w - cw, h);
+        }
+        break; }
+    case QStyleOptionViewItem::Bottom: {
+        if (hasText)
+            textRect->setHeight(textRect->height() + textMargin); // add space
+        h = sizehint ? textRect->height() + pm.height() : h;
+
+        if (opt->direction == Qt::RightToLeft) {
+            display.setRect(x, y, w - cw, textRect->height());
+            decoration.setRect(x, y + textRect->height(), w - cw, h - textRect->height());
+        } else {
+            display.setRect(x + cw, y, w - cw, textRect->height());
+            decoration.setRect(x + cw, y + textRect->height(), w - cw, h - textRect->height());
+        }
+        break; }
+    case QStyleOptionViewItem::Left: {
+        if (opt->direction == Qt::LeftToRight) {
+            decoration.setRect(x + cw, y, pm.width(), h);
+            display.setRect(decoration.right() + 1, y, w - pm.width() - cw, h);
+        } else {
+            display.setRect(x, y, w - pm.width() - cw, h);
+            decoration.setRect(display.right() + 1, y, pm.width(), h);
+        }
+        break; }
+    case QStyleOptionViewItem::Right: {
+        if (opt->direction == Qt::LeftToRight) {
+            display.setRect(x + cw, y, w - pm.width() - cw, h);
+            decoration.setRect(display.right() + 1, y, pm.width(), h);
+        } else {
+            decoration.setRect(x, y, pm.width(), h);
+            display.setRect(decoration.right() + 1, y, w - pm.width() - cw, h);
+        }
+        break; }
+    default:
+        qWarning("doLayout: decoration position is invalid");
+        decoration = *pixmapRect;
+        break;
+    }
+
+    if (!sizehint) { // we only need to do the internal layout if we are going to paint
+        *checkRect = QStyle::alignedRect(opt->direction, Qt::AlignCenter,
+                                         checkRect->size(), check);
+        *pixmapRect = QStyle::alignedRect(opt->direction, opt->decorationAlignment,
+                                          pixmapRect->size(), decoration);
+        // the text takes up all available space, unless the decoration is not shown as selected
+        if (opt->showDecorationSelected)
+            *textRect = display;
+        else
+            *textRect = QStyle::alignedRect(opt->direction, opt->displayAlignment,
+                                            textRect->size().boundedTo(display.size()), display);
+    } else {
+        *checkRect = check;
+        *pixmapRect = decoration;
+        *textRect = display;
+    }
+}
+#endif // QT_NO_ITEMVIEWS
+
+
+#ifndef QT_NO_TABBAR
+/*! \internal
+    Compute the textRect and the pixmapRect from the opt rect
+
+    Uses the same computation than in QTabBar::tabSizeHint
+ */
+void QCommonStylePrivate::tabLayout(const QStyleOptionTabV3 *opt, const QWidget *widget, QRect *textRect, QRect *iconRect) const
+{
+    Q_ASSERT(textRect);
+    Q_ASSERT(iconRect);
+    QRect tr = opt->rect;
+    bool verticalTabs = opt->shape == QTabBar::RoundedEast
+                        || opt->shape == QTabBar::RoundedWest
+                        || opt->shape == QTabBar::TriangularEast
+                        || opt->shape == QTabBar::TriangularWest;
+    if (verticalTabs)
+        tr.setRect(0, 0, tr.height(), tr.width()); //0, 0 as we will have a translate transform
+
+    int verticalShift = proxyStyle->pixelMetric(QStyle::PM_TabBarTabShiftVertical, opt, widget);
+    int horizontalShift = proxyStyle->pixelMetric(QStyle::PM_TabBarTabShiftHorizontal, opt, widget);
+    int hpadding = proxyStyle->pixelMetric(QStyle::PM_TabBarTabHSpace, opt, widget) / 2;
+    int vpadding = proxyStyle->pixelMetric(QStyle::PM_TabBarTabVSpace, opt, widget) / 2;
+    if (opt->shape == QTabBar::RoundedSouth || opt->shape == QTabBar::TriangularSouth)
+        verticalShift = -verticalShift;
+    tr.adjust(hpadding, verticalShift - vpadding, horizontalShift - hpadding, vpadding);
+    bool selected = opt->state & QStyle::State_Selected;
+    if (selected) {
+        tr.setTop(tr.top() - verticalShift);
+        tr.setRight(tr.right() - horizontalShift);
+    }
+
+    // left widget
+    if (!opt->leftButtonSize.isEmpty()) {
+        tr.setLeft(tr.left() + 4 +
+            (verticalTabs ? opt->leftButtonSize.height() : opt->leftButtonSize.width()));
+    }
+    // right widget
+    if (!opt->rightButtonSize.isEmpty()) {
+        tr.setRight(tr.right() - 4 -
+        (verticalTabs ? opt->rightButtonSize.height() : opt->rightButtonSize.width()));
+    }
+
+    // icon
+    if (!opt->icon.isNull()) {
+        QSize iconSize = opt->iconSize;
+        if (!iconSize.isValid()) {
+            int iconExtent = proxyStyle->pixelMetric(QStyle::PM_SmallIconSize);
+            iconSize = QSize(iconExtent, iconExtent);
+        }
+        QSize tabIconSize = opt->icon.actualSize(iconSize,
+                        (opt->state & QStyle::State_Enabled) ? QIcon::Normal : QIcon::Disabled,
+                        (opt->state & QStyle::State_Selected) ? QIcon::On : QIcon::Off  );
+        // High-dpi icons do not need adjustmet; make sure tabIconSize is not larger than iconSize
+        tabIconSize = QSize(qMin(tabIconSize.width(), iconSize.width()), qMin(tabIconSize.height(), iconSize.width()));
+
+        *iconRect = QRect(tr.left(), tr.center().y() - tabIconSize.height() / 2,
+                    tabIconSize.width(), tabIconSize .height());
+        if (!verticalTabs)
+            *iconRect = proxyStyle->visualRect(opt->direction, opt->rect, *iconRect);
+        tr.setLeft(tr.left() + tabIconSize.width() + 4);
+    }
+
+    if (!verticalTabs)
+        tr = proxyStyle->visualRect(opt->direction, opt->rect, tr);
+
+    *textRect = tr;
+}
+#endif //QT_NO_TABBAR
+
+#ifndef QT_NO_ANIMATION
+/*! \internal */
+QList<const QObject*> QCommonStylePrivate::animationTargets() const
+{
+    return animations.keys();
+}
+
+/*! \internal */
+QStyleAnimation * QCommonStylePrivate::animation(const QObject *target) const
+{
+    return animations.value(target);
+}
+
+/*! \internal */
+void QCommonStylePrivate::startAnimation(QStyleAnimation *animation) const
+{
+    Q_Q(const QCommonStyle);
+    stopAnimation(animation->target());
+    q->connect(animation, SIGNAL(destroyed()), SLOT(_q_removeAnimation()), Qt::UniqueConnection);
+    animations.insert(animation->target(), animation);
+    animation->start(QAbstractAnimation::DeleteWhenStopped);
+}
+
+/*! \internal */
+void QCommonStylePrivate::stopAnimation(const QObject *target) const
+{
+    QStyleAnimation *animation = animations.take(target);
+    if (animation) {
+        animation->stop();
+        delete animation;
+    }
+}
+
+/*! \internal */
+void QCommonStylePrivate::_q_removeAnimation()
+{
+    Q_Q(QCommonStyle);
+    QObject *animation = q->sender();
+    if (animation)
+        animations.remove(animation->parent());
+}
+#endif
+
+/*!
+  \reimp
+*/
+void QCommonStyle::drawControl(ControlElement element, const QStyleOption *opt,
+                               QPainter *p, const QWidget *widget) const
+{
+    Q_D(const QCommonStyle);
+    switch (element) {
+
+    case CE_PushButton:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
+            proxy()->drawControl(CE_PushButtonBevel, btn, p, widget);
+            QStyleOptionButton subopt = *btn;
+            subopt.rect = subElementRect(SE_PushButtonContents, btn, widget);
+            proxy()->drawControl(CE_PushButtonLabel, &subopt, p, widget);
+            if (btn->state & State_HasFocus) {
+                QStyleOptionFocusRect fropt;
+                fropt.QStyleOption::operator=(*btn);
+                fropt.rect = subElementRect(SE_PushButtonFocusRect, btn, widget);
+                proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, p, widget);
+            }
+        }
+        break;
+    case CE_PushButtonBevel:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
+            QRect br = btn->rect;
+            int dbi = proxy()->pixelMetric(PM_ButtonDefaultIndicator, btn, widget);
+            if (btn->features & QStyleOptionButton::DefaultButton)
+                proxy()->drawPrimitive(PE_FrameDefaultButton, opt, p, widget);
+            if (btn->features & QStyleOptionButton::AutoDefaultButton)
+                br.setCoords(br.left() + dbi, br.top() + dbi, br.right() - dbi, br.bottom() - dbi);
+            if (!(btn->features & (QStyleOptionButton::Flat | QStyleOptionButton::CommandLinkButton))
+                || btn->state & (State_Sunken | State_On)
+                || (btn->features & QStyleOptionButton::CommandLinkButton && btn->state & State_MouseOver)) {
+                QStyleOptionButton tmpBtn = *btn;
+                tmpBtn.rect = br;
+                proxy()->drawPrimitive(PE_PanelButtonCommand, &tmpBtn, p, widget);
+            }
+            if (btn->features & QStyleOptionButton::HasMenu) {
+                int mbi = proxy()->pixelMetric(PM_MenuButtonIndicator, btn, widget);
+                QRect ir = btn->rect;
+                QStyleOptionButton newBtn = *btn;
+                newBtn.rect = QRect(ir.right() - mbi + 2, ir.height()/2 - mbi/2 + 3, mbi - 6, mbi - 6);
+                proxy()->drawPrimitive(PE_IndicatorArrowDown, &newBtn, p, widget);
+            }
+        }
+        break;
+ case CE_PushButtonLabel:
+        if (const QStyleOptionButton *button = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
+            QRect textRect = button->rect;
+            uint tf = Qt::AlignVCenter | Qt::TextShowMnemonic;
+            if (!proxy()->styleHint(SH_UnderlineShortcut, button, widget))
+                tf |= Qt::TextHideMnemonic;
+
+            if (!button->icon.isNull()) {
+                //Center both icon and text
+                QRect iconRect;
+                QIcon::Mode mode = button->state & State_Enabled ? QIcon::Normal : QIcon::Disabled;
+                if (mode == QIcon::Normal && button->state & State_HasFocus)
+                    mode = QIcon::Active;
+                QIcon::State state = QIcon::Off;
+                if (button->state & State_On)
+                    state = QIcon::On;
+
+                QPixmap pixmap = button->icon.pixmap(button->iconSize, mode, state);
+
+                int pixmapWidth = pixmap.width() / pixmap.devicePixelRatio();
+                int pixmapHeight = pixmap.height() / pixmap.devicePixelRatio();
+                int labelWidth = pixmapWidth;
+                int labelHeight = pixmapHeight;
+                int iconSpacing = 4;//### 4 is currently hardcoded in QPushButton::sizeHint()
+                int textWidth = button->fontMetrics.boundingRect(opt->rect, tf, button->text).width();
+                if (!button->text.isEmpty())
+                    labelWidth += (textWidth + iconSpacing);
+
+                iconRect = QRect(textRect.x() + (textRect.width() - labelWidth) / 2,
+                                 textRect.y() + (textRect.height() - labelHeight) / 2,
+                                 pixmapWidth, pixmapHeight);
+
+                iconRect = visualRect(button->direction, textRect, iconRect);
+
+                tf |= Qt::AlignLeft; //left align, we adjust the text-rect instead
+
+                if (button->direction == Qt::RightToLeft)
+                    textRect.setRight(iconRect.left() - iconSpacing);
+                else
+                    textRect.setLeft(iconRect.left() + iconRect.width() + iconSpacing);
+
+                if (button->state & (State_On | State_Sunken))
+                    iconRect.translate(proxy()->pixelMetric(PM_ButtonShiftHorizontal, opt, widget),
+                                       proxy()->pixelMetric(PM_ButtonShiftVertical, opt, widget));
+                p->drawPixmap(iconRect, pixmap);
+            } else {
+                tf |= Qt::AlignHCenter;
+            }
+            if (button->state & (State_On | State_Sunken))
+                textRect.translate(proxy()->pixelMetric(PM_ButtonShiftHorizontal, opt, widget),
+                             proxy()->pixelMetric(PM_ButtonShiftVertical, opt, widget));
+
+            if (button->features & QStyleOptionButton::HasMenu) {
+                int indicatorSize = proxy()->pixelMetric(PM_MenuButtonIndicator, button, widget);
+                if (button->direction == Qt::LeftToRight)
+                    textRect = textRect.adjusted(0, 0, -indicatorSize, 0);
+                else
+                    textRect = textRect.adjusted(indicatorSize, 0, 0, 0);
+            }
+            proxy()->drawItemText(p, textRect, tf, button->palette, (button->state & State_Enabled),
+                         button->text, QPalette::ButtonText);
+        }
+        break;
+    case CE_RadioButton:
+    case CE_CheckBox:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
+            bool isRadio = (element == CE_RadioButton);
+            QStyleOptionButton subopt = *btn;
+            subopt.rect = subElementRect(isRadio ? SE_RadioButtonIndicator
+                                                 : SE_CheckBoxIndicator, btn, widget);
+            proxy()->drawPrimitive(isRadio ? PE_IndicatorRadioButton : PE_IndicatorCheckBox,
+                          &subopt, p, widget);
+            subopt.rect = subElementRect(isRadio ? SE_RadioButtonContents
+                                                 : SE_CheckBoxContents, btn, widget);
+            proxy()->drawControl(isRadio ? CE_RadioButtonLabel : CE_CheckBoxLabel, &subopt, p, widget);
+            if (btn->state & State_HasFocus) {
+                QStyleOptionFocusRect fropt;
+                fropt.QStyleOption::operator=(*btn);
+                fropt.rect = subElementRect(isRadio ? SE_RadioButtonFocusRect
+                                                    : SE_CheckBoxFocusRect, btn, widget);
+                proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, p, widget);
+            }
+        }
+        break;
+    case CE_RadioButtonLabel:
+    case CE_CheckBoxLabel:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
+            uint alignment = visualAlignment(btn->direction, Qt::AlignLeft | Qt::AlignVCenter);
+
+            if (!proxy()->styleHint(SH_UnderlineShortcut, btn, widget))
+                alignment |= Qt::TextHideMnemonic;
+            QPixmap pix;
+            QRect textRect = btn->rect;
+            if (!btn->icon.isNull()) {
+                pix = btn->icon.pixmap(btn->iconSize, btn->state & State_Enabled ? QIcon::Normal : QIcon::Disabled);
+                proxy()->drawItemPixmap(p, btn->rect, alignment, pix);
+                if (btn->direction == Qt::RightToLeft)
+                    textRect.setRight(textRect.right() - btn->iconSize.width() - 4);
+                else
+                    textRect.setLeft(textRect.left() + btn->iconSize.width() + 4);
+            }
+            if (!btn->text.isEmpty()){
+                proxy()->drawItemText(p, textRect, alignment | Qt::TextShowMnemonic,
+                    btn->palette, btn->state & State_Enabled, btn->text, QPalette::WindowText);
+            }
+        }
+        break;
+#ifndef QT_NO_MENU
+    case CE_MenuScroller: {
+        QStyleOption arrowOpt = *opt;
+        arrowOpt.state |= State_Enabled;
+        proxy()->drawPrimitive(((opt->state & State_DownArrow) ? PE_IndicatorArrowDown : PE_IndicatorArrowUp),
+                    &arrowOpt, p, widget);
+        break; }
+    case CE_MenuTearoff:
+        if (opt->state & State_Selected)
+            p->fillRect(opt->rect, opt->palette.brush(QPalette::Highlight));
+        else
+            p->fillRect(opt->rect, opt->palette.brush(QPalette::Button));
+        p->setPen(QPen(opt->palette.dark().color(), 1, Qt::DashLine));
+        p->drawLine(opt->rect.x() + 2, opt->rect.y() + opt->rect.height() / 2 - 1,
+                    opt->rect.x() + opt->rect.width() - 4,
+                    opt->rect.y() + opt->rect.height() / 2 - 1);
+        p->setPen(QPen(opt->palette.light().color(), 1, Qt::DashLine));
+        p->drawLine(opt->rect.x() + 2, opt->rect.y() + opt->rect.height() / 2,
+                    opt->rect.x() + opt->rect.width() - 4, opt->rect.y() + opt->rect.height() / 2);
+        break;
+#endif // QT_NO_MENU
+#ifndef QT_NO_MENUBAR
+    case CE_MenuBarItem:
+        if (const QStyleOptionMenuItem *mbi = qstyleoption_cast<const QStyleOptionMenuItem *>(opt)) {
+            uint alignment = Qt::AlignCenter | Qt::TextShowMnemonic | Qt::TextDontClip
+                            | Qt::TextSingleLine;
+            if (!proxy()->styleHint(SH_UnderlineShortcut, mbi, widget))
+                alignment |= Qt::TextHideMnemonic;
+            QPixmap pix = mbi->icon.pixmap(proxy()->pixelMetric(PM_SmallIconSize), (mbi->state & State_Enabled) ? QIcon::Normal : QIcon::Disabled);
+            if (!pix.isNull())
+                proxy()->drawItemPixmap(p,mbi->rect, alignment, pix);
+            else
+                proxy()->drawItemText(p, mbi->rect, alignment, mbi->palette, mbi->state & State_Enabled,
+                             mbi->text, QPalette::ButtonText);
+        }
+        break;
+    case CE_MenuBarEmptyArea:
+        if (widget && !widget->testAttribute(Qt::WA_NoSystemBackground))
+            p->eraseRect(opt->rect);
+        break;
+#endif // QT_NO_MENUBAR
+#ifndef QT_NO_PROGRESSBAR
+    case CE_ProgressBar:
+        if (const QStyleOptionProgressBar *pb
+                = qstyleoption_cast<const QStyleOptionProgressBar *>(opt)) {
+            QStyleOptionProgressBarV2 subopt = *pb;
+            subopt.rect = subElementRect(SE_ProgressBarGroove, pb, widget);
+            proxy()->drawControl(CE_ProgressBarGroove, &subopt, p, widget);
+            subopt.rect = subElementRect(SE_ProgressBarContents, pb, widget);
+            proxy()->drawControl(CE_ProgressBarContents, &subopt, p, widget);
+            if (pb->textVisible) {
+                subopt.rect = subElementRect(SE_ProgressBarLabel, pb, widget);
+                proxy()->drawControl(CE_ProgressBarLabel, &subopt, p, widget);
+            }
+        }
+        break;
+    case CE_ProgressBarGroove:
+        if (opt->rect.isValid())
+            qDrawShadePanel(p, opt->rect, opt->palette, true, 1,
+                            &opt->palette.brush(QPalette::Window));
+        break;
+    case CE_ProgressBarLabel:
+        if (const QStyleOptionProgressBar *pb = qstyleoption_cast<const QStyleOptionProgressBar *>(opt)) {
+            bool vertical = false;
+            if (const QStyleOptionProgressBarV2 *pb2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(opt)) {
+                vertical = (pb2->orientation == Qt::Vertical);
+            }
+            if (!vertical) {
+                QPalette::ColorRole textRole = QPalette::NoRole;
+                if ((pb->textAlignment & Qt::AlignCenter) && pb->textVisible
+                    && ((qint64(pb->progress) - qint64(pb->minimum)) * 2 >= (qint64(pb->maximum) - qint64(pb->minimum)))) {
+                    textRole = QPalette::HighlightedText;
+                    //Draw text shadow, This will increase readability when the background of same color
+                    QRect shadowRect(pb->rect);
+                    shadowRect.translate(1,1);
+                    QColor shadowColor = (pb->palette.color(textRole).value() <= 128)
+                       ? QColor(255,255,255,160) : QColor(0,0,0,160);
+                    QPalette shadowPalette = pb->palette;
+                    shadowPalette.setColor(textRole, shadowColor);
+                    proxy()->drawItemText(p, shadowRect, Qt::AlignCenter | Qt::TextSingleLine, shadowPalette,
+                                 pb->state & State_Enabled, pb->text, textRole);
+                }
+                proxy()->drawItemText(p, pb->rect, Qt::AlignCenter | Qt::TextSingleLine, pb->palette,
+                             pb->state & State_Enabled, pb->text, textRole);
+            }
+        }
+        break;
+    case CE_ProgressBarContents:
+        if (const QStyleOptionProgressBar *pb = qstyleoption_cast<const QStyleOptionProgressBar *>(opt)) {
+
+            QRect rect = pb->rect;
+            bool vertical = false;
+            bool inverted = false;
+            qint64 minimum = qint64(pb->minimum);
+            qint64 maximum = qint64(pb->maximum);
+            qint64 progress = qint64(pb->progress);
+
+            // Get extra style options if version 2
+            const QStyleOptionProgressBarV2 *pb2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(opt);
+            if (pb2) {
+                vertical = (pb2->orientation == Qt::Vertical);
+                inverted = pb2->invertedAppearance;
+            }
+            QMatrix m;
+
+            if (vertical) {
+                rect = QRect(rect.y(), rect.x(), rect.height(), rect.width()); // flip width and height
+                m.rotate(90);
+                m.translate(0, -(rect.height() + rect.y()*2));
+            }
+
+            QPalette pal2 = pb->palette;
+            // Correct the highlight color if it is the same as the background
+            if (pal2.highlight() == pal2.background())
+                pal2.setColor(QPalette::Highlight, pb->palette.color(QPalette::Active,
+                                                                     QPalette::Highlight));
+            bool reverse = ((!vertical && (pb->direction == Qt::RightToLeft)) || vertical);
+            if (inverted)
+                reverse = !reverse;
+            int w = rect.width();
+            if (pb->minimum == 0 && pb->maximum == 0) {
+                // draw busy indicator
+                int x = (progress - minimum) % (w * 2);
+                if (x > w)
+                    x = 2 * w - x;
+                x = reverse ? rect.right() - x : x + rect.x();
+                p->setPen(QPen(pal2.highlight().color(), 4));
+                p->drawLine(x, rect.y(), x, rect.height());
+            } else {
+                const int unit_width = proxy()->pixelMetric(PM_ProgressBarChunkWidth, pb, widget);
+                if (!unit_width)
+                    return;
+
+                int u;
+                if (unit_width > 1)
+                    u = ((rect.width() + unit_width) / unit_width);
+                else
+                    u = w / unit_width;
+                qint64 p_v = progress - minimum;
+                qint64 t_s = (maximum - minimum) ? (maximum - minimum) : qint64(1);
+
+                if (u > 0 && p_v >= INT_MAX / u && t_s >= u) {
+                    // scale down to something usable.
+                    p_v /= u;
+                    t_s /= u;
+                }
+
+                // nu < tnu, if last chunk is only a partial chunk
+                int tnu, nu;
+                tnu = nu = p_v * u / t_s;
+
+                if (nu * unit_width > w)
+                    --nu;
+
+                // Draw nu units out of a possible u of unit_width
+                // width, each a rectangle bordered by background
+                // color, all in a sunken panel with a percentage text
+                // display at the end.
+                int x = 0;
+                int x0 = reverse ? rect.right() - ((unit_width > 1) ? unit_width : 0)
+                                 : rect.x();
+
+                QStyleOptionProgressBarV2 pbBits = *pb;
+                pbBits.rect = rect;
+                pbBits.palette = pal2;
+                int myY = pbBits.rect.y();
+                int myHeight = pbBits.rect.height();
+                pbBits.state = State_None;
+                for (int i = 0; i < nu; ++i) {
+                    pbBits.rect.setRect(x0 + x, myY, unit_width, myHeight);
+                    pbBits.rect = m.mapRect(QRectF(pbBits.rect)).toRect();
+                    proxy()->drawPrimitive(PE_IndicatorProgressChunk, &pbBits, p, widget);
+                    x += reverse ? -unit_width : unit_width;
+                }
+
+                // Draw the last partial chunk to fill up the
+                // progress bar entirely
+                if (nu < tnu) {
+                    int pixels_left = w - (nu * unit_width);
+                    int offset = reverse ? x0 + x + unit_width-pixels_left : x0 + x;
+                    pbBits.rect.setRect(offset, myY, pixels_left, myHeight);
+                    pbBits.rect = m.mapRect(QRectF(pbBits.rect)).toRect();
+                    proxy()->drawPrimitive(PE_IndicatorProgressChunk, &pbBits, p, widget);
+                }
+            }
+        }
+        break;
+#endif // QT_NO_PROGRESSBAR
+    case CE_HeaderLabel:
+        if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(opt)) {
+            QRect rect = header->rect;
+            if (!header->icon.isNull()) {
+                QPixmap pixmap
+                    = header->icon.pixmap(proxy()->pixelMetric(PM_SmallIconSize), (header->state & State_Enabled) ? QIcon::Normal : QIcon::Disabled);
+                int pixw = pixmap.width() / pixmap.devicePixelRatio();
+
+                QRect aligned = alignedRect(header->direction, QFlag(header->iconAlignment), pixmap.size() / pixmap.devicePixelRatio(), rect);
+                QRect inter = aligned.intersected(rect);
+                p->drawPixmap(inter.x(), inter.y(), pixmap,
+                              inter.x() - aligned.x(), inter.y() - aligned.y(),
+                              aligned.width() * pixmap.devicePixelRatio(),
+                              pixmap.height() * pixmap.devicePixelRatio());
+
+                if (header->direction == Qt::LeftToRight)
+                    rect.setLeft(rect.left() + pixw + 2);
+                else
+                    rect.setRight(rect.right() - pixw - 2);
+            }
+            if (header->state & QStyle::State_On) {
+                QFont fnt = p->font();
+                fnt.setBold(true);
+                p->setFont(fnt);
+            }
+            proxy()->drawItemText(p, rect, header->textAlignment, header->palette,
+                         (header->state & State_Enabled), header->text, QPalette::ButtonText);
+        }
+        break;
+#ifndef QT_NO_TOOLBUTTON
+    case CE_ToolButtonLabel:
+        if (const QStyleOptionToolButton *toolbutton
+                = qstyleoption_cast<const QStyleOptionToolButton *>(opt)) {
+            QRect rect = toolbutton->rect;
+            int shiftX = 0;
+            int shiftY = 0;
+            if (toolbutton->state & (State_Sunken | State_On)) {
+                shiftX = proxy()->pixelMetric(PM_ButtonShiftHorizontal, toolbutton, widget);
+                shiftY = proxy()->pixelMetric(PM_ButtonShiftVertical, toolbutton, widget);
+            }
+            // Arrow type always overrules and is always shown
+            bool hasArrow = toolbutton->features & QStyleOptionToolButton::Arrow;
+            if (((!hasArrow && toolbutton->icon.isNull()) && !toolbutton->text.isEmpty())
+                || toolbutton->toolButtonStyle == Qt::ToolButtonTextOnly) {
+                int alignment = Qt::AlignCenter | Qt::TextShowMnemonic;
+                if (!proxy()->styleHint(SH_UnderlineShortcut, opt, widget))
+                    alignment |= Qt::TextHideMnemonic;
+                rect.translate(shiftX, shiftY);
+                p->setFont(toolbutton->font);
+                proxy()->drawItemText(p, rect, alignment, toolbutton->palette,
+                             opt->state & State_Enabled, toolbutton->text,
+                             QPalette::ButtonText);
+            } else {
+                QPixmap pm;
+                QSize pmSize = toolbutton->iconSize;
+                if (!toolbutton->icon.isNull()) {
+                    QIcon::State state = toolbutton->state & State_On ? QIcon::On : QIcon::Off;
+                    QIcon::Mode mode;
+                    if (!(toolbutton->state & State_Enabled))
+                        mode = QIcon::Disabled;
+                    else if ((opt->state & State_MouseOver) && (opt->state & State_AutoRaise))
+                        mode = QIcon::Active;
+                    else
+                        mode = QIcon::Normal;
+                    pm = toolbutton->icon.pixmap(toolbutton->rect.size().boundedTo(toolbutton->iconSize),
+                                                 mode, state);
+                    pmSize = pm.size() / pm.devicePixelRatio();
+                }
+
+                if (toolbutton->toolButtonStyle != Qt::ToolButtonIconOnly) {
+                    p->setFont(toolbutton->font);
+                    QRect pr = rect,
+                    tr = rect;
+                    int alignment = Qt::TextShowMnemonic;
+                    if (!proxy()->styleHint(SH_UnderlineShortcut, opt, widget))
+                        alignment |= Qt::TextHideMnemonic;
+
+                    if (toolbutton->toolButtonStyle == Qt::ToolButtonTextUnderIcon) {
+                        pr.setHeight(pmSize.height() + 6);
+                        tr.adjust(0, pr.height() - 1, 0, -1);
+                        pr.translate(shiftX, shiftY);
+                        if (!hasArrow) {
+                            proxy()->drawItemPixmap(p, pr, Qt::AlignCenter, pm);
+                        } else {
+                            drawArrow(this, toolbutton, pr, p, widget);
+                        }
+                        alignment |= Qt::AlignCenter;
+                    } else {
+                        pr.setWidth(pmSize.width() + 8);
+                        tr.adjust(pr.width(), 0, 0, 0);
+                        pr.translate(shiftX, shiftY);
+                        if (!hasArrow) {
+                            proxy()->drawItemPixmap(p, QStyle::visualRect(opt->direction, rect, pr), Qt::AlignCenter, pm);
+                        } else {
+                            drawArrow(this, toolbutton, pr, p, widget);
+                        }
+                        alignment |= Qt::AlignLeft | Qt::AlignVCenter;
+                    }
+                    tr.translate(shiftX, shiftY);
+                    proxy()->drawItemText(p, QStyle::visualRect(opt->direction, rect, tr), alignment, toolbutton->palette,
+                                 toolbutton->state & State_Enabled, toolbutton->text,
+                                 QPalette::ButtonText);
+                } else {
+                    rect.translate(shiftX, shiftY);
+                    if (hasArrow) {
+                        drawArrow(this, toolbutton, rect, p, widget);
+                    } else {
+                        proxy()->drawItemPixmap(p, rect, Qt::AlignCenter, pm);
+                    }
+                }
+            }
+        }
+        break;
+#endif // QT_NO_TOOLBUTTON
+#ifndef QT_NO_TOOLBOX
+    case CE_ToolBoxTab:
+        if (const QStyleOptionToolBox *tb = qstyleoption_cast<const QStyleOptionToolBox *>(opt)) {
+            proxy()->drawControl(CE_ToolBoxTabShape, tb, p, widget);
+            proxy()->drawControl(CE_ToolBoxTabLabel, tb, p, widget);
+        }
+        break;
+    case CE_ToolBoxTabShape:
+        if (const QStyleOptionToolBox *tb = qstyleoption_cast<const QStyleOptionToolBox *>(opt)) {
+            int d = 20 + tb->rect.height() - 3;
+            QPolygon a(7);
+            if (tb->direction != Qt::RightToLeft) {
+                a.setPoint(0, -1, tb->rect.height() + 1);
+                a.setPoint(1, -1, 1);
+                a.setPoint(2, tb->rect.width() - d, 1);
+                a.setPoint(3, tb->rect.width() - 20, tb->rect.height() - 2);
+                a.setPoint(4, tb->rect.width() - 1, tb->rect.height() - 2);
+                a.setPoint(5, tb->rect.width() - 1, tb->rect.height() + 1);
+                a.setPoint(6, -1, tb->rect.height() + 1);
+            } else {
+                a.setPoint(0, tb->rect.width(), tb->rect.height() + 1);
+                a.setPoint(1, tb->rect.width(), 1);
+                a.setPoint(2, d - 1, 1);
+                a.setPoint(3, 20 - 1, tb->rect.height() - 2);
+                a.setPoint(4, 0, tb->rect.height() - 2);
+                a.setPoint(5, 0, tb->rect.height() + 1);
+                a.setPoint(6, tb->rect.width(), tb->rect.height() + 1);
+            }
+
+            p->setPen(tb->palette.mid().color().darker(150));
+            bool oldQt4CompatiblePainting = p->testRenderHint(QPainter::Qt4CompatiblePainting);
+            p->setRenderHint(QPainter::Qt4CompatiblePainting);
+            p->drawPolygon(a);
+            p->setRenderHint(QPainter::Qt4CompatiblePainting, oldQt4CompatiblePainting);
+            p->setPen(tb->palette.light().color());
+            if (tb->direction != Qt::RightToLeft) {
+                p->drawLine(0, 2, tb->rect.width() - d, 2);
+                p->drawLine(tb->rect.width() - d - 1, 2, tb->rect.width() - 21, tb->rect.height() - 1);
+                p->drawLine(tb->rect.width() - 20, tb->rect.height() - 1,
+                            tb->rect.width(), tb->rect.height() - 1);
+            } else {
+                p->drawLine(tb->rect.width() - 1, 2, d - 1, 2);
+                p->drawLine(d, 2, 20, tb->rect.height() - 1);
+                p->drawLine(19, tb->rect.height() - 1,
+                            -1, tb->rect.height() - 1);
+            }
+            p->setBrush(Qt::NoBrush);
+        }
+        break;
+#endif // QT_NO_TOOLBOX
+#ifndef QT_NO_TABBAR
+    case CE_TabBarTab:
+        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(opt)) {
+            proxy()->drawControl(CE_TabBarTabShape, tab, p, widget);
+            proxy()->drawControl(CE_TabBarTabLabel, tab, p, widget);
+        }
+        break;
+    case CE_TabBarTabShape:
+        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(opt)) {
+            p->save();
+
+            QRect rect(tab->rect);
+            bool selected = tab->state & State_Selected;
+            bool onlyOne = tab->position == QStyleOptionTab::OnlyOneTab;
+            int tabOverlap = onlyOne ? 0 : proxy()->pixelMetric(PM_TabBarTabOverlap, opt, widget);
+
+            if (!selected) {
+                switch (tab->shape) {
+                case QTabBar::TriangularNorth:
+                    rect.adjust(0, 0, 0, -tabOverlap);
+                    if(!selected)
+                        rect.adjust(1, 1, -1, 0);
+                    break;
+                case QTabBar::TriangularSouth:
+                    rect.adjust(0, tabOverlap, 0, 0);
+                    if(!selected)
+                        rect.adjust(1, 0, -1, -1);
+                    break;
+                case QTabBar::TriangularEast:
+                    rect.adjust(tabOverlap, 0, 0, 0);
+                    if(!selected)
+                        rect.adjust(0, 1, -1, -1);
+                    break;
+                case QTabBar::TriangularWest:
+                    rect.adjust(0, 0, -tabOverlap, 0);
+                    if(!selected)
+                        rect.adjust(1, 1, 0, -1);
+                    break;
+                default:
+                    break;
+                }
+            }
+
+            p->setPen(QPen(tab->palette.foreground(), 0));
+            if (selected) {
+                p->setBrush(tab->palette.base());
+            } else {
+                if (widget && widget->parentWidget())
+                    p->setBrush(widget->parentWidget()->palette().background());
+                else
+                    p->setBrush(tab->palette.background());
+            }
+
+            int y;
+            int x;
+            QPolygon a(10);
+            switch (tab->shape) {
+            case QTabBar::TriangularNorth:
+            case QTabBar::TriangularSouth: {
+                a.setPoint(0, 0, -1);
+                a.setPoint(1, 0, 0);
+                y = rect.height() - 2;
+                x = y / 3;
+                a.setPoint(2, x++, y - 1);
+                ++x;
+                a.setPoint(3, x++, y++);
+                a.setPoint(4, x, y);
+
+                int i;
+                int right = rect.width() - 1;
+                for (i = 0; i < 5; ++i)
+                    a.setPoint(9 - i, right - a.point(i).x(), a.point(i).y());
+                if (tab->shape == QTabBar::TriangularNorth)
+                    for (i = 0; i < 10; ++i)
+                        a.setPoint(i, a.point(i).x(), rect.height() - 1 - a.point(i).y());
+
+                a.translate(rect.left(), rect.top());
+                p->setRenderHint(QPainter::Antialiasing);
+                p->translate(0, 0.5);
+
+                QPainterPath path;
+                path.addPolygon(a);
+                p->drawPath(path);
+                break; }
+            case QTabBar::TriangularEast:
+            case QTabBar::TriangularWest: {
+                a.setPoint(0, -1, 0);
+                a.setPoint(1, 0, 0);
+                x = rect.width() - 2;
+                y = x / 3;
+                a.setPoint(2, x - 1, y++);
+                ++y;
+                a.setPoint(3, x++, y++);
+                a.setPoint(4, x, y);
+                int i;
+                int bottom = rect.height() - 1;
+                for (i = 0; i < 5; ++i)
+                    a.setPoint(9 - i, a.point(i).x(), bottom - a.point(i).y());
+                if (tab->shape == QTabBar::TriangularWest)
+                    for (i = 0; i < 10; ++i)
+                        a.setPoint(i, rect.width() - 1 - a.point(i).x(), a.point(i).y());
+                a.translate(rect.left(), rect.top());
+                p->setRenderHint(QPainter::Antialiasing);
+                p->translate(0.5, 0);
+                QPainterPath path;
+                path.addPolygon(a);
+                p->drawPath(path);
+                break; }
+            default:
+                break;
+            }
+            p->restore();
+        }
+        break;
+    case CE_ToolBoxTabLabel:
+        if (const QStyleOptionToolBox *tb = qstyleoption_cast<const QStyleOptionToolBox *>(opt)) {
+            bool enabled = tb->state & State_Enabled;
+            bool selected = tb->state & State_Selected;
+            QPixmap pm = tb->icon.pixmap(proxy()->pixelMetric(QStyle::PM_SmallIconSize, tb, widget),
+                                         enabled ? QIcon::Normal : QIcon::Disabled);
+
+            QRect cr = subElementRect(QStyle::SE_ToolBoxTabContents, tb, widget);
+            QRect tr, ir;
+            int ih = 0;
+            if (pm.isNull()) {
+                tr = cr;
+                tr.adjust(4, 0, -8, 0);
+            } else {
+                int iw = pm.width() / pm.devicePixelRatio() + 4;
+                ih = pm.height()/ pm.devicePixelRatio();
+                ir = QRect(cr.left() + 4, cr.top(), iw + 2, ih);
+                tr = QRect(ir.right(), cr.top(), cr.width() - ir.right() - 4, cr.height());
+            }
+
+            if (selected && proxy()->styleHint(QStyle::SH_ToolBox_SelectedPageTitleBold, tb, widget)) {
+                QFont f(p->font());
+                f.setBold(true);
+                p->setFont(f);
+            }
+
+            QString txt = tb->fontMetrics.elidedText(tb->text, Qt::ElideRight, tr.width());
+
+            if (ih)
+                p->drawPixmap(ir.left(), (tb->rect.height() - ih) / 2, pm);
+
+            int alignment = Qt::AlignLeft | Qt::AlignVCenter | Qt::TextShowMnemonic;
+            if (!proxy()->styleHint(QStyle::SH_UnderlineShortcut, tb, widget))
+                alignment |= Qt::TextHideMnemonic;
+            proxy()->drawItemText(p, tr, alignment, tb->palette, enabled, txt, QPalette::ButtonText);
+
+            if (!txt.isEmpty() && opt->state & State_HasFocus) {
+                QStyleOptionFocusRect opt;
+                opt.rect = tr;
+                opt.palette = tb->palette;
+                opt.state = QStyle::State_None;
+                proxy()->drawPrimitive(QStyle::PE_FrameFocusRect, &opt, p, widget);
+            }
+        }
+        break;
+    case CE_TabBarTabLabel:
+        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(opt)) {
+            QStyleOptionTabV3 tabV2(*tab);
+            QRect tr = tabV2.rect;
+            bool verticalTabs = tabV2.shape == QTabBar::RoundedEast
+                                || tabV2.shape == QTabBar::RoundedWest
+                                || tabV2.shape == QTabBar::TriangularEast
+                                || tabV2.shape == QTabBar::TriangularWest;
+
+            int alignment = Qt::AlignCenter | Qt::TextShowMnemonic;
+            if (!proxy()->styleHint(SH_UnderlineShortcut, opt, widget))
+                alignment |= Qt::TextHideMnemonic;
+
+            if (verticalTabs) {
+                p->save();
+                int newX, newY, newRot;
+                if (tabV2.shape == QTabBar::RoundedEast || tabV2.shape == QTabBar::TriangularEast) {
+                    newX = tr.width() + tr.x();
+                    newY = tr.y();
+                    newRot = 90;
+                } else {
+                    newX = tr.x();
+                    newY = tr.y() + tr.height();
+                    newRot = -90;
+                }
+                QTransform m = QTransform::fromTranslate(newX, newY);
+                m.rotate(newRot);
+                p->setTransform(m, true);
+            }
+            QRect iconRect;
+            d->tabLayout(&tabV2, widget, &tr, &iconRect);
+            tr = proxy()->subElementRect(SE_TabBarTabText, opt, widget); //we compute tr twice because the style may override subElementRect
+
+            if (!tabV2.icon.isNull()) {
+                QPixmap tabIcon = tabV2.icon.pixmap(tabV2.iconSize,
+                                                    (tabV2.state & State_Enabled) ? QIcon::Normal
+                                                                                  : QIcon::Disabled,
+                                                    (tabV2.state & State_Selected) ? QIcon::On
+                                                                                   : QIcon::Off);
+                p->drawPixmap(iconRect.x(), iconRect.y(), tabIcon);
+            }
+
+            proxy()->drawItemText(p, tr, alignment, tab->palette, tab->state & State_Enabled, tab->text, QPalette::WindowText);
+            if (verticalTabs)
+                p->restore();
+
+            if (tabV2.state & State_HasFocus) {
+                const int OFFSET = 1 + pixelMetric(PM_DefaultFrameWidth);
+
+                int x1, x2;
+                x1 = tabV2.rect.left();
+                x2 = tabV2.rect.right() - 1;
+
+                QStyleOptionFocusRect fropt;
+                fropt.QStyleOption::operator=(*tab);
+                fropt.rect.setRect(x1 + 1 + OFFSET, tabV2.rect.y() + OFFSET,
+                                   x2 - x1 - 2*OFFSET, tabV2.rect.height() - 2*OFFSET);
+                drawPrimitive(PE_FrameFocusRect, &fropt, p, widget);
+            }
+        }
+        break;
+#endif // QT_NO_TABBAR
+#ifndef QT_NO_SIZEGRIP
+    case CE_SizeGrip: {
+        p->save();
+        int x, y, w, h;
+        opt->rect.getRect(&x, &y, &w, &h);
+
+        int sw = qMin(h, w);
+        if (h > w)
+            p->translate(0, h - w);
+        else
+            p->translate(w - h, 0);
+
+        int sx = x;
+        int sy = y;
+        int s = sw / 3;
+
+        Qt::Corner corner;
+        if (const QStyleOptionSizeGrip *sgOpt = qstyleoption_cast<const QStyleOptionSizeGrip *>(opt))
+            corner = sgOpt->corner;
+        else if (opt->direction == Qt::RightToLeft)
+            corner = Qt::BottomLeftCorner;
+        else
+            corner = Qt::BottomRightCorner;
+
+        if (corner == Qt::BottomLeftCorner) {
+            sx = x + sw;
+            for (int i = 0; i < 4; ++i) {
+                p->setPen(QPen(opt->palette.light().color(), 1));
+                p->drawLine(x, sy - 1 , sx + 1, sw);
+                p->setPen(QPen(opt->palette.dark().color(), 1));
+                p->drawLine(x, sy, sx, sw);
+                p->setPen(QPen(opt->palette.dark().color(), 1));
+                p->drawLine(x, sy + 1, sx - 1, sw);
+                sx -= s;
+                sy += s;
+            }
+        } else if (corner == Qt::BottomRightCorner) {
+            for (int i = 0; i < 4; ++i) {
+                p->setPen(QPen(opt->palette.light().color(), 1));
+                p->drawLine(sx - 1, sw, sw, sy - 1);
+                p->setPen(QPen(opt->palette.dark().color(), 1));
+                p->drawLine(sx, sw, sw, sy);
+                p->setPen(QPen(opt->palette.dark().color(), 1));
+                p->drawLine(sx + 1, sw, sw, sy + 1);
+                sx += s;
+                sy += s;
+            }
+        } else if (corner == Qt::TopRightCorner) {
+            sy = y + sw;
+            for (int i = 0; i < 4; ++i) {
+                p->setPen(QPen(opt->palette.light().color(), 1));
+                p->drawLine(sx - 1, y, sw, sy + 1);
+                p->setPen(QPen(opt->palette.dark().color(), 1));
+                p->drawLine(sx, y, sw, sy);
+                p->setPen(QPen(opt->palette.dark().color(), 1));
+                p->drawLine(sx + 1, y, sw, sy - 1);
+                sx += s;
+                sy -= s;
+            }
+        } else if (corner == Qt::TopLeftCorner) {
+            for (int i = 0; i < 4; ++i) {
+                p->setPen(QPen(opt->palette.light().color(), 1));
+                p->drawLine(x, sy - 1, sx - 1, y);
+                p->setPen(QPen(opt->palette.dark().color(), 1));
+                p->drawLine(x, sy, sx, y);
+                p->setPen(QPen(opt->palette.dark().color(), 1));
+                p->drawLine(x, sy + 1, sx + 1, y);
+                sx += s;
+                sy += s;
+            }
+        }
+        p->restore();
+        break; }
+#endif // QT_NO_SIZEGRIP
+#ifndef QT_NO_RUBBERBAND
+    case CE_RubberBand: {
+        if (const QStyleOptionRubberBand *rbOpt = qstyleoption_cast<const QStyleOptionRubberBand *>(opt)) {
+            QPixmap tiledPixmap(16, 16);
+            QPainter pixmapPainter(&tiledPixmap);
+            pixmapPainter.setPen(Qt::NoPen);
+            pixmapPainter.setBrush(Qt::Dense4Pattern);
+            pixmapPainter.setBackground(QBrush(opt->palette.base()));
+            pixmapPainter.setBackgroundMode(Qt::OpaqueMode);
+            pixmapPainter.drawRect(0, 0, tiledPixmap.width(), tiledPixmap.height());
+            pixmapPainter.end();
+            // ### workaround for borked XRENDER
+            tiledPixmap = QPixmap::fromImage(tiledPixmap.toImage());
+
+            p->save();
+            QRect r = opt->rect;
+            QStyleHintReturnMask mask;
+            if (proxy()->styleHint(QStyle::SH_RubberBand_Mask, opt, widget, &mask))
+                p->setClipRegion(mask.region);
+            p->drawTiledPixmap(r.x(), r.y(), r.width(), r.height(), tiledPixmap);
+            p->setPen(opt->palette.color(QPalette::Active, QPalette::WindowText));
+            p->setBrush(Qt::NoBrush);
+            p->drawRect(r.adjusted(0, 0, -1, -1));
+            if (rbOpt->shape == QRubberBand::Rectangle)
+                p->drawRect(r.adjusted(3, 3, -4, -4));
+            p->restore();
+        }
+        break; }
+#endif // QT_NO_RUBBERBAND
+#ifndef QT_NO_DOCKWIDGET
+    case CE_DockWidgetTitle:
+        if (const QStyleOptionDockWidget *dwOpt = qstyleoption_cast<const QStyleOptionDockWidget *>(opt)) {
+            QRect r = dwOpt->rect.adjusted(0, 0, -1, -1);
+            if (dwOpt->movable) {
+                p->setPen(dwOpt->palette.color(QPalette::Dark));
+                p->drawRect(r);
+            }
+
+            if (!dwOpt->title.isEmpty()) {
+                const QStyleOptionDockWidgetV2 *v2
+                    = qstyleoption_cast<const QStyleOptionDockWidgetV2*>(opt);
+                bool verticalTitleBar = v2 == 0 ? false : v2->verticalTitleBar;
+
+                if (verticalTitleBar) {
+                    QSize s = r.size();
+                    s.transpose();
+                    r.setSize(s);
+
+                    p->save();
+                    p->translate(r.left(), r.top() + r.width());
+                    p->rotate(-90);
+                    p->translate(-r.left(), -r.top());
+                }
+
+                const int indent = p->fontMetrics().descent();
+                proxy()->drawItemText(p, r.adjusted(indent + 1, 1, -indent - 1, -1),
+                              Qt::AlignLeft | Qt::AlignVCenter | Qt::TextShowMnemonic, dwOpt->palette,
+                              dwOpt->state & State_Enabled, dwOpt->title,
+                              QPalette::WindowText);
+
+                if (verticalTitleBar)
+                    p->restore();
+            }
+        }
+        break;
+#endif // QT_NO_DOCKWIDGET
+    case CE_Header:
+        if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(opt)) {
+            QRegion clipRegion = p->clipRegion();
+            p->setClipRect(opt->rect);
+            proxy()->drawControl(CE_HeaderSection, header, p, widget);
+            QStyleOptionHeader subopt = *header;
+            subopt.rect = subElementRect(SE_HeaderLabel, header, widget);
+            if (subopt.rect.isValid())
+                proxy()->drawControl(CE_HeaderLabel, &subopt, p, widget);
+            if (header->sortIndicator != QStyleOptionHeader::None) {
+                subopt.rect = subElementRect(SE_HeaderArrow, opt, widget);
+                proxy()->drawPrimitive(PE_IndicatorHeaderArrow, &subopt, p, widget);
+            }
+            p->setClipRegion(clipRegion);
+        }
+        break;
+    case CE_FocusFrame:
+            p->fillRect(opt->rect, opt->palette.foreground());
+        break;
+    case CE_HeaderSection:
+            qDrawShadePanel(p, opt->rect, opt->palette,
+                        opt->state & State_Sunken, 1,
+                        &opt->palette.brush(QPalette::Button));
+        break;
+    case CE_HeaderEmptyArea:
+            p->fillRect(opt->rect, opt->palette.background());
+        break;
+#ifndef QT_NO_COMBOBOX
+    case CE_ComboBoxLabel:
+        if (const QStyleOptionComboBox *cb = qstyleoption_cast<const QStyleOptionComboBox *>(opt)) {
+            QRect editRect = proxy()->subControlRect(CC_ComboBox, cb, SC_ComboBoxEditField, widget);
+            p->save();
+            p->setClipRect(editRect);
+            if (!cb->currentIcon.isNull()) {
+                QIcon::Mode mode = cb->state & State_Enabled ? QIcon::Normal
+                                                             : QIcon::Disabled;
+                QPixmap pixmap = cb->currentIcon.pixmap(cb->iconSize, mode);
+                QRect iconRect(editRect);
+                iconRect.setWidth(cb->iconSize.width() + 4);
+                iconRect = alignedRect(cb->direction,
+                                       Qt::AlignLeft | Qt::AlignVCenter,
+                                       iconRect.size(), editRect);
+                if (cb->editable)
+                    p->fillRect(iconRect, opt->palette.brush(QPalette::Base));
+                proxy()->drawItemPixmap(p, iconRect, Qt::AlignCenter, pixmap);
+
+                if (cb->direction == Qt::RightToLeft)
+                    editRect.translate(-4 - cb->iconSize.width(), 0);
+                else
+                    editRect.translate(cb->iconSize.width() + 4, 0);
+            }
+            if (!cb->currentText.isEmpty() && !cb->editable) {
+                proxy()->drawItemText(p, editRect.adjusted(1, 0, -1, 0),
+                             visualAlignment(cb->direction, Qt::AlignLeft | Qt::AlignVCenter),
+                             cb->palette, cb->state & State_Enabled, cb->currentText);
+            }
+            p->restore();
+        }
+        break;
+#endif // QT_NO_COMBOBOX
+#ifndef QT_NO_TOOLBAR
+    case CE_ToolBar:
+        if (const QStyleOptionToolBar *toolBar = qstyleoption_cast<const QStyleOptionToolBar *>(opt)) {
+            // Compatibility with styles that use PE_PanelToolBar
+            QStyleOptionFrame frame;
+            frame.QStyleOption::operator=(*toolBar);
+            frame.lineWidth = toolBar->lineWidth;
+            frame.midLineWidth = toolBar->midLineWidth;
+            proxy()->drawPrimitive(PE_PanelToolBar, opt, p, widget);
+
+            if (widget && qobject_cast<QToolBar *>(widget->parentWidget()))
+                break;
+            qDrawShadePanel(p, toolBar->rect, toolBar->palette, false, toolBar->lineWidth,
+                            &toolBar->palette.brush(QPalette::Button));
+        }
+        break;
+#endif // QT_NO_TOOLBAR
+    case CE_ColumnViewGrip: {
+        // draw background gradients
+        QLinearGradient g(0, 0, opt->rect.width(), 0);
+        g.setColorAt(0, opt->palette.color(QPalette::Active, QPalette::Mid));
+        g.setColorAt(0.5, Qt::white);
+        p->fillRect(QRect(0, 0, opt->rect.width(), opt->rect.height()), g);
+
+        // draw the two lines
+        QPen pen(p->pen());
+        pen.setWidth(opt->rect.width()/20);
+        pen.setColor(opt->palette.color(QPalette::Active, QPalette::Dark));
+        p->setPen(pen);
+
+        int line1starting = opt->rect.width()*8 / 20;
+        int line2starting = opt->rect.width()*13 / 20;
+        int top = opt->rect.height()*20/75;
+        int bottom = opt->rect.height() - 1 - top;
+        p->drawLine(line1starting, top, line1starting, bottom);
+        p->drawLine(line2starting, top, line2starting, bottom);
+        }
+        break;
+
+#ifndef QT_NO_ITEMVIEWS
+    case CE_ItemViewItem:
+        if (const QStyleOptionViewItem *vopt = qstyleoption_cast<const QStyleOptionViewItem *>(opt)) {
+            p->save();
+            p->setClipRect(opt->rect);
+
+            QRect checkRect = proxy()->subElementRect(SE_ItemViewItemCheckIndicator, vopt, widget);
+            QRect iconRect = proxy()->subElementRect(SE_ItemViewItemDecoration, vopt, widget);
+            QRect textRect = proxy()->subElementRect(SE_ItemViewItemText, vopt, widget);
+
+            // draw the background
+            proxy()->drawPrimitive(PE_PanelItemViewItem, opt, p, widget);
+
+            // draw the check mark
+            if (vopt->features & QStyleOptionViewItem::HasCheckIndicator) {
+                QStyleOptionViewItem option(*vopt);
+                option.rect = checkRect;
+                option.state = option.state & ~QStyle::State_HasFocus;
+
+                switch (vopt->checkState) {
+                case Qt::Unchecked:
+                    option.state |= QStyle::State_Off;
+                    break;
+                case Qt::PartiallyChecked:
+                    option.state |= QStyle::State_NoChange;
+                    break;
+                case Qt::Checked:
+                    option.state |= QStyle::State_On;
+                    break;
+                }
+                proxy()->drawPrimitive(QStyle::PE_IndicatorViewItemCheck, &option, p, widget);
+            }
+
+            // draw the icon
+            QIcon::Mode mode = QIcon::Normal;
+            if (!(vopt->state & QStyle::State_Enabled))
+                mode = QIcon::Disabled;
+            else if (vopt->state & QStyle::State_Selected)
+                mode = QIcon::Selected;
+            QIcon::State state = vopt->state & QStyle::State_Open ? QIcon::On : QIcon::Off;
+            vopt->icon.paint(p, iconRect, vopt->decorationAlignment, mode, state);
+
+            // draw the text
+            if (!vopt->text.isEmpty()) {
+                QPalette::ColorGroup cg = vopt->state & QStyle::State_Enabled
+                                      ? QPalette::Normal : QPalette::Disabled;
+                if (cg == QPalette::Normal && !(vopt->state & QStyle::State_Active))
+                    cg = QPalette::Inactive;
+
+                if (vopt->state & QStyle::State_Selected) {
+                    p->setPen(vopt->palette.color(cg, QPalette::HighlightedText));
+                } else {
+                    p->setPen(vopt->palette.color(cg, QPalette::Text));
+                }
+                if (vopt->state & QStyle::State_Editing) {
+                    p->setPen(vopt->palette.color(cg, QPalette::Text));
+                    p->drawRect(textRect.adjusted(0, 0, -1, -1));
+                }
+
+                d->viewItemDrawText(p, vopt, textRect);
+            }
+
+            // draw the focus rect
+             if (vopt->state & QStyle::State_HasFocus) {
+                QStyleOptionFocusRect o;
+                o.QStyleOption::operator=(*vopt);
+                o.rect = proxy()->subElementRect(SE_ItemViewItemFocusRect, vopt, widget);
+                o.state |= QStyle::State_KeyboardFocusChange;
+                o.state |= QStyle::State_Item;
+                QPalette::ColorGroup cg = (vopt->state & QStyle::State_Enabled)
+                              ? QPalette::Normal : QPalette::Disabled;
+                o.backgroundColor = vopt->palette.color(cg, (vopt->state & QStyle::State_Selected)
+                                             ? QPalette::Highlight : QPalette::Window);
+                proxy()->drawPrimitive(QStyle::PE_FrameFocusRect, &o, p, widget);
+            }
+
+             p->restore();
+        }
+        break;
+
+#endif // QT_NO_ITEMVIEWS
+#ifndef QT_NO_FRAME
+    case CE_ShapedFrame:
+        if (const QStyleOptionFrameV3 *f = qstyleoption_cast<const QStyleOptionFrameV3 *>(opt)) {
+            int frameShape  = f->frameShape;
+            int frameShadow = QFrame::Plain;
+            if (f->state & QStyle::State_Sunken) {
+                frameShadow = QFrame::Sunken;
+            } else if (f->state & QStyle::State_Raised) {
+                frameShadow = QFrame::Raised;
+            }
+
+            int lw = f->lineWidth;
+            int mlw = f->midLineWidth;
+            QPalette::ColorRole foregroundRole = QPalette::WindowText;
+            if (widget)
+                foregroundRole = widget->foregroundRole();
+
+            switch (frameShape) {
+            case QFrame::Box:
+                if (frameShadow == QFrame::Plain) {
+                    qDrawPlainRect(p, f->rect, f->palette.color(foregroundRole), lw);
+                } else {
+                    qDrawShadeRect(p, f->rect, f->palette, frameShadow == QFrame::Sunken, lw, mlw);
+                }
+                break;
+            case QFrame::StyledPanel:
+                //keep the compatibility with Qt 4.4 if there is a proxy style.
+                //be sure to call drawPrimitive(QStyle::PE_Frame) on the proxy style
+                if (widget) {
+                    widget->style()->drawPrimitive(QStyle::PE_Frame, opt, p, widget);
+                } else {
+                    proxy()->drawPrimitive(QStyle::PE_Frame, opt, p, widget);
+                }
+                break;
+            case QFrame::Panel:
+                if (frameShadow == QFrame::Plain) {
+                    qDrawPlainRect(p, f->rect, f->palette.color(foregroundRole), lw);
+                } else {
+                    qDrawShadePanel(p, f->rect, f->palette, frameShadow == QFrame::Sunken, lw);
+                }
+                break;
+            case QFrame::WinPanel:
+                if (frameShadow == QFrame::Plain) {
+                    qDrawPlainRect(p, f->rect, f->palette.color(foregroundRole), lw);
+                } else {
+                    qDrawWinPanel(p, f->rect, f->palette, frameShadow == QFrame::Sunken);
+                }
+                break;
+            case QFrame::HLine:
+            case QFrame::VLine: {
+                QPoint p1, p2;
+                if (frameShape == QFrame::HLine) {
+                    p1 = QPoint(opt->rect.x(), opt->rect.y() + opt->rect.height() / 2);
+                    p2 = QPoint(opt->rect.x() + opt->rect.width(), p1.y());
+                } else {
+                    p1 = QPoint(opt->rect.x() + opt->rect.width() / 2, opt->rect.y());
+                    p2 = QPoint(p1.x(), p1.y() + opt->rect.height());
+                }
+                if (frameShadow == QFrame::Plain) {
+                    QPen oldPen = p->pen();
+                    p->setPen(QPen(opt->palette.brush(foregroundRole), lw));
+                    p->drawLine(p1, p2);
+                    p->setPen(oldPen);
+                } else {
+                    qDrawShadeLine(p, p1, p2, f->palette, frameShadow == QFrame::Sunken, lw, mlw);
+                }
+                break;
+                }
+            }
+        }
+        break;
+#endif
+    default:
+        break;
+    }
+}
+
+/*!
+  \reimp
+*/
+QRect QCommonStyle::subElementRect(SubElement sr, const QStyleOption *opt,
+                                   const QWidget *widget) const
+{
+    Q_D(const QCommonStyle);
+    QRect r;
+    switch (sr) {
+    case SE_PushButtonContents:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
+            int dx1, dx2;
+            dx1 = proxy()->pixelMetric(PM_DefaultFrameWidth, btn, widget);
+            if (btn->features & QStyleOptionButton::AutoDefaultButton)
+                dx1 += proxy()->pixelMetric(PM_ButtonDefaultIndicator, btn, widget);
+            dx2 = dx1 * 2;
+            r.setRect(opt->rect.x() + dx1, opt->rect.y() + dx1, opt->rect.width() - dx2,
+                      opt->rect.height() - dx2);
+            r = visualRect(opt->direction, opt->rect, r);
+        }
+        break;
+    case SE_PushButtonFocusRect:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
+            int dbw1 = 0, dbw2 = 0;
+            if (btn->features & QStyleOptionButton::AutoDefaultButton){
+                dbw1 = proxy()->pixelMetric(PM_ButtonDefaultIndicator, btn, widget);
+                dbw2 = dbw1 * 2;
+            }
+
+            int dfw1 = proxy()->pixelMetric(PM_DefaultFrameWidth, btn, widget) + 1,
+                dfw2 = dfw1 * 2;
+
+            r.setRect(btn->rect.x() + dfw1 + dbw1, btn->rect.y() + dfw1 + dbw1,
+                      btn->rect.width() - dfw2 - dbw2, btn->rect.height()- dfw2 - dbw2);
+            r = visualRect(opt->direction, opt->rect, r);
+        }
+        break;
+    case SE_CheckBoxIndicator:
+        {
+            int h = proxy()->pixelMetric(PM_IndicatorHeight, opt, widget);
+            r.setRect(opt->rect.x(), opt->rect.y() + ((opt->rect.height() - h) / 2),
+                      proxy()->pixelMetric(PM_IndicatorWidth, opt, widget), h);
+            r = visualRect(opt->direction, opt->rect, r);
+        }
+        break;
+
+    case SE_CheckBoxContents:
+        {
+            // Deal with the logical first, then convert it back to screen coords.
+            QRect ir = visualRect(opt->direction, opt->rect,
+                                  subElementRect(SE_CheckBoxIndicator, opt, widget));
+            int spacing = proxy()->pixelMetric(PM_CheckBoxLabelSpacing, opt, widget);
+            r.setRect(ir.right() + spacing, opt->rect.y(), opt->rect.width() - ir.width() - spacing,
+                      opt->rect.height());
+            r = visualRect(opt->direction, opt->rect, r);
+        }
+        break;
+
+    case SE_CheckBoxFocusRect:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
+            if (btn->icon.isNull() && btn->text.isEmpty()) {
+                r = subElementRect(SE_CheckBoxIndicator, opt, widget);
+                r.adjust(1, 1, -1, -1);
+                break;
+            }
+            // As above, deal with the logical first, then convert it back to screen coords.
+            QRect cr = visualRect(btn->direction, btn->rect,
+                                  subElementRect(SE_CheckBoxContents, btn, widget));
+
+            QRect iconRect, textRect;
+            if (!btn->text.isEmpty()) {
+                textRect = itemTextRect(opt->fontMetrics, cr, Qt::AlignAbsolute | Qt::AlignLeft
+                                        | Qt::AlignVCenter | Qt::TextShowMnemonic,
+                                        btn->state & State_Enabled, btn->text);
+            }
+            if (!btn->icon.isNull()) {
+                iconRect = itemPixmapRect(cr, Qt::AlignAbsolute | Qt::AlignLeft | Qt::AlignVCenter
+                                        | Qt::TextShowMnemonic,
+                                   btn->icon.pixmap(btn->iconSize, QIcon::Normal));
+                if (!textRect.isEmpty())
+                    textRect.translate(iconRect.right() + 4, 0);
+            }
+            r = iconRect | textRect;
+            r.adjust(-3, -2, 3, 2);
+            r = r.intersected(btn->rect);
+            r = visualRect(btn->direction, btn->rect, r);
+        }
+        break;
+
+    case SE_RadioButtonIndicator:
+        {
+            int h = proxy()->pixelMetric(PM_ExclusiveIndicatorHeight, opt, widget);
+            r.setRect(opt->rect.x(), opt->rect.y() + ((opt->rect.height() - h) / 2),
+                    proxy()->pixelMetric(PM_ExclusiveIndicatorWidth, opt, widget), h);
+            r = visualRect(opt->direction, opt->rect, r);
+        }
+        break;
+
+    case SE_RadioButtonContents:
+        {
+            QRect ir = visualRect(opt->direction, opt->rect,
+                                  subElementRect(SE_RadioButtonIndicator, opt, widget));
+            int spacing = proxy()->pixelMetric(PM_RadioButtonLabelSpacing, opt, widget);
+            r.setRect(ir.left() + ir.width() + spacing, opt->rect.y(), opt->rect.width() - ir.width() - spacing,
+                      opt->rect.height());
+            r = visualRect(opt->direction, opt->rect, r);
+            break;
+        }
+
+    case SE_RadioButtonFocusRect:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
+            if (btn->icon.isNull() && btn->text.isEmpty()) {
+                r = subElementRect(SE_RadioButtonIndicator, opt, widget);
+                r.adjust(1, 1, -1, -1);
+                break;
+            }
+            QRect cr = visualRect(btn->direction, btn->rect,
+                                  subElementRect(SE_RadioButtonContents, opt, widget));
+
+            QRect iconRect, textRect;
+            if (!btn->text.isEmpty()){
+                textRect = itemTextRect(opt->fontMetrics, cr, Qt::AlignAbsolute | Qt::AlignLeft | Qt::AlignVCenter
+                                 | Qt::TextShowMnemonic, btn->state & State_Enabled, btn->text);
+            }
+            if (!btn->icon.isNull()) {
+                iconRect = itemPixmapRect(cr, Qt::AlignAbsolute | Qt::AlignLeft | Qt::AlignVCenter | Qt::TextShowMnemonic,
+                                   btn->icon.pixmap(btn->iconSize, QIcon::Normal));
+                if (!textRect.isEmpty())
+                    textRect.translate(iconRect.right() + 4, 0);
+            }
+            r = iconRect | textRect;
+            r.adjust(-3, -2, 3, 2);
+            r = r.intersected(btn->rect);
+            r = visualRect(btn->direction, btn->rect, r);
+        }
+        break;
+#ifndef QT_NO_SLIDER
+    case SE_SliderFocusRect:
+        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+            int tickOffset = proxy()->pixelMetric(PM_SliderTickmarkOffset, slider, widget);
+            int thickness  = proxy()->pixelMetric(PM_SliderControlThickness, slider, widget);
+            if (slider->orientation == Qt::Horizontal)
+                r.setRect(0, tickOffset - 1, slider->rect.width(), thickness + 2);
+            else
+                r.setRect(tickOffset - 1, 0, thickness + 2, slider->rect.height());
+            r = r.intersected(slider->rect);
+            r = visualRect(opt->direction, opt->rect, r);
+        }
+        break;
+#endif // QT_NO_SLIDER
+#ifndef QT_NO_PROGRESSBAR
+    case SE_ProgressBarGroove:
+    case SE_ProgressBarContents:
+    case SE_ProgressBarLabel:
+        if (const QStyleOptionProgressBar *pb = qstyleoption_cast<const QStyleOptionProgressBar *>(opt)) {
+            int textw = 0;
+            bool vertical = false;
+            if (const QStyleOptionProgressBarV2 *pb2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(opt)) {
+                vertical = (pb2->orientation == Qt::Vertical);
+            }
+            if (!vertical) {
+                if (pb->textVisible)
+                    textw = qMax(pb->fontMetrics.width(pb->text), pb->fontMetrics.width(QLatin1String("100%"))) + 6;
+            }
+
+            if ((pb->textAlignment & Qt::AlignCenter) == 0) {
+                if (sr != SE_ProgressBarLabel)
+                    r.setCoords(pb->rect.left(), pb->rect.top(),
+                                pb->rect.right() - textw, pb->rect.bottom());
+                else
+                    r.setCoords(pb->rect.right() - textw, pb->rect.top(),
+                                pb->rect.right(), pb->rect.bottom());
+            } else {
+                r = pb->rect;
+            }
+            r = visualRect(pb->direction, pb->rect, r);
+        }
+        break;
+#endif // QT_NO_PROGRESSBAR
+#ifndef QT_NO_COMBOBOX
+    case SE_ComboBoxFocusRect:
+        if (const QStyleOptionComboBox *cb = qstyleoption_cast<const QStyleOptionComboBox *>(opt)) {
+            int margin = cb->frame ? 3 : 0;
+            r.setRect(opt->rect.left() + margin, opt->rect.top() + margin,
+                      opt->rect.width() - 2*margin - 16, opt->rect.height() - 2*margin);
+            r = visualRect(opt->direction, opt->rect, r);
+        }
+        break;
+#endif // QT_NO_COMBOBOX
+#ifndef QT_NO_TOOLBOX
+    case SE_ToolBoxTabContents:
+        r = opt->rect;
+        r.adjust(0, 0, -30, 0);
+        break;
+#endif // QT_NO_TOOLBOX
+    case SE_HeaderLabel: {
+        int margin = proxy()->pixelMetric(QStyle::PM_HeaderMargin, opt, widget);
+        r.setRect(opt->rect.x() + margin, opt->rect.y() + margin,
+                  opt->rect.width() - margin * 2, opt->rect.height() - margin * 2);
+
+        if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(opt)) {
+            // Subtract width needed for arrow, if there is one
+            if (header->sortIndicator != QStyleOptionHeader::None) {
+                if (opt->state & State_Horizontal)
+                    r.setWidth(r.width() - (opt->rect.height() / 2) - (margin * 2));
+                else
+                    r.setHeight(r.height() - (opt->rect.width() / 2) - (margin * 2));
+            }
+        }
+        r = visualRect(opt->direction, opt->rect, r);
+        break; }
+    case SE_HeaderArrow: {
+        int h = opt->rect.height();
+        int w = opt->rect.width();
+        int x = opt->rect.x();
+        int y = opt->rect.y();
+        int margin = proxy()->pixelMetric(QStyle::PM_HeaderMargin, opt, widget);
+
+        if (opt->state & State_Horizontal) {
+            int horiz_size = h / 2;
+            r.setRect(x + w - margin * 2 - horiz_size, y + 5,
+                      horiz_size, h - margin * 2 - 5);
+        } else {
+            int vert_size = w / 2;
+            r.setRect(x + 5, y + h - margin * 2 - vert_size,
+                      w - margin * 2 - 5, vert_size);
+        }
+        r = visualRect(opt->direction, opt->rect, r);
+        break; }
+
+    case SE_RadioButtonClickRect:
+        r = subElementRect(SE_RadioButtonFocusRect, opt, widget);
+        r |= subElementRect(SE_RadioButtonIndicator, opt, widget);
+        break;
+    case SE_CheckBoxClickRect:
+        r = subElementRect(SE_CheckBoxFocusRect, opt, widget);
+        r |= subElementRect(SE_CheckBoxIndicator, opt, widget);
+        break;
+#ifndef QT_NO_TABWIDGET
+    case SE_TabWidgetTabBar:
+        if (const QStyleOptionTabWidgetFrame *twf
+                = qstyleoption_cast<const QStyleOptionTabWidgetFrame *>(opt)) {
+            r.setSize(twf->tabBarSize);
+            const uint alingMask = Qt::AlignLeft | Qt::AlignRight | Qt::AlignHCenter;
+            switch (twf->shape) {
+            case QTabBar::RoundedNorth:
+            case QTabBar::TriangularNorth:
+                // Constrain the size now, otherwise, center could get off the page
+                // This of course repeated for all the other directions
+                r.setWidth(qMin(r.width(), twf->rect.width()
+                                            - twf->leftCornerWidgetSize.width()
+                                            - twf->rightCornerWidgetSize.width()));
+                switch (proxy()->styleHint(SH_TabBar_Alignment, twf, widget) & alingMask) {
+                default:
+                case Qt::AlignLeft:
+                    r.moveTopLeft(QPoint(twf->leftCornerWidgetSize.width(), 0));
+                    break;
+                case Qt::AlignHCenter:
+                    r.moveTopLeft(QPoint(twf->rect.center().x() - qRound(r.width() / 2.0f)
+                                         + (twf->leftCornerWidgetSize.width() / 2)
+                                         - (twf->rightCornerWidgetSize.width() / 2), 0));
+                    break;
+                case Qt::AlignRight:
+                    r.moveTopLeft(QPoint(twf->rect.width() - twf->tabBarSize.width()
+                                         - twf->rightCornerWidgetSize.width(), 0));
+                    break;
+                }
+                r = visualRect(twf->direction, twf->rect, r);
+                break;
+            case QTabBar::RoundedSouth:
+            case QTabBar::TriangularSouth:
+                r.setWidth(qMin(r.width(), twf->rect.width()
+                                            - twf->leftCornerWidgetSize.width()
+                                            - twf->rightCornerWidgetSize.width()));
+                switch (proxy()->styleHint(SH_TabBar_Alignment, twf, widget) & alingMask) {
+                default:
+                case Qt::AlignLeft:
+                    r.moveTopLeft(QPoint(twf->leftCornerWidgetSize.width(),
+                                         twf->rect.height() - twf->tabBarSize.height()));
+                    break;
+                case Qt::AlignHCenter:
+                    r.moveTopLeft(QPoint(twf->rect.center().x() - qRound(r.width() / 2.0f)
+                                         + (twf->leftCornerWidgetSize.width() / 2)
+                                         - (twf->rightCornerWidgetSize.width() / 2),
+                                         twf->rect.height() - twf->tabBarSize.height()));
+                    break;
+                case Qt::AlignRight:
+                    r.moveTopLeft(QPoint(twf->rect.width() - twf->tabBarSize.width()
+                                         - twf->rightCornerWidgetSize.width(),
+                                         twf->rect.height() - twf->tabBarSize.height()));
+                    break;
+                }
+                r = visualRect(twf->direction, twf->rect, r);
+                break;
+            case QTabBar::RoundedEast:
+            case QTabBar::TriangularEast:
+                r.setHeight(qMin(r.height(), twf->rect.height()
+                                            - twf->leftCornerWidgetSize.height()
+                                            - twf->rightCornerWidgetSize.height()));
+                switch (proxy()->styleHint(SH_TabBar_Alignment, twf, widget) & alingMask) {
+                default:
+                case Qt::AlignLeft:
+                    r.moveTopLeft(QPoint(twf->rect.width() - twf->tabBarSize.width(),
+                                         twf->leftCornerWidgetSize.height()));
+                    break;
+                case Qt::AlignHCenter:
+                    r.moveTopLeft(QPoint(twf->rect.width() - twf->tabBarSize.width(),
+                                         twf->rect.center().y() - r.height() / 2));
+                    break;
+                case Qt::AlignRight:
+                    r.moveTopLeft(QPoint(twf->rect.width() - twf->tabBarSize.width(),
+                                         twf->rect.height() - twf->tabBarSize.height()
+                                         - twf->rightCornerWidgetSize.height()));
+                    break;
+                }
+                break;
+            case QTabBar::RoundedWest:
+            case QTabBar::TriangularWest:
+                r.setHeight(qMin(r.height(), twf->rect.height()
+                                             - twf->leftCornerWidgetSize.height()
+                                             - twf->rightCornerWidgetSize.height()));
+                switch (proxy()->styleHint(SH_TabBar_Alignment, twf, widget) & alingMask) {
+                default:
+                case Qt::AlignLeft:
+                    r.moveTopLeft(QPoint(0, twf->leftCornerWidgetSize.height()));
+                    break;
+                case Qt::AlignHCenter:
+                    r.moveTopLeft(QPoint(0, twf->rect.center().y() - r.height() / 2));
+                    break;
+                case Qt::AlignRight:
+                    r.moveTopLeft(QPoint(0, twf->rect.height() - twf->tabBarSize.height()
+                                         - twf->rightCornerWidgetSize.height()));
+                    break;
+                }
+                break;
+            }
+        }
+        break;
+    case SE_TabWidgetTabPane:
+    case SE_TabWidgetTabContents:
+        if (const QStyleOptionTabWidgetFrame *twf = qstyleoption_cast<const QStyleOptionTabWidgetFrame *>(opt)) {
+            QStyleOptionTab tabopt;
+            tabopt.shape = twf->shape;
+            int overlap = proxy()->pixelMetric(PM_TabBarBaseOverlap, &tabopt, widget);
+            if (twf->lineWidth == 0)
+                overlap = 0;
+            switch (twf->shape) {
+            case QTabBar::RoundedNorth:
+            case QTabBar::TriangularNorth:
+                r = QRect(QPoint(0,qMax(twf->tabBarSize.height() - overlap, 0)),
+                          QSize(twf->rect.width(), qMin(twf->rect.height() - twf->tabBarSize.height() + overlap, twf->rect.height())));
+                break;
+            case QTabBar::RoundedSouth:
+            case QTabBar::TriangularSouth:
+                r = QRect(QPoint(0,0), QSize(twf->rect.width(), qMin(twf->rect.height() - twf->tabBarSize.height() + overlap, twf->rect.height())));
+                break;
+            case QTabBar::RoundedEast:
+            case QTabBar::TriangularEast:
+                r = QRect(QPoint(0, 0), QSize(qMin(twf->rect.width() - twf->tabBarSize.width() + overlap, twf->rect.width()), twf->rect.height()));
+                break;
+            case QTabBar::RoundedWest:
+            case QTabBar::TriangularWest:
+                r = QRect(QPoint(qMax(twf->tabBarSize.width() - overlap, 0), 0),
+                          QSize(qMin(twf->rect.width() - twf->tabBarSize.width() + overlap, twf->rect.width()), twf->rect.height()));
+                break;
+            }
+            if (sr == SE_TabWidgetTabContents && twf->lineWidth > 0)
+               r.adjust(2, 2, -2, -2);
+        }
+        break;
+    case SE_TabWidgetLeftCorner:
+        if (const QStyleOptionTabWidgetFrame *twf = qstyleoption_cast<const QStyleOptionTabWidgetFrame *>(opt)) {
+            QRect paneRect = subElementRect(SE_TabWidgetTabPane, twf, widget);
+            switch (twf->shape) {
+            case QTabBar::RoundedNorth:
+            case QTabBar::TriangularNorth:
+                r = QRect(QPoint(paneRect.x(), paneRect.y() - twf->leftCornerWidgetSize.height()),
+                          twf->leftCornerWidgetSize);
+                break;
+            case QTabBar::RoundedSouth:
+            case QTabBar::TriangularSouth:
+                r = QRect(QPoint(paneRect.x(), paneRect.height()), twf->leftCornerWidgetSize);
+               break;
+            default:
+               break;
+            }
+           r = visualRect(twf->direction, twf->rect, r);
+        }
+        break;
+   case SE_TabWidgetRightCorner:
+       if (const QStyleOptionTabWidgetFrame *twf = qstyleoption_cast<const QStyleOptionTabWidgetFrame *>(opt)) {
+           QRect paneRect = subElementRect(SE_TabWidgetTabPane, twf, widget);
+           switch (twf->shape) {
+           case QTabBar::RoundedNorth:
+           case QTabBar::TriangularNorth:
+                r = QRect(QPoint(paneRect.width() - twf->rightCornerWidgetSize.width(),
+                                 paneRect.y() - twf->rightCornerWidgetSize.height()),
+                          twf->rightCornerWidgetSize);
+               break;
+           case QTabBar::RoundedSouth:
+           case QTabBar::TriangularSouth:
+                r = QRect(QPoint(paneRect.width() - twf->rightCornerWidgetSize.width(),
+                                 paneRect.height()), twf->rightCornerWidgetSize);
+               break;
+           default:
+               break;
+           }
+           r = visualRect(twf->direction, twf->rect, r);
+        }
+        break;
+    case SE_TabBarTabText:
+        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(opt)) {
+            QStyleOptionTabV3 tabV3(*tab);
+            QRect dummyIconRect;
+            d->tabLayout(&tabV3, widget, &r, &dummyIconRect);
+        }
+        break;
+    case SE_TabBarTabLeftButton:
+    case SE_TabBarTabRightButton:
+        if (const QStyleOptionTabV3 *tab = qstyleoption_cast<const QStyleOptionTabV3 *>(opt)) {
+            bool selected = tab->state & State_Selected;
+            int verticalShift = proxy()->pixelMetric(QStyle::PM_TabBarTabShiftVertical, tab, widget);
+            int horizontalShift = proxy()->pixelMetric(QStyle::PM_TabBarTabShiftHorizontal, tab, widget);
+            int hpadding = proxy()->pixelMetric(QStyle::PM_TabBarTabHSpace, opt, widget) / 2;
+            hpadding = qMax(hpadding, 4); //workaround KStyle returning 0 because they workaround an old bug in Qt
+
+            bool verticalTabs = tab->shape == QTabBar::RoundedEast
+                    || tab->shape == QTabBar::RoundedWest
+                    || tab->shape == QTabBar::TriangularEast
+                    || tab->shape == QTabBar::TriangularWest;
+
+            QRect tr = tab->rect;
+            if (tab->shape == QTabBar::RoundedSouth || tab->shape == QTabBar::TriangularSouth)
+                verticalShift = -verticalShift;
+            if (verticalTabs) {
+                qSwap(horizontalShift, verticalShift);
+                horizontalShift *= -1;
+                verticalShift *= -1;
+            }
+            if (tab->shape == QTabBar::RoundedWest || tab->shape == QTabBar::TriangularWest)
+                horizontalShift = -horizontalShift;
+
+            tr.adjust(0, 0, horizontalShift, verticalShift);
+            if (selected)
+            {
+                tr.setBottom(tr.bottom() - verticalShift);
+                tr.setRight(tr.right() - horizontalShift);
+            }
+
+            QSize size = (sr == SE_TabBarTabLeftButton) ? tab->leftButtonSize : tab->rightButtonSize;
+            int w = size.width();
+            int h = size.height();
+            int midHeight = static_cast<int>(qCeil(float(tr.height() - h) / 2));
+            int midWidth = ((tr.width() - w) / 2);
+
+            bool atTheTop = true;
+            switch (tab->shape) {
+            case QTabBar::RoundedWest:
+            case QTabBar::TriangularWest:
+                atTheTop = (sr == SE_TabBarTabLeftButton);
+                break;
+            case QTabBar::RoundedEast:
+            case QTabBar::TriangularEast:
+                atTheTop = (sr == SE_TabBarTabRightButton);
+                break;
+            default:
+                if (sr == SE_TabBarTabLeftButton)
+                    r = QRect(tab->rect.x() + hpadding, midHeight, w, h);
+                else
+                    r = QRect(tab->rect.right() - w - hpadding, midHeight, w, h);
+                r = visualRect(tab->direction, tab->rect, r);
+            }
+            if (verticalTabs) {
+                if (atTheTop)
+                    r = QRect(midWidth, tr.y() + tab->rect.height() - hpadding - h, w, h);
+                else
+                    r = QRect(midWidth, tr.y() + hpadding, w, h);
+            }
+        }
+
+        break;
+#endif // QT_NO_TABWIDGET
+#ifndef QT_NO_TABBAR
+    case SE_TabBarTearIndicator:
+        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(opt)) {
+            switch (tab->shape) {
+            case QTabBar::RoundedNorth:
+            case QTabBar::TriangularNorth:
+            case QTabBar::RoundedSouth:
+            case QTabBar::TriangularSouth:
+                r.setRect(tab->rect.left(), tab->rect.top(), 4, opt->rect.height());
+                break;
+            case QTabBar::RoundedWest:
+            case QTabBar::TriangularWest:
+            case QTabBar::RoundedEast:
+            case QTabBar::TriangularEast:
+                r.setRect(tab->rect.left(), tab->rect.top(), opt->rect.width(), 4);
+                break;
+            default:
+                break;
+            }
+            r = visualRect(opt->direction, opt->rect, r);
+        }
+        break;
+#endif
+    case SE_TreeViewDisclosureItem:
+        r = opt->rect;
+        break;
+    case SE_LineEditContents:
+        if (const QStyleOptionFrame *f = qstyleoption_cast<const QStyleOptionFrame *>(opt)) {
+            r = f->rect.adjusted(f->lineWidth, f->lineWidth, -f->lineWidth, -f->lineWidth);
+            r = visualRect(opt->direction, opt->rect, r);
+        }
+        break;
+    case SE_FrameContents:
+        if (const QStyleOptionFrameV2 *f = qstyleoption_cast<const QStyleOptionFrameV2 *>(opt)) {
+            int fw = proxy()->pixelMetric(PM_DefaultFrameWidth, f, widget);
+            r = opt->rect.adjusted(fw, fw, -fw, -fw);
+            r = visualRect(opt->direction, opt->rect, r);
+        }
+        break;
+    case SE_ShapedFrameContents:
+        if (const QStyleOptionFrameV3 *f = qstyleoption_cast<const QStyleOptionFrameV3 *>(opt)) {
+            int frameShape  = f->frameShape;
+            int frameShadow = QFrame::Plain;
+            if (f->state & QStyle::State_Sunken) {
+                frameShadow = QFrame::Sunken;
+            } else if (f->state & QStyle::State_Raised) {
+                frameShadow = QFrame::Raised;
+            }
+
+            int frameWidth = 0;
+
+            switch (frameShape) {
+            case QFrame::NoFrame:
+                frameWidth = 0;
+                break;
+
+            case QFrame::Box:
+            case QFrame::HLine:
+            case QFrame::VLine:
+                switch (frameShadow) {
+                case QFrame::Plain:
+                    frameWidth = f->lineWidth;
+                    break;
+                case QFrame::Raised:
+                case QFrame::Sunken:
+                    frameWidth = (short)(f->lineWidth*2 + f->midLineWidth);
+                    break;
+                }
+                break;
+
+            case QFrame::StyledPanel:
+                //keep the compatibility with Qt 4.4 if there is a proxy style.
+                //be sure to call drawPrimitive(QStyle::SE_FrameContents) on the proxy style
+                if (widget)
+                    return widget->style()->subElementRect(QStyle::SE_FrameContents, opt, widget);
+                else
+                    return subElementRect(QStyle::SE_FrameContents, opt, widget);
+
+            case QFrame::WinPanel:
+                frameWidth = 2;
+                break;
+
+            case QFrame::Panel:
+                switch (frameShadow) {
+                case QFrame::Plain:
+                case QFrame::Raised:
+                case QFrame::Sunken:
+                    frameWidth = f->lineWidth;
+                    break;
+                }
+                break;
+            }
+            r = f->rect.adjusted(frameWidth, frameWidth, -frameWidth, -frameWidth);
+        }
+        break;
+#ifndef QT_NO_DOCKWIDGET
+    case SE_DockWidgetCloseButton:
+    case SE_DockWidgetFloatButton:
+    case SE_DockWidgetTitleBarText:
+    case SE_DockWidgetIcon: {
+        int iconSize = proxy()->pixelMetric(PM_SmallIconSize, opt, widget);
+        int buttonMargin = proxy()->pixelMetric(PM_DockWidgetTitleBarButtonMargin, opt, widget);
+        int margin = proxy()->pixelMetric(QStyle::PM_DockWidgetTitleMargin, opt, widget);
+        QRect rect = opt->rect;
+
+        const QStyleOptionDockWidget *dwOpt
+            = qstyleoption_cast<const QStyleOptionDockWidget*>(opt);
+        bool canClose = dwOpt == 0 ? true : dwOpt->closable;
+        bool canFloat = dwOpt == 0 ? false : dwOpt->floatable;
+        const QStyleOptionDockWidgetV2 *v2
+            = qstyleoption_cast<const QStyleOptionDockWidgetV2*>(opt);
+        bool verticalTitleBar = v2 == 0 ? false : v2->verticalTitleBar;
+
+        // If this is a vertical titlebar, we transpose and work as if it was
+        // horizontal, then transpose again.
+
+        if (verticalTitleBar) {
+            QSize size = rect.size();
+            size.transpose();
+            rect.setSize(size);
+        }
+
+        do {
+
+            int right = rect.right();
+            int left = rect.left();
+
+            QRect closeRect;
+            if (canClose) {
+                QSize sz = standardIcon(QStyle::SP_TitleBarCloseButton,
+                                        opt, widget).actualSize(QSize(iconSize, iconSize));
+                sz += QSize(buttonMargin, buttonMargin);
+                if (verticalTitleBar)
+                    sz.transpose();
+                closeRect = QRect(right - sz.width(),
+                                    rect.center().y() - sz.height()/2,
+                                    sz.width(), sz.height());
+                right = closeRect.left() - 1;
+            }
+            if (sr == SE_DockWidgetCloseButton) {
+                r = closeRect;
+                break;
+            }
+
+            QRect floatRect;
+            if (canFloat) {
+                QSize sz = standardIcon(QStyle::SP_TitleBarNormalButton,
+                                        opt, widget).actualSize(QSize(iconSize, iconSize));
+                sz += QSize(buttonMargin, buttonMargin);
+                if (verticalTitleBar)
+                    sz.transpose();
+                floatRect = QRect(right - sz.width(),
+                                    rect.center().y() - sz.height()/2,
+                                    sz.width(), sz.height());
+                right = floatRect.left() - 1;
+            }
+            if (sr == SE_DockWidgetFloatButton) {
+                r = floatRect;
+                break;
+            }
+
+            QRect iconRect;
+            if (const QDockWidget *dw = qobject_cast<const QDockWidget*>(widget)) {
+                QIcon icon;
+                if (dw->isFloating())
+                    icon = dw->windowIcon();
+                if (!icon.isNull()
+                        && icon.cacheKey() != QApplication::windowIcon().cacheKey()) {
+                    QSize sz = icon.actualSize(QSize(r.height(), r.height()));
+                    if (verticalTitleBar)
+                        sz.transpose();
+                    iconRect = QRect(left, rect.center().y() - sz.height()/2,
+                                        sz.width(), sz.height());
+                    left = iconRect.right() + margin;
+                }
+            }
+            if (sr == SE_DockWidgetIcon) {
+                r = iconRect;
+                break;
+            }
+
+            QRect textRect = QRect(left, rect.top(),
+                                    right - left, rect.height());
+            if (sr == SE_DockWidgetTitleBarText) {
+                r = textRect;
+                break;
+            }
+
+        } while (false);
+
+        if (verticalTitleBar) {
+            r = QRect(rect.left() + r.top() - rect.top(),
+                        rect.top() + rect.right() - r.right(),
+                        r.height(), r.width());
+        } else {
+            r = visualRect(opt->direction, rect, r);
+        }
+        break;
+    }
+#endif
+#ifndef QT_NO_ITEMVIEWS
+    case SE_ItemViewItemCheckIndicator:
+        if (!qstyleoption_cast<const QStyleOptionViewItem *>(opt)) {
+            r = subElementRect(SE_CheckBoxIndicator, opt, widget);
+            break;
+        }
+    case SE_ItemViewItemDecoration:
+    case SE_ItemViewItemText:
+    case SE_ItemViewItemFocusRect:
+        if (const QStyleOptionViewItem *vopt = qstyleoption_cast<const QStyleOptionViewItem *>(opt)) {
+            if (!d->isViewItemCached(*vopt)) {
+                d->viewItemLayout(vopt, &d->checkRect, &d->decorationRect, &d->displayRect, false);
+                if (d->cachedOption) {
+                    delete d->cachedOption;
+                    d->cachedOption = 0;
+                }
+                d->cachedOption = new QStyleOptionViewItem(*vopt);
+            }
+            if (sr == SE_ViewItemCheckIndicator)
+                r = d->checkRect;
+            else if (sr == SE_ItemViewItemDecoration)
+                r = d->decorationRect;
+            else if (sr == SE_ItemViewItemText || sr == SE_ItemViewItemFocusRect)
+                r = d->displayRect;
+                               }
+        break;
+#endif //QT_NO_ITEMVIEWS
+#ifndef QT_NO_TOOLBAR
+    case SE_ToolBarHandle:
+        if (const QStyleOptionToolBar *tbopt = qstyleoption_cast<const QStyleOptionToolBar *>(opt)) {
+            if (tbopt->features & QStyleOptionToolBar::Movable) {
+                ///we need to access the widget here because the style option doesn't
+                //have all the information we need (ie. the layout's margin)
+                const QToolBar *tb = qobject_cast<const QToolBar*>(widget);
+                const int margin = tb && tb->layout() ? tb->layout()->margin() : 2;
+                const int handleExtent = pixelMetric(QStyle::PM_ToolBarHandleExtent, opt, tb);
+                if (tbopt->state & QStyle::State_Horizontal) {
+                    r = QRect(margin, margin, handleExtent, tbopt->rect.height() - 2*margin);
+                    r = QStyle::visualRect(tbopt->direction, tbopt->rect, r);
+                } else {
+                    r = QRect(margin, margin, tbopt->rect.width() - 2*margin, handleExtent);
+                }
+            }
+        }
+        break;
+#endif //QT_NO_TOOLBAR
+    default:
+        break;
+    }
+    return r;
+}
+
+#ifndef QT_NO_DIAL
+
+static QPolygonF calcArrow(const QStyleOptionSlider *dial, qreal &a)
+{
+    int width = dial->rect.width();
+    int height = dial->rect.height();
+    int r = qMin(width, height) / 2;
+    int currentSliderPosition = dial->upsideDown ? dial->sliderPosition : (dial->maximum - dial->sliderPosition);
+
+    if (dial->maximum == dial->minimum)
+        a = Q_PI / 2;
+    else if (dial->dialWrapping)
+        a = Q_PI * 3 / 2 - (currentSliderPosition - dial->minimum) * 2 * Q_PI
+            / (dial->maximum - dial->minimum);
+    else
+        a = (Q_PI * 8 - (currentSliderPosition - dial->minimum) * 10 * Q_PI
+            / (dial->maximum - dial->minimum)) / 6;
+
+    int xc = width / 2;
+    int yc = height / 2;
+
+    int len = r - QStyleHelper::calcBigLineSize(r) - 5;
+    if (len < 5)
+        len = 5;
+    int back = len / 2;
+
+    QPolygonF arrow(3);
+    arrow[0] = QPointF(0.5 + xc + len * qCos(a),
+                       0.5 + yc - len * qSin(a));
+    arrow[1] = QPointF(0.5 + xc + back * qCos(a + Q_PI * 5 / 6),
+                       0.5 + yc - back * qSin(a + Q_PI * 5 / 6));
+    arrow[2] = QPointF(0.5 + xc + back * qCos(a - Q_PI * 5 / 6),
+                       0.5 + yc - back * qSin(a - Q_PI * 5 / 6));
+    return arrow;
+}
+
+#endif // QT_NO_DIAL
+
+/*!
+  \reimp
+*/
+void QCommonStyle::drawComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
+                                      QPainter *p, const QWidget *widget) const
+{
+    switch (cc) {
+#ifndef QT_NO_SLIDER
+    case CC_Slider:
+        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+            if (slider->subControls == SC_SliderTickmarks) {
+                int tickOffset = proxy()->pixelMetric(PM_SliderTickmarkOffset, slider, widget);
+                int ticks = slider->tickPosition;
+                int thickness = proxy()->pixelMetric(PM_SliderControlThickness, slider, widget);
+                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
+                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
+                int interval = slider->tickInterval;
+                if (interval <= 0) {
+                    interval = slider->singleStep;
+                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
+                                                        available)
+                        - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
+                                                          0, available) < 3)
+                        interval = slider->pageStep;
+                }
+                if (!interval)
+                    interval = 1;
+                int fudge = len / 2;
+                int pos;
+                // Since there is no subrect for tickmarks do a translation here.
+                p->save();
+                p->translate(slider->rect.x(), slider->rect.y());
+                p->setPen(slider->palette.foreground().color());
+                int v = slider->minimum;
+                while (v <= slider->maximum + 1) {
+                    if (v == slider->maximum + 1 && interval == 1)
+                        break;
+                    const int v_ = qMin(v, slider->maximum);
+                    pos = QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
+                                                          v_, available) + fudge;
+                    if (slider->orientation == Qt::Horizontal) {
+                        if (ticks & QSlider::TicksAbove)
+                            p->drawLine(pos, 0, pos, tickOffset - 2);
+                        if (ticks & QSlider::TicksBelow)
+                            p->drawLine(pos, tickOffset + thickness + 1, pos,
+                                        slider->rect.height()-1);
+                    } else {
+                        if (ticks & QSlider::TicksAbove)
+                            p->drawLine(0, pos, tickOffset - 2, pos);
+                        if (ticks & QSlider::TicksBelow)
+                            p->drawLine(tickOffset + thickness + 1, pos,
+                                        slider->rect.width()-1, pos);
+                    }
+                    // in the case where maximum is max int
+                    int nextInterval = v + interval;
+                    if (nextInterval < v)
+                        break;
+                    v = nextInterval;
+                }
+                p->restore();
+            }
+        }
+        break;
+#endif // QT_NO_SLIDER
+#ifndef QT_NO_SCROLLBAR
+    case CC_ScrollBar:
+        if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+            // Make a copy here and reset it for each primitive.
+            QStyleOptionSlider newScrollbar = *scrollbar;
+            State saveFlags = scrollbar->state;
+
+            if (scrollbar->subControls & SC_ScrollBarSubLine) {
+                newScrollbar.state = saveFlags;
+                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarSubLine, widget);
+                if (newScrollbar.rect.isValid()) {
+                    if (!(scrollbar->activeSubControls & SC_ScrollBarSubLine))
+                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
+                    proxy()->drawControl(CE_ScrollBarSubLine, &newScrollbar, p, widget);
+                }
+            }
+            if (scrollbar->subControls & SC_ScrollBarAddLine) {
+                newScrollbar.rect = scrollbar->rect;
+                newScrollbar.state = saveFlags;
+                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarAddLine, widget);
+                if (newScrollbar.rect.isValid()) {
+                    if (!(scrollbar->activeSubControls & SC_ScrollBarAddLine))
+                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
+                    proxy()->drawControl(CE_ScrollBarAddLine, &newScrollbar, p, widget);
+                }
+            }
+            if (scrollbar->subControls & SC_ScrollBarSubPage) {
+                newScrollbar.rect = scrollbar->rect;
+                newScrollbar.state = saveFlags;
+                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarSubPage, widget);
+                if (newScrollbar.rect.isValid()) {
+                    if (!(scrollbar->activeSubControls & SC_ScrollBarSubPage))
+                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
+                    proxy()->drawControl(CE_ScrollBarSubPage, &newScrollbar, p, widget);
+                }
+            }
+            if (scrollbar->subControls & SC_ScrollBarAddPage) {
+                newScrollbar.rect = scrollbar->rect;
+                newScrollbar.state = saveFlags;
+                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarAddPage, widget);
+                if (newScrollbar.rect.isValid()) {
+                    if (!(scrollbar->activeSubControls & SC_ScrollBarAddPage))
+                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
+                    proxy()->drawControl(CE_ScrollBarAddPage, &newScrollbar, p, widget);
+                }
+            }
+            if (scrollbar->subControls & SC_ScrollBarFirst) {
+                newScrollbar.rect = scrollbar->rect;
+                newScrollbar.state = saveFlags;
+                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarFirst, widget);
+                if (newScrollbar.rect.isValid()) {
+                    if (!(scrollbar->activeSubControls & SC_ScrollBarFirst))
+                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
+                    proxy()->drawControl(CE_ScrollBarFirst, &newScrollbar, p, widget);
+                }
+            }
+            if (scrollbar->subControls & SC_ScrollBarLast) {
+                newScrollbar.rect = scrollbar->rect;
+                newScrollbar.state = saveFlags;
+                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarLast, widget);
+                if (newScrollbar.rect.isValid()) {
+                    if (!(scrollbar->activeSubControls & SC_ScrollBarLast))
+                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
+                    proxy()->drawControl(CE_ScrollBarLast, &newScrollbar, p, widget);
+                }
+            }
+            if (scrollbar->subControls & SC_ScrollBarSlider) {
+                newScrollbar.rect = scrollbar->rect;
+                newScrollbar.state = saveFlags;
+                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarSlider, widget);
+                if (newScrollbar.rect.isValid()) {
+                    if (!(scrollbar->activeSubControls & SC_ScrollBarSlider))
+                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
+                    proxy()->drawControl(CE_ScrollBarSlider, &newScrollbar, p, widget);
+
+                    if (scrollbar->state & State_HasFocus) {
+                        QStyleOptionFocusRect fropt;
+                        fropt.QStyleOption::operator=(newScrollbar);
+                        fropt.rect.setRect(newScrollbar.rect.x() + 2, newScrollbar.rect.y() + 2,
+                                           newScrollbar.rect.width() - 5,
+                                           newScrollbar.rect.height() - 5);
+                        proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, p, widget);
+                    }
+                }
+            }
+        }
+        break;
+#endif // QT_NO_SCROLLBAR
+#ifndef QT_NO_SPINBOX
+    case CC_SpinBox:
+        if (const QStyleOptionSpinBox *sb = qstyleoption_cast<const QStyleOptionSpinBox *>(opt)) {
+            QStyleOptionSpinBox copy = *sb;
+            PrimitiveElement pe;
+
+            if (sb->frame && (sb->subControls & SC_SpinBoxFrame)) {
+                QRect r = proxy()->subControlRect(CC_SpinBox, sb, SC_SpinBoxFrame, widget);
+                qDrawWinPanel(p, r, sb->palette, true);
+            }
+
+            if (sb->subControls & SC_SpinBoxUp) {
+                copy.subControls = SC_SpinBoxUp;
+                QPalette pal2 = sb->palette;
+                if (!(sb->stepEnabled & QAbstractSpinBox::StepUpEnabled)) {
+                    pal2.setCurrentColorGroup(QPalette::Disabled);
+                    copy.state &= ~State_Enabled;
+                }
+
+                copy.palette = pal2;
+
+                if (sb->activeSubControls == SC_SpinBoxUp && (sb->state & State_Sunken)) {
+                    copy.state |= State_On;
+                    copy.state |= State_Sunken;
+                } else {
+                    copy.state |= State_Raised;
+                    copy.state &= ~State_Sunken;
+                }
+                pe = (sb->buttonSymbols == QAbstractSpinBox::PlusMinus ? PE_IndicatorSpinPlus
+                      : PE_IndicatorSpinUp);
+
+                copy.rect = proxy()->subControlRect(CC_SpinBox, sb, SC_SpinBoxUp, widget);
+                proxy()->drawPrimitive(PE_PanelButtonBevel, &copy, p, widget);
+                copy.rect.adjust(3, 0, -4, 0);
+                proxy()->drawPrimitive(pe, &copy, p, widget);
+            }
+
+            if (sb->subControls & SC_SpinBoxDown) {
+                copy.subControls = SC_SpinBoxDown;
+                copy.state = sb->state;
+                QPalette pal2 = sb->palette;
+                if (!(sb->stepEnabled & QAbstractSpinBox::StepDownEnabled)) {
+                    pal2.setCurrentColorGroup(QPalette::Disabled);
+                    copy.state &= ~State_Enabled;
+                }
+                copy.palette = pal2;
+
+                if (sb->activeSubControls == SC_SpinBoxDown && (sb->state & State_Sunken)) {
+                    copy.state |= State_On;
+                    copy.state |= State_Sunken;
+                } else {
+                    copy.state |= State_Raised;
+                    copy.state &= ~State_Sunken;
+                }
+                pe = (sb->buttonSymbols == QAbstractSpinBox::PlusMinus ? PE_IndicatorSpinMinus
+                      : PE_IndicatorSpinDown);
+
+                copy.rect = proxy()->subControlRect(CC_SpinBox, sb, SC_SpinBoxDown, widget);
+                proxy()->drawPrimitive(PE_PanelButtonBevel, &copy, p, widget);
+                copy.rect.adjust(3, 0, -4, 0);
+                proxy()->drawPrimitive(pe, &copy, p, widget);
+            }
+        }
+        break;
+#endif // QT_NO_SPINBOX
+#ifndef QT_NO_TOOLBUTTON
+    case CC_ToolButton:
+        if (const QStyleOptionToolButton *toolbutton
+            = qstyleoption_cast<const QStyleOptionToolButton *>(opt)) {
+            QRect button, menuarea;
+            button = proxy()->subControlRect(cc, toolbutton, SC_ToolButton, widget);
+            menuarea = proxy()->subControlRect(cc, toolbutton, SC_ToolButtonMenu, widget);
+
+            State bflags = toolbutton->state & ~State_Sunken;
+
+            if (bflags & State_AutoRaise) {
+                if (!(bflags & State_MouseOver) || !(bflags & State_Enabled)) {
+                    bflags &= ~State_Raised;
+                }
+            }
+            State mflags = bflags;
+            if (toolbutton->state & State_Sunken) {
+                if (toolbutton->activeSubControls & SC_ToolButton)
+                    bflags |= State_Sunken;
+                mflags |= State_Sunken;
+            }
+
+            QStyleOption tool(0);
+            tool.palette = toolbutton->palette;
+            if (toolbutton->subControls & SC_ToolButton) {
+                if (bflags & (State_Sunken | State_On | State_Raised)) {
+                    tool.rect = button;
+                    tool.state = bflags;
+                    proxy()->drawPrimitive(PE_PanelButtonTool, &tool, p, widget);
+                }
+            }
+
+            if (toolbutton->state & State_HasFocus) {
+                QStyleOptionFocusRect fr;
+                fr.QStyleOption::operator=(*toolbutton);
+                fr.rect.adjust(3, 3, -3, -3);
+                if (toolbutton->features & QStyleOptionToolButton::MenuButtonPopup)
+                    fr.rect.adjust(0, 0, -proxy()->pixelMetric(QStyle::PM_MenuButtonIndicator,
+                                                      toolbutton, widget), 0);
+                proxy()->drawPrimitive(PE_FrameFocusRect, &fr, p, widget);
+            }
+            QStyleOptionToolButton label = *toolbutton;
+            label.state = bflags;
+            int fw = proxy()->pixelMetric(PM_DefaultFrameWidth, opt, widget);
+            label.rect = button.adjusted(fw, fw, -fw, -fw);
+            proxy()->drawControl(CE_ToolButtonLabel, &label, p, widget);
+
+            if (toolbutton->subControls & SC_ToolButtonMenu) {
+                tool.rect = menuarea;
+                tool.state = mflags;
+                if (mflags & (State_Sunken | State_On | State_Raised))
+                    proxy()->drawPrimitive(PE_IndicatorButtonDropDown, &tool, p, widget);
+                proxy()->drawPrimitive(PE_IndicatorArrowDown, &tool, p, widget);
+            } else if (toolbutton->features & QStyleOptionToolButton::HasMenu) {
+                int mbi = proxy()->pixelMetric(PM_MenuButtonIndicator, toolbutton, widget);
+                QRect ir = toolbutton->rect;
+                QStyleOptionToolButton newBtn = *toolbutton;
+                newBtn.rect = QRect(ir.right() + 5 - mbi, ir.y() + ir.height() - mbi + 4, mbi - 6, mbi - 6);
+                proxy()->drawPrimitive(PE_IndicatorArrowDown, &newBtn, p, widget);
+            }
+        }
+        break;
+#endif // QT_NO_TOOLBUTTON
+    case CC_TitleBar:
+        if (const QStyleOptionTitleBar *tb = qstyleoption_cast<const QStyleOptionTitleBar *>(opt)) {
+            QRect ir;
+            if (opt->subControls & SC_TitleBarLabel) {
+                QColor left = tb->palette.highlight().color();
+                QColor right = tb->palette.base().color();
+
+                QBrush fillBrush(left);
+                if (left != right) {
+                    QPoint p1(tb->rect.x(), tb->rect.top() + tb->rect.height()/2);
+                    QPoint p2(tb->rect.right(), tb->rect.top() + tb->rect.height()/2);
+                    QLinearGradient lg(p1, p2);
+                    lg.setColorAt(0, left);
+                    lg.setColorAt(1, right);
+                    fillBrush = lg;
+                }
+
+                p->fillRect(opt->rect, fillBrush);
+
+                ir = proxy()->subControlRect(CC_TitleBar, tb, SC_TitleBarLabel, widget);
+
+                p->setPen(tb->palette.highlightedText().color());
+                p->drawText(ir.x() + 2, ir.y(), ir.width() - 2, ir.height(),
+                            Qt::AlignLeft | Qt::AlignVCenter | Qt::TextSingleLine, tb->text);
+            }
+
+            bool down = false;
+            QPixmap pm;
+
+            QStyleOption tool(0);
+            tool.palette = tb->palette;
+            if (tb->subControls & SC_TitleBarCloseButton && tb->titleBarFlags & Qt::WindowSystemMenuHint) {
+                ir = proxy()->subControlRect(CC_TitleBar, tb, SC_TitleBarCloseButton, widget);
+                down = tb->activeSubControls & SC_TitleBarCloseButton && (opt->state & State_Sunken);
+                if ((tb->titleBarFlags & Qt::WindowType_Mask) == Qt::Tool
+#ifndef QT_NO_DOCKWIDGET
+                    || qobject_cast<const QDockWidget *>(widget)
+#endif
+                    )
+                    pm = standardIcon(SP_DockWidgetCloseButton, &tool, widget).pixmap(10, 10);
+                else
+                    pm = standardIcon(SP_TitleBarCloseButton, &tool, widget).pixmap(10, 10);
+                tool.rect = ir;
+                tool.state = down ? State_Sunken : State_Raised;
+                proxy()->drawPrimitive(PE_PanelButtonTool, &tool, p, widget);
+
+                p->save();
+                if (down)
+                    p->translate(proxy()->pixelMetric(PM_ButtonShiftHorizontal, tb, widget),
+                                 proxy()->pixelMetric(PM_ButtonShiftVertical, tb, widget));
+                proxy()->drawItemPixmap(p, ir, Qt::AlignCenter, pm);
+                p->restore();
+            }
+
+            if (tb->subControls & SC_TitleBarMaxButton
+                    && tb->titleBarFlags & Qt::WindowMaximizeButtonHint
+                    && !(tb->titleBarState & Qt::WindowMaximized)) {
+                ir = proxy()->subControlRect(CC_TitleBar, tb, SC_TitleBarMaxButton, widget);
+
+                down = tb->activeSubControls & SC_TitleBarMaxButton && (opt->state & State_Sunken);
+                pm = standardIcon(SP_TitleBarMaxButton, &tool, widget).pixmap(10, 10);
+                tool.rect = ir;
+                tool.state = down ? State_Sunken : State_Raised;
+                proxy()->drawPrimitive(PE_PanelButtonTool, &tool, p, widget);
+
+                p->save();
+                if (down)
+                    p->translate(proxy()->pixelMetric(PM_ButtonShiftHorizontal, tb, widget),
+                                 proxy()->pixelMetric(PM_ButtonShiftVertical, tb, widget));
+                proxy()->drawItemPixmap(p, ir, Qt::AlignCenter, pm);
+                p->restore();
+            }
+
+            if (tb->subControls & SC_TitleBarMinButton
+                    && tb->titleBarFlags & Qt::WindowMinimizeButtonHint
+                    && !(tb->titleBarState & Qt::WindowMinimized)) {
+                ir = proxy()->subControlRect(CC_TitleBar, tb, SC_TitleBarMinButton, widget);
+                down = tb->activeSubControls & SC_TitleBarMinButton && (opt->state & State_Sunken);
+                pm = standardIcon(SP_TitleBarMinButton, &tool, widget).pixmap(10, 10);
+                tool.rect = ir;
+                tool.state = down ? State_Sunken : State_Raised;
+                proxy()->drawPrimitive(PE_PanelButtonTool, &tool, p, widget);
+
+                p->save();
+                if (down)
+                    p->translate(proxy()->pixelMetric(PM_ButtonShiftHorizontal, tb, widget),
+                                 proxy()->pixelMetric(PM_ButtonShiftVertical, tb, widget));
+                proxy()->drawItemPixmap(p, ir, Qt::AlignCenter, pm);
+                p->restore();
+            }
+
+            bool drawNormalButton = (tb->subControls & SC_TitleBarNormalButton)
+                                    && (((tb->titleBarFlags & Qt::WindowMinimizeButtonHint)
+                                    && (tb->titleBarState & Qt::WindowMinimized))
+                                    || ((tb->titleBarFlags & Qt::WindowMaximizeButtonHint)
+                                    && (tb->titleBarState & Qt::WindowMaximized)));
+
+            if (drawNormalButton) {
+                ir = proxy()->subControlRect(CC_TitleBar, tb, SC_TitleBarNormalButton, widget);
+                down = tb->activeSubControls & SC_TitleBarNormalButton && (opt->state & State_Sunken);
+                pm = standardIcon(SP_TitleBarNormalButton, &tool, widget).pixmap(10, 10);
+                tool.rect = ir;
+                tool.state = down ? State_Sunken : State_Raised;
+                proxy()->drawPrimitive(PE_PanelButtonTool, &tool, p, widget);
+
+                p->save();
+                if (down)
+                    p->translate(proxy()->pixelMetric(PM_ButtonShiftHorizontal, tb, widget),
+                                 proxy()->pixelMetric(PM_ButtonShiftVertical, tb, widget));
+                proxy()->drawItemPixmap(p, ir, Qt::AlignCenter, pm);
+                p->restore();
+            }
+
+            if (tb->subControls & SC_TitleBarShadeButton
+                    && tb->titleBarFlags & Qt::WindowShadeButtonHint
+                    && !(tb->titleBarState & Qt::WindowMinimized)) {
+                ir = proxy()->subControlRect(CC_TitleBar, tb, SC_TitleBarShadeButton, widget);
+                down = (tb->activeSubControls & SC_TitleBarShadeButton && (opt->state & State_Sunken));
+                pm = standardIcon(SP_TitleBarShadeButton, &tool, widget).pixmap(10, 10);
+                tool.rect = ir;
+                tool.state = down ? State_Sunken : State_Raised;
+                proxy()->drawPrimitive(PE_PanelButtonTool, &tool, p, widget);
+                p->save();
+                if (down)
+                    p->translate(proxy()->pixelMetric(PM_ButtonShiftHorizontal, tb, widget),
+                                 proxy()->pixelMetric(PM_ButtonShiftVertical, tb, widget));
+                proxy()->drawItemPixmap(p, ir, Qt::AlignCenter, pm);
+                p->restore();
+            }
+
+            if (tb->subControls & SC_TitleBarUnshadeButton
+                    && tb->titleBarFlags & Qt::WindowShadeButtonHint
+                    && tb->titleBarState & Qt::WindowMinimized) {
+                ir = proxy()->subControlRect(CC_TitleBar, tb, SC_TitleBarUnshadeButton, widget);
+
+                down = tb->activeSubControls & SC_TitleBarUnshadeButton  && (opt->state & State_Sunken);
+                pm = standardIcon(SP_TitleBarUnshadeButton, &tool, widget).pixmap(10, 10);
+                tool.rect = ir;
+                tool.state = down ? State_Sunken : State_Raised;
+                proxy()->drawPrimitive(PE_PanelButtonTool, &tool, p, widget);
+                p->save();
+                if (down)
+                    p->translate(proxy()->pixelMetric(PM_ButtonShiftHorizontal, tb, widget),
+                                 proxy()->pixelMetric(PM_ButtonShiftVertical, tb, widget));
+                proxy()->drawItemPixmap(p, ir, Qt::AlignCenter, pm);
+                p->restore();
+            }
+            if (tb->subControls & SC_TitleBarContextHelpButton
+                    && tb->titleBarFlags & Qt::WindowContextHelpButtonHint) {
+                ir = proxy()->subControlRect(CC_TitleBar, tb, SC_TitleBarContextHelpButton, widget);
+
+                down = tb->activeSubControls & SC_TitleBarContextHelpButton  && (opt->state & State_Sunken);
+                pm = standardIcon(SP_TitleBarContextHelpButton, &tool, widget).pixmap(10, 10);
+                tool.rect = ir;
+                tool.state = down ? State_Sunken : State_Raised;
+                proxy()->drawPrimitive(PE_PanelButtonTool, &tool, p, widget);
+                p->save();
+                if (down)
+                    p->translate(proxy()->pixelMetric(PM_ButtonShiftHorizontal, tb, widget),
+                                 proxy()->pixelMetric(PM_ButtonShiftVertical, tb, widget));
+                proxy()->drawItemPixmap(p, ir, Qt::AlignCenter, pm);
+                p->restore();
+            }
+            if (tb->subControls & SC_TitleBarSysMenu && tb->titleBarFlags & Qt::WindowSystemMenuHint) {
+                ir = proxy()->subControlRect(CC_TitleBar, tb, SC_TitleBarSysMenu, widget);
+                if (!tb->icon.isNull()) {
+                    tb->icon.paint(p, ir);
+                } else {
+                    int iconSize = proxy()->pixelMetric(PM_SmallIconSize, tb, widget);
+                    pm = standardIcon(SP_TitleBarMenuButton, &tool, widget).pixmap(iconSize, iconSize);
+                    tool.rect = ir;
+                    p->save();
+                    proxy()->drawItemPixmap(p, ir, Qt::AlignCenter, pm);
+                    p->restore();
+                }
+            }
+        }
+        break;
+#ifndef QT_NO_DIAL
+    case CC_Dial:
+        if (const QStyleOptionSlider *dial = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+            // OK, this is more a port of things over
+            p->save();
+
+            // avoid dithering
+            if (p->paintEngine()->hasFeature(QPaintEngine::Antialiasing))
+                p->setRenderHint(QPainter::Antialiasing);
+
+            int width = dial->rect.width();
+            int height = dial->rect.height();
+            qreal r = qMin(width, height) / 2;
+            qreal d_ = r / 6;
+            qreal dx = dial->rect.x() + d_ + (width - 2 * r) / 2 + 1;
+            qreal dy = dial->rect.y() + d_ + (height - 2 * r) / 2 + 1;
+            QRect br = QRect(int(dx), int(dy), int(r * 2 - 2 * d_ - 2), int(r * 2 - 2 * d_ - 2));
+
+            QPalette pal = opt->palette;
+            // draw notches
+            if (dial->subControls & QStyle::SC_DialTickmarks) {
+                p->setPen(pal.foreground().color());
+                p->drawLines(QStyleHelper::calcLines(dial));
+            }
+
+            if (dial->state & State_Enabled) {
+                p->setBrush(pal.brush(QPalette::ColorRole(proxy()->styleHint(SH_Dial_BackgroundRole,
+                                                                    dial, widget))));
+                p->setPen(Qt::NoPen);
+                p->drawEllipse(br);
+                p->setBrush(Qt::NoBrush);
+            }
+            p->setPen(QPen(pal.dark().color()));
+            p->drawArc(br, 60 * 16, 180 * 16);
+            p->setPen(QPen(pal.light().color()));
+            p->drawArc(br, 240 * 16, 180 * 16);
+
+            qreal a;
+            QPolygonF arrow(calcArrow(dial, a));
+
+            p->setPen(Qt::NoPen);
+            p->setBrush(pal.button());
+            p->setRenderHint(QPainter::Qt4CompatiblePainting);
+            p->drawPolygon(arrow);
+
+            a = QStyleHelper::angle(QPointF(width / 2, height / 2), arrow[0]);
+            p->setBrush(Qt::NoBrush);
+
+            if (a <= 0 || a > 200) {
+                p->setPen(pal.light().color());
+                p->drawLine(arrow[2], arrow[0]);
+                p->drawLine(arrow[1], arrow[2]);
+                p->setPen(pal.dark().color());
+                p->drawLine(arrow[0], arrow[1]);
+            } else if (a > 0 && a < 45) {
+                p->setPen(pal.light().color());
+                p->drawLine(arrow[2], arrow[0]);
+                p->setPen(pal.dark().color());
+                p->drawLine(arrow[1], arrow[2]);
+                p->drawLine(arrow[0], arrow[1]);
+            } else if (a >= 45 && a < 135) {
+                p->setPen(pal.dark().color());
+                p->drawLine(arrow[2], arrow[0]);
+                p->drawLine(arrow[1], arrow[2]);
+                p->setPen(pal.light().color());
+                p->drawLine(arrow[0], arrow[1]);
+            } else if (a >= 135 && a < 200) {
+                p->setPen(pal.dark().color());
+                p->drawLine(arrow[2], arrow[0]);
+                p->setPen(pal.light().color());
+                p->drawLine(arrow[0], arrow[1]);
+                p->drawLine(arrow[1], arrow[2]);
+            }
+
+            // draw focus rect around the dial
+            QStyleOptionFocusRect fropt;
+            fropt.rect = dial->rect;
+            fropt.state = dial->state;
+            fropt.palette = dial->palette;
+            if (fropt.state & QStyle::State_HasFocus) {
+                br.adjust(0, 0, 2, 2);
+                if (dial->subControls & SC_DialTickmarks) {
+                    int r = qMin(width, height) / 2;
+                    br.translate(-r / 6, - r / 6);
+                    br.setWidth(br.width() + r / 3);
+                    br.setHeight(br.height() + r / 3);
+                }
+                fropt.rect = br.adjusted(-2, -2, 2, 2);
+                proxy()->drawPrimitive(QStyle::PE_FrameFocusRect, &fropt, p, widget);
+            }
+            p->restore();
+        }
+        break;
+#endif // QT_NO_DIAL
+#ifndef QT_NO_GROUPBOX
+    case CC_GroupBox:
+        if (const QStyleOptionGroupBox *groupBox = qstyleoption_cast<const QStyleOptionGroupBox *>(opt)) {
+            // Draw frame
+            QRect textRect = proxy()->subControlRect(CC_GroupBox, opt, SC_GroupBoxLabel, widget);
+            QRect checkBoxRect = proxy()->subControlRect(CC_GroupBox, opt, SC_GroupBoxCheckBox, widget);
+            if (groupBox->subControls & QStyle::SC_GroupBoxFrame) {
+                QStyleOptionFrameV2 frame;
+                frame.QStyleOption::operator=(*groupBox);
+                frame.features = groupBox->features;
+                frame.lineWidth = groupBox->lineWidth;
+                frame.midLineWidth = groupBox->midLineWidth;
+                frame.rect = proxy()->subControlRect(CC_GroupBox, opt, SC_GroupBoxFrame, widget);
+                p->save();
+                QRegion region(groupBox->rect);
+                if (!groupBox->text.isEmpty()) {
+                    bool ltr = groupBox->direction == Qt::LeftToRight;
+                    QRect finalRect;
+                    if (groupBox->subControls & QStyle::SC_GroupBoxCheckBox) {
+                        finalRect = checkBoxRect.united(textRect);
+                        finalRect.adjust(ltr ? -4 : 0, 0, ltr ? 0 : 4, 0);
+                    } else {
+                        finalRect = textRect;
+                    }
+                    region -= finalRect;
+                }
+                p->setClipRegion(region);
+                proxy()->drawPrimitive(PE_FrameGroupBox, &frame, p, widget);
+                p->restore();
+            }
+
+            // Draw title
+            if ((groupBox->subControls & QStyle::SC_GroupBoxLabel) && !groupBox->text.isEmpty()) {
+                QColor textColor = groupBox->textColor;
+                if (textColor.isValid())
+                    p->setPen(textColor);
+                int alignment = int(groupBox->textAlignment);
+                if (!proxy()->styleHint(QStyle::SH_UnderlineShortcut, opt, widget))
+                    alignment |= Qt::TextHideMnemonic;
+
+                proxy()->drawItemText(p, textRect,  Qt::TextShowMnemonic | Qt::AlignHCenter | alignment,
+                             groupBox->palette, groupBox->state & State_Enabled, groupBox->text,
+                             textColor.isValid() ? QPalette::NoRole : QPalette::WindowText);
+
+                if (groupBox->state & State_HasFocus) {
+                    QStyleOptionFocusRect fropt;
+                    fropt.QStyleOption::operator=(*groupBox);
+                    fropt.rect = textRect;
+                    proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, p, widget);
+                }
+            }
+
+            // Draw checkbox
+            if (groupBox->subControls & SC_GroupBoxCheckBox) {
+                QStyleOptionButton box;
+                box.QStyleOption::operator=(*groupBox);
+                box.rect = checkBoxRect;
+                proxy()->drawPrimitive(PE_IndicatorCheckBox, &box, p, widget);
+            }
+        }
+        break;
+#endif // QT_NO_GROUPBOX
+#ifndef QT_NO_MDIAREA
+    case CC_MdiControls:
+        {
+            QStyleOptionButton btnOpt;
+            btnOpt.QStyleOption::operator=(*opt);
+            btnOpt.state &= ~State_MouseOver;
+            int bsx = 0;
+            int bsy = 0;
+            if (opt->subControls & QStyle::SC_MdiCloseButton) {
+                if (opt->activeSubControls & QStyle::SC_MdiCloseButton && (opt->state & State_Sunken)) {
+                    btnOpt.state |= State_Sunken;
+                    btnOpt.state &= ~State_Raised;
+                    bsx = proxy()->pixelMetric(PM_ButtonShiftHorizontal);
+                    bsy = proxy()->pixelMetric(PM_ButtonShiftVertical);
+                } else {
+                    btnOpt.state |= State_Raised;
+                    btnOpt.state &= ~State_Sunken;
+                    bsx = 0;
+                    bsy = 0;
+                }
+                btnOpt.rect = proxy()->subControlRect(CC_MdiControls, opt, SC_MdiCloseButton, widget);
+                proxy()->drawPrimitive(PE_PanelButtonCommand, &btnOpt, p, widget);
+                QPixmap pm = standardIcon(SP_TitleBarCloseButton).pixmap(16, 16);
+                proxy()->drawItemPixmap(p, btnOpt.rect.translated(bsx, bsy), Qt::AlignCenter, pm);
+            }
+            if (opt->subControls & QStyle::SC_MdiNormalButton) {
+                if (opt->activeSubControls & QStyle::SC_MdiNormalButton && (opt->state & State_Sunken)) {
+                    btnOpt.state |= State_Sunken;
+                    btnOpt.state &= ~State_Raised;
+                    bsx = proxy()->pixelMetric(PM_ButtonShiftHorizontal);
+                    bsy = proxy()->pixelMetric(PM_ButtonShiftVertical);
+                } else {
+                    btnOpt.state |= State_Raised;
+                    btnOpt.state &= ~State_Sunken;
+                    bsx = 0;
+                    bsy = 0;
+                }
+                btnOpt.rect = proxy()->subControlRect(CC_MdiControls, opt, SC_MdiNormalButton, widget);
+                proxy()->drawPrimitive(PE_PanelButtonCommand, &btnOpt, p, widget);
+                QPixmap pm = standardIcon(SP_TitleBarNormalButton).pixmap(16, 16);
+                proxy()->drawItemPixmap(p, btnOpt.rect.translated(bsx, bsy), Qt::AlignCenter, pm);
+            }
+            if (opt->subControls & QStyle::SC_MdiMinButton) {
+                if (opt->activeSubControls & QStyle::SC_MdiMinButton && (opt->state & State_Sunken)) {
+                    btnOpt.state |= State_Sunken;
+                    btnOpt.state &= ~State_Raised;
+                    bsx = proxy()->pixelMetric(PM_ButtonShiftHorizontal);
+                    bsy = proxy()->pixelMetric(PM_ButtonShiftVertical);
+                } else {
+                    btnOpt.state |= State_Raised;
+                    btnOpt.state &= ~State_Sunken;
+                    bsx = 0;
+                    bsy = 0;
+                }
+                btnOpt.rect = proxy()->subControlRect(CC_MdiControls, opt, SC_MdiMinButton, widget);
+                proxy()->drawPrimitive(PE_PanelButtonCommand, &btnOpt, p, widget);
+                QPixmap pm = standardIcon(SP_TitleBarMinButton).pixmap(16, 16);
+                proxy()->drawItemPixmap(p, btnOpt.rect.translated(bsx, bsy), Qt::AlignCenter, pm);
+            }
+        }
+        break;
+#endif // QT_NO_MDIAREA
+    default:
+        qWarning("QCommonStyle::drawComplexControl: Control %d not handled", cc);
+    }
+}
+
+/*!
+    \reimp
+*/
+QStyle::SubControl QCommonStyle::hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
+                                                 const QPoint &pt, const QWidget *widget) const
+{
+    SubControl sc = SC_None;
+    switch (cc) {
+#ifndef QT_NO_SLIDER
+    case CC_Slider:
+        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+            QRect r = proxy()->subControlRect(cc, slider, SC_SliderHandle, widget);
+            if (r.isValid() && r.contains(pt)) {
+                sc = SC_SliderHandle;
+            } else {
+                r = proxy()->subControlRect(cc, slider, SC_SliderGroove ,widget);
+                if (r.isValid() && r.contains(pt))
+                    sc = SC_SliderGroove;
+            }
+        }
+        break;
+#endif // QT_NO_SLIDER
+#ifndef QT_NO_SCROLLBAR
+    case CC_ScrollBar:
+        if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+            QRect r;
+            uint ctrl = SC_ScrollBarAddLine;
+            while (ctrl <= SC_ScrollBarGroove) {
+                r = proxy()->subControlRect(cc, scrollbar, QStyle::SubControl(ctrl), widget);
+                if (r.isValid() && r.contains(pt)) {
+                    sc = QStyle::SubControl(ctrl);
+                    break;
+                }
+                ctrl <<= 1;
+            }
+        }
+        break;
+#endif // QT_NO_SCROLLBAR
+#ifndef QT_NO_TOOLBUTTON
+    case CC_ToolButton:
+        if (const QStyleOptionToolButton *toolbutton = qstyleoption_cast<const QStyleOptionToolButton *>(opt)) {
+            QRect r;
+            uint ctrl = SC_ToolButton;
+            while (ctrl <= SC_ToolButtonMenu) {
+                r = proxy()->subControlRect(cc, toolbutton, QStyle::SubControl(ctrl), widget);
+                if (r.isValid() && r.contains(pt)) {
+                    sc = QStyle::SubControl(ctrl);
+                    break;
+                }
+                ctrl <<= 1;
+            }
+        }
+        break;
+#endif // QT_NO_TOOLBUTTON
+#ifndef QT_NO_SPINBOX
+    case CC_SpinBox:
+        if (const QStyleOptionSpinBox *spinbox = qstyleoption_cast<const QStyleOptionSpinBox *>(opt)) {
+            QRect r;
+            uint ctrl = SC_SpinBoxUp;
+            while (ctrl <= SC_SpinBoxEditField) {
+                r = proxy()->subControlRect(cc, spinbox, QStyle::SubControl(ctrl), widget);
+                if (r.isValid() && r.contains(pt)) {
+                    sc = QStyle::SubControl(ctrl);
+                    break;
+                }
+                ctrl <<= 1;
+            }
+        }
+        break;
+#endif // QT_NO_SPINBOX
+    case CC_TitleBar:
+        if (const QStyleOptionTitleBar *tb = qstyleoption_cast<const QStyleOptionTitleBar *>(opt)) {
+            QRect r;
+            uint ctrl = SC_TitleBarSysMenu;
+
+            while (ctrl <= SC_TitleBarLabel) {
+                r = proxy()->subControlRect(cc, tb, QStyle::SubControl(ctrl), widget);
+                if (r.isValid() && r.contains(pt)) {
+                    sc = QStyle::SubControl(ctrl);
+                    break;
+                }
+                ctrl <<= 1;
+            }
+        }
+        break;
+#ifndef QT_NO_COMBOBOX
+    case CC_ComboBox:
+        if (const QStyleOptionComboBox *cb = qstyleoption_cast<const QStyleOptionComboBox *>(opt)) {
+            QRect r;
+            uint ctrl = SC_ComboBoxArrow;  // Start here and go down.
+            while (ctrl > 0) {
+                r = proxy()->subControlRect(cc, cb, QStyle::SubControl(ctrl), widget);
+                if (r.isValid() && r.contains(pt)) {
+                    sc = QStyle::SubControl(ctrl);
+                    break;
+                }
+                ctrl >>= 1;
+            }
+        }
+        break;
+#endif // QT_NO_COMBOBOX
+#ifndef QT_NO_GROUPBOX
+    case CC_GroupBox:
+        if (const QStyleOptionGroupBox *groupBox = qstyleoption_cast<const QStyleOptionGroupBox *>(opt)) {
+            QRect r;
+            uint ctrl = SC_GroupBoxCheckBox;
+            while (ctrl <= SC_GroupBoxFrame) {
+                r = proxy()->subControlRect(cc, groupBox, QStyle::SubControl(ctrl), widget);
+                if (r.isValid() && r.contains(pt)) {
+                    sc = QStyle::SubControl(ctrl);
+                    break;
+                }
+                ctrl <<= 1;
+            }
+        }
+        break;
+#endif // QT_NO_GROUPBOX
+    case CC_MdiControls:
+        {
+            QRect r;
+            uint ctrl = SC_MdiMinButton;
+            while (ctrl <= SC_MdiCloseButton) {
+                r = proxy()->subControlRect(CC_MdiControls, opt, QStyle::SubControl(ctrl), widget);
+                if (r.isValid() && r.contains(pt) && (opt->subControls & ctrl)) {
+                    sc = QStyle::SubControl(ctrl);
+                    return sc;
+                }
+                ctrl <<= 1;
+            }
+        }
+        break;
+    default:
+        qWarning("QCommonStyle::hitTestComplexControl: Case %d not handled", cc);
+    }
+    return sc;
+}
+
+/*!
+    \reimp
+*/
+QRect QCommonStyle::subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
+                                   SubControl sc, const QWidget *widget) const
+{
+    QRect ret;
+    switch (cc) {
+#ifndef QT_NO_SLIDER
+    case CC_Slider:
+        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+            int tickOffset = proxy()->pixelMetric(PM_SliderTickmarkOffset, slider, widget);
+            int thickness = proxy()->pixelMetric(PM_SliderControlThickness, slider, widget);
+
+            switch (sc) {
+            case SC_SliderHandle: {
+                int sliderPos = 0;
+                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
+                bool horizontal = slider->orientation == Qt::Horizontal;
+                sliderPos = sliderPositionFromValue(slider->minimum, slider->maximum,
+                                                    slider->sliderPosition,
+                                                    (horizontal ? slider->rect.width()
+                                                                : slider->rect.height()) - len,
+                                                    slider->upsideDown);
+                if (horizontal)
+                    ret.setRect(slider->rect.x() + sliderPos, slider->rect.y() + tickOffset, len, thickness);
+                else
+                    ret.setRect(slider->rect.x() + tickOffset, slider->rect.y() + sliderPos, thickness, len);
+                break; }
+            case SC_SliderGroove:
+                if (slider->orientation == Qt::Horizontal)
+                    ret.setRect(slider->rect.x(), slider->rect.y() + tickOffset,
+                                slider->rect.width(), thickness);
+                else
+                    ret.setRect(slider->rect.x() + tickOffset, slider->rect.y(),
+                                thickness, slider->rect.height());
+                break;
+            default:
+                break;
+            }
+            ret = visualRect(slider->direction, slider->rect, ret);
+        }
+        break;
+#endif // QT_NO_SLIDER
+#ifndef QT_NO_SCROLLBAR
+    case CC_ScrollBar:
+        if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+            const QRect scrollBarRect = scrollbar->rect;
+            int sbextent = 0;
+            if (!proxy()->styleHint(SH_ScrollBar_Transient, scrollbar, widget))
+                sbextent = proxy()->pixelMetric(PM_ScrollBarExtent, scrollbar, widget);
+            int maxlen = ((scrollbar->orientation == Qt::Horizontal) ?
+                          scrollBarRect.width() : scrollBarRect.height()) - (sbextent * 2);
+            int sliderlen;
+
+            // calculate slider length
+            if (scrollbar->maximum != scrollbar->minimum) {
+                uint range = scrollbar->maximum - scrollbar->minimum;
+                sliderlen = (qint64(scrollbar->pageStep) * maxlen) / (range + scrollbar->pageStep);
+
+                int slidermin = proxy()->pixelMetric(PM_ScrollBarSliderMin, scrollbar, widget);
+                if (sliderlen < slidermin || range > INT_MAX / 2)
+                    sliderlen = slidermin;
+                if (sliderlen > maxlen)
+                    sliderlen = maxlen;
+            } else {
+                sliderlen = maxlen;
+            }
+
+            int sliderstart = sbextent + sliderPositionFromValue(scrollbar->minimum,
+                                                                 scrollbar->maximum,
+                                                                 scrollbar->sliderPosition,
+                                                                 maxlen - sliderlen,
+                                                                 scrollbar->upsideDown);
+
+            switch (sc) {
+            case SC_ScrollBarSubLine:            // top/left button
+                if (scrollbar->orientation == Qt::Horizontal) {
+                    int buttonWidth = qMin(scrollBarRect.width() / 2, sbextent);
+                    ret.setRect(0, 0, buttonWidth, scrollBarRect.height());
+                } else {
+                    int buttonHeight = qMin(scrollBarRect.height() / 2, sbextent);
+                    ret.setRect(0, 0, scrollBarRect.width(), buttonHeight);
+                }
+                break;
+            case SC_ScrollBarAddLine:            // bottom/right button
+                if (scrollbar->orientation == Qt::Horizontal) {
+                    int buttonWidth = qMin(scrollBarRect.width()/2, sbextent);
+                    ret.setRect(scrollBarRect.width() - buttonWidth, 0, buttonWidth, scrollBarRect.height());
+                } else {
+                    int buttonHeight = qMin(scrollBarRect.height()/2, sbextent);
+                    ret.setRect(0, scrollBarRect.height() - buttonHeight, scrollBarRect.width(), buttonHeight);
+                }
+                break;
+            case SC_ScrollBarSubPage:            // between top/left button and slider
+                if (scrollbar->orientation == Qt::Horizontal)
+                    ret.setRect(sbextent, 0, sliderstart - sbextent, scrollBarRect.height());
+                else
+                    ret.setRect(0, sbextent, scrollBarRect.width(), sliderstart - sbextent);
+                break;
+            case SC_ScrollBarAddPage:            // between bottom/right button and slider
+                if (scrollbar->orientation == Qt::Horizontal)
+                    ret.setRect(sliderstart + sliderlen, 0,
+                                maxlen - sliderstart - sliderlen + sbextent, scrollBarRect.height());
+                else
+                    ret.setRect(0, sliderstart + sliderlen, scrollBarRect.width(),
+                                maxlen - sliderstart - sliderlen + sbextent);
+                break;
+            case SC_ScrollBarGroove:
+                if (scrollbar->orientation == Qt::Horizontal)
+                    ret.setRect(sbextent, 0, scrollBarRect.width() - sbextent * 2,
+                                scrollBarRect.height());
+                else
+                    ret.setRect(0, sbextent, scrollBarRect.width(),
+                                scrollBarRect.height() - sbextent * 2);
+                break;
+            case SC_ScrollBarSlider:
+                if (scrollbar->orientation == Qt::Horizontal)
+                    ret.setRect(sliderstart, 0, sliderlen, scrollBarRect.height());
+                else
+                    ret.setRect(0, sliderstart, scrollBarRect.width(), sliderlen);
+                break;
+            default:
+                break;
+            }
+            ret = visualRect(scrollbar->direction, scrollBarRect, ret);
+        }
+        break;
+#endif // QT_NO_SCROLLBAR
+#ifndef QT_NO_SPINBOX
+    case CC_SpinBox:
+        if (const QStyleOptionSpinBox *spinbox = qstyleoption_cast<const QStyleOptionSpinBox *>(opt)) {
+            QSize bs;
+            int fw = spinbox->frame ? proxy()->pixelMetric(PM_SpinBoxFrameWidth, spinbox, widget) : 0;
+            bs.setHeight(qMax(8, spinbox->rect.height()/2 - fw));
+            // 1.6 -approximate golden mean
+            bs.setWidth(qMax(16, qMin(bs.height() * 8 / 5, spinbox->rect.width() / 4)));
+            bs = bs.expandedTo(QApplication::globalStrut());
+            int y = fw + spinbox->rect.y();
+            int x, lx, rx;
+            x = spinbox->rect.x() + spinbox->rect.width() - fw - bs.width();
+            lx = fw;
+            rx = x - fw;
+            switch (sc) {
+            case SC_SpinBoxUp:
+                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons)
+                    return QRect();
+                ret = QRect(x, y, bs.width(), bs.height());
+                break;
+            case SC_SpinBoxDown:
+                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons)
+                    return QRect();
+
+                ret = QRect(x, y + bs.height(), bs.width(), bs.height());
+                break;
+            case SC_SpinBoxEditField:
+                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons) {
+                    ret = QRect(lx, fw, spinbox->rect.width() - 2*fw, spinbox->rect.height() - 2*fw);
+                } else {
+                    ret = QRect(lx, fw, rx, spinbox->rect.height() - 2*fw);
+                }
+                break;
+            case SC_SpinBoxFrame:
+                ret = spinbox->rect;
+            default:
+                break;
+            }
+            ret = visualRect(spinbox->direction, spinbox->rect, ret);
+        }
+        break;
+#endif // Qt_NO_SPINBOX
+#ifndef QT_NO_TOOLBUTTON
+    case CC_ToolButton:
+        if (const QStyleOptionToolButton *tb = qstyleoption_cast<const QStyleOptionToolButton *>(opt)) {
+            int mbi = proxy()->pixelMetric(PM_MenuButtonIndicator, tb, widget);
+            ret = tb->rect;
+            switch (sc) {
+            case SC_ToolButton:
+                if ((tb->features
+                     & (QStyleOptionToolButton::MenuButtonPopup | QStyleOptionToolButton::PopupDelay))
+                    == QStyleOptionToolButton::MenuButtonPopup)
+                    ret.adjust(0, 0, -mbi, 0);
+                break;
+            case SC_ToolButtonMenu:
+                if ((tb->features
+                     & (QStyleOptionToolButton::MenuButtonPopup | QStyleOptionToolButton::PopupDelay))
+                    == QStyleOptionToolButton::MenuButtonPopup)
+                    ret.adjust(ret.width() - mbi, 0, 0, 0);
+                break;
+            default:
+                break;
+            }
+            ret = visualRect(tb->direction, tb->rect, ret);
+        }
+        break;
+#endif // QT_NO_TOOLBUTTON
+#ifndef QT_NO_COMBOBOX
+    case CC_ComboBox:
+        if (const QStyleOptionComboBox *cb = qstyleoption_cast<const QStyleOptionComboBox *>(opt)) {
+            int x = cb->rect.x(),
+                y = cb->rect.y(),
+                wi = cb->rect.width(),
+                he = cb->rect.height();
+            int xpos = x;
+            int margin = cb->frame ? 3 : 0;
+            int bmarg = cb->frame ? 2 : 0;
+            xpos += wi - bmarg - 16;
+
+
+            switch (sc) {
+            case SC_ComboBoxFrame:
+                ret = cb->rect;
+                break;
+            case SC_ComboBoxArrow:
+                ret.setRect(xpos, y + bmarg, 16, he - 2*bmarg);
+                break;
+            case SC_ComboBoxEditField:
+                ret.setRect(x + margin, y + margin, wi - 2 * margin - 16, he - 2 * margin);
+                break;
+            case SC_ComboBoxListBoxPopup:
+                ret = cb->rect;
+                break;
+            default:
+                break;
+            }
+            ret = visualRect(cb->direction, cb->rect, ret);
+        }
+        break;
+#endif // QT_NO_COMBOBOX
+    case CC_TitleBar:
+        if (const QStyleOptionTitleBar *tb = qstyleoption_cast<const QStyleOptionTitleBar *>(opt)) {
+            const int controlMargin = 2;
+            const int controlHeight = tb->rect.height() - controlMargin *2;
+            const int delta = controlHeight + controlMargin;
+            int offset = 0;
+
+            bool isMinimized = tb->titleBarState & Qt::WindowMinimized;
+            bool isMaximized = tb->titleBarState & Qt::WindowMaximized;
+
+            switch (sc) {
+            case SC_TitleBarLabel:
+                if (tb->titleBarFlags & (Qt::WindowTitleHint | Qt::WindowSystemMenuHint)) {
+                    ret = tb->rect;
+                    if (tb->titleBarFlags & Qt::WindowSystemMenuHint)
+                        ret.adjust(delta, 0, -delta, 0);
+                    if (tb->titleBarFlags & Qt::WindowMinimizeButtonHint)
+                        ret.adjust(0, 0, -delta, 0);
+                    if (tb->titleBarFlags & Qt::WindowMaximizeButtonHint)
+                        ret.adjust(0, 0, -delta, 0);
+                    if (tb->titleBarFlags & Qt::WindowShadeButtonHint)
+                        ret.adjust(0, 0, -delta, 0);
+                    if (tb->titleBarFlags & Qt::WindowContextHelpButtonHint)
+                        ret.adjust(0, 0, -delta, 0);
+                }
+                break;
+            case SC_TitleBarContextHelpButton:
+                if (tb->titleBarFlags & Qt::WindowContextHelpButtonHint)
+                    offset += delta;
+            case SC_TitleBarMinButton:
+                if (!isMinimized && (tb->titleBarFlags & Qt::WindowMinimizeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarMinButton)
+                    break;
+            case SC_TitleBarNormalButton:
+                if (isMinimized && (tb->titleBarFlags & Qt::WindowMinimizeButtonHint))
+                    offset += delta;
+                else if (isMaximized && (tb->titleBarFlags & Qt::WindowMaximizeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarNormalButton)
+                    break;
+            case SC_TitleBarMaxButton:
+                if (!isMaximized && (tb->titleBarFlags & Qt::WindowMaximizeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarMaxButton)
+                    break;
+            case SC_TitleBarShadeButton:
+                if (!isMinimized && (tb->titleBarFlags & Qt::WindowShadeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarShadeButton)
+                    break;
+            case SC_TitleBarUnshadeButton:
+                if (isMinimized && (tb->titleBarFlags & Qt::WindowShadeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarUnshadeButton)
+                    break;
+            case SC_TitleBarCloseButton:
+                if (tb->titleBarFlags & Qt::WindowSystemMenuHint)
+                    offset += delta;
+                else if (sc == SC_TitleBarCloseButton)
+                    break;
+                ret.setRect(tb->rect.right() - offset, tb->rect.top() + controlMargin,
+                            controlHeight, controlHeight);
+                break;
+            case SC_TitleBarSysMenu:
+                if (tb->titleBarFlags & Qt::WindowSystemMenuHint) {
+                    ret.setRect(tb->rect.left() + controlMargin, tb->rect.top() + controlMargin,
+                                controlHeight, controlHeight);
+                }
+                break;
+            default:
+                break;
+            }
+            ret = visualRect(tb->direction, tb->rect, ret);
+        }
+        break;
+#ifndef QT_NO_GROUPBOX
+    case CC_GroupBox: {
+        if (const QStyleOptionGroupBox *groupBox = qstyleoption_cast<const QStyleOptionGroupBox *>(opt)) {
+            switch (sc) {
+            case SC_GroupBoxFrame:
+                // FALL THROUGH
+            case SC_GroupBoxContents: {
+                int topMargin = 0;
+                int topHeight = 0;
+                int verticalAlignment = proxy()->styleHint(SH_GroupBox_TextLabelVerticalAlignment, groupBox, widget);
+                if (groupBox->text.size() || (groupBox->subControls & QStyle::SC_GroupBoxCheckBox)) {
+                    topHeight = groupBox->fontMetrics.height();
+                    if (verticalAlignment & Qt::AlignVCenter)
+                        topMargin = topHeight / 2;
+                    else if (verticalAlignment & Qt::AlignTop)
+                        topMargin = topHeight;
+                }
+
+                QRect frameRect = groupBox->rect;
+                frameRect.setTop(topMargin);
+
+                if (sc == SC_GroupBoxFrame) {
+                    ret = frameRect;
+                    break;
+                }
+
+                int frameWidth = 0;
+                if ((groupBox->features & QStyleOptionFrameV2::Flat) == 0)
+                    frameWidth = proxy()->pixelMetric(PM_DefaultFrameWidth, groupBox, widget);
+                ret = frameRect.adjusted(frameWidth, frameWidth + topHeight - topMargin,
+                                         -frameWidth, -frameWidth);
+                break;
+            }
+            case SC_GroupBoxCheckBox:
+                // FALL THROUGH
+            case SC_GroupBoxLabel: {
+                QFontMetrics fontMetrics = groupBox->fontMetrics;
+                int h = fontMetrics.height();
+                int tw = fontMetrics.size(Qt::TextShowMnemonic, groupBox->text + QLatin1Char(' ')).width();
+                int marg = (groupBox->features & QStyleOptionFrameV2::Flat) ? 0 : 8;
+                ret = groupBox->rect.adjusted(marg, 0, -marg, 0);
+                ret.setHeight(h);
+
+                int indicatorWidth = proxy()->pixelMetric(PM_IndicatorWidth, opt, widget);
+                int indicatorSpace = proxy()->pixelMetric(PM_CheckBoxLabelSpacing, opt, widget) - 1;
+                bool hasCheckBox = groupBox->subControls & QStyle::SC_GroupBoxCheckBox;
+                int checkBoxSize = hasCheckBox ? (indicatorWidth + indicatorSpace) : 0;
+
+                // Adjusted rect for label + indicatorWidth + indicatorSpace
+                QRect totalRect = alignedRect(groupBox->direction, groupBox->textAlignment,
+                                              QSize(tw + checkBoxSize, h), ret);
+
+                // Adjust totalRect if checkbox is set
+                if (hasCheckBox) {
+                    bool ltr = groupBox->direction == Qt::LeftToRight;
+                    int left = 0;
+                    // Adjust for check box
+                    if (sc == SC_GroupBoxCheckBox) {
+                        int indicatorHeight = proxy()->pixelMetric(PM_IndicatorHeight, opt, widget);
+                        left = ltr ? totalRect.left() : (totalRect.right() - indicatorWidth);
+                        int top = totalRect.top() + qMax(0, fontMetrics.height() - indicatorHeight) / 2;
+                        totalRect.setRect(left, top, indicatorWidth, indicatorHeight);
+                    // Adjust for label
+                    } else {
+                        left = ltr ? (totalRect.left() + checkBoxSize - 2) : totalRect.left();
+                        totalRect.setRect(left, totalRect.top(),
+                                          totalRect.width() - checkBoxSize, totalRect.height());
+                    }
+                }
+                ret = totalRect;
+                break;
+            }
+            default:
+                break;
+            }
+        }
+        break;
+    }
+#endif // QT_NO_GROUPBOX
+#ifndef QT_NO_MDIAREA
+    case CC_MdiControls:
+    {
+        int numSubControls = 0;
+        if (opt->subControls & SC_MdiCloseButton)
+            ++numSubControls;
+        if (opt->subControls & SC_MdiMinButton)
+            ++numSubControls;
+        if (opt->subControls & SC_MdiNormalButton)
+            ++numSubControls;
+        if (numSubControls == 0)
+            break;
+
+        int buttonWidth = opt->rect.width() / numSubControls - 1;
+        int offset = 0;
+        switch (sc) {
+        case SC_MdiCloseButton:
+            // Only one sub control, no offset needed.
+            if (numSubControls == 1)
+                break;
+            offset += buttonWidth + 2;
+            //FALL THROUGH
+        case SC_MdiNormalButton:
+            // No offset needed if
+            // 1) There's only one sub control
+            // 2) We have a close button and a normal button (offset already added in SC_MdiClose)
+            if (numSubControls == 1 || (numSubControls == 2 && !(opt->subControls & SC_MdiMinButton)))
+                break;
+            if (opt->subControls & SC_MdiNormalButton)
+                offset += buttonWidth;
+            break;
+        default:
+            break;
+        }
+
+        // Subtract one pixel if we only have one sub control. At this point
+        // buttonWidth is the actual width + 1 pixel margin, but we don't want the
+        // margin when there are no other controllers.
+        if (numSubControls == 1)
+            --buttonWidth;
+        ret = QRect(offset, 0, buttonWidth, opt->rect.height());
+        break;
+    }
+#endif // QT_NO_MDIAREA
+     default:
+        qWarning("QCommonStyle::subControlRect: Case %d not handled", cc);
+    }
+    return ret;
+}
+
+/*! \reimp */
+int QCommonStyle::pixelMetric(PixelMetric m, const QStyleOption *opt, const QWidget *widget) const
+{
+    int ret;
+
+    switch (m) {
+    case PM_FocusFrameVMargin:
+    case PM_FocusFrameHMargin:
+        ret = 2;
+        break;
+    case PM_MenuBarVMargin:
+    case PM_MenuBarHMargin:
+        ret = 0;
+        break;
+    case PM_DialogButtonsSeparator:
+        ret = int(QStyleHelper::dpiScaled(5.));
+        break;
+    case PM_DialogButtonsButtonWidth:
+        ret = int(QStyleHelper::dpiScaled(70.));
+        break;
+    case PM_DialogButtonsButtonHeight:
+        ret = int(QStyleHelper::dpiScaled(30.));
+        break;
+    case PM_TitleBarHeight: {
+        if (const QStyleOptionTitleBar *tb = qstyleoption_cast<const QStyleOptionTitleBar *>(opt)) {
+            if ((tb->titleBarFlags & Qt::WindowType_Mask) == Qt::Tool) {
+                ret = qMax(widget ? widget->fontMetrics().height() : opt->fontMetrics.height(), 16);
+#ifndef QT_NO_DOCKWIDGET
+            } else if (qobject_cast<const QDockWidget*>(widget)) {
+                ret = qMax(widget->fontMetrics().height(), int(QStyleHelper::dpiScaled(13)));
+#endif
+            } else {
+                ret = qMax(widget ? widget->fontMetrics().height() : opt->fontMetrics.height(), 18);
+            }
+        } else {
+            ret = int(QStyleHelper::dpiScaled(18.));
+        }
+
+        break; }
+    case PM_ScrollBarSliderMin:
+        ret = int(QStyleHelper::dpiScaled(9.));
+        break;
+
+    case PM_ButtonMargin:
+        ret = int(QStyleHelper::dpiScaled(6.));
+        break;
+
+    case PM_DockWidgetTitleBarButtonMargin:
+        ret = int(QStyleHelper::dpiScaled(2.));
+        break;
+
+    case PM_ButtonDefaultIndicator:
+        ret = 0;
+        break;
+
+    case PM_MenuButtonIndicator:
+        ret = int(QStyleHelper::dpiScaled(12.));
+        break;
+
+    case PM_ButtonShiftHorizontal:
+    case PM_ButtonShiftVertical:
+
+    case PM_DefaultFrameWidth:
+        ret = 2;
+        break;
+
+    case PM_ComboBoxFrameWidth:
+    case PM_SpinBoxFrameWidth:
+    case PM_MenuPanelWidth:
+    case PM_TabBarBaseOverlap:
+    case PM_TabBarBaseHeight:
+        ret = proxy()->pixelMetric(PM_DefaultFrameWidth, opt, widget);
+        break;
+
+    case PM_MdiSubWindowFrameWidth:
+        ret = int(QStyleHelper::dpiScaled(4.));
+        break;
+
+    case PM_MdiSubWindowMinimizedWidth:
+        ret = int(QStyleHelper::dpiScaled(196.));
+        break;
+
+#ifndef QT_NO_SCROLLBAR
+    case PM_ScrollBarExtent:
+        if (const QStyleOptionSlider *sb = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+            int s = sb->orientation == Qt::Horizontal ?
+                    QApplication::globalStrut().height()
+                    : QApplication::globalStrut().width();
+            ret = qMax(16, s);
+        } else {
+            ret = int(QStyleHelper::dpiScaled(16.));
+        }
+        break;
+#endif
+    case PM_MaximumDragDistance:
+        ret = QGuiApplicationPrivate::platformTheme()->themeHint(QPlatformTheme::MaximumScrollBarDragDistance).toInt();
+        break;
+
+#ifndef QT_NO_SLIDER
+    case PM_SliderThickness:
+        ret = int(QStyleHelper::dpiScaled(16.));
+        break;
+
+    case PM_SliderTickmarkOffset:
+        if (const QStyleOptionSlider *sl = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+            int space = (sl->orientation == Qt::Horizontal) ? sl->rect.height()
+                                                            : sl->rect.width();
+            int thickness = proxy()->pixelMetric(PM_SliderControlThickness, sl, widget);
+            int ticks = sl->tickPosition;
+
+            if (ticks == QSlider::TicksBothSides)
+                ret = (space - thickness) / 2;
+            else if (ticks == QSlider::TicksAbove)
+                ret = space - thickness;
+            else
+                ret = 0;
+        } else {
+            ret = 0;
+        }
+        break;
+
+    case PM_SliderSpaceAvailable:
+        if (const QStyleOptionSlider *sl = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+            if (sl->orientation == Qt::Horizontal)
+                ret = sl->rect.width() - proxy()->pixelMetric(PM_SliderLength, sl, widget);
+            else
+                ret = sl->rect.height() - proxy()->pixelMetric(PM_SliderLength, sl, widget);
+        } else {
+            ret = 0;
+        }
+        break;
+#endif // QT_NO_SLIDER
+#ifndef QT_NO_DOCKWIDGET
+    case PM_DockWidgetSeparatorExtent:
+        ret = int(QStyleHelper::dpiScaled(6.));
+        break;
+
+    case PM_DockWidgetHandleExtent:
+        ret = int(QStyleHelper::dpiScaled(8.));
+        break;
+    case PM_DockWidgetTitleMargin:
+        ret = 0;
+        break;
+    case PM_DockWidgetFrameWidth:
+        ret = 1;
+        break;
+#endif // QT_NO_DOCKWIDGET
+
+    case PM_SpinBoxSliderHeight:
+    case PM_MenuBarPanelWidth:
+        ret = 2;
+        break;
+
+    case PM_MenuBarItemSpacing:
+        ret = 0;
+        break;
+
+#ifndef QT_NO_TOOLBAR
+    case PM_ToolBarFrameWidth:
+        ret = 1;
+        break;
+
+    case PM_ToolBarItemMargin:
+        ret = 0;
+        break;
+
+    case PM_ToolBarItemSpacing:
+        ret = int(QStyleHelper::dpiScaled(4.));
+        break;
+
+    case PM_ToolBarHandleExtent:
+        ret = int(QStyleHelper::dpiScaled(8.));
+        break;
+
+    case PM_ToolBarSeparatorExtent:
+        ret = int(QStyleHelper::dpiScaled(6.));
+        break;
+
+    case PM_ToolBarExtensionExtent:
+        ret = int(QStyleHelper::dpiScaled(12.));
+        break;
+#endif // QT_NO_TOOLBAR
+
+#ifndef QT_NO_TABBAR
+    case PM_TabBarTabOverlap:
+        ret = 3;
+        break;
+
+    case PM_TabBarTabHSpace:
+        ret = int(QStyleHelper::dpiScaled(24.));
+        break;
+
+    case PM_TabBarTabShiftHorizontal:
+        ret = 0;
+        break;
+
+    case PM_TabBarTabShiftVertical:
+        ret = 2;
+        break;
+
+    case PM_TabBarTabVSpace: {
+        const QStyleOptionTab *tb = qstyleoption_cast<const QStyleOptionTab *>(opt);
+        if (tb && (tb->shape == QTabBar::RoundedNorth || tb->shape == QTabBar::RoundedSouth
+                   || tb->shape == QTabBar::RoundedWest || tb->shape == QTabBar::RoundedEast))
+            ret = 8;
+        else
+            if(tb && (tb->shape == QTabBar::TriangularWest || tb->shape == QTabBar::TriangularEast))
+                ret = 3;
+            else
+                ret = 2;
+        break; }
+#endif
+
+    case PM_ProgressBarChunkWidth:
+        ret = 9;
+        break;
+
+    case PM_IndicatorWidth:
+        ret = int(QStyleHelper::dpiScaled(13.));
+        break;
+
+    case PM_IndicatorHeight:
+        ret = int(QStyleHelper::dpiScaled(13.));
+        break;
+
+    case PM_ExclusiveIndicatorWidth:
+        ret = int(QStyleHelper::dpiScaled(12.));
+        break;
+
+    case PM_ExclusiveIndicatorHeight:
+        ret = int(QStyleHelper::dpiScaled(12.));
+        break;
+
+    case PM_MenuTearoffHeight:
+        ret = int(QStyleHelper::dpiScaled(10.));
+        break;
+
+    case PM_MenuScrollerHeight:
+        ret = int(QStyleHelper::dpiScaled(10.));
+        break;
+
+    case PM_MenuDesktopFrameWidth:
+    case PM_MenuHMargin:
+    case PM_MenuVMargin:
+        ret = 0;
+        break;
+
+    case PM_HeaderMargin:
+        ret = int(QStyleHelper::dpiScaled(4.));
+        break;
+    case PM_HeaderMarkSize:
+        ret = int(QStyleHelper::dpiScaled(32.));
+        break;
+    case PM_HeaderGripMargin:
+        ret = int(QStyleHelper::dpiScaled(4.));
+        break;
+    case PM_TabBarScrollButtonWidth:
+        ret = int(QStyleHelper::dpiScaled(16.));
+        break;
+    case PM_LayoutLeftMargin:
+    case PM_LayoutTopMargin:
+    case PM_LayoutRightMargin:
+    case PM_LayoutBottomMargin:
+        {
+            bool isWindow = false;
+            if (opt) {
+                isWindow = (opt->state & State_Window);
+            } else if (widget) {
+                isWindow = widget->isWindow();
+            }
+            ret = proxy()->pixelMetric(isWindow ? PM_DefaultTopLevelMargin : PM_DefaultChildMargin);
+        }
+        break;
+    case PM_LayoutHorizontalSpacing:
+    case PM_LayoutVerticalSpacing:
+        ret = proxy()->pixelMetric(PM_DefaultLayoutSpacing);
+        break;
+
+    case PM_DefaultTopLevelMargin:
+        ret = int(QStyleHelper::dpiScaled(11.));
+        break;
+    case PM_DefaultChildMargin:
+        ret = int(QStyleHelper::dpiScaled(9.));
+        break;
+    case PM_DefaultLayoutSpacing:
+        ret = int(QStyleHelper::dpiScaled(6.));
+        break;
+
+    case PM_ToolBarIconSize:
+        ret = 0;
+        if (const QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme())
+            ret = theme->themeHint(QPlatformTheme::ToolBarIconSize).toInt();
+        if (ret <= 0)
+            ret =  int(QStyleHelper::dpiScaled(24.));
+        break;
+
+    case PM_TabBarIconSize:
+    case PM_ListViewIconSize:
+        ret = proxy()->pixelMetric(PM_SmallIconSize, opt, widget);
+        break;
+
+    case PM_ButtonIconSize:
+    case PM_SmallIconSize:
+        ret = int(QStyleHelper::dpiScaled(16.));
+        break;
+    case PM_IconViewIconSize:
+        ret = proxy()->pixelMetric(PM_LargeIconSize, opt, widget);
+        break;
+
+    case PM_LargeIconSize:
+        ret = int(QStyleHelper::dpiScaled(32.));
+        break;
+
+    case PM_ToolTipLabelFrameWidth:
+        ret = 1;
+        break;
+    case PM_CheckBoxLabelSpacing:
+    case PM_RadioButtonLabelSpacing:
+        ret = int(QStyleHelper::dpiScaled(6.));
+        break;
+    case PM_SizeGripSize:
+        ret = int(QStyleHelper::dpiScaled(13.));
+        break;
+    case PM_MessageBoxIconSize:
+#ifdef Q_OS_MAC
+        if (QApplication::desktopSettingsAware()) {
+            ret = 64; // No DPI scaling, it's handled elsewhere.
+        } else
+#endif
+        {
+            ret = int(QStyleHelper::dpiScaled(32.));
+        }
+        break;
+    case PM_TextCursorWidth:
+        ret = QGuiApplicationPrivate::platformTheme()->themeHint(QPlatformTheme::TextCursorWidth).toInt();
+        break;
+    case PM_TabBar_ScrollButtonOverlap:
+        ret = 1;
+        break;
+    case PM_TabCloseIndicatorWidth:
+    case PM_TabCloseIndicatorHeight:
+        ret = int(QStyleHelper::dpiScaled(16.));
+        break;
+    case PM_ScrollView_ScrollBarSpacing:
+        ret = 2 * proxy()->pixelMetric(PM_DefaultFrameWidth, opt, widget);
+        break;
+    case PM_ScrollView_ScrollBarOverlap:
+        ret = 0;
+        break;
+    case PM_SubMenuOverlap:
+        ret = -proxy()->pixelMetric(QStyle::PM_MenuPanelWidth, opt, widget);
+        break;
+    default:
+        ret = 0;
+        break;
+    }
+
+    return ret;
+}
+
+/*!
+    \reimp
+*/
+QSize QCommonStyle::sizeFromContents(ContentsType ct, const QStyleOption *opt,
+                                     const QSize &csz, const QWidget *widget) const
+{
+    Q_D(const QCommonStyle);
+    QSize sz(csz);
+    switch (ct) {
+    case CT_PushButton:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
+            int w = csz.width(),
+                h = csz.height(),
+                bm = proxy()->pixelMetric(PM_ButtonMargin, btn, widget),
+            fw = proxy()->pixelMetric(PM_DefaultFrameWidth, btn, widget) * 2;
+            w += bm + fw;
+            h += bm + fw;
+            if (btn->features & QStyleOptionButton::AutoDefaultButton){
+                int dbw = proxy()->pixelMetric(PM_ButtonDefaultIndicator, btn, widget) * 2;
+                w += dbw;
+                h += dbw;
+            }
+            sz = QSize(w, h);
+        }
+        break;
+    case CT_RadioButton:
+    case CT_CheckBox:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
+            bool isRadio = (ct == CT_RadioButton);
+
+            int w = proxy()->pixelMetric(isRadio ? PM_ExclusiveIndicatorWidth
+                                        : PM_IndicatorWidth, btn, widget);
+            int h = proxy()->pixelMetric(isRadio ? PM_ExclusiveIndicatorHeight
+                                        : PM_IndicatorHeight, btn, widget);
+
+            int margins = 0;
+            // we add 4 pixels for label margins
+            if (!btn->icon.isNull() || !btn->text.isEmpty())
+                margins = 4 + proxy()->pixelMetric(isRadio ? PM_RadioButtonLabelSpacing
+                                                  : PM_CheckBoxLabelSpacing, opt, widget);
+            sz += QSize(w + margins, 4);
+            sz.setHeight(qMax(sz.height(), h));
+        }
+        break;
+#ifndef QT_NO_MENU
+    case CT_MenuItem:
+        if (const QStyleOptionMenuItem *mi = qstyleoption_cast<const QStyleOptionMenuItem *>(opt)) {
+            bool checkable = mi->menuHasCheckableItems;
+            int maxpmw = mi->maxIconWidth;
+            int w = sz.width(), h = sz.height();
+            if (mi->menuItemType == QStyleOptionMenuItem::Separator) {
+                w = 10;
+                h = 2;
+            } else {
+                h =  mi->fontMetrics.height() + 8;
+                if (!mi->icon.isNull()) {
+                    int iconExtent = proxy()->pixelMetric(PM_SmallIconSize);
+                    h = qMax(h, mi->icon.actualSize(QSize(iconExtent, iconExtent)).height() + 4);
+                }
+            }
+            if (mi->text.contains(QLatin1Char('\t')))
+                w += 12;
+            if (maxpmw > 0)
+                w += maxpmw + 6;
+            if (checkable && maxpmw < 20)
+                w += 20 - maxpmw;
+            if (checkable || maxpmw > 0)
+                w += 2;
+            w += 12;
+            sz = QSize(w, h);
+        }
+        break;
+#endif // QT_NO_MENU
+#ifndef QT_NO_TOOLBUTTON
+    case CT_ToolButton:
+        sz = QSize(sz.width() + 6, sz.height() + 5);
+        break;
+#endif // QT_NO_TOOLBUTTON
+#ifndef QT_NO_COMBOBOX
+    case CT_ComboBox:
+        if (const QStyleOptionComboBox *cmb = qstyleoption_cast<const QStyleOptionComboBox *>(opt)) {
+            int fw = cmb->frame ? proxy()->pixelMetric(PM_ComboBoxFrameWidth, opt, widget) * 2 : 0;
+            const int textMargins = 2*(proxy()->pixelMetric(PM_FocusFrameHMargin) + 1);
+            // QItemDelegate::sizeHint expands the textMargins two times, thus the 2*textMargins...
+            int other = qMax(23, 2*textMargins + proxy()->pixelMetric(QStyle::PM_ScrollBarExtent, opt, widget));
+            sz = QSize(sz.width() + fw + other, sz.height() + fw);
+        }
+        break;
+#endif // QT_NO_COMBOBOX
+    case CT_HeaderSection:
+        if (const QStyleOptionHeader *hdr = qstyleoption_cast<const QStyleOptionHeader *>(opt)) {
+            bool nullIcon = hdr->icon.isNull();
+            int margin = proxy()->pixelMetric(QStyle::PM_HeaderMargin, hdr, widget);
+            int iconSize = nullIcon ? 0 : proxy()->pixelMetric(QStyle::PM_SmallIconSize, hdr, widget);
+            QSize txt = hdr->fontMetrics.size(0, hdr->text);
+            sz.setHeight(margin + qMax(iconSize, txt.height()) + margin);
+            sz.setWidth((nullIcon ? 0 : margin) + iconSize
+                        + (hdr->text.isNull() ? 0 : margin) + txt.width() + margin);
+            if (hdr->sortIndicator != QStyleOptionHeader::None) {
+                int margin = proxy()->pixelMetric(QStyle::PM_HeaderMargin, hdr, widget);
+                if (hdr->orientation == Qt::Horizontal)
+                    sz.rwidth() += sz.height() + margin;
+                else
+                    sz.rheight() += sz.width() + margin;
+            }
+        }
+        break;
+    case CT_TabWidget:
+        sz += QSize(4, 4);
+        break;
+    case CT_LineEdit:
+        if (const QStyleOptionFrame *f = qstyleoption_cast<const QStyleOptionFrame *>(opt))
+            sz += QSize(2*f->lineWidth, 2*f->lineWidth);
+        break;
+#ifndef QT_NO_GROUPBOX
+    case CT_GroupBox:
+        if (const QGroupBox *grb = static_cast<const QGroupBox *>(widget))
+            sz += QSize(!grb->isFlat() ? 16 : 0, 0);
+        break;
+#endif // QT_NO_GROUPBOX
+    case CT_MdiControls:
+        if (const QStyleOptionComplex *styleOpt = qstyleoption_cast<const QStyleOptionComplex *>(opt)) {
+            int width = 1;
+            if (styleOpt->subControls & SC_MdiMinButton)
+                width += 16 + 1;
+            if (styleOpt->subControls & SC_MdiNormalButton)
+                width += 16 + 1;
+            if (styleOpt->subControls & SC_MdiCloseButton)
+                width += 16 + 1;
+            sz = QSize(width, 16);
+        } else {
+            sz = QSize(52, 16);
+        }
+        break;
+#ifndef QT_NO_ITEMVIEWS
+    case CT_ItemViewItem:
+        if (const QStyleOptionViewItem *vopt = qstyleoption_cast<const QStyleOptionViewItem *>(opt)) {
+            QRect decorationRect, displayRect, checkRect;
+            d->viewItemLayout(vopt, &checkRect, &decorationRect, &displayRect, true);
+            sz = (decorationRect|displayRect|checkRect).size();
+                      }
+        break;
+#endif // QT_NO_ITEMVIEWS
+#ifndef QT_NO_SPINBOX
+    case CT_SpinBox:
+        if (const QStyleOptionSpinBox *vopt = qstyleoption_cast<const QStyleOptionSpinBox *>(opt)) {
+            // Add button + frame widths
+            int buttonWidth = 20;
+            int fw = vopt->frame ? proxy()->pixelMetric(PM_SpinBoxFrameWidth, vopt, widget) : 0;
+            sz += QSize(buttonWidth + 2*fw, 2*fw);
+        }
+        break;
+#endif
+    case CT_ScrollBar:
+    case CT_MenuBar:
+    case CT_Menu:
+    case CT_MenuBarItem:
+    case CT_Slider:
+    case CT_ProgressBar:
+    case CT_TabBarTab:
+        // just return the contentsSize for now
+        // fall through intended
+    default:
+        break;
+    }
+    return sz;
+}
+
+
+/*! \reimp */
+int QCommonStyle::styleHint(StyleHint sh, const QStyleOption *opt, const QWidget *widget,
+                            QStyleHintReturn *hret) const
+{
+    int ret = 0;
+
+    switch (sh) {
+    case SH_Menu_KeyboardSearch:
+        ret = false;
+        break;
+    case SH_Slider_AbsoluteSetButtons:
+        ret = Qt::MidButton;
+        break;
+    case SH_Slider_PageSetButtons:
+        ret = Qt::LeftButton;
+        break;
+    case SH_ScrollBar_ContextMenu:
+        ret = true;
+        break;
+    case SH_DialogButtons_DefaultButton:  // This value not used anywhere.
+        ret = QDialogButtonBox::AcceptRole;
+        break;
+#ifndef QT_NO_GROUPBOX
+    case SH_GroupBox_TextLabelVerticalAlignment:
+        ret = Qt::AlignVCenter;
+        break;
+
+    case SH_GroupBox_TextLabelColor:
+        ret = opt ? int(opt->palette.color(QPalette::Text).rgba()) : 0;
+        break;
+#endif // QT_NO_GROUPBOX
+
+    case SH_ListViewExpand_SelectMouseType:
+    case SH_TabBar_SelectMouseType:
+        ret = QEvent::MouseButtonPress;
+        break;
+
+
+    case SH_TabBar_Alignment:
+    case SH_Header_ArrowAlignment:
+        ret = Qt::AlignLeft;
+        break;
+
+    case SH_TitleBar_AutoRaise:
+        ret = false;
+        break;
+
+    case SH_Menu_SubMenuPopupDelay:
+        ret = 256;
+        break;
+
+    case SH_Menu_SloppySubMenus:
+        ret = true;
+        break;
+
+    case SH_ProgressDialog_TextLabelAlignment:
+        ret = Qt::AlignCenter;
+        break;
+
+    case SH_BlinkCursorWhenTextSelected:
+        ret = 1;
+        break;
+
+    case SH_Table_GridLineColor:
+        if (opt)
+            ret = opt->palette.color(QPalette::Mid).rgb();
+        else
+            ret = -1;
+        break;
+    case SH_LineEdit_PasswordCharacter: {
+        const QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme();
+        const QPlatformTheme::ThemeHint hintType = QPlatformTheme::PasswordMaskCharacter;
+        const QVariant hint = theme ? theme->themeHint(hintType) : QPlatformTheme::defaultThemeHint(hintType);
+        ret = hint.toChar().unicode();
+        break;
+    }
+    case SH_ToolBox_SelectedPageTitleBold:
+        ret = 1;
+        break;
+
+    case SH_UnderlineShortcut:
+        ret = 1;
+        break;
+
+    case SH_SpinBox_ClickAutoRepeatRate:
+        ret = 150;
+        break;
+
+    case SH_SpinBox_ClickAutoRepeatThreshold:
+        ret = 500;
+        break;
+
+    case SH_SpinBox_KeyPressAutoRepeatRate:
+        ret = 75;
+        break;
+
+    case SH_Menu_SelectionWrap:
+        ret = true;
+        break;
+
+    case SH_Menu_FillScreenWithScroll:
+        ret = true;
+        break;
+
+    case SH_ToolTipLabel_Opacity:
+        ret = 255;
+        break;
+
+    case SH_Button_FocusPolicy:
+        ret = Qt::StrongFocus;
+        break;
+
+    case SH_MessageBox_UseBorderForButtonSpacing:
+        ret = 0;
+        break;
+
+    case SH_ToolButton_PopupDelay:
+        ret = 600;
+        break;
+
+    case SH_FocusFrame_Mask:
+        ret = 1;
+        if (widget) {
+            if(QStyleHintReturnMask *mask = qstyleoption_cast<QStyleHintReturnMask*>(hret)) {
+                mask->region = widget->rect();
+                int vmargin = proxy()->pixelMetric(QStyle::PM_FocusFrameVMargin),
+                    hmargin = proxy()->pixelMetric(QStyle::PM_FocusFrameHMargin);
+                mask->region -= QRect(widget->rect().adjusted(hmargin, vmargin, -hmargin, -vmargin));
+            }
+        }
+        break;
+#ifndef QT_NO_RUBBERBAND
+    case SH_RubberBand_Mask:
+        if (const QStyleOptionRubberBand *rbOpt = qstyleoption_cast<const QStyleOptionRubberBand *>(opt)) {
+            ret = 0;
+            if (rbOpt->shape == QRubberBand::Rectangle) {
+                ret = true;
+                if(QStyleHintReturnMask *mask = qstyleoption_cast<QStyleHintReturnMask*>(hret)) {
+                    mask->region = opt->rect;
+                    int margin = proxy()->pixelMetric(PM_DefaultFrameWidth) * 2;
+                    mask->region -= opt->rect.adjusted(margin, margin, -margin, -margin);
+                }
+            }
+        }
+        break;
+#endif // QT_NO_RUBBERBAND
+    case SH_SpinControls_DisableOnBounds:
+        ret = 1;
+        break;
+
+    case SH_Dial_BackgroundRole:
+        ret = QPalette::Window;
+        break;
+
+    case SH_ComboBox_LayoutDirection:
+        ret = opt ? opt->direction : Qt::LeftToRight;
+        break;
+
+    case SH_ItemView_EllipsisLocation:
+        ret = Qt::AlignTrailing;
+        break;
+
+    case SH_ItemView_ShowDecorationSelected:
+        ret = false;
+        break;
+
+    case SH_ItemView_ActivateItemOnSingleClick:
+        ret = 0;
+        if (const QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme())
+            ret = theme->themeHint(QPlatformTheme::ItemViewActivateItemOnSingleClick).toBool() ? 1 : 0;
+        break;
+    case SH_TitleBar_ModifyNotification:
+        ret = true;
+        break;
+    case SH_ScrollBar_RollBetweenButtons:
+        ret = false;
+        break;
+    case SH_TabBar_ElideMode:
+        ret = Qt::ElideNone;
+        break;
+    case SH_DialogButtonLayout:
+        ret = QDialogButtonBox::WinLayout;
+        if (const QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme())
+            ret = theme->themeHint(QPlatformTheme::DialogButtonBoxLayout).toInt();
+        break;
+    case SH_ComboBox_PopupFrameStyle:
+        ret = QFrame::StyledPanel | QFrame::Plain;
+        break;
+    case SH_MessageBox_TextInteractionFlags:
+        ret = Qt::LinksAccessibleByMouse;
+        break;
+    case SH_DialogButtonBox_ButtonsHaveIcons:
+        ret = 0;
+        if (const QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme())
+            ret = theme->themeHint(QPlatformTheme::DialogButtonBoxButtonsHaveIcons).toBool() ? 1 : 0;
+        break;
+    case SH_SpellCheckUnderlineStyle:
+        ret = QTextCharFormat::WaveUnderline;
+        break;
+    case SH_MessageBox_CenterButtons:
+        ret = true;
+        break;
+    case SH_ItemView_MovementWithoutUpdatingSelection:
+        ret = true;
+        break;
+    case SH_FocusFrame_AboveWidget:
+        ret = false;
+        break;
+#ifndef QT_NO_TABWIDGET
+    case SH_TabWidget_DefaultTabPosition:
+        ret = QTabWidget::North;
+        break;
+#endif
+    case SH_ToolBar_Movable:
+        ret = true;
+        break;
+    case SH_TextControl_FocusIndicatorTextCharFormat:
+        ret = true;
+        if (QStyleHintReturnVariant *vret = qstyleoption_cast<QStyleHintReturnVariant*>(hret)) {
+            QPen outline(opt->palette.color(QPalette::Text), 1, Qt::DotLine);
+            QTextCharFormat fmt;
+            fmt.setProperty(QTextFormat::OutlinePen, outline);
+            vret->variant = fmt;
+        }
+        break;
+#ifndef QT_NO_WIZARD
+    case SH_WizardStyle:
+        ret = QWizard::ClassicStyle;
+        break;
+#endif
+    case SH_FormLayoutWrapPolicy:
+        ret = QFormLayout::DontWrapRows;
+        break;
+    case SH_FormLayoutFieldGrowthPolicy:
+        ret = QFormLayout::AllNonFixedFieldsGrow;
+        break;
+    case SH_FormLayoutFormAlignment:
+        ret = Qt::AlignLeft | Qt::AlignTop;
+        break;
+    case SH_FormLayoutLabelAlignment:
+        ret = Qt::AlignLeft;
+        break;
+    case SH_ItemView_ArrowKeysNavigateIntoChildren:
+        ret = false;
+        break;
+    case SH_ItemView_DrawDelegateFrame:
+        ret = 0;
+        break;
+#ifndef QT_NO_TABBAR
+    case SH_TabBar_CloseButtonPosition:
+        ret = QTabBar::RightSide;
+        break;
+#endif
+    case SH_DockWidget_ButtonsHaveFrame:
+        ret = true;
+        break;
+    case SH_ToolButtonStyle:
+        ret = 0;
+        if (const QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme())
+            ret = theme->themeHint(QPlatformTheme::ToolButtonStyle).toInt();
+        break;
+    case SH_RequestSoftwareInputPanel:
+        ret = RSIP_OnMouseClick;
+        break;
+    case SH_ScrollBar_Transient:
+        ret = false;
+        break;
+    case SH_Menu_SupportsSections:
+        ret = false;
+        break;
+#ifndef QT_NO_TOOLTIP
+    case SH_ToolTip_WakeUpDelay:
+        ret = 700;
+        break;
+    case SH_ToolTip_FallAsleepDelay:
+        ret = 2000;
+        break;
+#endif
+    case SH_Widget_Animate:
+#ifndef QT_NO_TREEVIEW
+        if (qobject_cast<const QTreeView*>(widget)) {
+            ret = false;
+        } else
+#endif
+            {
+            ret = true;
+        }
+        break;
+    case SH_Splitter_OpaqueResize:
+        ret = true;
+        break;
+    default:
+        ret = 0;
+        break;
+    }
+
+    return ret;
+}
+
+/*! \reimp */
+QPixmap QCommonStyle::standardPixmap(StandardPixmap sp, const QStyleOption *option,
+                                     const QWidget *widget) const
+{
+    const bool rtl = (option && option->direction == Qt::RightToLeft) || (!option && QApplication::isRightToLeft());
+#ifdef QT_NO_IMAGEFORMAT_PNG
+    Q_UNUSED(widget);
+    Q_UNUSED(sp);
+#else
+    QPixmap pixmap;
+
+    if (QApplication::desktopSettingsAware() && !QIcon::themeName().isEmpty()) {
+        switch (sp) {
+        case SP_DialogYesButton:
+        case SP_DialogOkButton:
+            pixmap = QIcon::fromTheme(QLatin1String("dialog-ok")).pixmap(16);
+            break;
+        case SP_DialogApplyButton:
+            pixmap = QIcon::fromTheme(QLatin1String("dialog-ok-apply")).pixmap(16);
+            break;
+        case SP_DialogDiscardButton:
+            pixmap = QIcon::fromTheme(QLatin1String("edit-delete")).pixmap(16);
+            break;
+        case SP_DialogCloseButton:
+            pixmap = QIcon::fromTheme(QLatin1String("dialog-close")).pixmap(16);
+            break;
+        case SP_DirHomeIcon:
+            pixmap = QIcon::fromTheme(QLatin1String("user-home")).pixmap(16);
+            break;
+        case SP_MessageBoxInformation:
+            pixmap = QIcon::fromTheme(QLatin1String("messagebox_info")).pixmap(16);
+            break;
+        case SP_MessageBoxWarning:
+            pixmap = QIcon::fromTheme(QLatin1String("messagebox_warning")).pixmap(16);
+            break;
+        case SP_MessageBoxCritical:
+            pixmap = QIcon::fromTheme(QLatin1String("messagebox_critical")).pixmap(16);
+            break;
+        case SP_MessageBoxQuestion:
+            pixmap = QIcon::fromTheme(QLatin1String("help")).pixmap(16);
+            break;
+        case SP_DialogOpenButton:
+        case SP_DirOpenIcon:
+            pixmap = QIcon::fromTheme(QLatin1String("folder-open")).pixmap(16);
+            break;
+        case SP_FileIcon:
+            pixmap = QIcon::fromTheme(QLatin1String("text-x-generic"),
+                                      QIcon::fromTheme(QLatin1String("empty"))).pixmap(16);
+            break;
+        case SP_DirClosedIcon:
+        case SP_DirIcon:
+                pixmap = QIcon::fromTheme(QLatin1String("folder")).pixmap(16);
+                break;
+        case SP_DriveFDIcon:
+                pixmap = QIcon::fromTheme(QLatin1String("media-floppy"),
+                                          QIcon::fromTheme(QLatin1String("3floppy_unmount"))).pixmap(16);
+                break;
+        case SP_ComputerIcon:
+                pixmap = QIcon::fromTheme(QLatin1String("computer"),
+                                          QIcon::fromTheme(QLatin1String("system"))).pixmap(16);
+                break;
+        case SP_DesktopIcon:
+                pixmap = QIcon::fromTheme(QLatin1String("user-desktop"),
+                                          QIcon::fromTheme(QLatin1String("desktop"))).pixmap(16);
+                break;
+        case SP_TrashIcon:
+                pixmap = QIcon::fromTheme(QLatin1String("user-trash"),
+                                          QIcon::fromTheme(QLatin1String("trashcan_empty"))).pixmap(16);
+                break;
+        case SP_DriveCDIcon:
+        case SP_DriveDVDIcon:
+                pixmap = QIcon::fromTheme(QLatin1String("media-optical"),
+                                          QIcon::fromTheme(QLatin1String("cdrom_unmount"))).pixmap(16);
+                break;
+        case SP_DriveHDIcon:
+                pixmap = QIcon::fromTheme(QLatin1String("drive-harddisk"),
+                                          QIcon::fromTheme(QLatin1String("hdd_unmount"))).pixmap(16);
+                break;
+        case SP_FileDialogToParent:
+                pixmap = QIcon::fromTheme(QLatin1String("go-up"),
+                                          QIcon::fromTheme(QLatin1String("up"))).pixmap(16);
+                break;
+        case SP_FileDialogNewFolder:
+                pixmap = QIcon::fromTheme(QLatin1String("folder_new")).pixmap(16);
+                break;
+        case SP_ArrowUp:
+                pixmap = QIcon::fromTheme(QLatin1String("go-up"),
+                                          QIcon::fromTheme(QLatin1String("up"))).pixmap(16);
+                break;
+        case SP_ArrowDown:
+                pixmap = QIcon::fromTheme(QLatin1String("go-down"),
+                                          QIcon::fromTheme(QLatin1String("down"))).pixmap(16);
+                break;
+        case SP_ArrowRight:
+                pixmap = QIcon::fromTheme(QLatin1String("go-next"),
+                                          QIcon::fromTheme(QLatin1String("forward"))).pixmap(16);
+                break;
+        case SP_ArrowLeft:
+                pixmap = QIcon::fromTheme(QLatin1String("go-previous"),
+                                          QIcon::fromTheme(QLatin1String("back"))).pixmap(16);
+                break;
+        case SP_FileDialogDetailedView:
+                pixmap = QIcon::fromTheme(QLatin1String("view_detailed")).pixmap(16);
+                break;
+        case SP_FileDialogListView:
+                pixmap = QIcon::fromTheme(QLatin1String("view_icon")).pixmap(16);
+                break;
+        case SP_BrowserReload:
+                pixmap = QIcon::fromTheme(QLatin1String("reload")).pixmap(16);
+                break;
+        case SP_BrowserStop:
+                pixmap = QIcon::fromTheme(QLatin1String("process-stop")).pixmap(16);
+                break;
+        case SP_MediaPlay:
+                pixmap = QIcon::fromTheme(QLatin1String("media-playback-start")).pixmap(16);
+                break;
+        case SP_MediaPause:
+                pixmap = QIcon::fromTheme(QLatin1String("media-playback-pause")).pixmap(16);
+                break;
+        case SP_MediaStop:
+                pixmap = QIcon::fromTheme(QLatin1String("media-playback-stop")).pixmap(16);
+                break;
+        case SP_MediaSeekForward:
+                pixmap = QIcon::fromTheme(QLatin1String("media-seek-forward")).pixmap(16);
+                break;
+        case SP_MediaSeekBackward:
+                pixmap = QIcon::fromTheme(QLatin1String("media-seek-backward")).pixmap(16);
+                break;
+        case SP_MediaSkipForward:
+                pixmap = QIcon::fromTheme(QLatin1String("media-skip-forward")).pixmap(16);
+                break;
+        case SP_MediaSkipBackward:
+                pixmap = QIcon::fromTheme(QLatin1String("media-skip-backward")).pixmap(16);
+                break;
+        case SP_DialogResetButton:
+                pixmap = QIcon::fromTheme(QLatin1String("edit-clear")).pixmap(24);
+                break;
+        case SP_DialogHelpButton:
+                pixmap = QIcon::fromTheme(QLatin1String("help-contents")).pixmap(24);
+                break;
+        case SP_DialogNoButton:
+        case SP_DialogCancelButton:
+                pixmap = QIcon::fromTheme(QLatin1String("dialog-cancel"),
+                                         QIcon::fromTheme(QLatin1String("process-stop"))).pixmap(24);
+                break;
+        case SP_DialogSaveButton:
+                pixmap = QIcon::fromTheme(QLatin1String("document-save")).pixmap(24);
+                break;
+        case SP_FileLinkIcon:
+            pixmap = QIcon::fromTheme(QLatin1String("emblem-symbolic-link")).pixmap(16);
+            if (!pixmap.isNull()) {
+                QPixmap fileIcon = QIcon::fromTheme(QLatin1String("text-x-generic")).pixmap(16);
+                if (fileIcon.isNull())
+                    fileIcon = QIcon::fromTheme(QLatin1String("empty")).pixmap(16);
+                if (!fileIcon.isNull()) {
+                    QPainter painter(&fileIcon);
+                    painter.drawPixmap(0, 0, 16, 16, pixmap);
+                    return fileIcon;
+                }
+            }
+            break;
+        case SP_DirLinkIcon:
+                pixmap = QIcon::fromTheme(QLatin1String("emblem-symbolic-link")).pixmap(16);
+                if (!pixmap.isNull()) {
+                    QPixmap dirIcon = QIcon::fromTheme(QLatin1String("folder")).pixmap(16);
+                    if (!dirIcon.isNull()) {
+                        QPainter painter(&dirIcon);
+                        painter.drawPixmap(0, 0, 16, 16, pixmap);
+                        return dirIcon;
+                    }
+                }
+                break;
+        case SP_LineEditClearButton: {
+            QString themeName = rtl ? QStringLiteral("edit-clear-locationbar-ltr") : QStringLiteral("edit-clear-locationbar-rtl");
+            if (!QIcon::hasThemeIcon(themeName))
+                themeName = QStringLiteral("edit-clear");
+            pixmap = QIcon::fromTheme(themeName).pixmap(16);
+        }
+            break;
+        default:
+            break;
+        }
+    }
+
+    if (!pixmap.isNull())
+        return pixmap;
+#endif //QT_NO_IMAGEFORMAT_PNG
+    switch (sp) {
+#ifndef QT_NO_IMAGEFORMAT_XPM
+    case SP_ToolBarHorizontalExtensionButton:
+        if (rtl) {
+            QImage im(tb_extension_arrow_h_xpm);
+            im = im.convertToFormat(QImage::Format_ARGB32).mirrored(true, false);
+            return QPixmap::fromImage(im);
+        }
+        return QPixmap(tb_extension_arrow_h_xpm);
+    case SP_ToolBarVerticalExtensionButton:
+        return QPixmap(tb_extension_arrow_v_xpm);
+    case SP_FileDialogStart:
+        return QPixmap(filedialog_start_xpm);
+    case SP_FileDialogEnd:
+        return QPixmap(filedialog_end_xpm);
+#endif
+#ifndef QT_NO_IMAGEFORMAT_PNG
+    case SP_CommandLink:
+    case SP_ArrowForward:
+        if (rtl)
+            return proxy()->standardPixmap(SP_ArrowLeft, option, widget);
+        return proxy()->standardPixmap(SP_ArrowRight, option, widget);
+    case SP_ArrowBack:
+        if (rtl)
+            return proxy()->standardPixmap(SP_ArrowRight, option, widget);
+        return proxy()->standardPixmap(SP_ArrowLeft, option, widget);
+    case SP_ArrowLeft:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/left-16.png"));
+    case SP_ArrowRight:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/right-16.png"));
+    case SP_ArrowUp:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/up-16.png"));
+    case SP_ArrowDown:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/down-16.png"));
+    case SP_FileDialogToParent:
+        return proxy()->standardPixmap(SP_ArrowUp, option, widget);
+    case SP_FileDialogNewFolder:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/newdirectory-16.png"));
+    case SP_FileDialogDetailedView:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/viewdetailed-16.png"));
+    case SP_FileDialogInfoView:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/fileinfo-16.png"));
+    case SP_FileDialogContentsView:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/filecontents-16.png"));
+    case SP_FileDialogListView:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/viewlist-16.png"));
+    case SP_FileDialogBack:
+        return proxy()->standardPixmap(SP_ArrowBack, option, widget);
+    case SP_DriveHDIcon:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/harddrive-16.png"));
+    case SP_TrashIcon:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/trash-16.png"));
+    case SP_DriveFDIcon:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/floppy-16.png"));
+    case SP_DriveNetIcon:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/networkdrive-16.png"));
+    case SP_DesktopIcon:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/desktop-16.png"));
+    case SP_ComputerIcon:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/computer-16.png"));
+    case SP_DriveCDIcon:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/cdr-16.png"));
+    case SP_DriveDVDIcon:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/dvd-16.png"));
+    case SP_DirHomeIcon:
+    case SP_DirOpenIcon:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/diropen-16.png"));
+    case SP_DirIcon:
+    case SP_DirClosedIcon:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/dirclosed-16.png"));
+    case SP_DirLinkIcon:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/dirlink-16.png"));
+    case SP_FileIcon:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/file-16.png"));
+    case SP_FileLinkIcon:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/filelink-16.png"));
+    case SP_DialogOkButton:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-ok-16.png"));
+    case SP_DialogCancelButton:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-cancel-16.png"));
+    case SP_DialogHelpButton:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-help-16.png"));
+    case SP_DialogOpenButton:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-open-16.png"));
+    case SP_DialogSaveButton:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-save-16.png"));
+    case SP_DialogCloseButton:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-close-16.png"));
+    case SP_DialogApplyButton:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-apply-16.png"));
+    case SP_DialogResetButton:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-clear-16.png"));
+    case SP_DialogDiscardButton:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-delete-16.png"));
+    case SP_DialogYesButton:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-yes-16.png"));
+    case SP_DialogNoButton:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-no-16.png"));
+    case SP_BrowserReload:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/refresh-24.png"));
+    case SP_BrowserStop:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/stop-24.png"));
+    case SP_MediaPlay:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-play-32.png"));
+    case SP_MediaPause:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-pause-32.png"));
+    case SP_MediaStop:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-stop-32.png"));
+    case SP_MediaSeekForward:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-seek-forward-32.png"));
+    case SP_MediaSeekBackward:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-seek-backward-32.png"));
+    case SP_MediaSkipForward:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-skip-forward-32.png"));
+    case SP_MediaSkipBackward:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-skip-backward-32.png"));
+    case SP_MediaVolume:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-volume-16.png"));
+    case SP_MediaVolumeMuted:
+        return QPixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-volume-muted-16.png"));
+    case SP_LineEditClearButton:
+        return QPixmap(QStringLiteral(":/qt-project.org/styles/commonstyle/images/cleartext-16.png"));
+#endif // QT_NO_IMAGEFORMAT_PNG
+    default:
+        break;
+    }
+
+#ifndef QT_NO_IMAGEFORMAT_XPM
+    switch (sp) {
+    case SP_TitleBarMenuButton:
+        return QPixmap(qt_menu_xpm);
+    case SP_TitleBarShadeButton:
+        return QPixmap(qt_shade_xpm);
+    case SP_TitleBarUnshadeButton:
+        return QPixmap(qt_unshade_xpm);
+    case SP_TitleBarNormalButton:
+        return QPixmap(qt_normalizeup_xpm);
+    case SP_TitleBarMinButton:
+        return QPixmap(qt_minimize_xpm);
+    case SP_TitleBarMaxButton:
+        return QPixmap(qt_maximize_xpm);
+    case SP_TitleBarCloseButton:
+        return QPixmap(qt_close_xpm);
+    case SP_TitleBarContextHelpButton:
+        return QPixmap(qt_help_xpm);
+    case SP_DockWidgetCloseButton:
+        return QPixmap(dock_widget_close_xpm);
+    case SP_MessageBoxInformation:
+        return QPixmap(information_xpm);
+    case SP_MessageBoxWarning:
+        return QPixmap(warning_xpm);
+    case SP_MessageBoxCritical:
+        return QPixmap(critical_xpm);
+    case SP_MessageBoxQuestion:
+        return QPixmap(question_xpm);
+    default:
+        break;
+    }
+#endif //QT_NO_IMAGEFORMAT_XPM
+
+
+    return QPixmap();
+}
+
+/*!
+    \internal
+*/
+QIcon QCommonStyle::standardIcon(StandardPixmap standardIcon, const QStyleOption *option,
+                                 const QWidget *widget) const
+{
+    QIcon icon;
+#ifdef Q_OS_WIN
+    switch (standardIcon) {
+    case SP_DriveCDIcon:
+    case SP_DriveDVDIcon:
+    case SP_DriveNetIcon:
+    case SP_DriveHDIcon:
+    case SP_DriveFDIcon:
+    case SP_FileIcon:
+    case SP_FileLinkIcon:
+    case SP_DesktopIcon:
+    case SP_ComputerIcon:
+        if (const QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme()) {
+            QPlatformTheme::StandardPixmap sp = static_cast<QPlatformTheme::StandardPixmap>(standardIcon);
+            for (int size = 16 ; size <= 32 ; size += 16) {
+                QPixmap pixmap = theme->standardPixmap(sp, QSizeF(size, size));
+                icon.addPixmap(pixmap, QIcon::Normal);
+            }
+        }
+        break;
+    case SP_DirIcon:
+    case SP_DirLinkIcon:
+        if (const QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme()) {
+            QPlatformTheme::StandardPixmap spOff = static_cast<QPlatformTheme::StandardPixmap>(standardIcon);
+            QPlatformTheme::StandardPixmap spOn = standardIcon == SP_DirIcon ? QPlatformTheme::DirOpenIcon :
+                                                                                 QPlatformTheme::DirLinkOpenIcon;
+            for (int size = 16 ; size <= 32 ; size += 16) {
+                QSizeF pixSize(size, size);
+                QPixmap pixmap = theme->standardPixmap(spOff, pixSize);
+                icon.addPixmap(pixmap, QIcon::Normal, QIcon::Off);
+                pixmap = theme->standardPixmap(spOn, pixSize);
+                icon.addPixmap(pixmap, QIcon::Normal, QIcon::On);
+            }
+        }
+        break;
+    case SP_VistaShield:
+        if (const QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme()) {
+            QPlatformTheme::StandardPixmap sp = static_cast<QPlatformTheme::StandardPixmap>(standardIcon);
+            QPixmap pixmap = theme->standardPixmap(sp, QSizeF(32, 32));
+            icon.addPixmap(pixmap);
+        }
+        break;
+    default:
+        break;
+    }
+    if (!icon.isNull())
+        return icon;
+
+#endif
+
+    const bool rtl = (option && option->direction == Qt::RightToLeft) || (!option && QApplication::isRightToLeft());
+    if (QApplication::desktopSettingsAware() && !QIcon::themeName().isEmpty()) {
+        switch (standardIcon) {
+        case SP_DirHomeIcon:
+                icon = QIcon::fromTheme(QLatin1String("user-home"));
+                break;
+        case SP_MessageBoxInformation:
+                icon = QIcon::fromTheme(QLatin1String("dialog-information"));
+                break;
+        case SP_MessageBoxWarning:
+                icon = QIcon::fromTheme(QLatin1String("dialog-warning"));
+                break;
+        case SP_MessageBoxCritical:
+                icon = QIcon::fromTheme(QLatin1String("dialog-error"));
+                break;
+        case SP_MessageBoxQuestion:
+                icon = QIcon::fromTheme(QLatin1String("dialog-question"));
+                break;
+        case SP_DialogOpenButton:
+        case SP_DirOpenIcon:
+                icon = QIcon::fromTheme(QLatin1String("folder-open"));
+                break;
+        case SP_DialogSaveButton:
+                icon = QIcon::fromTheme(QLatin1String("document-save"));
+                break;
+        case SP_DialogApplyButton:
+                icon = QIcon::fromTheme(QLatin1String("dialog-ok-apply"));
+                break;
+        case SP_DialogYesButton:
+        case SP_DialogOkButton:
+                icon = QIcon::fromTheme(QLatin1String("dialog-ok"));
+                break;
+        case SP_DialogDiscardButton:
+                icon = QIcon::fromTheme(QLatin1String("edit-delete"));
+                break;
+        case SP_DialogResetButton:
+                icon = QIcon::fromTheme(QLatin1String("edit-clear"));
+                break;
+        case SP_DialogHelpButton:
+                icon = QIcon::fromTheme(QLatin1String("help-contents"));
+                break;
+        case SP_FileIcon:
+                icon = QIcon::fromTheme(QLatin1String("text-x-generic"));
+                break;
+        case SP_DirClosedIcon:
+        case SP_DirIcon:
+                icon = QIcon::fromTheme(QLatin1String("folder"));
+                break;
+        case SP_DriveFDIcon:
+                icon = QIcon::fromTheme(QLatin1String("floppy_unmount"));
+                break;
+        case SP_ComputerIcon:
+                icon = QIcon::fromTheme(QLatin1String("computer"),
+                                        QIcon::fromTheme(QLatin1String("system")));
+                break;
+        case SP_DesktopIcon:
+                icon = QIcon::fromTheme(QLatin1String("user-desktop"));
+                break;
+        case SP_TrashIcon:
+                icon = QIcon::fromTheme(QLatin1String("user-trash"));
+                break;
+        case SP_DriveCDIcon:
+        case SP_DriveDVDIcon:
+                icon = QIcon::fromTheme(QLatin1String("media-optical"));
+                break;
+        case SP_DriveHDIcon:
+                icon = QIcon::fromTheme(QLatin1String("drive-harddisk"));
+                break;
+        case SP_FileDialogToParent:
+                icon = QIcon::fromTheme(QLatin1String("go-up"));
+                break;
+        case SP_FileDialogNewFolder:
+                icon = QIcon::fromTheme(QLatin1String("folder-new"));
+                break;
+        case SP_ArrowUp:
+                icon = QIcon::fromTheme(QLatin1String("go-up"));
+                break;
+        case SP_ArrowDown:
+                icon = QIcon::fromTheme(QLatin1String("go-down"));
+                break;
+        case SP_ArrowRight:
+                icon = QIcon::fromTheme(QLatin1String("go-next"));
+                break;
+        case SP_ArrowLeft:
+                icon = QIcon::fromTheme(QLatin1String("go-previous"));
+                break;
+        case SP_DialogCancelButton:
+                icon = QIcon::fromTheme(QLatin1String("dialog-cancel"),
+                                        QIcon::fromTheme(QLatin1String("process-stop")));
+                break;
+        case SP_DialogCloseButton:
+                icon = QIcon::fromTheme(QLatin1String("window-close"));
+                break;
+        case SP_FileDialogDetailedView:
+                icon = QIcon::fromTheme(QLatin1String("view-list-details"));
+                break;
+        case SP_FileDialogListView:
+                icon = QIcon::fromTheme(QLatin1String("view-list-icons"));
+                break;
+        case SP_BrowserReload:
+                icon = QIcon::fromTheme(QLatin1String("view-refresh"));
+                break;
+        case SP_BrowserStop:
+                icon = QIcon::fromTheme(QLatin1String("process-stop"));
+                break;
+        case SP_MediaPlay:
+                icon = QIcon::fromTheme(QLatin1String("media-playback-start"));
+                break;
+        case SP_MediaPause:
+                icon = QIcon::fromTheme(QLatin1String("media-playback-pause"));
+                break;
+        case SP_MediaStop:
+                icon = QIcon::fromTheme(QLatin1String("media-playback-stop"));
+                break;
+        case SP_MediaSeekForward:
+                icon = QIcon::fromTheme(QLatin1String("media-seek-forward"));
+                break;
+        case SP_MediaSeekBackward:
+                icon = QIcon::fromTheme(QLatin1String("media-seek-backward"));
+                break;
+        case SP_MediaSkipForward:
+                icon = QIcon::fromTheme(QLatin1String("media-skip-forward"));
+                break;
+        case SP_MediaSkipBackward:
+                icon = QIcon::fromTheme(QLatin1String("media-skip-backward"));
+                break;
+        case SP_MediaVolume:
+                icon = QIcon::fromTheme(QLatin1String("audio-volume-medium"));
+                break;
+        case SP_MediaVolumeMuted:
+                icon = QIcon::fromTheme(QLatin1String("audio-volume-muted"));
+                break;
+        case SP_ArrowForward:
+            if (rtl)
+                return QCommonStyle::standardIcon(SP_ArrowLeft, option, widget);
+            return QCommonStyle::standardIcon(SP_ArrowRight, option, widget);
+        case SP_ArrowBack:
+            if (rtl)
+                return QCommonStyle::standardIcon(SP_ArrowRight, option, widget);
+            return QCommonStyle::standardIcon(SP_ArrowLeft, option, widget);
+        case SP_FileLinkIcon:
+            {
+                QIcon linkIcon = QIcon::fromTheme(QLatin1String("emblem-symbolic-link"));
+                if (!linkIcon.isNull()) {
+                    QIcon baseIcon = QCommonStyle::standardIcon(SP_FileIcon, option, widget);
+                    const QList<QSize> sizes = baseIcon.availableSizes(QIcon::Normal, QIcon::Off);
+                    for (int i = 0 ; i < sizes.size() ; ++i) {
+                        int size = sizes[i].width();
+                        QPixmap basePixmap = baseIcon.pixmap(size);
+                        QPixmap linkPixmap = linkIcon.pixmap(size/2);
+                        QPainter painter(&basePixmap);
+                        painter.drawPixmap(size/2, size/2, linkPixmap);
+                        icon.addPixmap(basePixmap);
+                    }
+                }
+            }
+            break;
+        case SP_DirLinkIcon:
+            {
+                QIcon linkIcon = QIcon::fromTheme(QLatin1String("emblem-symbolic-link"));
+                if (!linkIcon.isNull()) {
+                    QIcon baseIcon = QCommonStyle::standardIcon(SP_DirIcon, option, widget);
+                    const QList<QSize> sizes = baseIcon.availableSizes(QIcon::Normal, QIcon::Off);
+                    for (int i = 0 ; i < sizes.size() ; ++i) {
+                        int size = sizes[i].width();
+                        QPixmap basePixmap = baseIcon.pixmap(size);
+                        QPixmap linkPixmap = linkIcon.pixmap(size/2);
+                        QPainter painter(&basePixmap);
+                        painter.drawPixmap(size/2, size/2, linkPixmap);
+                        icon.addPixmap(basePixmap);
+                    }
+                }
+        }
+        break;
+        default:
+            break;
+        }
+    } // if (QApplication::desktopSettingsAware() && !QIcon::themeName().isEmpty())
+
+    if (!icon.isNull())
+        return icon;
+
+#if defined(Q_OS_MAC)
+    if (QApplication::desktopSettingsAware()) {
+        switch (standardIcon) {
+        case SP_DirIcon: {
+            // A rather special case
+            QIcon closeIcon = QCommonStyle::standardIcon(SP_DirClosedIcon, option, widget);
+            QIcon openIcon = QCommonStyle::standardIcon(SP_DirOpenIcon, option, widget);
+            closeIcon.addPixmap(openIcon.pixmap(16, 16), QIcon::Normal, QIcon::On);
+            closeIcon.addPixmap(openIcon.pixmap(32, 32), QIcon::Normal, QIcon::On);
+            closeIcon.addPixmap(openIcon.pixmap(64, 64), QIcon::Normal, QIcon::On);
+            closeIcon.addPixmap(openIcon.pixmap(128, 128), QIcon::Normal, QIcon::On);
+            return closeIcon;
+        }
+
+        case SP_TitleBarNormalButton:
+        case SP_TitleBarCloseButton: {
+            QIcon titleBarIcon;
+            if (standardIcon == SP_TitleBarCloseButton) {
+                titleBarIcon.addFile(QLatin1String(":/qt-project.org/styles/macstyle/images/closedock-16.png"));
+                titleBarIcon.addFile(QLatin1String(":/qt-project.org/styles/macstyle/images/closedock-down-16.png"), QSize(16, 16), QIcon::Normal, QIcon::On);
+            } else {
+                titleBarIcon.addFile(QLatin1String(":/qt-project.org/styles/macstyle/images/dockdock-16.png"));
+                titleBarIcon.addFile(QLatin1String(":/qt-project.org/styles/macstyle/images/dockdock-down-16.png"), QSize(16, 16), QIcon::Normal, QIcon::On);
+            }
+            return titleBarIcon;
+        }
+
+        case SP_MessageBoxQuestion:
+        case SP_MessageBoxInformation:
+        case SP_MessageBoxWarning:
+        case SP_MessageBoxCritical:
+        case SP_DesktopIcon:
+        case SP_TrashIcon:
+        case SP_ComputerIcon:
+        case SP_DriveFDIcon:
+        case SP_DriveHDIcon:
+        case SP_DriveCDIcon:
+        case SP_DriveDVDIcon:
+        case SP_DriveNetIcon:
+        case SP_DirOpenIcon:
+        case SP_DirClosedIcon:
+        case SP_DirLinkIcon:
+        case SP_FileLinkIcon:
+        case SP_FileIcon:
+            if (const QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme()) {
+                QPlatformTheme::StandardPixmap sp = static_cast<QPlatformTheme::StandardPixmap>(standardIcon);
+                QIcon retIcon;
+                QList<int> sizes = theme->themeHint(QPlatformTheme::IconPixmapSizes).value<QList<int> >();
+                Q_FOREACH (int size, sizes) {
+                    QPixmap mainIcon;
+                    const QString cacheKey = QLatin1String("qt_mac_constructQIconFromIconRef") + QString::number(standardIcon) + QString::number(size);
+                    if (standardIcon >= QStyle::SP_CustomBase) {
+                        mainIcon = theme->standardPixmap(sp, QSizeF(size, size));
+                    } else if (QPixmapCache::find(cacheKey, mainIcon) == false) {
+                        mainIcon = theme->standardPixmap(sp, QSizeF(size, size));
+                        QPixmapCache::insert(cacheKey, mainIcon);
+                    }
+
+                    retIcon.addPixmap(mainIcon);
+                }
+                if (!retIcon.isNull())
+                    return retIcon;
+            }
+
+        default:
+            break;
+        }
+    } // if (QApplication::desktopSettingsAware())
+#endif // Q_OS_MAC
+
+    switch (standardIcon) {
+#ifndef QT_NO_IMAGEFORMAT_PNG
+     case SP_FileDialogNewFolder:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/newdirectory-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/newdirectory-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/newdirectory-128.png"), QSize(128, 128));
+        break;
+    case SP_FileDialogBack:
+        return QCommonStyle::standardIcon(SP_ArrowBack, option, widget);
+    case SP_FileDialogToParent:
+        return QCommonStyle::standardIcon(SP_ArrowUp, option, widget);
+    case SP_FileDialogDetailedView:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/viewdetailed-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/viewdetailed-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/viewdetailed-128.png"), QSize(128, 128));
+        break;
+    case SP_FileDialogInfoView:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/fileinfo-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/fileinfo-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/fileinfo-128.png"), QSize(128, 128));
+        break;
+    case SP_FileDialogContentsView:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/filecontents-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/filecontents-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/filecontents-128.png"), QSize(128, 128));
+        break;
+    case SP_FileDialogListView:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/viewlist-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/viewlist-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/viewlist-128.png"), QSize(128, 128));
+        break;
+    case SP_DialogOkButton:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-ok-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-ok-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-ok-128.png"), QSize(128, 128));
+        break;
+    case SP_DialogCancelButton:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-cancel-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-cancel-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-cancel-128.png"), QSize(128, 128));
+        break;
+    case SP_DialogHelpButton:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-help-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-help-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-help-128.png"), QSize(128, 128));
+        break;
+    case SP_DialogOpenButton:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-open-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-open-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-open-128.png"), QSize(128, 128));
+        break;
+    case SP_DialogSaveButton:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-save-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-save-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-save-128.png"), QSize(128, 128));
+        break;
+    case SP_DialogCloseButton:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-close-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-close-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-close-128.png"), QSize(128, 128));
+        break;
+    case SP_DialogApplyButton:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-apply-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-apply-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-apply-128.png"), QSize(128, 128));
+        break;
+    case SP_DialogResetButton:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-clear-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-clear-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-clear-128.png"), QSize(128, 128));
+        break;
+    case SP_DialogDiscardButton:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-delete-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-delete-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-delete-128.png"), QSize(128, 128));
+        break;
+    case SP_DialogYesButton:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-yes-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-yes-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-yes-128.png"), QSize(128, 128));
+        break;
+    case SP_DialogNoButton:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-no-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-no-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/standardbutton-no-128.png"), QSize(128, 128));
+        break;
+    case SP_ArrowForward:
+        if (rtl)
+            return QCommonStyle::standardIcon(SP_ArrowLeft, option, widget);
+        return QCommonStyle::standardIcon(SP_ArrowRight, option, widget);
+    case SP_ArrowBack:
+        if (rtl)
+            return QCommonStyle::standardIcon(SP_ArrowRight, option, widget);
+        return QCommonStyle::standardIcon(SP_ArrowLeft, option, widget);
+    case SP_ArrowLeft:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/left-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/left-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/left-128.png"), QSize(128, 128));
+        break;
+    case SP_ArrowRight:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/right-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/right-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/right-128.png"), QSize(128, 128));
+        break;
+    case SP_ArrowUp:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/up-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/up-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/up-128.png"), QSize(128, 128));
+        break;
+    case SP_ArrowDown:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/down-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/down-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/down-128.png"), QSize(128, 128));
+        break;
+   case SP_DirHomeIcon:
+   case SP_DirIcon:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/dirclosed-16.png"),
+                     QSize(), QIcon::Normal, QIcon::Off);
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/diropen-16.png"),
+                     QSize(), QIcon::Normal, QIcon::On);
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/dirclosed-32.png"),
+                     QSize(32, 32), QIcon::Normal, QIcon::Off);
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/diropen-32.png"),
+                     QSize(32, 32), QIcon::Normal, QIcon::On);
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/dirclosed-128.png"),
+                     QSize(128, 128), QIcon::Normal, QIcon::Off);
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/diropen-128.png"),
+                     QSize(128, 128), QIcon::Normal, QIcon::On);
+        break;
+    case SP_DriveCDIcon:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/cdr-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/cdr-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/cdr-128.png"), QSize(128, 128));
+        break;
+    case SP_DriveDVDIcon:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/dvd-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/dvd-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/dvd-128.png"), QSize(128, 128));
+        break;
+    case SP_FileIcon:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/file-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/file-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/file-128.png"), QSize(128, 128));
+        break;
+    case SP_FileLinkIcon:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/filelink-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/filelink-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/filelink-128.png"), QSize(128, 128));
+        break;
+    case SP_TrashIcon:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/trash-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/trash-32.png"), QSize(32, 32));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/trash-128.png"), QSize(128, 128));
+        break;
+    case SP_BrowserReload:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/refresh-24.png"), QSize(24, 24));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/refresh-32.png"), QSize(32, 32));
+        break;
+    case SP_BrowserStop:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/stop-24.png"), QSize(24, 24));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/stop-32.png"), QSize(32, 32));
+        break;
+    case SP_MediaPlay:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-play-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-play-32.png"), QSize(32, 32));
+        break;
+    case SP_MediaPause:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-pause-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-pause-32.png"), QSize(32, 32));
+        break;
+    case SP_MediaStop:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-stop-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-stop-32.png"), QSize(32, 32));
+        break;
+    case SP_MediaSeekForward:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-seek-forward-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-seek-forward-32.png"), QSize(32, 32));
+        break;
+    case SP_MediaSeekBackward:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-seek-backward-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-seek-backward-32.png"), QSize(32, 32));
+        break;
+    case SP_MediaSkipForward:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-skip-forward-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-skip-forward-32.png"), QSize(32, 32));
+        break;
+    case SP_MediaSkipBackward:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-skip-backward-16.png"), QSize(16, 16));
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-skip-backward-32.png"), QSize(32, 32));
+        break;
+    case SP_MediaVolume:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-volume-16.png"), QSize(16, 16));
+        break;
+    case SP_MediaVolumeMuted:
+        icon.addFile(QLatin1String(":/qt-project.org/styles/commonstyle/images/media-volume-muted-16.png"), QSize(16, 16));
+        break;
+#endif // QT_NO_IMAGEFORMAT_PNG
+    default:
+        icon.addPixmap(proxy()->standardPixmap(standardIcon, option, widget));
+        break;
+    }
+    return icon;
+}
+
+static inline uint qt_intensity(uint r, uint g, uint b)
+{
+    // 30% red, 59% green, 11% blue
+    return (77 * r + 150 * g + 28 * b) / 255;
+}
+
+/*! \reimp */
+QPixmap QCommonStyle::generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
+                                          const QStyleOption *opt) const
+{
+    switch (iconMode) {
+    case QIcon::Disabled: {
+        QImage im = pixmap.toImage().convertToFormat(QImage::Format_ARGB32);
+
+        // Create a colortable based on the background (black -> bg -> white)
+        QColor bg = opt->palette.color(QPalette::Disabled, QPalette::Window);
+        int red = bg.red();
+        int green = bg.green();
+        int blue = bg.blue();
+        uchar reds[256], greens[256], blues[256];
+        for (int i=0; i<128; ++i) {
+            reds[i]   = uchar((red   * (i<<1)) >> 8);
+            greens[i] = uchar((green * (i<<1)) >> 8);
+            blues[i]  = uchar((blue  * (i<<1)) >> 8);
+        }
+        for (int i=0; i<128; ++i) {
+            reds[i+128]   = uchar(qMin(red   + (i << 1), 255));
+            greens[i+128] = uchar(qMin(green + (i << 1), 255));
+            blues[i+128]  = uchar(qMin(blue  + (i << 1), 255));
+        }
+
+        int intensity = qt_intensity(red, green, blue);
+        const int factor = 191;
+
+        // High intensity colors needs dark shifting in the color table, while
+        // low intensity colors needs light shifting. This is to increase the
+        // percieved contrast.
+        if ((red - factor > green && red - factor > blue)
+            || (green - factor > red && green - factor > blue)
+            || (blue - factor > red && blue - factor > green))
+            intensity = qMin(255, intensity + 91);
+        else if (intensity <= 128)
+            intensity -= 51;
+
+        for (int y=0; y<im.height(); ++y) {
+            QRgb *scanLine = (QRgb*)im.scanLine(y);
+            for (int x=0; x<im.width(); ++x) {
+                QRgb pixel = *scanLine;
+                // Calculate color table index, taking intensity adjustment
+                // and a magic offset into account.
+                uint ci = uint(qGray(pixel)/3 + (130 - intensity / 3));
+                *scanLine = qRgba(reds[ci], greens[ci], blues[ci], qAlpha(pixel));
+                ++scanLine;
+            }
+        }
+
+        return QPixmap::fromImage(im);
+    }
+    case QIcon::Selected: {
+        QImage img = pixmap.toImage().convertToFormat(QImage::Format_ARGB32_Premultiplied);
+        QColor color = opt->palette.color(QPalette::Normal, QPalette::Highlight);
+        color.setAlphaF(qreal(0.3));
+        QPainter painter(&img);
+        painter.setCompositionMode(QPainter::CompositionMode_SourceAtop);
+        painter.fillRect(0, 0, img.width(), img.height(), color);
+        painter.end();
+        return QPixmap::fromImage(img); }
+    case QIcon::Active:
+        return pixmap;
+    default:
+        break;
+    }
+    return pixmap;
+}
+
+/*!
+  \reimp
+*/
+int QCommonStyle::layoutSpacing(QSizePolicy::ControlType /* control1 */, QSizePolicy::ControlType /* control2 */,
+                          Qt::Orientation /* orientation */, const QStyleOption * /* option */,
+                          const QWidget * /* widget */) const
+{
+    return -1;
+}
+
+/*!
+  \reimp
+*/
+void QCommonStyle::polish(QPalette &pal)
+{
+    QStyle::polish(pal);
+}
+
+/*!
+    \reimp
+ */
+void QCommonStyle::polish(QWidget *widget)
+{
+    QStyle::polish(widget);
+}
+
+/*!
+    \reimp
+ */
+void QCommonStyle::unpolish(QWidget *widget)
+{
+    QStyle::unpolish(widget);
+}
+
+/*!
+  \reimp
+*/
+void QCommonStyle::polish(QApplication *app)
+{
+    QStyle::polish(app);
+}
+
+/*!
+    \reimp
+ */
+void QCommonStyle::unpolish(QApplication *application)
+{
+    Q_D(const QCommonStyle);
+    d->tabBarcloseButtonIcon = QIcon();
+    QStyle::unpolish(application);
+}
+
+
+QT_END_NAMESPACE
+
+#include "moc_qcommonstyle.cpp"
diff --git a/.pc/inendi.patch/src/widgets/styles/qfusionstyle.cpp b/.pc/inendi.patch/src/widgets/styles/qfusionstyle.cpp
new file mode 100644
index 0000000..012f5ea
--- /dev/null
+++ b/.pc/inendi.patch/src/widgets/styles/qfusionstyle.cpp
@@ -0,0 +1,3699 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtWidgets module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qfusionstyle_p.h"
+#include "qfusionstyle_p_p.h"
+
+#if !defined(QT_NO_STYLE_FUSION) || defined(QT_PLUGIN)
+#include "qcommonstyle_p.h"
+#include <qcombobox.h>
+#include <qpushbutton.h>
+#include <qpainter.h>
+#include <qdir.h>
+#include <qhash.h>
+#include <qstyleoption.h>
+#include <qapplication.h>
+#include <qmainwindow.h>
+#include <qfont.h>
+#include <qgroupbox.h>
+#include <qprocess.h>
+#include <qpixmapcache.h>
+#include <qdialogbuttonbox.h>
+#include <qscrollbar.h>
+#include <qspinbox.h>
+#include <qslider.h>
+#include <qsplitter.h>
+#include <qprogressbar.h>
+#include <qwizard.h>
+#include <qlibrary.h>
+#include <qdrawutil.h>
+#include <private/qstylehelper_p.h>
+#include <private/qdrawhelper_p.h>
+#include <private/qapplication_p.h>
+
+QT_BEGIN_NAMESPACE
+
+using namespace QStyleHelper;
+
+enum Direction {
+    TopDown,
+    FromLeft,
+    BottomUp,
+    FromRight
+};
+
+// from windows style
+static const int windowsItemFrame        =  2; // menu item frame width
+static const int windowsItemHMargin      =  3; // menu item hor text margin
+static const int windowsItemVMargin      =  8; // menu item ver text margin
+static const int windowsRightBorder      = 15; // right border on windows
+
+static const int groupBoxBottomMargin    =  0;  // space below the groupbox
+static const int groupBoxTopMargin       =  3;
+
+
+/* XPM */
+static const char * const dock_widget_close_xpm[] = {
+    "11 13 7 1",
+    "  c None",
+    ". c #D5CFCB",
+    "+ c #8F8B88",
+    "@ c #6C6A67",
+    "# c #ABA6A3",
+    "$ c #B5B0AC",
+    "% c #A4A09D",
+    "           ",
+    " +@@@@@@@+ ",
+    "+#       #+",
+    "@ $@   @$ @",
+    "@ @@@ @@@ @",
+    "@  @@@@@  @",
+    "@   @@@   @",
+    "@  @@@@@  @",
+    "@ @@@ @@@ @",
+    "@ $@   @$ @",
+    "+%       #+",
+    " +@@@@@@@+ ",
+    "           "};
+
+static const char * const dock_widget_restore_xpm[] = {
+    "11 13 7 1",
+    " c None",
+    ". c #D5CFCB",
+    "+ c #8F8B88",
+    "@ c #6C6A67",
+    "# c #ABA6A3",
+    "$ c #B5B0AC",
+    "% c #A4A09D",
+    "           ",
+    " +@@@@@@@+ ",
+    "+#       #+",
+    "@   #@@@# @",
+    "@   @   @ @",
+    "@ #@@@# @ @",
+    "@ @   @ @ @",
+    "@ @   @@@ @",
+    "@ @   @   @",
+    "@ #@@@#   @",
+    "+%       #+",
+    " +@@@@@@@+ ",
+    "           "};
+
+static const char * const workspace_minimize[] = {
+    "11 13 7 1",
+    "  c None",
+    ". c #D5CFCB",
+    "+ c #8F8B88",
+    "@ c #6C6A67",
+    "# c #ABA6A3",
+    "$ c #B5B0AC",
+    "% c #A4A09D",
+    "           ",
+    " +@@@@@@@+ ",
+    "+#       #+",
+    "@         @",
+    "@         @",
+    "@         @",
+    "@ @@@@@@@ @",
+    "@ @@@@@@@ @",
+    "@         @",
+    "@         @",
+    "+%       #+",
+    " +@@@@@@@+ ",
+    "           "};
+
+
+static const char * const qt_titlebar_context_help[] = {
+    "10 10 3 1",
+    "  c None",
+    "# c #000000",
+    "+ c #444444",
+    "  +####+  ",
+    " ###  ### ",
+    " ##    ## ",
+    "     +##+ ",
+    "    +##   ",
+    "    ##    ",
+    "    ##    ",
+    "          ",
+    "    ##    ",
+    "    ##    "};
+
+
+static QColor mergedColors(const QColor &colorA, const QColor &colorB, int factor = 50)
+{
+    const int maxFactor = 100;
+    QColor tmp = colorA;
+    tmp.setRed((tmp.red() * factor) / maxFactor + (colorB.red() * (maxFactor - factor)) / maxFactor);
+    tmp.setGreen((tmp.green() * factor) / maxFactor + (colorB.green() * (maxFactor - factor)) / maxFactor);
+    tmp.setBlue((tmp.blue() * factor) / maxFactor + (colorB.blue() * (maxFactor - factor)) / maxFactor);
+    return tmp;
+}
+
+static QPixmap colorizedImage(const QString &fileName, const QColor &color, int rotation = 0) {
+
+    QString pixmapName = QLatin1String("$qt_ia-") % fileName % HexString<uint>(color.rgba()) % QString::number(rotation);
+    QPixmap pixmap;
+    if (!QPixmapCache::find(pixmapName, pixmap)) {
+        QImage image(fileName);
+
+        if (image.format() != QImage::Format_ARGB32_Premultiplied)
+            image = image.convertToFormat( QImage::Format_ARGB32_Premultiplied);
+
+        int width = image.width();
+        int height = image.height();
+        int source = color.rgba();
+
+        unsigned char sourceRed = qRed(source);
+        unsigned char sourceGreen = qGreen(source);
+        unsigned char sourceBlue = qBlue(source);
+
+        for (int y = 0; y < height; ++y)
+        {
+            QRgb *data = (QRgb*) image.scanLine(y);
+            for (int x = 0 ; x < width ; x++) {
+                QRgb col = data[x];
+                unsigned int colorDiff = (qBlue(col) - qRed(col));
+                unsigned char gray = qGreen(col);
+                unsigned char red = gray + qt_div_255(sourceRed * colorDiff);
+                unsigned char green = gray + qt_div_255(sourceGreen * colorDiff);
+                unsigned char blue = gray + qt_div_255(sourceBlue * colorDiff);
+                unsigned char alpha = qt_div_255(qAlpha(col) * qAlpha(source));
+                data[x] = qRgba(red, green, blue, alpha);
+            }
+        }
+        if (rotation != 0) {
+            QTransform transform;
+            transform.translate(-image.width()/2, -image.height()/2);
+            transform.rotate(rotation);
+            transform.translate(image.width()/2, image.height()/2);
+            image = image.transformed(transform);
+        }
+
+        pixmap = QPixmap::fromImage(image);
+        QPixmapCache::insert(pixmapName, pixmap);
+    }
+    return pixmap;
+}
+
+// The default button and handle gradient
+static QLinearGradient qt_fusion_gradient(const QRect &rect, const QBrush &baseColor, Direction direction = TopDown)
+{
+    int x = rect.center().x();
+    int y = rect.center().y();
+    QLinearGradient gradient;
+    switch (direction) {
+    case FromLeft:
+        gradient = QLinearGradient(rect.left(), y, rect.right(), y);
+        break;
+    case FromRight:
+        gradient = QLinearGradient(rect.right(), y, rect.left(), y);
+        break;
+    case BottomUp:
+        gradient = QLinearGradient(x, rect.bottom(), x, rect.top());
+        break;
+    case TopDown:
+    default:
+        gradient = QLinearGradient(x, rect.top(), x, rect.bottom());
+        break;
+    }
+    if (baseColor.gradient())
+        gradient.setStops(baseColor.gradient()->stops());
+    else {
+        QColor gradientStartColor = baseColor.color().lighter(124);
+        QColor gradientStopColor = baseColor.color().lighter(102);
+        gradient.setColorAt(0, gradientStartColor);
+        gradient.setColorAt(1, gradientStopColor);
+        //          Uncomment for adding shiny shading
+        //            QColor midColor1 = mergedColors(gradientStartColor, gradientStopColor, 55);
+        //            QColor midColor2 = mergedColors(gradientStartColor, gradientStopColor, 45);
+        //            gradient.setColorAt(0.5, midColor1);
+        //            gradient.setColorAt(0.501, midColor2);
+    }
+    return gradient;
+}
+
+
+static void qt_fusion_draw_mdibutton(QPainter *painter, const QStyleOptionTitleBar *option, const QRect &tmp, bool hover, bool sunken)
+{
+    QColor dark;
+    dark.setHsv(option->palette.button().color().hue(),
+                qMin(255, (int)(option->palette.button().color().saturation())),
+                qMin(255, (int)(option->palette.button().color().value()*0.7)));
+
+    QColor highlight = option->palette.highlight().color();
+
+    bool active = (option->titleBarState & QStyle::State_Active);
+    QColor titleBarHighlight(255, 255, 255, 60);
+
+    if (sunken)
+        painter->fillRect(tmp.adjusted(1, 1, -1, -1), option->palette.highlight().color().darker(120));
+    else if (hover)
+        painter->fillRect(tmp.adjusted(1, 1, -1, -1), QColor(255, 255, 255, 20));
+
+    QColor mdiButtonGradientStartColor;
+    QColor mdiButtonGradientStopColor;
+
+    mdiButtonGradientStartColor = QColor(0, 0, 0, 40);
+    mdiButtonGradientStopColor = QColor(255, 255, 255, 60);
+
+    if (sunken)
+        titleBarHighlight = highlight.darker(130);
+
+    QLinearGradient gradient(tmp.center().x(), tmp.top(), tmp.center().x(), tmp.bottom());
+    gradient.setColorAt(0, mdiButtonGradientStartColor);
+    gradient.setColorAt(1, mdiButtonGradientStopColor);
+    QColor mdiButtonBorderColor(active ? option->palette.highlight().color().darker(180): dark.darker(110));
+
+    painter->setPen(QPen(mdiButtonBorderColor));
+    const QLine lines[4] = {
+        QLine(tmp.left() + 2, tmp.top(), tmp.right() - 2, tmp.top()),
+        QLine(tmp.left() + 2, tmp.bottom(), tmp.right() - 2, tmp.bottom()),
+        QLine(tmp.left(), tmp.top() + 2, tmp.left(), tmp.bottom() - 2),
+        QLine(tmp.right(), tmp.top() + 2, tmp.right(), tmp.bottom() - 2)
+    };
+    painter->drawLines(lines, 4);
+    const QPoint points[4] = {
+        QPoint(tmp.left() + 1, tmp.top() + 1),
+        QPoint(tmp.right() - 1, tmp.top() + 1),
+        QPoint(tmp.left() + 1, tmp.bottom() - 1),
+        QPoint(tmp.right() - 1, tmp.bottom() - 1)
+    };
+    painter->drawPoints(points, 4);
+
+    painter->setPen(titleBarHighlight);
+    painter->drawLine(tmp.left() + 2, tmp.top() + 1, tmp.right() - 2, tmp.top() + 1);
+    painter->drawLine(tmp.left() + 1, tmp.top() + 2, tmp.left() + 1, tmp.bottom() - 2);
+
+    painter->setPen(QPen(gradient, 1));
+    painter->drawLine(tmp.right() + 1, tmp.top() + 2, tmp.right() + 1, tmp.bottom() - 2);
+    painter->drawPoint(tmp.right() , tmp.top() + 1);
+
+    painter->drawLine(tmp.left() + 2, tmp.bottom() + 1, tmp.right() - 2, tmp.bottom() + 1);
+    painter->drawPoint(tmp.left() + 1, tmp.bottom());
+    painter->drawPoint(tmp.right() - 1, tmp.bottom());
+    painter->drawPoint(tmp.right() , tmp.bottom() - 1);
+}
+
+/*
+    \internal
+*/
+QFusionStylePrivate::QFusionStylePrivate()
+{
+    animationFps = 60;
+}
+
+/*!
+    \class QFusionStyle
+    \brief The QFusionStyle class provides a custom widget style
+
+    \inmodule QtWidgets
+    \internal
+
+    The Fusion style provides a custom look and feel that is not
+    tied to a particular platform.
+    //{Fusion Style Widget Gallery}
+    \sa QWindowsStyle, QWindowsVistaStyle, QMacStyle, QCommonStyle
+*/
+
+/*!
+    Constructs a QFusionStyle object.
+*/
+QFusionStyle::QFusionStyle() : QCommonStyle(*new QFusionStylePrivate)
+{
+    setObjectName(QLatin1String("Fusion"));
+}
+
+/*!
+    \internal
+
+    Constructs a QFusionStyle object.
+*/
+QFusionStyle::QFusionStyle(QFusionStylePrivate &dd) : QCommonStyle(dd)
+{
+}
+
+/*!
+    Destroys the QFusionStyle object.
+*/
+QFusionStyle::~QFusionStyle()
+{
+}
+
+/*!
+    \fn void QFusionStyle::drawItemText(QPainter *painter, const QRect &rectangle, int alignment, const QPalette &palette,
+                                    bool enabled, const QString& text, QPalette::ColorRole textRole) const
+
+    Draws the given \a text in the specified \a rectangle using the
+    provided \a painter and \a palette.
+
+    Text is drawn using the painter's pen. If an explicit \a textRole
+    is specified, then the text is drawn using the \a palette's color
+    for the specified role.  The \a enabled value indicates whether or
+    not the item is enabled; when reimplementing, this value should
+    influence how the item is drawn.
+
+    The text is aligned and wrapped according to the specified \a
+    alignment.
+
+    \sa Qt::Alignment
+*/
+void QFusionStyle::drawItemText(QPainter *painter, const QRect &rect, int alignment, const QPalette &pal,
+                                bool enabled, const QString& text, QPalette::ColorRole textRole) const
+{
+    if (text.isEmpty())
+        return;
+
+    QPen savedPen = painter->pen();
+    if (textRole != QPalette::NoRole) {
+        painter->setPen(QPen(pal.brush(textRole), savedPen.widthF()));
+    }
+    if (!enabled) {
+        QPen pen = painter->pen();
+        painter->setPen(pen);
+    }
+    painter->drawText(rect, alignment, text);
+    painter->setPen(savedPen);
+}
+
+
+/*!
+    \reimp
+*/
+void QFusionStyle::drawPrimitive(PrimitiveElement elem,
+                                 const QStyleOption *option,
+                                 QPainter *painter, const QWidget *widget) const
+{
+    Q_ASSERT(option);
+    Q_D (const QFusionStyle);
+
+    QRect rect = option->rect;
+    int state = option->state;
+
+    QColor outline = d->outline(option->palette);
+    QColor highlightedOutline = d->highlightedOutline(option->palette);
+
+    QColor tabFrameColor = d->tabFrameColor(option->palette);
+
+    switch (elem) {
+
+    // No frame drawn
+    case PE_FrameGroupBox:
+    {
+        QPixmap pixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_groupbox.png"));
+        int topMargin = qMax(pixelMetric(PM_ExclusiveIndicatorHeight), option->fontMetrics.height()) + groupBoxTopMargin;
+        QRect frame = option->rect.adjusted(0, topMargin, 0, 0);
+        qDrawBorderPixmap(painter, frame, QMargins(6, 6, 6, 6), pixmap);
+        break;
+    }
+    case PE_IndicatorBranch: {
+        if (!(option->state & State_Children))
+            break;
+        if (option->state & State_Open)
+            drawPrimitive(PE_IndicatorArrowDown, option, painter, widget);
+        else
+            drawPrimitive(PE_IndicatorArrowRight, option, painter, widget);
+        break;
+    }
+    case PE_FrameTabBarBase:
+        if (const QStyleOptionTabBarBase *tbb
+                = qstyleoption_cast<const QStyleOptionTabBarBase *>(option)) {
+            painter->save();
+            painter->setPen(QPen(outline.lighter(110)));
+            switch (tbb->shape) {
+            case QTabBar::RoundedNorth: {
+                QRegion region(tbb->rect);
+                region -= tbb->selectedTabRect;
+                painter->drawLine(tbb->rect.topLeft(), tbb->rect.topRight());
+                painter->setClipRegion(region);
+                painter->setPen(option->palette.light().color());
+                painter->drawLine(tbb->rect.topLeft() + QPoint(0, 1), tbb->rect.topRight() + QPoint(0, 1));
+            }
+                break;
+            case QTabBar::RoundedWest:
+                painter->drawLine(tbb->rect.left(), tbb->rect.top(), tbb->rect.left(), tbb->rect.bottom());
+                break;
+            case QTabBar::RoundedSouth:
+                painter->drawLine(tbb->rect.left(), tbb->rect.bottom(),
+                                  tbb->rect.right(), tbb->rect.bottom());
+                break;
+            case QTabBar::RoundedEast:
+                painter->drawLine(tbb->rect.topRight(), tbb->rect.bottomRight());
+                break;
+            case QTabBar::TriangularNorth:
+            case QTabBar::TriangularEast:
+            case QTabBar::TriangularWest:
+            case QTabBar::TriangularSouth:
+                painter->restore();
+                QCommonStyle::drawPrimitive(elem, option, painter, widget);
+                return;
+            }
+            painter->restore();
+        }
+        return;
+    case PE_PanelScrollAreaCorner: {
+        painter->save();
+        QColor alphaOutline = outline;
+        alphaOutline.setAlpha(180);
+        painter->setPen(alphaOutline);
+        painter->setBrush(option->palette.brush(QPalette::Window));
+        painter->drawRect(option->rect);
+        painter->restore();
+    } break;
+    case PE_IndicatorArrowUp:
+    case PE_IndicatorArrowDown:
+    case PE_IndicatorArrowRight:
+    case PE_IndicatorArrowLeft:
+    {
+        if (option->rect.width() <= 1 || option->rect.height() <= 1)
+            break;
+        QColor arrowColor = option->palette.foreground().color();
+        QPixmap arrow;
+        int rotation = 0;
+        switch (elem) {
+        case PE_IndicatorArrowDown:
+            rotation = 180;
+            break;
+        case PE_IndicatorArrowRight:
+            rotation = 90;
+            break;
+        case PE_IndicatorArrowLeft:
+            rotation = -90;
+            break;
+        default:
+            break;
+        }
+        arrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), arrowColor, rotation);
+        QRect rect = option->rect;
+        QRect arrowRect;
+        int imageMax = qMin(arrow.height(), arrow.width());
+        int rectMax = qMin(rect.height(), rect.width());
+        int size = qMin(imageMax, rectMax);
+
+        arrowRect.setWidth(size);
+        arrowRect.setHeight(size);
+        if (arrow.width() > arrow.height())
+            arrowRect.setHeight(arrow.height() * size / arrow.width());
+        else
+            arrowRect.setWidth(arrow.width() * size / arrow.height());
+
+        arrowRect.moveTopLeft(rect.center() - arrowRect.center());
+        painter->save();
+        painter->setRenderHint(QPainter::SmoothPixmapTransform);
+        painter->drawPixmap(arrowRect, arrow);
+        painter->restore();
+    }
+        break;
+    case PE_IndicatorViewItemCheck:
+    {
+        QStyleOptionButton button;
+        button.QStyleOption::operator=(*option);
+        button.state &= ~State_MouseOver;
+        proxy()->drawPrimitive(PE_IndicatorCheckBox, &button, painter, widget);
+    }
+        return;
+    case PE_IndicatorHeaderArrow:
+        if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(option)) {
+            QRect r = header->rect;
+            QPixmap arrow;
+            QColor arrowColor = header->palette.foreground().color();
+            QPoint offset = QPoint(0, -1);
+
+            if (header->sortIndicator & QStyleOptionHeader::SortUp) {
+                arrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), arrowColor);
+            } else if (header->sortIndicator & QStyleOptionHeader::SortDown) {
+                arrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), arrowColor, 180);
+            } if (!arrow.isNull()) {
+                r.setSize(QSize(arrow.width()/2, arrow.height()/2));
+                r.moveCenter(header->rect.center());
+                painter->drawPixmap(r.translated(offset), arrow);
+            }
+        }
+        break;
+    case PE_IndicatorButtonDropDown:
+        proxy()->drawPrimitive(PE_PanelButtonCommand, option, painter, widget);
+        break;
+
+    case PE_IndicatorToolBarSeparator:
+    {
+        QRect rect = option->rect;
+        const int margin = 6;
+        if (option->state & State_Horizontal) {
+            const int offset = rect.width()/2;
+            painter->setPen(QPen(option->palette.background().color().darker(110)));
+            painter->drawLine(rect.bottomLeft().x() + offset,
+                              rect.bottomLeft().y() - margin,
+                              rect.topLeft().x() + offset,
+                              rect.topLeft().y() + margin);
+            painter->setPen(QPen(option->palette.background().color().lighter(110)));
+            painter->drawLine(rect.bottomLeft().x() + offset + 1,
+                              rect.bottomLeft().y() - margin,
+                              rect.topLeft().x() + offset + 1,
+                              rect.topLeft().y() + margin);
+        } else { //Draw vertical separator
+            const int offset = rect.height()/2;
+            painter->setPen(QPen(option->palette.background().color().darker(110)));
+            painter->drawLine(rect.topLeft().x() + margin ,
+                              rect.topLeft().y() + offset,
+                              rect.topRight().x() - margin,
+                              rect.topRight().y() + offset);
+            painter->setPen(QPen(option->palette.background().color().lighter(110)));
+            painter->drawLine(rect.topLeft().x() + margin ,
+                              rect.topLeft().y() + offset + 1,
+                              rect.topRight().x() - margin,
+                              rect.topRight().y() + offset + 1);
+        }
+    }
+        break;
+    case PE_Frame: {
+        if (widget && widget->inherits("QComboBoxPrivateContainer")){
+            QStyleOption copy = *option;
+            copy.state |= State_Raised;
+            proxy()->drawPrimitive(PE_PanelMenu, &copy, painter, widget);
+            break;
+        }
+        painter->save();
+        QPen thePen(outline.lighter(108));
+        thePen.setCosmetic(false);
+        painter->setPen(thePen);
+        painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
+        painter->restore(); }
+        break;
+    case PE_FrameMenu:
+        painter->save();
+    {
+        painter->setPen(QPen(outline));
+        painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
+        QColor frameLight = option->palette.background().color().lighter(160);
+        QColor frameShadow = option->palette.background().color().darker(110);
+
+        //paint beveleffect
+        QRect frame = option->rect.adjusted(1, 1, -1, -1);
+        painter->setPen(frameLight);
+        painter->drawLine(frame.topLeft(), frame.bottomLeft());
+        painter->drawLine(frame.topLeft(), frame.topRight());
+
+        painter->setPen(frameShadow);
+        painter->drawLine(frame.topRight(), frame.bottomRight());
+        painter->drawLine(frame.bottomLeft(), frame.bottomRight());
+    }
+        painter->restore();
+        break;
+    case PE_FrameDockWidget:
+
+        painter->save();
+    {
+        QColor softshadow = option->palette.background().color().darker(120);
+
+        QRect rect= option->rect;
+        painter->setPen(softshadow);
+        painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
+        painter->setPen(QPen(option->palette.light(), 1));
+        painter->drawLine(QPoint(rect.left() + 1, rect.top() + 1), QPoint(rect.left() + 1, rect.bottom() - 1));
+        painter->setPen(QPen(option->palette.background().color().darker(120)));
+        painter->drawLine(QPoint(rect.left() + 1, rect.bottom() - 1), QPoint(rect.right() - 2, rect.bottom() - 1));
+        painter->drawLine(QPoint(rect.right() - 1, rect.top() + 1), QPoint(rect.right() - 1, rect.bottom() - 1));
+
+    }
+        painter->restore();
+        break;
+    case PE_PanelButtonTool:
+        painter->save();
+        if ((option->state & State_Enabled || option->state & State_On) || !(option->state & State_AutoRaise)) {
+            if (widget && widget->inherits("QDockWidgetTitleButton")) {
+                if (option->state & State_MouseOver)
+                    proxy()->drawPrimitive(PE_PanelButtonCommand, option, painter, widget);
+            } else {
+                proxy()->drawPrimitive(PE_PanelButtonCommand, option, painter, widget);
+            }
+        }
+        painter->restore();
+        break;
+    case PE_IndicatorDockWidgetResizeHandle:
+    {
+        QStyleOption dockWidgetHandle = *option;
+        bool horizontal = option->state & State_Horizontal;
+        if (horizontal)
+            dockWidgetHandle.state &= ~State_Horizontal;
+        else
+            dockWidgetHandle.state |= State_Horizontal;
+        proxy()->drawControl(CE_Splitter, &dockWidgetHandle, painter, widget);
+    }
+        break;
+    case PE_FrameWindow:
+        painter->save();
+    {
+        QRect rect= option->rect;
+        painter->setPen(QPen(outline.darker(150)));
+        painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
+        painter->setPen(QPen(option->palette.light(), 1));
+        painter->drawLine(QPoint(rect.left() + 1, rect.top() + 1),
+                          QPoint(rect.left() + 1, rect.bottom() - 1));
+        painter->setPen(QPen(option->palette.background().color().darker(120)));
+        painter->drawLine(QPoint(rect.left() + 1, rect.bottom() - 1),
+                          QPoint(rect.right() - 2, rect.bottom() - 1));
+        painter->drawLine(QPoint(rect.right() - 1, rect.top() + 1),
+                          QPoint(rect.right() - 1, rect.bottom() - 1));
+    }
+        painter->restore();
+        break;
+    case PE_FrameLineEdit:
+    {
+        QRect r = rect;
+        bool hasFocus = option->state & State_HasFocus;
+
+        painter->save();
+
+        painter->setRenderHint(QPainter::Antialiasing, true);
+        //  ### highdpi painter bug.
+        painter->translate(0.5, 0.5);
+
+        // Draw Outline
+        painter->setPen( QPen(hasFocus ? highlightedOutline : outline));
+        painter->setBrush(option->palette.base());
+        painter->drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
+
+        if (hasFocus) {
+            QColor softHighlight = highlightedOutline;
+            softHighlight.setAlpha(40);
+            painter->setPen(softHighlight);
+            painter->drawRoundedRect(r.adjusted(1, 1, -2, -2), 1.7, 1.7);
+        }
+        // Draw inner shadow
+        painter->setPen(d->topShadow());
+        painter->drawLine(QPoint(r.left() + 2, r.top() + 1), QPoint(r.right() - 2, r.top() + 1));
+
+        painter->restore();
+
+    }
+        break;
+    case PE_IndicatorCheckBox:
+        painter->save();
+        if (const QStyleOptionButton *checkbox = qstyleoption_cast<const QStyleOptionButton*>(option)) {
+            painter->setRenderHint(QPainter::Antialiasing, true);
+            painter->translate(0.5, 0.5);
+            rect = rect.adjusted(0, 0, -1, -1);
+
+            QColor pressedColor = mergedColors(option->palette.base().color(), option->palette.foreground().color(), 85);
+            painter->setBrush(Qt::NoBrush);
+
+            // Gradient fill
+            QLinearGradient gradient(rect.topLeft(), rect.bottomLeft());
+            gradient.setColorAt(0, (state & State_Sunken) ? pressedColor : option->palette.base().color().darker(115));
+            gradient.setColorAt(0.15, (state & State_Sunken) ? pressedColor : option->palette.base().color());
+            gradient.setColorAt(1, (state & State_Sunken) ? pressedColor : option->palette.base().color());
+
+            painter->setBrush((state & State_Sunken) ? QBrush(pressedColor) : gradient);
+            painter->setPen(QPen(outline.lighter(110)));
+
+            if (option->state & State_HasFocus && option->state & State_KeyboardFocusChange)
+                painter->setPen(QPen(highlightedOutline));
+            painter->drawRect(rect);
+
+            QColor checkMarkColor = option->palette.text().color().darker(120);
+
+            if (checkbox->state & State_NoChange) {
+                gradient = QLinearGradient(rect.topLeft(), rect.bottomLeft());
+                checkMarkColor.setAlpha(80);
+                gradient.setColorAt(0, checkMarkColor);
+                checkMarkColor.setAlpha(140);
+                gradient.setColorAt(1, checkMarkColor);
+                checkMarkColor.setAlpha(180);
+                painter->setPen(QPen(checkMarkColor, 1));
+                painter->setBrush(gradient);
+                painter->drawRect(rect.adjusted(3, 3, -3, -3));
+
+            } else if (checkbox->state & (State_On)) {
+                QPen checkPen = QPen(checkMarkColor, 1.8);
+                checkMarkColor.setAlpha(210);
+                painter->translate(-1, 0.5);
+                painter->setPen(checkPen);
+                painter->setBrush(Qt::NoBrush);
+                painter->translate(0.2, 0.0);
+
+                // Draw checkmark
+                QPainterPath path;
+                path.moveTo(5, rect.height() / 2.0);
+                path.lineTo(rect.width() / 2.0 - 0, rect.height() - 3);
+                path.lineTo(rect.width() - 2.5, 3);
+                painter->drawPath(path.translated(rect.topLeft()));
+            }
+        }
+        painter->restore();
+        break;
+    case PE_IndicatorRadioButton:
+        painter->save();
+    {
+        QColor pressedColor = mergedColors(option->palette.base().color(), option->palette.foreground().color(), 85);
+        painter->setBrush((state & State_Sunken) ? pressedColor : option->palette.base().color());
+        painter->setRenderHint(QPainter::Antialiasing, true);
+        QPainterPath circle;
+        circle.addEllipse(rect.center() + QPoint(1.0, 1.0), 6.5, 6.5);
+        painter->setPen(QPen(option->palette.background().color().darker(150)));
+        if (option->state & State_HasFocus && option->state & State_KeyboardFocusChange)
+            painter->setPen(QPen(highlightedOutline));
+        painter->drawPath(circle);
+
+        if (state & (State_On )) {
+            circle = QPainterPath();
+            circle.addEllipse(rect.center() + QPoint(1, 1), 2.8, 2.8);
+            QColor checkMarkColor = option->palette.text().color().darker(120);
+            checkMarkColor.setAlpha(200);
+            painter->setPen(checkMarkColor);
+            checkMarkColor.setAlpha(180);
+            painter->setBrush(checkMarkColor);
+            painter->drawPath(circle);
+        }
+    }
+        painter->restore();
+        break;
+    case PE_IndicatorToolBarHandle:
+    {
+        //draw grips
+        if (option->state & State_Horizontal) {
+            for (int i = -3 ; i < 2 ; i += 3) {
+                for (int j = -8 ; j < 10 ; j += 3) {
+                    painter->fillRect(rect.center().x() + i, rect.center().y() + j, 2, 2, d->lightShade());
+                    painter->fillRect(rect.center().x() + i, rect.center().y() + j, 1, 1, d->darkShade());
+                }
+            }
+        } else { //vertical toolbar
+            for (int i = -6 ; i < 12 ; i += 3) {
+                for (int j = -3 ; j < 2 ; j += 3) {
+                    painter->fillRect(rect.center().x() + i, rect.center().y() + j, 2, 2, d->lightShade());
+                    painter->fillRect(rect.center().x() + i, rect.center().y() + j, 1, 1, d->darkShade());
+                }
+            }
+        }
+        break;
+    }
+    case PE_FrameDefaultButton:
+        break;
+    case PE_FrameFocusRect:
+        if (const QStyleOptionFocusRect *fropt = qstyleoption_cast<const QStyleOptionFocusRect *>(option)) {
+            //### check for d->alt_down
+            if (!(fropt->state & State_KeyboardFocusChange))
+                return;
+            QRect rect = option->rect;
+
+            painter->save();
+            painter->setRenderHint(QPainter::Antialiasing, true);
+            painter->translate(0.5, 0.5);
+            QColor fillcolor = highlightedOutline;
+            fillcolor.setAlpha(80);
+            painter->setPen(fillcolor.darker(120));
+            fillcolor.setAlpha(30);
+            QLinearGradient gradient(rect.topLeft(), rect.bottomLeft());
+            gradient.setColorAt(0, fillcolor.lighter(160));
+            gradient.setColorAt(1, fillcolor);
+            painter->setBrush(gradient);
+            painter->drawRoundedRect(option->rect.adjusted(0, 0, -1, -1), 1, 1);
+            painter->restore();
+        }
+        break;
+    case PE_PanelButtonCommand:
+    {
+        bool isDefault = false;
+        bool isFlat = false;
+        bool isDown = (option->state & State_Sunken) || (option->state & State_On);
+        QRect r;
+
+        if (const QStyleOptionButton *button = qstyleoption_cast<const QStyleOptionButton*>(option)) {
+            isDefault = (button->features & QStyleOptionButton::DefaultButton) && (button->state & State_Enabled);
+            isFlat = (button->features & QStyleOptionButton::Flat);
+        }
+
+        if (isFlat && !isDown) {
+            if (isDefault) {
+                r = option->rect.adjusted(0, 1, 0, -1);
+                painter->setPen(QPen(Qt::black));
+                const QLine lines[4] = {
+                    QLine(QPoint(r.left() + 2, r.top()),
+                    QPoint(r.right() - 2, r.top())),
+                    QLine(QPoint(r.left(), r.top() + 2),
+                    QPoint(r.left(), r.bottom() - 2)),
+                    QLine(QPoint(r.right(), r.top() + 2),
+                    QPoint(r.right(), r.bottom() - 2)),
+                    QLine(QPoint(r.left() + 2, r.bottom()),
+                    QPoint(r.right() - 2, r.bottom()))
+                };
+                painter->drawLines(lines, 4);
+                const QPoint points[4] = {
+                    QPoint(r.right() - 1, r.bottom() - 1),
+                    QPoint(r.right() - 1, r.top() + 1),
+                    QPoint(r.left() + 1, r.bottom() - 1),
+                    QPoint(r.left() + 1, r.top() + 1)
+                };
+                painter->drawPoints(points, 4);
+            }
+            return;
+        }
+
+        BEGIN_STYLE_PIXMAPCACHE(QString::fromLatin1("pushbutton-%1").arg(isDefault))
+                r = rect.adjusted(0, 1, -1, 0);
+
+        bool isEnabled = option->state & State_Enabled;
+        bool hasFocus = (option->state & State_HasFocus && option->state & State_KeyboardFocusChange);
+        QColor buttonColor = d->buttonColor(option->palette);
+
+        QColor darkOutline = outline;
+        if (hasFocus | isDefault) {
+            darkOutline = highlightedOutline;
+        }
+
+        if (isDefault)
+            buttonColor = mergedColors(buttonColor, highlightedOutline.lighter(130), 90);
+
+        p->setRenderHint(QPainter::Antialiasing, true);
+        p->translate(0.5, -0.5);
+
+        QLinearGradient gradient = qt_fusion_gradient(rect, (isEnabled && option->state & State_MouseOver ) ? buttonColor : buttonColor.darker(104));
+        p->setPen(Qt::transparent);
+        p->setBrush(isDown ? QBrush(buttonColor.darker(110)) : gradient);
+        p->drawRoundedRect(r, 2.0, 2.0);
+        p->setBrush(Qt::NoBrush);
+
+        // Outline
+        p->setPen(!isEnabled ? QPen(darkOutline.lighter(115)) : QPen(darkOutline));
+        p->drawRoundedRect(r, 2.0, 2.0);
+
+        p->setPen(d->innerContrastLine());
+        p->drawRoundedRect(r.adjusted(1, 1, -1, -1), 2.0, 2.0);
+
+        END_STYLE_PIXMAPCACHE
+        }
+        break;
+    case PE_FrameTabWidget:
+        painter->save();
+        painter->fillRect(option->rect.adjusted(0, 0, -1, -1), tabFrameColor);
+        if (const QStyleOptionTabWidgetFrame *twf = qstyleoption_cast<const QStyleOptionTabWidgetFrame *>(option)) {
+            QColor borderColor = outline.lighter(110);
+            QRect rect = option->rect.adjusted(0, 0, -1, -1);
+
+            // Shadow outline
+            if (twf->shape != QTabBar::RoundedSouth) {
+                rect.adjust(0, 0, 0, -1);
+                QColor alphaShadow(Qt::black);
+                alphaShadow.setAlpha(15);
+                painter->setPen(alphaShadow);
+                painter->drawLine(option->rect.bottomLeft(), option->rect.bottomRight());            painter->setPen(borderColor);
+            }
+
+            // outline
+            painter->setPen(outline);
+            painter->drawRect(rect);
+
+            // Inner frame highlight
+            painter->setPen(d->innerContrastLine());
+            painter->drawRect(rect.adjusted(1, 1, -1, -1));
+
+        }
+        painter->restore();
+        break ;
+
+    case PE_FrameStatusBarItem:
+        break;
+    case PE_IndicatorTabClose:
+    {
+        Q_D(const QFusionStyle);
+        if (d->tabBarcloseButtonIcon.isNull())
+            d->tabBarcloseButtonIcon = standardIcon(SP_DialogCloseButton, option, widget);
+        if ((option->state & State_Enabled) && (option->state & State_MouseOver))
+            proxy()->drawPrimitive(PE_PanelButtonCommand, option, painter, widget);
+        QPixmap pixmap = d->tabBarcloseButtonIcon.pixmap(QSize(16, 16), QIcon::Normal, QIcon::On);
+        proxy()->drawItemPixmap(painter, option->rect, Qt::AlignCenter, pixmap);
+    }
+        break;
+    case PE_PanelMenu: {
+        painter->save();
+        QColor menuBackground = option->palette.base().color().lighter(108);
+        QColor borderColor = option->palette.background().color().darker(160);
+        painter->setPen(borderColor);
+        painter->setBrush(menuBackground);
+        painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
+        painter->restore();
+    }
+        break;
+
+    default:
+        QCommonStyle::drawPrimitive(elem, option, painter, widget);
+        break;
+    }
+}
+
+/*!
+  \reimp
+*/
+void QFusionStyle::drawControl(ControlElement element, const QStyleOption *option, QPainter *painter,
+                               const QWidget *widget) const
+{
+    Q_D (const QFusionStyle);
+    QRect rect = option->rect;
+    QColor outline = d->outline(option->palette);
+    QColor highlightedOutline = d->highlightedOutline(option->palette);
+    QColor shadow = d->darkShade();
+
+    switch (element) {
+    case CE_ComboBoxLabel:
+        if (const QStyleOptionComboBox *cb = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
+            QRect editRect = proxy()->subControlRect(CC_ComboBox, cb, SC_ComboBoxEditField, widget);
+            painter->save();
+            painter->setClipRect(editRect);
+            if (!cb->currentIcon.isNull()) {
+                QIcon::Mode mode = cb->state & State_Enabled ? QIcon::Normal
+                                                             : QIcon::Disabled;
+                QPixmap pixmap = cb->currentIcon.pixmap(cb->iconSize, mode);
+                QRect iconRect(editRect);
+                iconRect.setWidth(cb->iconSize.width() + 4);
+                iconRect = alignedRect(cb->direction,
+                                       Qt::AlignLeft | Qt::AlignVCenter,
+                                       iconRect.size(), editRect);
+                if (cb->editable)
+                    painter->fillRect(iconRect, cb->palette.brush(QPalette::Base));
+                proxy()->drawItemPixmap(painter, iconRect, Qt::AlignCenter, pixmap);
+
+                if (cb->direction == Qt::RightToLeft)
+                    editRect.translate(-4 - cb->iconSize.width(), 0);
+                else
+                    editRect.translate(cb->iconSize.width() + 4, 0);
+            }
+            if (!cb->currentText.isEmpty() && !cb->editable) {
+                proxy()->drawItemText(painter, editRect.adjusted(1, 0, -1, 0),
+                                      visualAlignment(cb->direction, Qt::AlignLeft | Qt::AlignVCenter),
+                                      cb->palette, cb->state & State_Enabled, cb->currentText,
+                                      cb->editable ? QPalette::Text : QPalette::ButtonText);
+            }
+            painter->restore();
+        }
+        break;
+    case CE_Splitter:
+    {
+        // Don't draw handle for single pixel splitters
+        if (option->rect.width() > 1 && option->rect.height() > 1) {
+            //draw grips
+            if (option->state & State_Horizontal) {
+                for (int j = -6 ; j< 12 ; j += 3) {
+                    painter->fillRect(rect.center().x() + 1, rect.center().y() + j, 2, 2, d->lightShade());
+                    painter->fillRect(rect.center().x() + 1, rect.center().y() + j, 1, 1, d->darkShade());
+                }
+            } else {
+                for (int i = -6; i< 12 ; i += 3) {
+                    painter->fillRect(rect.center().x() + i, rect.center().y(), 2, 2, d->lightShade());
+                    painter->fillRect(rect.center().x() + i, rect.center().y(), 1, 1, d->darkShade());
+                }
+            }
+        }
+        break;
+    }
+    case CE_RubberBand:
+        if (qstyleoption_cast<const QStyleOptionRubberBand *>(option)) {
+            QColor highlight = option->palette.color(QPalette::Active, QPalette::Highlight);
+            painter->save();
+            QColor penColor = highlight.darker(120);
+            penColor.setAlpha(180);
+            painter->setPen(penColor);
+            QColor dimHighlight(qMin(highlight.red()/2 + 110, 255),
+                                qMin(highlight.green()/2 + 110, 255),
+                                qMin(highlight.blue()/2 + 110, 255));
+            dimHighlight.setAlpha(widget && widget->isTopLevel() ? 255 : 80);
+            QLinearGradient gradient(rect.topLeft(), QPoint(rect.bottomLeft().x(), rect.bottomLeft().y()));
+            gradient.setColorAt(0, dimHighlight.lighter(120));
+            gradient.setColorAt(1, dimHighlight);
+            painter->setRenderHint(QPainter::Antialiasing, true);
+            painter->translate(0.5, 0.5);
+            painter->setBrush(dimHighlight);
+            painter->drawRoundedRect(option->rect.adjusted(0, 0, -1, -1), 1, 1);
+            QColor innerLine = Qt::white;
+            innerLine.setAlpha(40);
+            painter->setPen(innerLine);
+            painter->drawRoundedRect(option->rect.adjusted(1, 1, -2, -2), 1, 1);
+            painter->restore();
+            return;
+        }
+    case CE_SizeGrip:
+        painter->save();
+    {
+        //draw grips
+        for (int i = -6; i< 12 ; i += 3) {
+            for (int j = -6 ; j< 12 ; j += 3) {
+                if ((option->direction == Qt::LeftToRight && i > -j) || (option->direction == Qt::RightToLeft && j > i) ) {
+                    painter->fillRect(rect.center().x() + i, rect.center().y() + j, 2, 2, d->lightShade());
+                    painter->fillRect(rect.center().x() + i, rect.center().y() + j, 1, 1, d->darkShade());
+                }
+            }
+        }
+    }
+        painter->restore();
+        break;
+    case CE_ToolBar:
+        if (const QStyleOptionToolBar *toolBar = qstyleoption_cast<const QStyleOptionToolBar *>(option)) {
+            // Reserve the beveled appearance only for mainwindow toolbars
+            if (widget && !(qobject_cast<const QMainWindow*> (widget->parentWidget())))
+                break;
+
+            // Draws the light line above and the dark line below menu bars and
+            // tool bars.
+            QLinearGradient gradient(option->rect.topLeft(), option->rect.bottomLeft());
+            if (!(option->state & State_Horizontal))
+                gradient = QLinearGradient(rect.left(), rect.center().y(),
+                                           rect.right(), rect.center().y());
+            gradient.setColorAt(0, option->palette.window().color().lighter(104));
+            gradient.setColorAt(1, option->palette.window().color());
+            painter->fillRect(option->rect, gradient);
+
+            QColor light = d->lightShade();
+            QColor shadow = d->darkShade();
+
+            QPen oldPen = painter->pen();
+            if (toolBar->toolBarArea == Qt::TopToolBarArea) {
+                if (toolBar->positionOfLine == QStyleOptionToolBar::End
+                        || toolBar->positionOfLine == QStyleOptionToolBar::OnlyOne) {
+                    // The end and onlyone top toolbar lines draw a double
+                    // line at the bottom to blend with the central
+                    // widget.
+                    painter->setPen(light);
+                    painter->drawLine(option->rect.bottomLeft(), option->rect.bottomRight());
+                    painter->setPen(shadow);
+                    painter->drawLine(option->rect.left(), option->rect.bottom() - 1,
+                                      option->rect.right(), option->rect.bottom() - 1);
+                } else {
+                    // All others draw a single dark line at the bottom.
+                    painter->setPen(shadow);
+                    painter->drawLine(option->rect.bottomLeft(), option->rect.bottomRight());
+                }
+                // All top toolbar lines draw a light line at the top.
+                painter->setPen(light);
+                painter->drawLine(option->rect.topLeft(), option->rect.topRight());
+            } else if (toolBar->toolBarArea == Qt::BottomToolBarArea) {
+                if (toolBar->positionOfLine == QStyleOptionToolBar::End
+                        || toolBar->positionOfLine == QStyleOptionToolBar::Middle) {
+                    // The end and middle bottom tool bar lines draw a dark
+                    // line at the bottom.
+                    painter->setPen(shadow);
+                    painter->drawLine(option->rect.bottomLeft(), option->rect.bottomRight());
+                }
+                if (toolBar->positionOfLine == QStyleOptionToolBar::Beginning
+                        || toolBar->positionOfLine == QStyleOptionToolBar::OnlyOne) {
+                    // The beginning and only one tool bar lines draw a
+                    // double line at the bottom to blend with the
+                    // status bar.
+                    // ### The styleoption could contain whether the
+                    // main window has a menu bar and a status bar, and
+                    // possibly dock widgets.
+                    painter->setPen(shadow);
+                    painter->drawLine(option->rect.left(), option->rect.bottom() - 1,
+                                      option->rect.right(), option->rect.bottom() - 1);
+                    painter->setPen(light);
+                    painter->drawLine(option->rect.bottomLeft(), option->rect.bottomRight());
+                }
+                if (toolBar->positionOfLine == QStyleOptionToolBar::End) {
+                    painter->setPen(shadow);
+                    painter->drawLine(option->rect.topLeft(), option->rect.topRight());
+                    painter->setPen(light);
+                    painter->drawLine(option->rect.left(), option->rect.top() + 1,
+                                      option->rect.right(), option->rect.top() + 1);
+
+                } else {
+                    // All other bottom toolbars draw a light line at the top.
+                    painter->setPen(light);
+                    painter->drawLine(option->rect.topLeft(), option->rect.topRight());
+                }
+            }
+            if (toolBar->toolBarArea == Qt::LeftToolBarArea) {
+                if (toolBar->positionOfLine == QStyleOptionToolBar::Middle
+                        || toolBar->positionOfLine == QStyleOptionToolBar::End) {
+                    // The middle and left end toolbar lines draw a light
+                    // line to the left.
+                    painter->setPen(light);
+                    painter->drawLine(option->rect.topLeft(), option->rect.bottomLeft());
+                }
+                if (toolBar->positionOfLine == QStyleOptionToolBar::End) {
+                    // All other left toolbar lines draw a dark line to the right
+                    painter->setPen(shadow);
+                    painter->drawLine(option->rect.right() - 1, option->rect.top(),
+                                      option->rect.right() - 1, option->rect.bottom());
+                    painter->setPen(light);
+                    painter->drawLine(option->rect.topRight(), option->rect.bottomRight());
+                } else {
+                    // All other left toolbar lines draw a dark line to the right
+                    painter->setPen(shadow);
+                    painter->drawLine(option->rect.topRight(), option->rect.bottomRight());
+                }
+            } else if (toolBar->toolBarArea == Qt::RightToolBarArea) {
+                if (toolBar->positionOfLine == QStyleOptionToolBar::Middle
+                        || toolBar->positionOfLine == QStyleOptionToolBar::End) {
+                    // Right middle and end toolbar lines draw the dark right line
+                    painter->setPen(shadow);
+                    painter->drawLine(option->rect.topRight(), option->rect.bottomRight());
+                }
+                if (toolBar->positionOfLine == QStyleOptionToolBar::End
+                        || toolBar->positionOfLine == QStyleOptionToolBar::OnlyOne) {
+                    // The right end and single toolbar draws the dark
+                    // line on its left edge
+                    painter->setPen(shadow);
+                    painter->drawLine(option->rect.topLeft(), option->rect.bottomLeft());
+                    // And a light line next to it
+                    painter->setPen(light);
+                    painter->drawLine(option->rect.left() + 1, option->rect.top(),
+                                      option->rect.left() + 1, option->rect.bottom());
+                } else {
+                    // Other right toolbars draw a light line on its left edge
+                    painter->setPen(light);
+                    painter->drawLine(option->rect.topLeft(), option->rect.bottomLeft());
+                }
+            }
+            painter->setPen(oldPen);
+        }
+        break;
+    case CE_DockWidgetTitle:
+        painter->save();
+        if (const QStyleOptionDockWidget *dwOpt = qstyleoption_cast<const QStyleOptionDockWidget *>(option)) {
+            bool verticalTitleBar = dwOpt->verticalTitleBar;
+
+            QRect titleRect = subElementRect(SE_DockWidgetTitleBarText, option, widget);
+            if (verticalTitleBar) {
+                QRect rect = dwOpt->rect;
+                QRect r = rect;
+                QSize s = r.size();
+                s.transpose();
+                r.setSize(s);
+                titleRect = QRect(r.left() + rect.bottom()
+                                  - titleRect.bottom(),
+                                  r.top() + titleRect.left() - rect.left(),
+                                  titleRect.height(), titleRect.width());
+
+                painter->translate(r.left(), r.top() + r.width());
+                painter->rotate(-90);
+                painter->translate(-r.left(), -r.top());
+            }
+
+            if (!dwOpt->title.isEmpty()) {
+                QString titleText
+                        = painter->fontMetrics().elidedText(dwOpt->title,
+                                                            Qt::ElideRight, titleRect.width());
+                proxy()->drawItemText(painter,
+                                      titleRect,
+                                      Qt::AlignLeft | Qt::AlignVCenter | Qt::TextShowMnemonic, dwOpt->palette,
+                                      dwOpt->state & State_Enabled, titleText,
+                                      QPalette::WindowText);
+            }
+        }
+        painter->restore();
+        break;
+    case CE_HeaderSection:
+        painter->save();
+        // Draws the header in tables.
+        if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(option)) {
+            QString pixmapName = QStyleHelper::uniqueName(QLatin1String("headersection"), option, option->rect.size());
+            pixmapName += QString::number(- int(header->position));
+            pixmapName += QString::number(- int(header->orientation));
+
+            QPixmap cache;
+            if (!QPixmapCache::find(pixmapName, cache)) {
+                cache = styleCachePixmap(rect.size());
+                cache.fill(Qt::transparent);
+                QRect pixmapRect(0, 0, rect.width(), rect.height());
+                QPainter cachePainter(&cache);
+                QColor buttonColor = d->buttonColor(option->palette);
+                QColor gradientStopColor;
+                QColor gradientStartColor = buttonColor.lighter(104);
+                gradientStopColor = buttonColor.darker(102);
+                QLinearGradient gradient(pixmapRect.topLeft(), pixmapRect.bottomLeft());
+
+                if (option->palette.background().gradient()) {
+                    gradient.setStops(option->palette.background().gradient()->stops());
+                } else {
+                    QColor midColor1 = mergedColors(gradientStartColor, gradientStopColor, 60);
+                    QColor midColor2 = mergedColors(gradientStartColor, gradientStopColor, 40);
+                    gradient.setColorAt(0, gradientStartColor);
+                    gradient.setColorAt(0.5, midColor1);
+                    gradient.setColorAt(0.501, midColor2);
+                    gradient.setColorAt(0.92, gradientStopColor);
+                    gradient.setColorAt(1, gradientStopColor.darker(104));
+                }
+                cachePainter.fillRect(pixmapRect, gradient);
+                cachePainter.setPen(d->innerContrastLine());
+                cachePainter.setBrush(Qt::NoBrush);
+                cachePainter.drawLine(pixmapRect.topLeft(), pixmapRect.topRight());
+                cachePainter.setPen(d->outline(option->palette));
+                cachePainter.drawLine(pixmapRect.bottomLeft(), pixmapRect.bottomRight());
+
+                if (header->orientation == Qt::Horizontal &&
+                        header->position != QStyleOptionHeader::End &&
+                        header->position != QStyleOptionHeader::OnlyOneSection) {
+                    cachePainter.setPen(QColor(0, 0, 0, 40));
+                    cachePainter.drawLine(pixmapRect.topRight(), pixmapRect.bottomRight() + QPoint(0, -1));
+                    cachePainter.setPen(d->innerContrastLine());
+                    cachePainter.drawLine(pixmapRect.topRight() + QPoint(-1, 0), pixmapRect.bottomRight() + QPoint(-1, -1));
+                } else if (header->orientation == Qt::Vertical) {
+                    cachePainter.setPen(d->outline(option->palette));
+                    cachePainter.drawLine(pixmapRect.topRight(), pixmapRect.bottomRight());
+                }
+                cachePainter.end();
+                QPixmapCache::insert(pixmapName, cache);
+            }
+            painter->drawPixmap(rect.topLeft(), cache);
+        }
+        painter->restore();
+        break;
+    case CE_ProgressBarGroove:
+        painter->save();
+    {
+        painter->setRenderHint(QPainter::Antialiasing, true);
+        painter->translate(0.5, 0.5);
+
+        QColor shadowAlpha = Qt::black;
+        shadowAlpha.setAlpha(16);
+        painter->setPen(shadowAlpha);
+        painter->drawLine(rect.topLeft() - QPoint(0, 1), rect.topRight() - QPoint(0, 1));
+
+        painter->setBrush(option->palette.base());
+        painter->setPen(QPen(outline));
+        painter->drawRoundedRect(rect.adjusted(0, 0, -1, -1), 2, 2);
+
+        // Inner shadow
+        painter->setPen(d->topShadow());
+        painter->drawLine(QPoint(rect.left() + 1, rect.top() + 1),
+                          QPoint(rect.right() - 1, rect.top() + 1));
+    }
+        painter->restore();
+        break;
+    case CE_ProgressBarContents:
+        painter->save();
+        painter->setRenderHint(QPainter::Antialiasing, true);
+        painter->translate(0.5, 0.5);
+        if (const QStyleOptionProgressBar *bar = qstyleoption_cast<const QStyleOptionProgressBar *>(option)) {
+            bool vertical = false;
+            bool inverted = false;
+            bool indeterminate = (bar->minimum == 0 && bar->maximum == 0);
+            bool complete = bar->progress == bar->maximum;
+
+            // Get extra style options if version 2
+            vertical = (bar->orientation == Qt::Vertical);
+            inverted = bar->invertedAppearance;
+
+            // If the orientation is vertical, we use a transform to rotate
+            // the progress bar 90 degrees clockwise.  This way we can use the
+            // same rendering code for both orientations.
+            if (vertical) {
+                rect = QRect(rect.left(), rect.top(), rect.height(), rect.width()); // flip width and height
+                QTransform m = QTransform::fromTranslate(rect.height()-1, -1.0);
+                m.rotate(90.0);
+                painter->setTransform(m, true);
+            }
+
+            int maxWidth = rect.width();
+            int minWidth = 0;
+            qreal progress = qMax(bar->progress, bar->minimum); // workaround for bug in QProgressBar
+            int progressBarWidth = (progress - bar->minimum) * qreal(maxWidth) / qMax(qreal(1.0), qreal(bar->maximum) - bar->minimum);
+            int width = indeterminate ? maxWidth : qMax(minWidth, progressBarWidth);
+
+            bool reverse = (!vertical && (bar->direction == Qt::RightToLeft)) || vertical;
+            if (inverted)
+                reverse = !reverse;
+
+            int step = 0;
+            QRect progressBar;
+            QColor highlight = d->highlight(option->palette);
+            QColor highlightedoutline = highlight.darker(140);
+            if (qGray(outline.rgb()) > qGray(highlightedoutline.rgb()))
+                outline = highlightedoutline;
+
+            if (!indeterminate) {
+                QColor innerShadow(Qt::black);
+                innerShadow.setAlpha(35);
+                painter->setPen(innerShadow);
+                if (!reverse) {
+                    progressBar.setRect(rect.left(), rect.top(), width - 1, rect.height() - 1);
+                    if (!complete) {
+                        painter->drawLine(progressBar.topRight() + QPoint(2, 1), progressBar.bottomRight() + QPoint(2, 0));
+                        painter->setPen(QPen(highlight.darker(140)));
+                        painter->drawLine(progressBar.topRight() + QPoint(1, 1), progressBar.bottomRight() + QPoint(1, 0));
+                    }
+                } else {
+                    progressBar.setRect(rect.right() - width - 1, rect.top(), width + 2, rect.height() - 1);
+                    if (!complete) {
+                        painter->drawLine(progressBar.topLeft() + QPoint(-2, 1), progressBar.bottomLeft() + QPoint(-2, 0));
+                        painter->setPen(QPen(highlight.darker(140)));
+                        painter->drawLine(progressBar.topLeft() + QPoint(-1, 1), progressBar.bottomLeft() + QPoint(-1, 0));
+                    }
+                }
+            } else {
+                progressBar.setRect(rect.left(), rect.top(), rect.width() - 1, rect.height() - 1);
+            }
+
+            if (indeterminate || bar->progress > bar->minimum) {
+
+                painter->setPen(QPen(outline));
+
+                QColor highlightedGradientStartColor = highlight.lighter(120);
+                QColor highlightedGradientStopColor  = highlight;
+                QLinearGradient gradient(rect.topLeft(), QPoint(rect.bottomLeft().x(), rect.bottomLeft().y()));
+                gradient.setColorAt(0, highlightedGradientStartColor);
+                gradient.setColorAt(1, highlightedGradientStopColor);
+
+                painter->setBrush(gradient);
+
+                painter->save();
+                if (!complete && !indeterminate)
+                    painter->setClipRect(progressBar.adjusted(-1, -1, -1, 1));
+                QRect fillRect = progressBar.adjusted( !indeterminate && !complete && reverse ? -2 : 0, 0,
+                                                       indeterminate || complete || reverse ? 0 : 2, 0);
+                painter->drawRoundedRect(fillRect, 2, 2);
+                painter->restore();
+
+                painter->setBrush(Qt::NoBrush);
+                painter->setPen(QColor(255, 255, 255, 50));
+                painter->drawRoundedRect(progressBar.adjusted(1, 1, -1, -1), 1, 1);
+
+                if (!indeterminate) {
+                    (const_cast<QFusionStylePrivate*>(d))->stopAnimation(option->styleObject);
+                } else {
+                    highlightedGradientStartColor.setAlpha(120);
+                    painter->setPen(QPen(highlightedGradientStartColor, 9.0));
+                    painter->setClipRect(progressBar.adjusted(1, 1, -1, -1));
+#ifndef QT_NO_ANIMATION
+                if (QProgressStyleAnimation *animation = qobject_cast<QProgressStyleAnimation*>(d->animation(option->styleObject)))
+                    step = animation->animationStep() % 22;
+                else
+                    (const_cast<QFusionStylePrivate*>(d))->startAnimation(new QProgressStyleAnimation(d->animationFps, option->styleObject));
+#endif
+                for (int x = progressBar.left() - rect.height(); x < rect.right() ; x += 22)
+                    painter->drawLine(x + step, progressBar.bottom() + 1,
+                                      x + rect.height() + step, progressBar.top() - 2);
+                }
+            }
+        }
+        painter->restore();
+        break;
+    case CE_ProgressBarLabel:
+        if (const QStyleOptionProgressBar *bar = qstyleoption_cast<const QStyleOptionProgressBar *>(option)) {
+            QRect leftRect;
+            QRect rect = bar->rect;
+            QColor textColor = option->palette.text().color();
+            QColor alternateTextColor = d->highlightedText(option->palette);
+
+            painter->save();
+            bool vertical = false, inverted = false;
+            vertical = (bar->orientation == Qt::Vertical);
+            inverted = bar->invertedAppearance;
+            if (vertical)
+                rect = QRect(rect.left(), rect.top(), rect.height(), rect.width()); // flip width and height
+            const int progressIndicatorPos = (bar->progress - qreal(bar->minimum)) * rect.width() /
+                    qMax(qreal(1.0), qreal(bar->maximum) - bar->minimum);
+            if (progressIndicatorPos >= 0 && progressIndicatorPos <= rect.width())
+                leftRect = QRect(rect.left(), rect.top(), progressIndicatorPos, rect.height());
+            if (vertical)
+                leftRect.translate(rect.width() - progressIndicatorPos, 0);
+
+            bool flip = (!vertical && (((bar->direction == Qt::RightToLeft) && !inverted) ||
+                                       ((bar->direction == Qt::LeftToRight) && inverted)));
+
+            QRegion rightRect = rect;
+            rightRect = rightRect.subtracted(leftRect);
+            painter->setClipRegion(rightRect);
+            painter->setPen(flip ? alternateTextColor : textColor);
+            painter->drawText(rect, bar->text, QTextOption(Qt::AlignAbsolute | Qt::AlignHCenter | Qt::AlignVCenter));
+            if (!leftRect.isNull()) {
+                painter->setPen(flip ? textColor : alternateTextColor);
+                painter->setClipRect(leftRect);
+                painter->drawText(rect, bar->text, QTextOption(Qt::AlignAbsolute | Qt::AlignHCenter | Qt::AlignVCenter));
+            }
+            painter->restore();
+        }
+        break;
+    case CE_MenuBarItem:
+        painter->save();
+        if (const QStyleOptionMenuItem *mbi = qstyleoption_cast<const QStyleOptionMenuItem *>(option))
+        {
+            QStyleOptionMenuItem item = *mbi;
+            item.rect = mbi->rect.adjusted(0, 1, 0, -3);
+            QColor highlightOutline = option->palette.highlight().color().darker(125);
+            painter->fillRect(rect, option->palette.window());
+
+            QCommonStyle::drawControl(element, &item, painter, widget);
+
+            bool act = mbi->state & State_Selected && mbi->state & State_Sunken;
+            bool dis = !(mbi->state & State_Enabled);
+
+            QRect r = option->rect;
+            if (act) {
+                painter->setBrush(option->palette.highlight().color());
+                painter->setPen(QPen(highlightOutline));
+                painter->drawRect(r.adjusted(0, 0, -1, -1));
+
+                //                painter->drawRoundedRect(r.adjusted(1, 1, -1, -1), 2, 2);
+
+                //draw text
+                QPalette::ColorRole textRole = dis ? QPalette::Text : QPalette::HighlightedText;
+                uint alignment = Qt::AlignCenter | Qt::TextShowMnemonic | Qt::TextDontClip | Qt::TextSingleLine;
+                if (!styleHint(SH_UnderlineShortcut, mbi, widget))
+                    alignment |= Qt::TextHideMnemonic;
+                proxy()->drawItemText(painter, item.rect, alignment, mbi->palette, mbi->state & State_Enabled, mbi->text, textRole);
+            } else {
+
+                QColor shadow = mergedColors(option->palette.background().color().darker(120),
+                                             outline.lighter(140), 60);
+                painter->setPen(QPen(shadow));
+                painter->drawLine(option->rect.bottomLeft(), option->rect.bottomRight());
+            }
+        }
+        painter->restore();
+        break;
+    case CE_MenuItem:
+        painter->save();
+        // Draws one item in a popup menu.
+        if (const QStyleOptionMenuItem *menuItem = qstyleoption_cast<const QStyleOptionMenuItem *>(option)) {
+            QColor highlightOutline = highlightedOutline;
+            QColor highlight = option->palette.highlight().color();
+            if (menuItem->menuItemType == QStyleOptionMenuItem::Separator) {
+                int w = 0;
+                if (!menuItem->text.isEmpty()) {
+                    painter->setFont(menuItem->font);
+                    proxy()->drawItemText(painter, menuItem->rect.adjusted(5, 0, -5, 0), Qt::AlignLeft | Qt::AlignVCenter,
+                                          menuItem->palette, menuItem->state & State_Enabled, menuItem->text,
+                                          QPalette::Text);
+                    w = menuItem->fontMetrics.width(menuItem->text) + 5;
+                }
+                painter->setPen(shadow.lighter(106));
+                bool reverse = menuItem->direction == Qt::RightToLeft;
+                painter->drawLine(menuItem->rect.left() + 5 + (reverse ? 0 : w), menuItem->rect.center().y(),
+                                  menuItem->rect.right() - 5 - (reverse ? w : 0), menuItem->rect.center().y());
+                painter->restore();
+                break;
+            }
+            bool selected = menuItem->state & State_Selected && menuItem->state & State_Enabled;
+            if (selected) {
+                QRect r = option->rect;
+                painter->fillRect(r, highlight);
+                painter->setPen(QPen(highlightOutline));
+                const QLine lines[4] = {
+                    QLine(QPoint(r.left() + 1, r.bottom()), QPoint(r.right() - 1, r.bottom())),
+                    QLine(QPoint(r.left() + 1, r.top()), QPoint(r.right() - 1, r.top())),
+                    QLine(QPoint(r.left(), r.top()), QPoint(r.left(), r.bottom())),
+                    QLine(QPoint(r.right() , r.top()), QPoint(r.right(), r.bottom())),
+                };
+                painter->drawLines(lines, 4);
+            }
+            bool checkable = menuItem->checkType != QStyleOptionMenuItem::NotCheckable;
+            bool checked = menuItem->checked;
+            bool sunken = menuItem->state & State_Sunken;
+            bool enabled = menuItem->state & State_Enabled;
+
+            bool ignoreCheckMark = false;
+            int checkcol = qMax(menuItem->maxIconWidth, 20);
+
+            if (qobject_cast<const QComboBox*>(widget))
+                ignoreCheckMark = true; //ignore the checkmarks provided by the QComboMenuDelegate
+
+            if (!ignoreCheckMark) {
+                // Check
+                QRect checkRect(option->rect.left() + 7, option->rect.center().y() - 6, 14, 14);
+                checkRect = visualRect(menuItem->direction, menuItem->rect, checkRect);
+                if (checkable) {
+                    if (menuItem->checkType & QStyleOptionMenuItem::Exclusive) {
+                        // Radio button
+                        if (checked || sunken) {
+                            painter->setRenderHint(QPainter::Antialiasing);
+                            painter->setPen(Qt::NoPen);
+
+                            QPalette::ColorRole textRole = !enabled ? QPalette::Text:
+                                                                      selected ? QPalette::HighlightedText : QPalette::ButtonText;
+                            painter->setBrush(option->palette.brush( option->palette.currentColorGroup(), textRole));
+                            painter->drawEllipse(checkRect.adjusted(4, 4, -4, -4));
+                        }
+                    } else {
+                        // Check box
+                        if (menuItem->icon.isNull()) {
+                            QStyleOptionButton box;
+                            box.QStyleOption::operator=(*option);
+                            box.rect = checkRect;
+                            if (checked)
+                                box.state |= State_On;
+                            proxy()->drawPrimitive(PE_IndicatorCheckBox, &box, painter, widget);
+                        }
+                    }
+                }
+            } else { //ignore checkmark
+                if (menuItem->icon.isNull())
+                    checkcol = 0;
+                else
+                    checkcol = menuItem->maxIconWidth;
+            }
+
+            // Text and icon, ripped from windows style
+            bool dis = !(menuItem->state & State_Enabled);
+            bool act = menuItem->state & State_Selected;
+            const QStyleOption *opt = option;
+            const QStyleOptionMenuItem *menuitem = menuItem;
+
+            QPainter *p = painter;
+            QRect vCheckRect = visualRect(opt->direction, menuitem->rect,
+                                          QRect(menuitem->rect.x() + 4, menuitem->rect.y(),
+                                                checkcol, menuitem->rect.height()));
+            if (!menuItem->icon.isNull()) {
+                QIcon::Mode mode = dis ? QIcon::Disabled : QIcon::Normal;
+                if (act && !dis)
+                    mode = QIcon::Active;
+                QPixmap pixmap;
+
+                int smallIconSize = proxy()->pixelMetric(PM_SmallIconSize, option, widget);
+                QSize iconSize(smallIconSize, smallIconSize);
+                if (const QComboBox *combo = qobject_cast<const QComboBox*>(widget))
+                    iconSize = combo->iconSize();
+                if (checked)
+                    pixmap = menuItem->icon.pixmap(iconSize, mode, QIcon::On);
+                else
+                    pixmap = menuItem->icon.pixmap(iconSize, mode);
+
+                int pixw = pixmap.width();
+                int pixh = pixmap.height();
+
+                QRect pmr(0, 0, pixw, pixh);
+                pmr.moveCenter(vCheckRect.center());
+                painter->setPen(menuItem->palette.text().color());
+                if (checkable && checked) {
+                    QStyleOption opt = *option;
+                    if (act) {
+                        QColor activeColor = mergedColors(option->palette.background().color(),
+                                                          option->palette.highlight().color());
+                        opt.palette.setBrush(QPalette::Button, activeColor);
+                    }
+                    opt.state |= State_Sunken;
+                    opt.rect = vCheckRect;
+                    proxy()->drawPrimitive(PE_PanelButtonCommand, &opt, painter, widget);
+                }
+                painter->drawPixmap(pmr.topLeft(), pixmap);
+            }
+            if (selected) {
+                painter->setPen(menuItem->palette.highlightedText().color());
+            } else {
+                painter->setPen(menuItem->palette.text().color());
+            }
+            int x, y, w, h;
+            menuitem->rect.getRect(&x, &y, &w, &h);
+            int tab = menuitem->tabWidth;
+            QColor discol;
+            if (dis) {
+                discol = menuitem->palette.text().color();
+                p->setPen(discol);
+            }
+            int xm = windowsItemFrame + checkcol + windowsItemHMargin + 2;
+            int xpos = menuitem->rect.x() + xm;
+
+            QRect textRect(xpos, y + windowsItemVMargin, w - xm - windowsRightBorder - tab + 1, h - 2 * windowsItemVMargin);
+            QRect vTextRect = visualRect(opt->direction, menuitem->rect, textRect);
+            QString s = menuitem->text;
+            if (!s.isEmpty()) {                     // draw text
+                p->save();
+                int t = s.indexOf(QLatin1Char('\t'));
+                int text_flags = Qt::AlignVCenter | Qt::TextShowMnemonic | Qt::TextDontClip | Qt::TextSingleLine;
+                if (!styleHint(SH_UnderlineShortcut, menuitem, widget))
+                    text_flags |= Qt::TextHideMnemonic;
+                text_flags |= Qt::AlignLeft;
+                if (t >= 0) {
+                    QRect vShortcutRect = visualRect(opt->direction, menuitem->rect,
+                                                     QRect(textRect.topRight(), QPoint(menuitem->rect.right(), textRect.bottom())));
+                    if (dis && !act && proxy()->styleHint(SH_EtchDisabledText, option, widget)) {
+                        p->setPen(menuitem->palette.light().color());
+                        p->drawText(vShortcutRect.adjusted(1, 1, 1, 1), text_flags, s.mid(t + 1));
+                        p->setPen(discol);
+                    }
+                    p->drawText(vShortcutRect, text_flags, s.mid(t + 1));
+                    s = s.left(t);
+                }
+                QFont font = menuitem->font;
+                // font may not have any "hard" flags set. We override
+                // the point size so that when it is resolved against the device, this font will win.
+                // This is mainly to handle cases where someone sets the font on the window
+                // and then the combo inherits it and passes it onward. At that point the resolve mask
+                // is very, very weak. This makes it stonger.
+                font.setPointSizeF(QFontInfo(menuItem->font).pointSizeF());
+
+                if (menuitem->menuItemType == QStyleOptionMenuItem::DefaultItem)
+                    font.setBold(true);
+
+                p->setFont(font);
+                if (dis && !act && proxy()->styleHint(SH_EtchDisabledText, option, widget)) {
+                    p->setPen(menuitem->palette.light().color());
+                    p->drawText(vTextRect.adjusted(1, 1, 1, 1), text_flags, s.left(t));
+                    p->setPen(discol);
+                }
+                p->drawText(vTextRect, text_flags, s.left(t));
+                p->restore();
+            }
+
+            // Arrow
+            if (menuItem->menuItemType == QStyleOptionMenuItem::SubMenu) {// draw sub menu arrow
+                int dim = (menuItem->rect.height() - 4) / 2;
+                PrimitiveElement arrow;
+                arrow = option->direction == Qt::RightToLeft ? PE_IndicatorArrowLeft : PE_IndicatorArrowRight;
+                int xpos = menuItem->rect.left() + menuItem->rect.width() - 3 - dim;
+                QRect  vSubMenuRect = visualRect(option->direction, menuItem->rect,
+                                                 QRect(xpos, menuItem->rect.top() + menuItem->rect.height() / 2 - dim / 2, dim, dim));
+                QStyleOptionMenuItem newMI = *menuItem;
+                newMI.rect = vSubMenuRect;
+                newMI.state = !enabled ? State_None : State_Enabled;
+                if (selected)
+                    newMI.palette.setColor(QPalette::Foreground,
+                                           newMI.palette.highlightedText().color());
+                proxy()->drawPrimitive(arrow, &newMI, painter, widget);
+            }
+        }
+        painter->restore();
+        break;
+    case CE_MenuHMargin:
+    case CE_MenuVMargin:
+        break;
+    case CE_MenuEmptyArea:
+        break;
+    case CE_PushButton:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(option)) {
+            proxy()->drawControl(CE_PushButtonBevel, btn, painter, widget);
+            QStyleOptionButton subopt = *btn;
+            subopt.rect = subElementRect(SE_PushButtonContents, btn, widget);
+            proxy()->drawControl(CE_PushButtonLabel, &subopt, painter, widget);
+        }
+        break;
+    case CE_PushButtonLabel:
+        if (const QStyleOptionButton *button = qstyleoption_cast<const QStyleOptionButton *>(option)) {
+            QRect ir = button->rect;
+            uint tf = Qt::AlignVCenter;
+            if (styleHint(SH_UnderlineShortcut, button, widget))
+                tf |= Qt::TextShowMnemonic;
+            else
+                tf |= Qt::TextHideMnemonic;
+
+            if (!button->icon.isNull()) {
+                //Center both icon and text
+                QPoint point;
+
+                QIcon::Mode mode = button->state & State_Enabled ? QIcon::Normal
+                                                                 : QIcon::Disabled;
+                if (mode == QIcon::Normal && button->state & State_HasFocus)
+                    mode = QIcon::Active;
+                QIcon::State state = QIcon::Off;
+                if (button->state & State_On)
+                    state = QIcon::On;
+
+                QPixmap pixmap = button->icon.pixmap(button->iconSize, mode, state);
+                int w = pixmap.width();
+                int h = pixmap.height();
+
+                if (!button->text.isEmpty())
+                    w += button->fontMetrics.boundingRect(option->rect, tf, button->text).width() + 2;
+
+                point = QPoint(ir.x() + ir.width() / 2 - w / 2,
+                               ir.y() + ir.height() / 2 - h / 2);
+
+                if (button->direction == Qt::RightToLeft)
+                    point.rx() += pixmap.width();
+
+                painter->drawPixmap(visualPos(button->direction, button->rect, point), pixmap);
+
+                if (button->direction == Qt::RightToLeft)
+                    ir.translate(-point.x() - 2, 0);
+                else
+                    ir.translate(point.x() + pixmap.width(), 0);
+
+                // left-align text if there is
+                if (!button->text.isEmpty())
+                    tf |= Qt::AlignLeft;
+
+            } else {
+                tf |= Qt::AlignHCenter;
+            }
+
+            if (button->features & QStyleOptionButton::HasMenu)
+                ir = ir.adjusted(0, 0, -proxy()->pixelMetric(PM_MenuButtonIndicator, button, widget), 0);
+            proxy()->drawItemText(painter, ir, tf, button->palette, (button->state & State_Enabled),
+                                  button->text, QPalette::ButtonText);
+        }
+        break;
+    case CE_MenuBarEmptyArea:
+        painter->save();
+    {
+        painter->fillRect(rect, option->palette.window());
+        QColor shadow = mergedColors(option->palette.background().color().darker(120),
+                                     outline.lighter(140), 60);
+        painter->setPen(QPen(shadow));
+        painter->drawLine(option->rect.bottomLeft(), option->rect.bottomRight());
+    }
+        painter->restore();
+        break;
+    case CE_TabBarTabShape:
+        painter->save();
+        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(option)) {
+
+            bool rtlHorTabs = (tab->direction == Qt::RightToLeft
+                               && (tab->shape == QTabBar::RoundedNorth
+                                   || tab->shape == QTabBar::RoundedSouth));
+            bool selected = tab->state & State_Selected;
+            bool lastTab = ((!rtlHorTabs && tab->position == QStyleOptionTab::End)
+                            || (rtlHorTabs
+                                && tab->position == QStyleOptionTab::Beginning));
+            bool onlyOne = tab->position == QStyleOptionTab::OnlyOneTab;
+            int tabOverlap = pixelMetric(PM_TabBarTabOverlap, option, widget);
+            rect = option->rect.adjusted(0, 0, (onlyOne || lastTab) ? 0 : tabOverlap, 0);
+
+            QRect r2(rect);
+            int x1 = r2.left();
+            int x2 = r2.right();
+            int y1 = r2.top();
+            int y2 = r2.bottom();
+
+            painter->setPen(d->innerContrastLine());
+
+            QTransform rotMatrix;
+            bool flip = false;
+            painter->setPen(shadow);
+
+            switch (tab->shape) {
+            case QTabBar::RoundedNorth:
+                break;
+            case QTabBar::RoundedSouth:
+                rotMatrix.rotate(180);
+                rotMatrix.translate(0, -rect.height() + 1);
+                rotMatrix.scale(-1, 1);
+                painter->setTransform(rotMatrix, true);
+                break;
+            case QTabBar::RoundedWest:
+                rotMatrix.rotate(180 + 90);
+                rotMatrix.scale(-1, 1);
+                flip = true;
+                painter->setTransform(rotMatrix, true);
+                break;
+            case QTabBar::RoundedEast:
+                rotMatrix.rotate(90);
+                rotMatrix.translate(0, - rect.width() + 1);
+                flip = true;
+                painter->setTransform(rotMatrix, true);
+                break;
+            default:
+                painter->restore();
+                QCommonStyle::drawControl(element, tab, painter, widget);
+                return;
+            }
+
+            if (flip) {
+                QRect tmp = rect;
+                rect = QRect(tmp.y(), tmp.x(), tmp.height(), tmp.width());
+                int temp = x1;
+                x1 = y1;
+                y1 = temp;
+                temp = x2;
+                x2 = y2;
+                y2 = temp;
+            }
+
+            painter->setRenderHint(QPainter::Antialiasing, true);
+            painter->translate(0.5, 0.5);
+
+            QColor tabFrameColor = tab->features & QStyleOptionTab::HasFrame ?
+                        d->tabFrameColor(option->palette) :
+                        option->palette.window().color();
+
+            QLinearGradient fillGradient(rect.topLeft(), rect.bottomLeft());
+            QLinearGradient outlineGradient(rect.topLeft(), rect.bottomLeft());
+            QPen outlinePen = outline.lighter(110);
+            if (selected) {
+                fillGradient.setColorAt(0, tabFrameColor.lighter(104));
+                //                QColor highlight = option->palette.highlight().color();
+                //                if (option->state & State_HasFocus && option->state & State_KeyboardFocusChange) {
+                //                    fillGradient.setColorAt(0, highlight.lighter(130));
+                //                    outlineGradient.setColorAt(0, highlight.darker(130));
+                //                    fillGradient.setColorAt(0.14, highlight);
+                //                    outlineGradient.setColorAt(0.14, highlight.darker(130));
+                //                    fillGradient.setColorAt(0.1401, tabFrameColor);
+                //                    outlineGradient.setColorAt(0.1401, highlight.darker(130));
+                //                }
+                fillGradient.setColorAt(1, tabFrameColor);
+                outlineGradient.setColorAt(1, outline);
+                outlinePen = QPen(outlineGradient, 1);
+            } else {
+                fillGradient.setColorAt(0, tabFrameColor.darker(108));
+                fillGradient.setColorAt(0.85, tabFrameColor.darker(108));
+                fillGradient.setColorAt(1, tabFrameColor.darker(116));
+            }
+
+            QRect drawRect = rect.adjusted(0, selected ? 0 : 2, 0, 3);
+            painter->setPen(outlinePen);
+            painter->save();
+            painter->setClipRect(rect.adjusted(-1, -1, 1, selected ? -2 : -3));
+            painter->setBrush(fillGradient);
+            painter->drawRoundedRect(drawRect.adjusted(0, 0, -1, -1), 2.0, 2.0);
+            painter->setBrush(Qt::NoBrush);
+            painter->setPen(d->innerContrastLine());
+            painter->drawRoundedRect(drawRect.adjusted(1, 1, -2, -1), 2.0, 2.0);
+            painter->restore();
+
+            if (selected) {
+                painter->fillRect(rect.left() + 1, rect.bottom() - 1, rect.width() - 2, rect.bottom() - 1, tabFrameColor);
+                painter->fillRect(QRect(rect.bottomRight() + QPoint(-2, -1), QSize(1, 1)), d->innerContrastLine());
+                painter->fillRect(QRect(rect.bottomLeft() + QPoint(0, -1), QSize(1, 1)), d->innerContrastLine());
+                painter->fillRect(QRect(rect.bottomRight() + QPoint(-1, -1), QSize(1, 1)), d->innerContrastLine());
+            }
+        }
+        painter->restore();
+        break;
+    default:
+        QCommonStyle::drawControl(element,option,painter,widget);
+        break;
+    }
+}
+
+extern QPalette qt_fusionPalette();
+
+/*!
+  \reimp
+*/
+QPalette QFusionStyle::standardPalette () const
+{
+    return qt_fusionPalette();
+}
+
+/*!
+  \reimp
+*/
+void QFusionStyle::drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
+                                      QPainter *painter, const QWidget *widget) const
+{
+
+    Q_D (const QFusionStyle);
+
+    QColor buttonColor = d->buttonColor(option->palette);
+    QColor gradientStartColor = buttonColor.lighter(118);
+    QColor gradientStopColor = buttonColor;
+    QColor outline = d->outline(option->palette);
+
+    QColor alphaCornerColor;
+    if (widget) {
+        // ### backgroundrole/foregroundrole should be part of the style option
+        alphaCornerColor = mergedColors(option->palette.color(widget->backgroundRole()), outline);
+    } else {
+        alphaCornerColor = mergedColors(option->palette.background().color(), outline);
+    }
+
+    switch (control) {
+    case CC_GroupBox:
+        painter->save();
+        if (const QStyleOptionGroupBox *groupBox = qstyleoption_cast<const QStyleOptionGroupBox *>(option)) {
+            // Draw frame
+            QRect textRect = proxy()->subControlRect(CC_GroupBox, option, SC_GroupBoxLabel, widget);
+            QRect checkBoxRect = proxy()->subControlRect(CC_GroupBox, option, SC_GroupBoxCheckBox, widget);
+
+            if (groupBox->subControls & QStyle::SC_GroupBoxFrame) {
+                QStyleOptionFrame frame;
+                frame.QStyleOption::operator=(*groupBox);
+                frame.features = groupBox->features;
+                frame.lineWidth = groupBox->lineWidth;
+                frame.midLineWidth = groupBox->midLineWidth;
+                frame.rect = proxy()->subControlRect(CC_GroupBox, option, SC_GroupBoxFrame, widget);
+                proxy()->drawPrimitive(PE_FrameGroupBox, &frame, painter, widget);
+            }
+
+            // Draw title
+            if ((groupBox->subControls & QStyle::SC_GroupBoxLabel) && !groupBox->text.isEmpty()) {
+                // groupBox->textColor gets the incorrect palette here
+                painter->setPen(QPen(option->palette.windowText(), 1));
+                int alignment = int(groupBox->textAlignment);
+                if (!proxy()->styleHint(QStyle::SH_UnderlineShortcut, option, widget))
+                    alignment |= Qt::TextHideMnemonic;
+
+                proxy()->drawItemText(painter, textRect,  Qt::TextShowMnemonic | Qt::AlignLeft | alignment,
+                                      groupBox->palette, groupBox->state & State_Enabled, groupBox->text, QPalette::NoRole);
+
+                if (groupBox->state & State_HasFocus) {
+                    QStyleOptionFocusRect fropt;
+                    fropt.QStyleOption::operator=(*groupBox);
+                    fropt.rect = textRect.adjusted(-2, -1, 2, 1);
+                    proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
+                }
+            }
+
+            // Draw checkbox
+            if (groupBox->subControls & SC_GroupBoxCheckBox) {
+                QStyleOptionButton box;
+                box.QStyleOption::operator=(*groupBox);
+                box.rect = checkBoxRect;
+                proxy()->drawPrimitive(PE_IndicatorCheckBox, &box, painter, widget);
+            }
+        }
+        painter->restore();
+        break;
+    case CC_SpinBox:
+        if (const QStyleOptionSpinBox *spinBox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
+            QPixmap cache;
+            QString pixmapName = QStyleHelper::uniqueName(QLatin1String("spinbox"), spinBox, spinBox->rect.size());
+            if (!QPixmapCache::find(pixmapName, cache)) {
+
+                cache = styleCachePixmap(spinBox->rect.size());
+                cache.fill(Qt::transparent);
+
+                QRect pixmapRect(0, 0, spinBox->rect.width(), spinBox->rect.height());
+                QRect rect = pixmapRect;
+                QRect r = rect.adjusted(0, 1, 0, -1);
+                QPainter cachePainter(&cache);
+                QColor arrowColor = spinBox->palette.foreground().color();
+                arrowColor.setAlpha(220);
+
+                bool isEnabled = (spinBox->state & State_Enabled);
+                bool hover = isEnabled && (spinBox->state & State_MouseOver);
+                bool sunken = (spinBox->state & State_Sunken);
+                bool upIsActive = (spinBox->activeSubControls == SC_SpinBoxUp);
+                bool downIsActive = (spinBox->activeSubControls == SC_SpinBoxDown);
+                bool hasFocus = (option->state & State_HasFocus);
+
+                QStyleOptionSpinBox spinBoxCopy = *spinBox;
+                spinBoxCopy.rect = pixmapRect;
+                QRect upRect = proxy()->subControlRect(CC_SpinBox, &spinBoxCopy, SC_SpinBoxUp, widget);
+                QRect downRect = proxy()->subControlRect(CC_SpinBox, &spinBoxCopy, SC_SpinBoxDown, widget);
+
+                if (spinBox->frame) {
+                    cachePainter.save();
+                    cachePainter.setRenderHint(QPainter::Antialiasing, true);
+                    cachePainter.translate(0.5, 0.5);
+
+                    // Fill background
+                    cachePainter.setPen(Qt::NoPen);
+                    cachePainter.setBrush(option->palette.base());
+                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
+
+                    // Draw inner shadow
+                    cachePainter.setPen(d->topShadow());
+                    cachePainter.drawLine(QPoint(r.left() + 2, r.top() + 1), QPoint(r.right() - 2, r.top() + 1));
+
+                    // Draw button gradient
+                    QColor buttonColor = d->buttonColor(option->palette);
+                    QRect updownRect = upRect.adjusted(0, -2, 0, downRect.height() + 2);
+                    QLinearGradient gradient = qt_fusion_gradient(updownRect, (isEnabled && option->state & State_MouseOver ) ? buttonColor : buttonColor.darker(104));
+
+                    // Draw button gradient
+                    cachePainter.setPen(Qt::NoPen);
+                    cachePainter.setBrush(gradient);
+
+                    cachePainter.save();
+                    cachePainter.setClipRect(updownRect);
+                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
+                    cachePainter.setPen(QPen(d->innerContrastLine()));
+                    cachePainter.setBrush(Qt::NoBrush);
+                    cachePainter.drawRoundedRect(r.adjusted(1, 1, -2, -2), 2, 2);
+                    cachePainter.restore();
+
+                    if ((spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) && upIsActive) {
+                        if (sunken)
+                            cachePainter.fillRect(upRect.adjusted(0, -1, 0, 0), gradientStopColor.darker(110));
+                        else if (hover)
+                            cachePainter.fillRect(upRect.adjusted(0, -1, 0, 0), d->innerContrastLine());
+                    }
+
+                    if ((spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) && downIsActive) {
+                        if (sunken)
+                            cachePainter.fillRect(downRect.adjusted(0, 0, 0, 1), gradientStopColor.darker(110));
+                        else if (hover)
+                            cachePainter.fillRect(downRect.adjusted(0, 0, 0, 1), d->innerContrastLine());
+                    }
+
+                    cachePainter.setPen(hasFocus ? d->highlightedOutline(option->palette) : outline);
+                    cachePainter.setBrush(Qt::NoBrush);
+                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
+                    if (hasFocus) {
+                        QColor softHighlight = option->palette.highlight().color();
+                        softHighlight.setAlpha(40);
+                        cachePainter.setPen(softHighlight);
+                        cachePainter.drawRoundedRect(r.adjusted(1, 1, -2, -2), 1.7, 1.7);
+                    }
+                    cachePainter.restore();
+                }
+
+                // outline the up/down buttons
+                cachePainter.setPen(outline);
+                if (spinBox->direction == Qt::RightToLeft) {
+                    cachePainter.drawLine(upRect.right(), upRect.top() - 1, upRect.right(), downRect.bottom() + 1);
+                } else {
+                    cachePainter.drawLine(upRect.left(), upRect.top() - 1, upRect.left(), downRect.bottom() + 1);
+                }
+
+                if (upIsActive && sunken) {
+                    cachePainter.setPen(gradientStopColor.darker(130));
+                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.right(), downRect.top());
+                    cachePainter.drawLine(upRect.left() + 1, upRect.top(), upRect.left() + 1, upRect.bottom());
+                    cachePainter.drawLine(upRect.left() + 1, upRect.top() - 1, upRect.right(), upRect.top() - 1);
+                }
+
+                if (downIsActive && sunken) {
+                    cachePainter.setPen(gradientStopColor.darker(130));
+                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.left() + 1, downRect.bottom() + 1);
+                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.right(), downRect.top());
+                    cachePainter.setPen(gradientStopColor.darker(110));
+                    cachePainter.drawLine(downRect.left() + 1, downRect.bottom() + 1, downRect.right(), downRect.bottom() + 1);
+                }
+
+                QColor disabledColor = mergedColors(arrowColor, option->palette.button().color());
+                if (spinBox->buttonSymbols == QAbstractSpinBox::PlusMinus) {
+                    int centerX = upRect.center().x();
+                    int centerY = upRect.center().y();
+
+                    // plus/minus
+                    cachePainter.setPen((spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) ? arrowColor : disabledColor);
+                    cachePainter.drawLine(centerX - 1, centerY, centerX + 3, centerY);
+                    cachePainter.drawLine(centerX + 1, centerY - 2, centerX + 1, centerY + 2);
+
+                    centerX = downRect.center().x();
+                    centerY = downRect.center().y();
+                    cachePainter.setPen((spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) ? arrowColor : disabledColor);
+                    cachePainter.drawLine(centerX - 1, centerY, centerX + 3, centerY);
+
+                } else if (spinBox->buttonSymbols == QAbstractSpinBox::UpDownArrows){
+                    // arrows
+                    painter->setRenderHint(QPainter::SmoothPixmapTransform);
+
+                    QPixmap upArrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"),
+                                                     (spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) ? arrowColor : disabledColor);
+
+                    QRectF upArrowRect = QRectF(upRect.center().x() - upArrow.width() / 4.0 + 1.0,
+                                                upRect.center().y() - upArrow.height() / 4.0 + 1.0,
+                                                upArrow.width() / 2.0, upArrow.height() / 2.0);
+
+                    cachePainter.drawPixmap(upArrowRect, upArrow, QRectF(QPointF(0.0, 0.0), upArrow.size()));
+
+                    QPixmap downArrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"),
+                                                       (spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) ? arrowColor : disabledColor, 180);
+                    QRectF downArrowRect = QRectF(downRect.center().x() - downArrow.width() / 4.0 + 1.0,
+                                                  downRect.center().y() - downArrow.height() / 4.0 + 1.0,
+                                                  downArrow.width() / 2.0, downArrow.height() / 2.0);
+                    cachePainter.drawPixmap(downArrowRect, downArrow, QRectF(QPointF(0.0, 0.0), downArrow.size()));
+                }
+
+                cachePainter.end();
+                QPixmapCache::insert(pixmapName, cache);
+            }
+            painter->drawPixmap(spinBox->rect.topLeft(), cache);
+        }
+        break;
+    case CC_TitleBar:
+        painter->save();
+        if (const QStyleOptionTitleBar *titleBar = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {
+            const int buttonMargin = 5;
+            bool active = (titleBar->titleBarState & State_Active);
+            QRect fullRect = titleBar->rect;
+            QPalette palette = option->palette;
+            QColor highlight = option->palette.highlight().color();
+
+            QColor titleBarFrameBorder(active ? highlight.darker(180): outline.darker(110));
+            QColor titleBarHighlight(active ? highlight.lighter(120): palette.background().color().lighter(120));
+            QColor textColor(active ? 0xffffff : 0xff000000);
+            QColor textAlphaColor(active ? 0xffffff : 0xff000000 );
+
+            {
+                // Fill title bar gradient
+                QColor titlebarColor = QColor(active ? highlight: palette.background().color());
+                QLinearGradient gradient(option->rect.center().x(), option->rect.top(),
+                                         option->rect.center().x(), option->rect.bottom());
+
+                gradient.setColorAt(0, titlebarColor.lighter(114));
+                gradient.setColorAt(0.5, titlebarColor.lighter(102));
+                gradient.setColorAt(0.51, titlebarColor.darker(104));
+                gradient.setColorAt(1, titlebarColor);
+                painter->fillRect(option->rect.adjusted(1, 1, -1, 0), gradient);
+
+                // Frame and rounded corners
+                painter->setPen(titleBarFrameBorder);
+
+                // top outline
+                painter->drawLine(fullRect.left() + 5, fullRect.top(), fullRect.right() - 5, fullRect.top());
+                painter->drawLine(fullRect.left(), fullRect.top() + 4, fullRect.left(), fullRect.bottom());
+                const QPoint points[5] = {
+                    QPoint(fullRect.left() + 4, fullRect.top() + 1),
+                    QPoint(fullRect.left() + 3, fullRect.top() + 1),
+                    QPoint(fullRect.left() + 2, fullRect.top() + 2),
+                    QPoint(fullRect.left() + 1, fullRect.top() + 3),
+                    QPoint(fullRect.left() + 1, fullRect.top() + 4)
+                };
+                painter->drawPoints(points, 5);
+
+                painter->drawLine(fullRect.right(), fullRect.top() + 4, fullRect.right(), fullRect.bottom());
+                const QPoint points2[5] = {
+                    QPoint(fullRect.right() - 3, fullRect.top() + 1),
+                    QPoint(fullRect.right() - 4, fullRect.top() + 1),
+                    QPoint(fullRect.right() - 2, fullRect.top() + 2),
+                    QPoint(fullRect.right() - 1, fullRect.top() + 3),
+                    QPoint(fullRect.right() - 1, fullRect.top() + 4)
+                };
+                painter->drawPoints(points2, 5);
+
+                // draw bottomline
+                painter->drawLine(fullRect.right(), fullRect.bottom(), fullRect.left(), fullRect.bottom());
+
+                // top highlight
+                painter->setPen(titleBarHighlight);
+                painter->drawLine(fullRect.left() + 6, fullRect.top() + 1, fullRect.right() - 6, fullRect.top() + 1);
+            }
+            // draw title
+            QRect textRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarLabel, widget);
+            painter->setPen(active? (titleBar->palette.text().color().lighter(120)) :
+                                    titleBar->palette.text().color() );
+            // Note workspace also does elliding but it does not use the correct font
+            QString title = painter->fontMetrics().elidedText(titleBar->text, Qt::ElideRight, textRect.width() - 14);
+            painter->drawText(textRect.adjusted(1, 1, 1, 1), title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
+            painter->setPen(Qt::white);
+            if (active)
+                painter->drawText(textRect, title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
+            // min button
+            if ((titleBar->subControls & SC_TitleBarMinButton) && (titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
+                    !(titleBar->titleBarState& Qt::WindowMinimized)) {
+                QRect minButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMinButton, widget);
+                if (minButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_Sunken);
+                    qt_fusion_draw_mdibutton(painter, titleBar, minButtonRect, hover, sunken);
+                    QRect minButtonIconRect = minButtonRect.adjusted(buttonMargin ,buttonMargin , -buttonMargin, -buttonMargin);
+                    painter->setPen(textColor);
+                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 3,
+                                      minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 3);
+                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 4,
+                                      minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 4);
+                    painter->setPen(textAlphaColor);
+                    painter->drawLine(minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 3,
+                                      minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 4);
+                    painter->drawLine(minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 3,
+                                      minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 4);
+                }
+            }
+            // max button
+            if ((titleBar->subControls & SC_TitleBarMaxButton) && (titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
+                    !(titleBar->titleBarState & Qt::WindowMaximized)) {
+                QRect maxButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMaxButton, widget);
+                if (maxButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_Sunken);
+                    qt_fusion_draw_mdibutton(painter, titleBar, maxButtonRect, hover, sunken);
+
+                    QRect maxButtonIconRect = maxButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+
+                    painter->setPen(textColor);
+                    painter->drawRect(maxButtonIconRect.adjusted(0, 0, -1, -1));
+                    painter->drawLine(maxButtonIconRect.left() + 1, maxButtonIconRect.top() + 1,
+                                      maxButtonIconRect.right() - 1, maxButtonIconRect.top() + 1);
+                    painter->setPen(textAlphaColor);
+                    const QPoint points[4] = {
+                        maxButtonIconRect.topLeft(),
+                        maxButtonIconRect.topRight(),
+                        maxButtonIconRect.bottomLeft(),
+                        maxButtonIconRect.bottomRight()
+                    };
+                    painter->drawPoints(points, 4);
+                }
+            }
+
+            // close button
+            if ((titleBar->subControls & SC_TitleBarCloseButton) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
+                QRect closeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarCloseButton, widget);
+                if (closeButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_Sunken);
+                    qt_fusion_draw_mdibutton(painter, titleBar, closeButtonRect, hover, sunken);
+                    QRect closeIconRect = closeButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+                    painter->setPen(textAlphaColor);
+                    const QLine lines[4] = {
+                        QLine(closeIconRect.left() + 1, closeIconRect.top(),
+                        closeIconRect.right(), closeIconRect.bottom() - 1),
+                        QLine(closeIconRect.left(), closeIconRect.top() + 1,
+                        closeIconRect.right() - 1, closeIconRect.bottom()),
+                        QLine(closeIconRect.right() - 1, closeIconRect.top(),
+                        closeIconRect.left(), closeIconRect.bottom() - 1),
+                        QLine(closeIconRect.right(), closeIconRect.top() + 1,
+                        closeIconRect.left() + 1, closeIconRect.bottom())
+                    };
+                    painter->drawLines(lines, 4);
+                    const QPoint points[4] = {
+                        closeIconRect.topLeft(),
+                        closeIconRect.topRight(),
+                        closeIconRect.bottomLeft(),
+                        closeIconRect.bottomRight()
+                    };
+                    painter->drawPoints(points, 4);
+
+                    painter->setPen(textColor);
+                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.top() + 1,
+                                      closeIconRect.right() - 1, closeIconRect.bottom() - 1);
+                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.bottom() - 1,
+                                      closeIconRect.right() - 1, closeIconRect.top() + 1);
+                }
+            }
+
+            // normalize button
+            if ((titleBar->subControls & SC_TitleBarNormalButton) &&
+                    (((titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
+                      (titleBar->titleBarState & Qt::WindowMinimized)) ||
+                     ((titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
+                      (titleBar->titleBarState & Qt::WindowMaximized)))) {
+                QRect normalButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarNormalButton, widget);
+                if (normalButtonRect.isValid()) {
+
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_Sunken);
+                    QRect normalButtonIconRect = normalButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+                    qt_fusion_draw_mdibutton(painter, titleBar, normalButtonRect, hover, sunken);
+
+                    QRect frontWindowRect = normalButtonIconRect.adjusted(0, 3, -3, 0);
+                    painter->setPen(textColor);
+                    painter->drawRect(frontWindowRect.adjusted(0, 0, -1, -1));
+                    painter->drawLine(frontWindowRect.left() + 1, frontWindowRect.top() + 1,
+                                      frontWindowRect.right() - 1, frontWindowRect.top() + 1);
+                    painter->setPen(textAlphaColor);
+                    const QPoint points[4] = {
+                        frontWindowRect.topLeft(),
+                        frontWindowRect.topRight(),
+                        frontWindowRect.bottomLeft(),
+                        frontWindowRect.bottomRight()
+                    };
+                    painter->drawPoints(points, 4);
+
+                    QRect backWindowRect = normalButtonIconRect.adjusted(3, 0, 0, -3);
+                    QRegion clipRegion = backWindowRect;
+                    clipRegion -= frontWindowRect;
+                    painter->save();
+                    painter->setClipRegion(clipRegion);
+                    painter->setPen(textColor);
+                    painter->drawRect(backWindowRect.adjusted(0, 0, -1, -1));
+                    painter->drawLine(backWindowRect.left() + 1, backWindowRect.top() + 1,
+                                      backWindowRect.right() - 1, backWindowRect.top() + 1);
+                    painter->setPen(textAlphaColor);
+                    const QPoint points2[4] = {
+                        backWindowRect.topLeft(),
+                        backWindowRect.topRight(),
+                        backWindowRect.bottomLeft(),
+                        backWindowRect.bottomRight()
+                    };
+                    painter->drawPoints(points2, 4);
+                    painter->restore();
+                }
+            }
+
+            // context help button
+            if (titleBar->subControls & SC_TitleBarContextHelpButton
+                    && (titleBar->titleBarFlags & Qt::WindowContextHelpButtonHint)) {
+                QRect contextHelpButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarContextHelpButton, widget);
+                if (contextHelpButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_Sunken);
+                    qt_fusion_draw_mdibutton(painter, titleBar, contextHelpButtonRect, hover, sunken);
+                    QImage image(qt_titlebar_context_help);
+                    QColor alpha = textColor;
+                    alpha.setAlpha(128);
+                    image.setColor(1, textColor.rgba());
+                    image.setColor(2, alpha.rgba());
+                    painter->setRenderHint(QPainter::SmoothPixmapTransform);
+                    painter->drawImage(contextHelpButtonRect.adjusted(4, 4, -4, -4), image);
+                }
+            }
+
+            // shade button
+            if (titleBar->subControls & SC_TitleBarShadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
+                QRect shadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarShadeButton, widget);
+                if (shadeButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_Sunken);
+                    qt_fusion_draw_mdibutton(painter, titleBar, shadeButtonRect, hover, sunken);
+                    QPixmap arrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), textColor);
+                    painter->drawPixmap(shadeButtonRect.adjusted(5, 7, -5, -7), arrow);
+                }
+            }
+
+            // unshade button
+            if (titleBar->subControls & SC_TitleBarUnshadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
+                QRect unshadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarUnshadeButton, widget);
+                if (unshadeButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_Sunken);
+                    qt_fusion_draw_mdibutton(painter, titleBar, unshadeButtonRect, hover, sunken);
+                    QPixmap arrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), textColor, 180);
+                    painter->drawPixmap(unshadeButtonRect.adjusted(5, 7, -5, -7), arrow);
+                }
+            }
+
+            if ((titleBar->subControls & SC_TitleBarSysMenu) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
+                QRect iconRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarSysMenu, widget);
+                if (iconRect.isValid()) {
+                    if (!titleBar->icon.isNull()) {
+                        titleBar->icon.paint(painter, iconRect);
+                    } else {
+                        QStyleOption tool(0);
+                        tool.palette = titleBar->palette;
+                        QPixmap pm = standardIcon(SP_TitleBarMenuButton, &tool, widget).pixmap(16, 16);
+                        tool.rect = iconRect;
+                        painter->save();
+                        proxy()->drawItemPixmap(painter, iconRect, Qt::AlignCenter, pm);
+                        painter->restore();
+                    }
+                }
+            }
+        }
+        painter->restore();
+        break;
+    case CC_ScrollBar:
+        painter->save();
+        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+            bool wasActive = false;
+            qreal expandScale = 1.0;
+            qreal expandOffset = -1.0;
+            QObject *styleObject = option->styleObject;
+            if (styleObject && proxy()->styleHint(SH_ScrollBar_Transient, option, widget)) {
+                qreal opacity = 0.0;
+                bool shouldExpand = false;
+                const qreal maxExpandScale = 13.0 / 9.0;
+
+                int oldPos = styleObject->property("_q_stylepos").toInt();
+                int oldMin = styleObject->property("_q_stylemin").toInt();
+                int oldMax = styleObject->property("_q_stylemax").toInt();
+                QRect oldRect = styleObject->property("_q_stylerect").toRect();
+                int oldState = styleObject->property("_q_stylestate").toInt();
+                uint oldActiveControls = styleObject->property("_q_stylecontrols").toUInt();
+
+                // a scrollbar is transient when the the scrollbar itself and
+                // its sibling are both inactive (ie. not pressed/hovered/moved)
+                bool transient = !option->activeSubControls && !(option->state & State_On);
+
+                if (!transient ||
+                        oldPos != scrollBar->sliderPosition ||
+                        oldMin != scrollBar->minimum ||
+                        oldMax != scrollBar->maximum ||
+                        oldRect != scrollBar->rect ||
+                        oldState != scrollBar->state ||
+                        oldActiveControls != scrollBar->activeSubControls) {
+
+                    // if the scrollbar is transient or its attributes, geometry or
+                    // state has changed, the opacity is reset back to 100% opaque
+                    opacity = 1.0;
+
+                    styleObject->setProperty("_q_stylepos", scrollBar->sliderPosition);
+                    styleObject->setProperty("_q_stylemin", scrollBar->minimum);
+                    styleObject->setProperty("_q_stylemax", scrollBar->maximum);
+                    styleObject->setProperty("_q_stylerect", scrollBar->rect);
+                    styleObject->setProperty("_q_stylestate", static_cast<int>(scrollBar->state));
+                    styleObject->setProperty("_q_stylecontrols", static_cast<uint>(scrollBar->activeSubControls));
+
+                    QScrollbarStyleAnimation *anim  = qobject_cast<QScrollbarStyleAnimation *>(d->animation(styleObject));
+                    if (transient) {
+                        if (!anim) {
+                            anim = new QScrollbarStyleAnimation(QScrollbarStyleAnimation::Deactivating, styleObject);
+                            d->startAnimation(anim);
+                        } else if (anim->mode() == QScrollbarStyleAnimation::Deactivating) {
+                            // the scrollbar was already fading out while the
+                            // state changed -> restart the fade out animation
+                            anim->setCurrentTime(0);
+                        }
+                    } else if (anim && anim->mode() == QScrollbarStyleAnimation::Deactivating) {
+                        d->stopAnimation(styleObject);
+                    }
+                }
+
+                QScrollbarStyleAnimation *anim = qobject_cast<QScrollbarStyleAnimation *>(d->animation(styleObject));
+                if (anim && anim->mode() == QScrollbarStyleAnimation::Deactivating) {
+                    // once a scrollbar was active (hovered/pressed), it retains
+                    // the active look even if it's no longer active while fading out
+                    if (oldActiveControls)
+                        anim->setActive(true);
+
+                    wasActive = anim->wasActive();
+                    opacity = anim->currentValue();
+                }
+
+                shouldExpand = (option->activeSubControls || wasActive);
+                if (shouldExpand) {
+                    if (!anim && !oldActiveControls) {
+                        // Start expand animation only once and when entering
+                        anim = new QScrollbarStyleAnimation(QScrollbarStyleAnimation::Activating, styleObject);
+                        d->startAnimation(anim);
+                    }
+                    if (anim && anim->mode() == QScrollbarStyleAnimation::Activating) {
+                        expandScale = 1.0 + (maxExpandScale - 1.0) * anim->currentValue();
+                        expandOffset = 5.5 * anim->currentValue() - 1;
+                    } else {
+                        // Keep expanded state after the animation ends, and when fading out
+                        expandScale = maxExpandScale;
+                        expandOffset = 4.5;
+                    }
+                }
+                painter->setOpacity(opacity);
+            }
+
+            bool transient = proxy()->styleHint(SH_ScrollBar_Transient, option, widget);
+            bool horizontal = scrollBar->orientation == Qt::Horizontal;
+            bool sunken = scrollBar->state & State_Sunken;
+
+            QRect scrollBarSubLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSubLine, widget);
+            QRect scrollBarAddLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarAddLine, widget);
+            QRect scrollBarSlider = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSlider, widget);
+            QRect scrollBarGroove = proxy()->subControlRect(control, scrollBar, SC_ScrollBarGroove, widget);
+
+            QRect rect = option->rect;
+            QColor alphaOutline = outline;
+            alphaOutline.setAlpha(180);
+
+            QColor arrowColor = option->palette.foreground().color();
+            arrowColor.setAlpha(220);
+
+            const QColor bgColor = QStyleHelper::backgroundColor(option->palette, widget);
+            const bool isDarkBg = bgColor.red() < 128 && bgColor.green() < 128 && bgColor.blue() < 128;
+
+            if (transient) {
+                if (horizontal) {
+                    rect.setY(rect.y() + 4.5 - expandOffset);
+                    scrollBarSlider.setY(scrollBarSlider.y() + 4.5 - expandOffset);
+                    scrollBarGroove.setY(scrollBarGroove.y() + 4.5 - expandOffset);
+
+                    rect.setHeight(rect.height() * expandScale);
+                    scrollBarGroove.setHeight(scrollBarGroove.height() * expandScale);
+                } else {
+                    rect.setX(rect.x() + 4.5 - expandOffset);
+                    scrollBarSlider.setX(scrollBarSlider.x() + 4.5 - expandOffset);
+                    scrollBarGroove.setX(scrollBarGroove.x() + 4.5 - expandOffset);
+
+                    rect.setWidth(rect.width() * expandScale);
+                    scrollBarGroove.setWidth(scrollBarGroove.width() * expandScale);
+                }
+            }
+
+            // Paint groove
+            if ((!transient || scrollBar->activeSubControls || wasActive) && scrollBar->subControls & SC_ScrollBarGroove) {
+                QLinearGradient gradient(rect.center().x(), rect.top(),
+                                         rect.center().x(), rect.bottom());
+                if (!horizontal)
+                    gradient = QLinearGradient(rect.left(), rect.center().y(),
+                                               rect.right(), rect.center().y());
+                if (!transient || !isDarkBg) {
+                    gradient.setColorAt(0, buttonColor.darker(107));
+                    gradient.setColorAt(0.1, buttonColor.darker(105));
+                    gradient.setColorAt(0.9, buttonColor.darker(105));
+                    gradient.setColorAt(1, buttonColor.darker(107));
+                } else {
+                    gradient.setColorAt(0, bgColor.lighter(157));
+                    gradient.setColorAt(0.1, bgColor.lighter(155));
+                    gradient.setColorAt(0.9, bgColor.lighter(155));
+                    gradient.setColorAt(1, bgColor.lighter(157));
+                }
+
+                painter->save();
+                if (transient)
+                    painter->setOpacity(0.8);
+                painter->fillRect(rect, gradient);
+                painter->setPen(Qt::NoPen);
+                if (transient)
+                    painter->setOpacity(0.4);
+                painter->setPen(alphaOutline);
+                if (horizontal)
+                    painter->drawLine(rect.topLeft(), rect.topRight());
+                else
+                    painter->drawLine(rect.topLeft(), rect.bottomLeft());
+
+                QColor subtleEdge = alphaOutline;
+                subtleEdge.setAlpha(40);
+                painter->setPen(Qt::NoPen);
+                painter->setBrush(Qt::NoBrush);
+                painter->setClipRect(scrollBarGroove.adjusted(1, 0, -1, -3));
+                painter->drawRect(scrollBarGroove.adjusted(1, 0, -1, -1));
+                painter->restore();
+            }
+
+            QRect pixmapRect = scrollBarSlider;
+            QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
+                                     pixmapRect.center().x(), pixmapRect.bottom());
+            if (!horizontal)
+                gradient = QLinearGradient(pixmapRect.left(), pixmapRect.center().y(),
+                                           pixmapRect.right(), pixmapRect.center().y());
+
+            QLinearGradient highlightedGradient = gradient;
+
+            QColor midColor2 = mergedColors(gradientStartColor, gradientStopColor, 40);
+            gradient.setColorAt(0, d->buttonColor(option->palette).lighter(108));
+            gradient.setColorAt(1, d->buttonColor(option->palette));
+
+            highlightedGradient.setColorAt(0, gradientStartColor.darker(102));
+            highlightedGradient.setColorAt(1, gradientStopColor.lighter(102));
+
+            // Paint slider
+            if (scrollBar->subControls & SC_ScrollBarSlider) {
+                if (transient) {
+                    QRect rect = scrollBarSlider.adjusted(horizontal ? 1 : 2, horizontal ? 2 : 1, -1, -1);
+                    painter->setPen(Qt::NoPen);
+                    painter->setBrush(isDarkBg ? d->lightShade() : d->darkShade());
+                    int r = qMin(rect.width(), rect.height()) / 2;
+
+                    painter->save();
+                    painter->setRenderHint(QPainter::Antialiasing, true);
+                    painter->drawRoundedRect(rect, r, r);
+                    painter->restore();
+                } else {
+                    QRect pixmapRect = scrollBarSlider;
+                    painter->setPen(QPen(alphaOutline));
+                    if (option->state & State_Sunken && scrollBar->activeSubControls & SC_ScrollBarSlider)
+                        painter->setBrush(midColor2);
+                    else if (option->state & State_MouseOver && scrollBar->activeSubControls & SC_ScrollBarSlider)
+                        painter->setBrush(highlightedGradient);
+                    else
+                        painter->setBrush(gradient);
+
+                    painter->drawRect(pixmapRect.adjusted(horizontal ? -1 : 0, horizontal ? 0 : -1, horizontal ? 0 : 1, horizontal ? 1 : 0));
+
+                    painter->setPen(d->innerContrastLine());
+                    painter->drawRect(scrollBarSlider.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, -1, -1));
+
+                    // Outer shadow
+                    //                  painter->setPen(subtleEdge);
+                    //                  if (horizontal) {
+                    ////                    painter->drawLine(scrollBarSlider.topLeft() + QPoint(-2, 0), scrollBarSlider.bottomLeft() + QPoint(2, 0));
+                    ////                    painter->drawLine(scrollBarSlider.topRight() + QPoint(-2, 0), scrollBarSlider.bottomRight() + QPoint(2, 0));
+                    //                  } else {
+                    ////                    painter->drawLine(pixmapRect.topLeft() + QPoint(0, -2), pixmapRect.bottomLeft() + QPoint(0, -2));
+                    ////                    painter->drawLine(pixmapRect.topRight() + QPoint(0, 2), pixmapRect.bottomRight() + QPoint(0, 2));
+                    //                  }
+                }
+            }
+
+            // The SubLine (up/left) buttons
+            if (!transient && scrollBar->subControls & SC_ScrollBarSubLine) {
+                if ((scrollBar->activeSubControls & SC_ScrollBarSubLine) && sunken)
+                    painter->setBrush(gradientStopColor);
+                else if ((scrollBar->activeSubControls & SC_ScrollBarSubLine))
+                    painter->setBrush(highlightedGradient);
+                else
+                    painter->setBrush(gradient);
+
+                painter->setPen(Qt::NoPen);
+                painter->drawRect(scrollBarSubLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, 0, 0));
+                painter->setPen(QPen(alphaOutline));
+                if (option->state & State_Horizontal) {
+                    if (option->direction == Qt::RightToLeft) {
+                        pixmapRect.setLeft(scrollBarSubLine.left());
+                        painter->drawLine(pixmapRect.topLeft(), pixmapRect.bottomLeft());
+                    } else {
+                        pixmapRect.setRight(scrollBarSubLine.right());
+                        painter->drawLine(pixmapRect.topRight(), pixmapRect.bottomRight());
+                    }
+                } else {
+                    pixmapRect.setBottom(scrollBarSubLine.bottom());
+                    painter->drawLine(pixmapRect.bottomLeft(), pixmapRect.bottomRight());
+                }
+
+                painter->setBrush(Qt::NoBrush);
+                painter->setPen(d->innerContrastLine());
+                painter->drawRect(scrollBarSubLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0 ,  horizontal ? -2 : -1, horizontal ? -1 : -2));
+
+                // Arrows
+                int rotation = 0;
+                if (option->state & State_Horizontal)
+                    rotation = option->direction == Qt::LeftToRight ? -90 : 90;
+                QRect upRect = scrollBarSubLine.translated(horizontal ? -2 : -1, 0);
+                QPixmap arrowPixmap = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), arrowColor, rotation);
+                painter->drawPixmap(QRectF(upRect.center().x() - arrowPixmap.width() / 4.0  + 2.0,
+                                          upRect.center().y() - arrowPixmap.height() / 4.0 + 1.0,
+                                          arrowPixmap.width() / 2.0, arrowPixmap.height() / 2.0),
+                                          arrowPixmap, QRectF(QPoint(0.0, 0.0), arrowPixmap.size()));
+            }
+
+            // The AddLine (down/right) button
+            if (!transient && scrollBar->subControls & SC_ScrollBarAddLine) {
+                if ((scrollBar->activeSubControls & SC_ScrollBarAddLine) && sunken)
+                    painter->setBrush(gradientStopColor);
+                else if ((scrollBar->activeSubControls & SC_ScrollBarAddLine))
+                    painter->setBrush(midColor2);
+                else
+                    painter->setBrush(gradient);
+
+                painter->setPen(Qt::NoPen);
+                painter->drawRect(scrollBarAddLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, 0, 0));
+                painter->setPen(QPen(alphaOutline, 1));
+                if (option->state & State_Horizontal) {
+                    if (option->direction == Qt::LeftToRight) {
+                        pixmapRect.setLeft(scrollBarAddLine.left());
+                        painter->drawLine(pixmapRect.topLeft(), pixmapRect.bottomLeft());
+                    } else {
+                        pixmapRect.setRight(scrollBarAddLine.right());
+                        painter->drawLine(pixmapRect.topRight(), pixmapRect.bottomRight());
+                    }
+                } else {
+                    pixmapRect.setTop(scrollBarAddLine.top());
+                    painter->drawLine(pixmapRect.topLeft(), pixmapRect.topRight());
+                }
+
+                painter->setPen(d->innerContrastLine());
+                painter->setBrush(Qt::NoBrush);
+                painter->drawRect(scrollBarAddLine.adjusted(1, 1, -1, -1));
+
+                int rotation = 180;
+                if (option->state & State_Horizontal)
+                    rotation = option->direction == Qt::LeftToRight ? 90 : -90;
+                QRect downRect = scrollBarAddLine.translated(-1, 1);
+                QPixmap arrowPixmap = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), arrowColor, rotation);
+                painter->drawPixmap(QRectF(downRect.center().x() - arrowPixmap.width() / 4.0 + 2.0,
+                                           downRect.center().y() - arrowPixmap.height() / 4.0,
+                                           arrowPixmap.width() / 2.0, arrowPixmap.height() / 2.0),
+                                           arrowPixmap, QRectF(QPoint(0.0, 0.0), arrowPixmap.size()));
+            }
+
+        }
+        painter->restore();
+        break;;
+    case CC_ComboBox:
+        painter->save();
+        if (const QStyleOptionComboBox *comboBox = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
+            bool hasFocus = option->state & State_HasFocus && option->state & State_KeyboardFocusChange;
+            bool sunken = comboBox->state & State_On; // play dead, if combobox has no items
+            bool isEnabled = (comboBox->state & State_Enabled);
+            QPixmap cache;
+            QString pixmapName = QStyleHelper::uniqueName(QLatin1String("combobox"), option, comboBox->rect.size());
+            if (sunken)
+                pixmapName += QLatin1String("-sunken");
+            if (comboBox->editable)
+                pixmapName += QLatin1String("-editable");
+            if (isEnabled)
+                pixmapName += QLatin1String("-enabled");
+
+            if (!QPixmapCache::find(pixmapName, cache)) {
+                cache = styleCachePixmap(comboBox->rect.size());
+                cache.fill(Qt::transparent);
+                QPainter cachePainter(&cache);
+                QRect pixmapRect(0, 0, comboBox->rect.width(), comboBox->rect.height());
+                QStyleOptionComboBox comboBoxCopy = *comboBox;
+                comboBoxCopy.rect = pixmapRect;
+
+                QRect rect = pixmapRect;
+                QRect downArrowRect = proxy()->subControlRect(CC_ComboBox, &comboBoxCopy,
+                                                              SC_ComboBoxArrow, widget);
+                // Draw a line edit
+                if (comboBox->editable) {
+                    QStyleOptionFrame  buttonOption;
+                    buttonOption.QStyleOption::operator=(*comboBox);
+                    buttonOption.rect = rect;
+                    buttonOption.state = (comboBox->state & (State_Enabled | State_MouseOver | State_HasFocus))
+                            | State_KeyboardFocusChange; // Always show hig
+
+                    if (sunken) {
+                        buttonOption.state |= State_Sunken;
+                        buttonOption.state &= ~State_MouseOver;
+                    }
+
+                    proxy()->drawPrimitive(PE_FrameLineEdit, &buttonOption, &cachePainter, widget);
+
+                    // Draw button clipped
+                    cachePainter.save();
+                    cachePainter.setClipRect(downArrowRect.adjusted(0, 0, 1, 0));
+                    buttonOption.rect.setLeft(comboBox->direction == Qt::LeftToRight ?
+                                                  downArrowRect.left() - 6: downArrowRect.right() + 6);
+                    proxy()->drawPrimitive(PE_PanelButtonCommand, &buttonOption, &cachePainter, widget);
+                    cachePainter.restore();
+                    cachePainter.setPen( QPen(hasFocus ? option->palette.highlight() : outline.lighter(110), 1));
+
+                    if (!sunken) {
+                        int borderSize = 1;
+                        if (comboBox->direction == Qt::RightToLeft) {
+                            cachePainter.drawLine(QPoint(downArrowRect.right() - 1, downArrowRect.top() + borderSize ),
+                                                  QPoint(downArrowRect.right() - 1, downArrowRect.bottom() - borderSize));
+                        } else {
+                            cachePainter.drawLine(QPoint(downArrowRect.left() , downArrowRect.top() + borderSize),
+                                                  QPoint(downArrowRect.left() , downArrowRect.bottom() - borderSize));
+                        }
+                    } else {
+                        if (comboBox->direction == Qt::RightToLeft) {
+                            cachePainter.drawLine(QPoint(downArrowRect.right(), downArrowRect.top() + 2),
+                                                  QPoint(downArrowRect.right(), downArrowRect.bottom() - 2));
+
+                        } else {
+                            cachePainter.drawLine(QPoint(downArrowRect.left(), downArrowRect.top() + 2),
+                                                  QPoint(downArrowRect.left(), downArrowRect.bottom() - 2));
+                        }
+                    }
+                } else {
+                    QStyleOptionButton buttonOption;
+                    buttonOption.QStyleOption::operator=(*comboBox);
+                    buttonOption.rect = rect;
+                    buttonOption.state = comboBox->state & (State_Enabled | State_MouseOver | State_HasFocus | State_KeyboardFocusChange);
+                    if (sunken) {
+                        buttonOption.state |= State_Sunken;
+                        buttonOption.state &= ~State_MouseOver;
+                    }
+                    proxy()->drawPrimitive(PE_PanelButtonCommand, &buttonOption, &cachePainter, widget);
+                }
+                if (comboBox->subControls & SC_ComboBoxArrow) {
+                    // Draw the up/down arrow
+                    QColor arrowColor = option->palette.buttonText().color();
+                    arrowColor.setAlpha(220);
+                    QPixmap downArrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), arrowColor, 180);
+                    cachePainter.drawPixmap(QRectF(downArrowRect.center().x() - downArrow.width() / 4.0 + 1.0,
+                                                   downArrowRect.center().y() - downArrow.height() / 4.0 + 1.0,
+                                                   downArrow.width() / 2.0, downArrow.height() / 2.0),
+                                                   downArrow, QRectF(QPointF(0.0, 0.0), downArrow.size()));
+                }
+                cachePainter.end();
+                QPixmapCache::insert(pixmapName, cache);
+            }
+            painter->drawPixmap(comboBox->rect.topLeft(), cache);
+        }
+        painter->restore();
+        break;
+    case CC_Slider:
+        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+            QRect groove = proxy()->subControlRect(CC_Slider, option, SC_SliderGroove, widget);
+            QRect handle = proxy()->subControlRect(CC_Slider, option, SC_SliderHandle, widget);
+
+            bool horizontal = slider->orientation == Qt::Horizontal;
+            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
+            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
+            QColor activeHighlight = d->highlight(option->palette);
+            QPixmap cache;
+            QBrush oldBrush = painter->brush();
+            QPen oldPen = painter->pen();
+            QColor shadowAlpha(Qt::black);
+            shadowAlpha.setAlpha(10);
+            if (option->state & State_HasFocus && option->state & State_KeyboardFocusChange)
+                outline = d->highlightedOutline(option->palette);
+
+
+            if ((option->subControls & SC_SliderGroove) && groove.isValid()) {
+                QColor grooveColor;
+                grooveColor.setHsv(buttonColor.hue(),
+                                   qMin(255, (int)(buttonColor.saturation())),
+                                   qMin(255, (int)(buttonColor.value()*0.9)));
+                QString groovePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_groove"), option, groove.size());
+                QRect pixmapRect(0, 0, groove.width(), groove.height());
+
+                // draw background groove
+                if (!QPixmapCache::find(groovePixmapName, cache)) {
+                    cache = styleCachePixmap(pixmapRect.size());
+                    cache.fill(Qt::transparent);
+                    QPainter groovePainter(&cache);
+                    groovePainter.setRenderHint(QPainter::Antialiasing, true);
+                    groovePainter.translate(0.5, 0.5);
+                    QLinearGradient gradient;
+                    if (horizontal) {
+                        gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
+                        gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
+                    }
+                    else {
+                        gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
+                        gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
+                    }
+                    groovePainter.setPen(QPen(outline));
+                    gradient.setColorAt(0, grooveColor.darker(110));
+                    gradient.setColorAt(1, grooveColor.lighter(110));//palette.button().color().darker(115));
+                    groovePainter.setBrush(gradient);
+                    groovePainter.drawRoundedRect(pixmapRect.adjusted(1, 1, -2, -2), 1, 1);
+                    groovePainter.end();
+                    QPixmapCache::insert(groovePixmapName, cache);
+                }
+                painter->drawPixmap(groove.topLeft(), cache);
+
+                // draw blue groove highlight
+                QRect clipRect;
+                groovePixmapName += QLatin1String("_blue");
+                if (!QPixmapCache::find(groovePixmapName, cache)) {
+                    cache = styleCachePixmap(pixmapRect.size());
+                    cache.fill(Qt::transparent);
+                    QPainter groovePainter(&cache);
+                    QLinearGradient gradient;
+                    if (horizontal) {
+                        gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
+                        gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
+                    }
+                    else {
+                        gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
+                        gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
+                    }
+                    QColor highlight = d->highlight(option->palette);
+                    QColor highlightedoutline = highlight.darker(140);
+                    if (qGray(outline.rgb()) > qGray(highlightedoutline.rgb()))
+                        outline = highlightedoutline;
+
+
+                    groovePainter.setRenderHint(QPainter::Antialiasing, true);
+                    groovePainter.translate(0.5, 0.5);
+                    groovePainter.setPen(QPen(outline));
+                    gradient.setColorAt(0, activeHighlight);
+                    gradient.setColorAt(1, activeHighlight.lighter(130));
+                    groovePainter.setBrush(gradient);
+                    groovePainter.drawRoundedRect(pixmapRect.adjusted(1, 1, -2, -2), 1, 1);
+                    groovePainter.setPen(d->innerContrastLine());
+                    groovePainter.setBrush(Qt::NoBrush);
+                    groovePainter.drawRoundedRect(pixmapRect.adjusted(2, 2, -3, -3), 1, 1);
+                    groovePainter.end();
+                    QPixmapCache::insert(groovePixmapName, cache);
+                }
+                if (horizontal) {
+                    if (slider->upsideDown)
+                        clipRect = QRect(handle.right(), groove.top(), groove.right() - handle.right(), groove.height());
+                    else
+                        clipRect = QRect(groove.left(), groove.top(), handle.left(), groove.height());
+                } else {
+                    if (slider->upsideDown)
+                        clipRect = QRect(groove.left(), handle.bottom(), groove.width(), groove.height() - handle.bottom());
+                    else
+                        clipRect = QRect(groove.left(), groove.top(), groove.width(), handle.top() - groove.top());
+                }
+                painter->save();
+                painter->setClipRect(clipRect.adjusted(0, 0, 1, 1), Qt::IntersectClip);
+                painter->drawPixmap(groove.topLeft(), cache);
+                painter->restore();
+            }
+
+            if (option->subControls & SC_SliderTickmarks) {
+                painter->setPen(outline);
+                int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
+                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
+                int interval = slider->tickInterval;
+                if (interval <= 0) {
+                    interval = slider->singleStep;
+                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
+                                                        available)
+                            - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
+                                                              0, available) < 3)
+                        interval = slider->pageStep;
+                }
+                if (interval <= 0)
+                    interval = 1;
+
+                int v = slider->minimum;
+                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
+                while (v <= slider->maximum + 1) {
+                    if (v == slider->maximum + 1 && interval == 1)
+                        break;
+                    const int v_ = qMin(v, slider->maximum);
+                    int pos = sliderPositionFromValue(slider->minimum, slider->maximum,
+                                                      v_, (horizontal
+                                                           ? slider->rect.width()
+                                                           : slider->rect.height()) - len,
+                                                      slider->upsideDown) + len / 2;
+                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
+
+                    if (horizontal) {
+                        if (ticksAbove) {
+                            painter->drawLine(pos, slider->rect.top() + extra,
+                                              pos, slider->rect.top() + tickSize);
+                        }
+                        if (ticksBelow) {
+                            painter->drawLine(pos, slider->rect.bottom() - extra,
+                                              pos, slider->rect.bottom() - tickSize);
+                        }
+                    } else {
+                        if (ticksAbove) {
+                            painter->drawLine(slider->rect.left() + extra, pos,
+                                              slider->rect.left() + tickSize, pos);
+                        }
+                        if (ticksBelow) {
+                            painter->drawLine(slider->rect.right() - extra, pos,
+                                              slider->rect.right() - tickSize, pos);
+                        }
+                    }
+                    // in the case where maximum is max int
+                    int nextInterval = v + interval;
+                    if (nextInterval < v)
+                        break;
+                    v = nextInterval;
+                }
+            }
+            // draw handle
+            if ((option->subControls & SC_SliderHandle) ) {
+                QString handlePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_handle"), option, handle.size());
+                if (!QPixmapCache::find(handlePixmapName, cache)) {
+                    cache = styleCachePixmap(handle.size());
+                    cache.fill(Qt::transparent);
+                    QRect pixmapRect(0, 0, handle.width(), handle.height());
+                    QPainter handlePainter(&cache);
+                    QRect gradRect = pixmapRect.adjusted(2, 2, -2, -2);
+
+                    // gradient fill
+                    QRect r = pixmapRect.adjusted(1, 1, -2, -2);
+                    QLinearGradient gradient = qt_fusion_gradient(gradRect, d->buttonColor(option->palette),horizontal ? TopDown : FromLeft);
+
+                    handlePainter.setRenderHint(QPainter::Antialiasing, true);
+                    handlePainter.translate(0.5, 0.5);
+
+                    handlePainter.setPen(Qt::NoPen);
+                    handlePainter.setBrush(QColor(0, 0, 0, 40));
+                    handlePainter.drawRect(r.adjusted(-1, 2, 1, -2));
+
+                    handlePainter.setPen(QPen(d->outline(option->palette)));
+                    if (option->state & State_HasFocus && option->state & State_KeyboardFocusChange)
+                        handlePainter.setPen(QPen(d->highlightedOutline(option->palette)));
+
+                    handlePainter.setBrush(gradient);
+                    handlePainter.drawRoundedRect(r, 2, 2);
+                    handlePainter.setBrush(Qt::NoBrush);
+                    handlePainter.setPen(d->innerContrastLine());
+                    handlePainter.drawRoundedRect(r.adjusted(1, 1, -1, -1), 2, 2);
+
+                    QColor cornerAlpha = outline.darker(120);
+                    cornerAlpha.setAlpha(80);
+
+                    //handle shadow
+                    handlePainter.setPen(shadowAlpha);
+                    handlePainter.drawLine(QPoint(r.left() + 2, r.bottom() + 1), QPoint(r.right() - 2, r.bottom() + 1));
+                    handlePainter.drawLine(QPoint(r.right() + 1, r.bottom() - 3), QPoint(r.right() + 1, r.top() + 4));
+                    handlePainter.drawLine(QPoint(r.right() - 1, r.bottom()), QPoint(r.right() + 1, r.bottom() - 2));
+
+                    handlePainter.end();
+                    QPixmapCache::insert(handlePixmapName, cache);
+                }
+
+                painter->drawPixmap(handle.topLeft(), cache);
+
+            }
+            painter->setBrush(oldBrush);
+            painter->setPen(oldPen);
+        }
+        break;
+    case CC_Dial:
+        if (const QStyleOptionSlider *dial = qstyleoption_cast<const QStyleOptionSlider *>(option))
+            QStyleHelper::drawDial(dial, painter);
+        break;
+    default:
+        QCommonStyle::drawComplexControl(control, option, painter, widget);
+        break;
+    }
+}
+
+/*!
+  \reimp
+*/
+int QFusionStyle::pixelMetric(PixelMetric metric, const QStyleOption *option, const QWidget *widget) const
+{
+    switch (metric) {
+    case PM_SliderTickmarkOffset:
+        return 4;
+    case PM_HeaderMargin:
+        return 2;
+    case PM_ToolTipLabelFrameWidth:
+        return 2;
+    case PM_ButtonDefaultIndicator:
+        return 0;
+    case PM_ButtonShiftHorizontal:
+    case PM_ButtonShiftVertical:
+        return 0;
+    case PM_MessageBoxIconSize:
+        return 48;
+    case PM_ListViewIconSize:
+        return 24;
+    case PM_DialogButtonsSeparator:
+    case PM_ScrollBarSliderMin:
+        return 26;
+    case PM_TitleBarHeight:
+        return 24;
+    case PM_ScrollBarExtent:
+        return 14;
+    case PM_SliderThickness:
+        return 15;
+    case PM_SliderLength:
+        return 15;
+    case PM_DockWidgetTitleMargin:
+        return 1;
+    case PM_DefaultFrameWidth:
+        return 1;
+    case PM_SpinBoxFrameWidth:
+        return 3;
+    case PM_MenuVMargin:
+    case PM_MenuHMargin:
+        return 0;
+    case PM_MenuPanelWidth:
+        return 0;
+    case PM_MenuBarItemSpacing:
+        return 6;
+    case PM_MenuBarVMargin:
+        return 0;
+    case PM_MenuBarHMargin:
+        return 0;
+    case PM_MenuBarPanelWidth:
+        return 0;
+    case PM_ToolBarHandleExtent:
+        return 9;
+    case PM_ToolBarItemSpacing:
+        return 1;
+    case PM_ToolBarFrameWidth:
+        return 2;
+    case PM_ToolBarItemMargin:
+        return 2;
+    case PM_SmallIconSize:
+        return 16;
+    case PM_ButtonIconSize:
+        return 16;
+    case PM_DockWidgetTitleBarButtonMargin:
+        return 2;
+    case PM_MaximumDragDistance:
+        return -1;
+    case PM_TabCloseIndicatorWidth:
+    case PM_TabCloseIndicatorHeight:
+        return 20;
+    case PM_TabBarTabVSpace:
+        return 12;
+    case PM_TabBarTabOverlap:
+        return 1;
+    case PM_TabBarBaseOverlap:
+        return 2;
+    case PM_SubMenuOverlap:
+        return -1;
+    case PM_DockWidgetHandleExtent:
+    case PM_SplitterWidth:
+        return 4;
+    case PM_IndicatorHeight:
+    case PM_IndicatorWidth:
+    case PM_ExclusiveIndicatorHeight:
+    case PM_ExclusiveIndicatorWidth:
+        return 14;
+    case PM_ScrollView_ScrollBarSpacing:
+        return 0;
+    case PM_ScrollView_ScrollBarOverlap:
+        if (proxy()->styleHint(SH_ScrollBar_Transient, option, widget))
+            return proxy()->pixelMetric(PM_ScrollBarExtent, option, widget);
+        return 0;
+    default:
+        break;
+    }
+    return QCommonStyle::pixelMetric(metric, option, widget);
+}
+
+/*!
+  \reimp
+*/
+QSize QFusionStyle::sizeFromContents(ContentsType type, const QStyleOption *option,
+                                     const QSize &size, const QWidget *widget) const
+{
+    QSize newSize = QCommonStyle::sizeFromContents(type, option, size, widget);
+    switch (type) {
+    case CT_PushButton:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(option)) {
+            if (!btn->text.isEmpty() && newSize.width() < 80)
+                newSize.setWidth(80);
+            if (!btn->icon.isNull() && btn->iconSize.height() > 16)
+                newSize -= QSize(0, 2);
+        }
+        break;
+    case CT_GroupBox:
+        if (option) {
+            int topMargin = qMax(pixelMetric(PM_ExclusiveIndicatorHeight), option->fontMetrics.height()) + groupBoxTopMargin;
+            newSize += QSize(10, topMargin); // Add some space below the groupbox
+        }
+        break;
+    case CT_RadioButton:
+    case CT_CheckBox:
+        newSize += QSize(0, 1);
+        break;
+    case CT_ToolButton:
+        newSize += QSize(2, 2);
+        break;
+    case CT_SpinBox:
+        newSize += QSize(0, -3);
+        break;
+    case CT_ComboBox:
+        newSize += QSize(2, 4);
+        break;
+    case CT_LineEdit:
+        newSize += QSize(0, 4);
+        break;
+    case CT_MenuBarItem:
+        newSize += QSize(8, 5);
+        break;
+    case CT_MenuItem:
+        if (const QStyleOptionMenuItem *menuItem = qstyleoption_cast<const QStyleOptionMenuItem *>(option)) {
+            int w = newSize.width();
+            int maxpmw = menuItem->maxIconWidth;
+            int tabSpacing = 20;
+            if (menuItem->text.contains(QLatin1Char('\t')))
+                w += tabSpacing;
+            else if (menuItem->menuItemType == QStyleOptionMenuItem::SubMenu)
+                w += 2 * QFusionStylePrivate::menuArrowHMargin;
+            else if (menuItem->menuItemType == QStyleOptionMenuItem::DefaultItem) {
+                QFontMetrics fm(menuItem->font);
+                QFont fontBold = menuItem->font;
+                fontBold.setBold(true);
+                QFontMetrics fmBold(fontBold);
+                w += fmBold.width(menuItem->text) - fm.width(menuItem->text);
+            }
+            int checkcol = qMax<int>(maxpmw, QFusionStylePrivate::menuCheckMarkWidth); // Windows always shows a check column
+            w += checkcol;
+            w += int(QFusionStylePrivate::menuRightBorder) + 10;
+            newSize.setWidth(w);
+            if (menuItem->menuItemType == QStyleOptionMenuItem::Separator) {
+                if (!menuItem->text.isEmpty()) {
+                    newSize.setHeight(menuItem->fontMetrics.height());
+                }
+            }
+            else if (!menuItem->icon.isNull()) {
+                if (const QComboBox *combo = qobject_cast<const QComboBox*>(widget)) {
+                    newSize.setHeight(qMax(combo->iconSize().height() + 2, newSize.height()));
+                }
+            }
+            newSize.setWidth(newSize.width() + 12);
+            newSize.setWidth(qMax(newSize.width(), 120));
+        }
+        break;
+    case CT_SizeGrip:
+        newSize += QSize(4, 4);
+        break;
+    case CT_MdiControls:
+        if (const QStyleOptionComplex *styleOpt = qstyleoption_cast<const QStyleOptionComplex *>(option)) {
+            int width = 0;
+            if (styleOpt->subControls & SC_MdiMinButton)
+                width += 19 + 1;
+            if (styleOpt->subControls & SC_MdiNormalButton)
+                width += 19 + 1;
+            if (styleOpt->subControls & SC_MdiCloseButton)
+                width += 19 + 1;
+            newSize = QSize(width, 19);
+        } else {
+            newSize = QSize(60, 19);
+        }
+        break;
+    default:
+        break;
+    }
+    return newSize;
+}
+
+/*!
+  \reimp
+*/
+void QFusionStyle::polish(QApplication *app)
+{
+    QCommonStyle::polish(app);
+}
+
+/*!
+  \reimp
+*/
+void QFusionStyle::polish(QWidget *widget)
+{
+    QCommonStyle::polish(widget);
+    if (qobject_cast<QAbstractButton*>(widget)
+            || qobject_cast<QComboBox *>(widget)
+            || qobject_cast<QProgressBar *>(widget)
+            || qobject_cast<QScrollBar *>(widget)
+            || qobject_cast<QSplitterHandle *>(widget)
+            || qobject_cast<QAbstractSlider *>(widget)
+            || qobject_cast<QAbstractSpinBox *>(widget)
+            || (widget->inherits("QDockSeparator"))
+            || (widget->inherits("QDockWidgetSeparator"))
+            ) {
+        widget->setAttribute(Qt::WA_Hover, true);
+        widget->setAttribute(Qt::WA_OpaquePaintEvent, false);
+    }
+}
+
+/*!
+  \reimp
+*/
+void QFusionStyle::polish(QPalette &pal)
+{
+    QCommonStyle::polish(pal);
+}
+
+/*!
+  \reimp
+*/
+void QFusionStyle::unpolish(QWidget *widget)
+{
+    QCommonStyle::unpolish(widget);
+    if (qobject_cast<QAbstractButton*>(widget)
+            || qobject_cast<QComboBox *>(widget)
+            || qobject_cast<QProgressBar *>(widget)
+            || qobject_cast<QScrollBar *>(widget)
+            || qobject_cast<QSplitterHandle *>(widget)
+            || qobject_cast<QAbstractSlider *>(widget)
+            || qobject_cast<QAbstractSpinBox *>(widget)
+            || (widget->inherits("QDockSeparator"))
+            || (widget->inherits("QDockWidgetSeparator"))
+            ) {
+        widget->setAttribute(Qt::WA_Hover, false);
+    }
+}
+
+/*!
+  \reimp
+*/
+void QFusionStyle::unpolish(QApplication *app)
+{
+    QCommonStyle::unpolish(app);
+}
+
+/*!
+  \reimp
+*/
+QRect QFusionStyle::subControlRect(ComplexControl control, const QStyleOptionComplex *option,
+                                   SubControl subControl, const QWidget *widget) const
+{
+    QRect rect = QCommonStyle::subControlRect(control, option, subControl, widget);
+
+    switch (control) {
+    case CC_Slider:
+        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+            int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
+            switch (subControl) {
+            case SC_SliderHandle: {
+                if (slider->orientation == Qt::Horizontal) {
+                    rect.setHeight(proxy()->pixelMetric(PM_SliderThickness));
+                    rect.setWidth(proxy()->pixelMetric(PM_SliderLength));
+                    int centerY = slider->rect.center().y() - rect.height() / 2;
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        centerY += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        centerY -= tickSize;
+                    rect.moveTop(centerY);
+                } else {
+                    rect.setWidth(proxy()->pixelMetric(PM_SliderThickness));
+                    rect.setHeight(proxy()->pixelMetric(PM_SliderLength));
+                    int centerX = slider->rect.center().x() - rect.width() / 2;
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        centerX += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        centerX -= tickSize;
+                    rect.moveLeft(centerX);
+                }
+            }
+                break;
+            case SC_SliderGroove: {
+                QPoint grooveCenter = slider->rect.center();
+                if (slider->orientation == Qt::Horizontal) {
+                    rect.setHeight(7);
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        grooveCenter.ry() += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        grooveCenter.ry() -= tickSize;
+                } else {
+                    rect.setWidth(7);
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        grooveCenter.rx() += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        grooveCenter.rx() -= tickSize;
+                }
+                rect.moveCenter(grooveCenter);
+                break;
+            }
+            default:
+                break;
+            }
+        }
+        break;
+    case CC_SpinBox:
+        if (const QStyleOptionSpinBox *spinbox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
+            QSize bs;
+            int center = spinbox->rect.height() / 2;
+            int fw = spinbox->frame ? proxy()->pixelMetric(PM_SpinBoxFrameWidth, spinbox, widget) : 0;
+            int y = fw;
+            bs.setHeight(qMax(8, spinbox->rect.height()/2 - y));
+            bs.setWidth(14);
+            int x, lx, rx;
+            x = spinbox->rect.width() - y - bs.width() + 2;
+            lx = fw;
+            rx = x - fw;
+            switch (subControl) {
+            case SC_SpinBoxUp:
+                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons)
+                    return QRect();
+                rect = QRect(x, fw, bs.width(), center - fw);
+                break;
+            case SC_SpinBoxDown:
+                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons)
+                    return QRect();
+
+                rect = QRect(x, center, bs.width(), spinbox->rect.bottom() - center - fw + 1);
+                break;
+            case SC_SpinBoxEditField:
+                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons) {
+                    rect = QRect(lx, fw, spinbox->rect.width() - 2*fw, spinbox->rect.height() - 2*fw);
+                } else {
+                    rect = QRect(lx, fw, rx - qMax(fw - 1, 0), spinbox->rect.height() - 2*fw);
+                }
+                break;
+            case SC_SpinBoxFrame:
+                rect = spinbox->rect;
+            default:
+                break;
+            }
+            rect = visualRect(spinbox->direction, spinbox->rect, rect);
+        }
+        break;
+
+    case CC_GroupBox:
+        if (const QStyleOptionGroupBox *groupBox = qstyleoption_cast<const QStyleOptionGroupBox *>(option)) {
+            rect = option->rect;
+            if (subControl == SC_GroupBoxFrame)
+                return rect.adjusted(0, 0, 0, 0);
+            else if (subControl == SC_GroupBoxContents) {
+                QRect frameRect = option->rect.adjusted(0, 0, 0, -groupBoxBottomMargin);
+                int margin = 3;
+                int leftMarginExtension = 0;
+                int topMargin = qMax(pixelMetric(PM_ExclusiveIndicatorHeight), option->fontMetrics.height()) + groupBoxTopMargin;
+                return frameRect.adjusted(leftMarginExtension + margin, margin + topMargin, -margin, -margin - groupBoxBottomMargin);
+            }
+
+            QSize textSize = option->fontMetrics.boundingRect(groupBox->text).size() + QSize(2, 2);
+            int indicatorWidth = proxy()->pixelMetric(PM_IndicatorWidth, option, widget);
+            int indicatorHeight = proxy()->pixelMetric(PM_IndicatorHeight, option, widget);
+            rect = QRect();
+            if (subControl == SC_GroupBoxCheckBox) {
+                rect.setWidth(indicatorWidth);
+                rect.setHeight(indicatorHeight);
+                rect.moveTop(textSize.height() > indicatorHeight ? (textSize.height() - indicatorHeight) / 2 : 0);
+                rect.moveLeft(1);
+            } else if (subControl == SC_GroupBoxLabel) {
+                rect.setSize(textSize);
+                rect.moveTop(1);
+                if (option->subControls & QStyle::SC_GroupBoxCheckBox)
+                    rect.translate(indicatorWidth + 5, 0);
+            }
+            return visualRect(option->direction, option->rect, rect);
+        }
+
+        return rect;
+
+    case CC_ComboBox:
+        switch (subControl) {
+        case SC_ComboBoxArrow:
+            rect = visualRect(option->direction, option->rect, rect);
+            rect.setRect(rect.right() - 18, rect.top() - 2,
+                         19, rect.height() + 4);
+            rect = visualRect(option->direction, option->rect, rect);
+            break;
+        case SC_ComboBoxEditField: {
+            int frameWidth = 2;
+            rect = visualRect(option->direction, option->rect, rect);
+            rect.setRect(option->rect.left() + frameWidth, option->rect.top() + frameWidth,
+                         option->rect.width() - 19 - 2 * frameWidth,
+                         option->rect.height() - 2 * frameWidth);
+            if (const QStyleOptionComboBox *box = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
+                if (!box->editable) {
+                    rect.adjust(2, 0, 0, 0);
+                    if (box->state & (State_Sunken | State_On))
+                        rect.translate(1, 1);
+                }
+            }
+            rect = visualRect(option->direction, option->rect, rect);
+            break;
+        }
+        default:
+            break;
+        }
+        break;
+    case CC_TitleBar:
+        if (const QStyleOptionTitleBar *tb = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {
+            SubControl sc = subControl;
+            QRect &ret = rect;
+            const int indent = 3;
+            const int controlTopMargin = 3;
+            const int controlBottomMargin = 3;
+            const int controlWidthMargin = 2;
+            const int controlHeight = tb->rect.height() - controlTopMargin - controlBottomMargin ;
+            const int delta = controlHeight + controlWidthMargin;
+            int offset = 0;
+
+            bool isMinimized = tb->titleBarState & Qt::WindowMinimized;
+            bool isMaximized = tb->titleBarState & Qt::WindowMaximized;
+
+            switch (sc) {
+            case SC_TitleBarLabel:
+                if (tb->titleBarFlags & (Qt::WindowTitleHint | Qt::WindowSystemMenuHint)) {
+                    ret = tb->rect;
+                    if (tb->titleBarFlags & Qt::WindowSystemMenuHint)
+                        ret.adjust(delta, 0, -delta, 0);
+                    if (tb->titleBarFlags & Qt::WindowMinimizeButtonHint)
+                        ret.adjust(0, 0, -delta, 0);
+                    if (tb->titleBarFlags & Qt::WindowMaximizeButtonHint)
+                        ret.adjust(0, 0, -delta, 0);
+                    if (tb->titleBarFlags & Qt::WindowShadeButtonHint)
+                        ret.adjust(0, 0, -delta, 0);
+                    if (tb->titleBarFlags & Qt::WindowContextHelpButtonHint)
+                        ret.adjust(0, 0, -delta, 0);
+                }
+                break;
+            case SC_TitleBarContextHelpButton:
+                if (tb->titleBarFlags & Qt::WindowContextHelpButtonHint)
+                    offset += delta;
+            case SC_TitleBarMinButton:
+                if (!isMinimized && (tb->titleBarFlags & Qt::WindowMinimizeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarMinButton)
+                    break;
+            case SC_TitleBarNormalButton:
+                if (isMinimized && (tb->titleBarFlags & Qt::WindowMinimizeButtonHint))
+                    offset += delta;
+                else if (isMaximized && (tb->titleBarFlags & Qt::WindowMaximizeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarNormalButton)
+                    break;
+            case SC_TitleBarMaxButton:
+                if (!isMaximized && (tb->titleBarFlags & Qt::WindowMaximizeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarMaxButton)
+                    break;
+            case SC_TitleBarShadeButton:
+                if (!isMinimized && (tb->titleBarFlags & Qt::WindowShadeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarShadeButton)
+                    break;
+            case SC_TitleBarUnshadeButton:
+                if (isMinimized && (tb->titleBarFlags & Qt::WindowShadeButtonHint))
+                    offset += delta;
+                else if (sc == SC_TitleBarUnshadeButton)
+                    break;
+            case SC_TitleBarCloseButton:
+                if (tb->titleBarFlags & Qt::WindowSystemMenuHint)
+                    offset += delta;
+                else if (sc == SC_TitleBarCloseButton)
+                    break;
+                ret.setRect(tb->rect.right() - indent - offset, tb->rect.top() + controlTopMargin,
+                            controlHeight, controlHeight);
+                break;
+            case SC_TitleBarSysMenu:
+                if (tb->titleBarFlags & Qt::WindowSystemMenuHint) {
+                    ret.setRect(tb->rect.left() + controlWidthMargin + indent, tb->rect.top() + controlTopMargin,
+                                controlHeight, controlHeight);
+                }
+                break;
+            default:
+                break;
+            }
+            ret = visualRect(tb->direction, tb->rect, ret);
+        }
+        break;
+    default:
+        break;
+    }
+
+    return rect;
+}
+
+
+/*!
+  \reimp
+*/
+QRect QFusionStyle::itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const
+{
+    return QCommonStyle::itemPixmapRect(r, flags, pixmap);
+}
+
+/*!
+  \reimp
+*/
+void QFusionStyle::drawItemPixmap(QPainter *painter, const QRect &rect,
+                                  int alignment, const QPixmap &pixmap) const
+{
+    QCommonStyle::drawItemPixmap(painter, rect, alignment, pixmap);
+}
+
+/*!
+  \reimp
+*/
+QStyle::SubControl QFusionStyle::hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
+                                                       const QPoint &pt, const QWidget *w) const
+{
+    return QCommonStyle::hitTestComplexControl(cc, opt, pt, w);
+}
+
+/*!
+  \reimp
+*/
+QPixmap QFusionStyle::generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
+                                          const QStyleOption *opt) const
+{
+    return QCommonStyle::generatedIconPixmap(iconMode, pixmap, opt);
+}
+
+/*!
+  \reimp
+*/
+int QFusionStyle::styleHint(StyleHint hint, const QStyleOption *option, const QWidget *widget,
+                            QStyleHintReturn *returnData) const
+{
+    switch (hint) {
+    case SH_Slider_SnapToValue:
+    case SH_PrintDialog_RightAlignButtons:
+    case SH_FontDialog_SelectAssociatedText:
+    case SH_MenuBar_AltKeyNavigation:
+    case SH_ComboBox_ListMouseTracking:
+    case SH_ScrollBar_StopMouseOverSlider:
+    case SH_ScrollBar_MiddleClickAbsolutePosition:
+    case SH_EtchDisabledText:
+    case SH_TitleBar_AutoRaise:
+    case SH_TitleBar_NoBorder:
+    case SH_ItemView_ShowDecorationSelected:
+    case SH_ItemView_ArrowKeysNavigateIntoChildren:
+    case SH_ItemView_ChangeHighlightOnFocus:
+    case SH_MenuBar_MouseTracking:
+    case SH_Menu_MouseTracking:
+    case SH_Menu_SupportsSections:
+        return 1;
+
+    case SH_ToolBox_SelectedPageTitleBold:
+    case SH_ScrollView_FrameOnlyAroundContents:
+    case SH_Menu_AllowActiveAndDisabled:
+    case SH_MainWindow_SpaceBelowMenuBar:
+    case SH_DialogButtonBox_ButtonsHaveIcons:
+    case SH_MessageBox_CenterButtons:
+    case SH_RubberBand_Mask:
+        return 0;
+
+    case SH_ComboBox_Popup:
+        if (const QStyleOptionComboBox *cmb = qstyleoption_cast<const QStyleOptionComboBox *>(option))
+            return !cmb->editable;
+        return 0;
+
+    case SH_Table_GridLineColor:
+        return option ? option->palette.background().color().darker(120).rgb() : 0;
+
+    case SH_MessageBox_TextInteractionFlags:
+        return Qt::TextSelectableByMouse | Qt::LinksAccessibleByMouse;
+#ifndef QT_NO_WIZARD
+    case SH_WizardStyle:
+        return QWizard::ClassicStyle;
+#endif
+    case SH_Menu_SubMenuPopupDelay:
+        return 225; // default from GtkMenu
+
+    case SH_WindowFrame_Mask:
+        if (QStyleHintReturnMask *mask = qstyleoption_cast<QStyleHintReturnMask *>(returnData)) {
+            //left rounded corner
+            mask->region = option->rect;
+            mask->region -= QRect(option->rect.left(), option->rect.top(), 5, 1);
+            mask->region -= QRect(option->rect.left(), option->rect.top() + 1, 3, 1);
+            mask->region -= QRect(option->rect.left(), option->rect.top() + 2, 2, 1);
+            mask->region -= QRect(option->rect.left(), option->rect.top() + 3, 1, 2);
+
+            //right rounded corner
+            mask->region -= QRect(option->rect.right() - 4, option->rect.top(), 5, 1);
+            mask->region -= QRect(option->rect.right() - 2, option->rect.top() + 1, 3, 1);
+            mask->region -= QRect(option->rect.right() - 1, option->rect.top() + 2, 2, 1);
+            mask->region -= QRect(option->rect.right() , option->rect.top() + 3, 1, 2);
+            return 1;
+        }
+    default:
+        break;
+    }
+    return QCommonStyle::styleHint(hint, option, widget, returnData);
+}
+
+/*! \reimp */
+QRect QFusionStyle::subElementRect(SubElement sr, const QStyleOption *opt, const QWidget *w) const
+{
+    QRect r = QCommonStyle::subElementRect(sr, opt, w);
+    switch (sr) {
+    case SE_ProgressBarLabel:
+    case SE_ProgressBarContents:
+    case SE_ProgressBarGroove:
+        return opt->rect;
+    case SE_PushButtonFocusRect:
+        r.adjust(0, 1, 0, -1);
+        break;
+    case SE_DockWidgetTitleBarText: {
+        if (const QStyleOptionDockWidget *titlebar = qstyleoption_cast<const QStyleOptionDockWidget*>(opt)) {
+            bool verticalTitleBar = titlebar->verticalTitleBar;
+            if (verticalTitleBar) {
+                r.adjust(0, 0, 0, -4);
+            } else {
+                if (opt->direction == Qt::LeftToRight)
+                    r.adjust(4, 0, 0, 0);
+                else
+                    r.adjust(0, 0, -4, 0);
+            }
+        }
+
+        break;
+    }
+    default:
+        break;
+    }
+    return r;
+}
+
+/*!
+    \reimp
+*/
+QIcon QFusionStyle::standardIcon(StandardPixmap standardIcon, const QStyleOption *option,
+                                 const QWidget *widget) const
+{
+    return QCommonStyle::standardIcon(standardIcon, option, widget);
+}
+
+/*!
+ \reimp
+ */
+QPixmap QFusionStyle::standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
+                                     const QWidget *widget) const
+{
+#ifndef QT_NO_IMAGEFORMAT_XPM
+    switch (standardPixmap) {
+    case SP_TitleBarNormalButton:
+        return QPixmap((const char **)dock_widget_restore_xpm);
+    case SP_TitleBarMinButton:
+        return QPixmap((const char **)workspace_minimize);
+    case SP_TitleBarCloseButton:
+    case SP_DockWidgetCloseButton:
+        return QPixmap((const char **)dock_widget_close_xpm);
+
+    default:
+        break;
+    }
+#endif //QT_NO_IMAGEFORMAT_XPM
+
+    return QCommonStyle::standardPixmap(standardPixmap, opt, widget);
+}
+
+QT_END_NAMESPACE
+
+#endif // QT_NO_STYLE_FUSION || QT_PLUGIN
diff --git a/.pc/inendi.patch/src/widgets/styles/qgtkstyle.cpp b/.pc/inendi.patch/src/widgets/styles/qgtkstyle.cpp
new file mode 100644
index 0000000..9fa0569
--- /dev/null
+++ b/.pc/inendi.patch/src/widgets/styles/qgtkstyle.cpp
@@ -0,0 +1,4253 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtWidgets module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include "qgtkstyle_p.h"
+
+#if !defined(QT_NO_STYLE_GTK)
+
+#include <private/qapplication_p.h>
+#include <QtCore/QLibrary>
+#include <QtCore/QSettings>
+#include <QtWidgets/QDialogButtonBox>
+#include <QtWidgets/QStatusBar>
+#include <QtWidgets/QLineEdit>
+#include <QtWidgets/QWidget>
+#include <QtWidgets/QListView>
+#include <QtWidgets/QApplication>
+#include <QtWidgets/QStyleOption>
+#include <QtWidgets/QPushButton>
+#include <QtGui/QPainter>
+#include <QtWidgets/QMainWindow>
+#include <QtWidgets/QToolBar>
+#include <QtWidgets/QHeaderView>
+#include <QtWidgets/QMenuBar>
+#include <QtWidgets/QComboBox>
+#include <QtWidgets/QSpinBox>
+#include <QtWidgets/QScrollBar>
+#include <QtWidgets/QAbstractButton>
+#include <QtWidgets/QToolButton>
+#include <QtWidgets/QGroupBox>
+#include <QtWidgets/QRadioButton>
+#include <QtWidgets/QCheckBox>
+#include <QtWidgets/QTreeView>
+#include <QtWidgets/QStyledItemDelegate>
+#include <QtWidgets/QWizard>
+
+#include <qpixmapcache.h>
+#include <private/qstyleanimation_p.h>
+#undef signals // Collides with GTK stymbols
+#include <private/qgtkpainter_p.h>
+#include <private/qstylehelper_p.h>
+#include <private/qgtkstyle_p_p.h>
+
+QT_BEGIN_NAMESPACE
+
+static GtkStateType qt_gtk_state(const QStyleOption *option)
+{
+    GtkStateType state = GTK_STATE_NORMAL;
+    if (!(option->state & QStyle::State_Enabled))
+        state = GTK_STATE_INSENSITIVE;
+    else if (option->state & QStyle::State_MouseOver)
+        state = GTK_STATE_PRELIGHT;
+
+    return state;
+}
+
+static QPixmap qt_gtk_get_icon(const char* iconName, GtkIconSize size = GTK_ICON_SIZE_BUTTON)
+{
+    GtkStyle *style = QGtkStylePrivate::gtkStyle();
+    GtkIconSet* iconSet  = QGtkStylePrivate::gtk_icon_factory_lookup_default (iconName);
+    GdkPixbuf* icon = QGtkStylePrivate::gtk_icon_set_render_icon(iconSet,
+                                                 style,
+                                                 GTK_TEXT_DIR_LTR,
+                                                 GTK_STATE_NORMAL,
+                                                 size,
+                                                 NULL,
+                                                 "button");
+    uchar* data = (uchar*)QGtkStylePrivate::gdk_pixbuf_get_pixels(icon);
+    int width = QGtkStylePrivate::gdk_pixbuf_get_width(icon);
+    int height = QGtkStylePrivate::gdk_pixbuf_get_height(icon);
+    QImage converted(width, height, QImage::Format_ARGB32);
+    uchar* tdata = (uchar*)converted.bits();
+
+    for ( int index = 0 ; index < height * width*4 ; index +=4 ) {
+        //int index = y * rowstride + x;
+        tdata[index + QT_RED] = data[index + GTK_RED];
+        tdata[index + QT_GREEN] = data[index + GTK_GREEN];
+        tdata[index + QT_BLUE] = data[index + GTK_BLUE];
+        tdata[index + QT_ALPHA] = data[index + GTK_ALPHA];
+    }
+
+    QGtkStylePrivate::gdk_pixbuf_unref(icon);
+
+    // should we free iconset?
+    return QPixmap::fromImage(converted);
+}
+
+static void qt_gtk_draw_mdibutton(QPainter *painter, const QStyleOptionTitleBar *option, const QRect &tmp, bool hover, bool sunken)
+{
+    QColor dark;
+    dark.setHsv(option->palette.button().color().hue(),
+                qMin(255, (int)(option->palette.button().color().saturation()*1.9)),
+                qMin(255, (int)(option->palette.button().color().value()*0.7)));
+
+    QColor highlight = option->palette.highlight().color();
+
+    bool active = (option->titleBarState & QStyle::State_Active);
+    QColor titleBarHighlight(255, 255, 255, 60);
+
+    if (sunken)
+        painter->fillRect(tmp.adjusted(1, 1, -1, -1), option->palette.highlight().color().darker(120));
+    else if (hover)
+        painter->fillRect(tmp.adjusted(1, 1, -1, -1), QColor(255, 255, 255, 20));
+
+    QColor mdiButtonGradientStartColor;
+    QColor mdiButtonGradientStopColor;
+
+    mdiButtonGradientStartColor = QColor(0, 0, 0, 40);
+    mdiButtonGradientStopColor = QColor(255, 255, 255, 60);
+
+    if (sunken)
+        titleBarHighlight = highlight.darker(130);
+
+    QLinearGradient gradient(tmp.center().x(), tmp.top(), tmp.center().x(), tmp.bottom());
+    gradient.setColorAt(0, mdiButtonGradientStartColor);
+    gradient.setColorAt(1, mdiButtonGradientStopColor);
+    QColor mdiButtonBorderColor(active ? option->palette.highlight().color().darker(180): dark.darker(110));
+
+    painter->setPen(QPen(mdiButtonBorderColor, 1));
+    const QLine lines[4] = {
+        QLine(tmp.left() + 2, tmp.top(), tmp.right() - 2, tmp.top()),
+        QLine(tmp.left() + 2, tmp.bottom(), tmp.right() - 2, tmp.bottom()),
+        QLine(tmp.left(), tmp.top() + 2, tmp.left(), tmp.bottom() - 2),
+        QLine(tmp.right(), tmp.top() + 2, tmp.right(), tmp.bottom() - 2)
+    };
+    painter->drawLines(lines, 4);
+    const QPoint points[4] = {
+        QPoint(tmp.left() + 1, tmp.top() + 1),
+        QPoint(tmp.right() - 1, tmp.top() + 1),
+        QPoint(tmp.left() + 1, tmp.bottom() - 1),
+        QPoint(tmp.right() - 1, tmp.bottom() - 1)
+    };
+    painter->drawPoints(points, 4);
+
+    painter->setPen(titleBarHighlight);
+    painter->drawLine(tmp.left() + 2, tmp.top() + 1, tmp.right() - 2, tmp.top() + 1);
+    painter->drawLine(tmp.left() + 1, tmp.top() + 2, tmp.left() + 1, tmp.bottom() - 2);
+
+    painter->setPen(QPen(gradient, 1));
+    painter->drawLine(tmp.right() + 1, tmp.top() + 2, tmp.right() + 1, tmp.bottom() - 2);
+    painter->drawPoint(tmp.right() , tmp.top() + 1);
+
+    painter->drawLine(tmp.left() + 2, tmp.bottom() + 1, tmp.right() - 2, tmp.bottom() + 1);
+    painter->drawPoint(tmp.left() + 1, tmp.bottom());
+    painter->drawPoint(tmp.right() - 1, tmp.bottom());
+    painter->drawPoint(tmp.right() , tmp.bottom() - 1);
+}
+
+static const char * const dock_widget_close_xpm[] =
+    {
+        "11 13 5 1",
+        "  c None",
+        ". c #D5CFCB",
+        "+ c #6C6A67",
+        "@ c #6C6A67",
+        "$ c #B5B0AC",
+        "           ",
+        " @@@@@@@@@ ",
+        "@+       +@",
+        "@ +@   @+ @",
+        "@ @@@ @@@ @",
+        "@  @@@@@  @",
+        "@   @@@   @",
+        "@  @@@@@  @",
+        "@ @@@ @@@ @",
+        "@ +@   @+ @",
+        "@+       +@",
+        " @@@@@@@@@ ",
+        "           "
+    };
+
+static const char * const dock_widget_restore_xpm[] =
+    {
+        "11 13 5 1",
+        "  c None",
+        ". c #D5CFCB",
+        "+ c #6C6A67",
+        "@ c #6C6A67",
+        "# c #6C6A67",
+        "           ",
+        " @@@@@@@@@ ",
+        "@+       +@",
+        "@   #@@@# @",
+        "@   @   @ @",
+        "@ #@@@# @ @",
+        "@ @   @ @ @",
+        "@ @   @@@ @",
+        "@ @   @   @",
+        "@ #@@@@   @",
+        "@+       +@",
+        " @@@@@@@@@ ",
+        "           "
+    };
+
+static const char * const qt_titlebar_context_help[] = {
+    "10 10 3 1",
+    "  c None",
+    "# c #000000",
+    "+ c #444444",
+    "  +####+  ",
+    " ###  ### ",
+    " ##    ## ",
+    "     +##+ ",
+    "    +##   ",
+    "    ##    ",
+    "    ##    ",
+    "          ",
+    "    ##    ",
+    "    ##    "};
+
+static const char * const qt_scrollbar_button_arrow_up[] = {
+    "7 4 2 1",
+    "   c None",
+    "*  c #BFBFBF",
+    "   *   ",
+    "  ***  ",
+    " ***** ",
+    "*******"};
+
+static const char * const qt_scrollbar_button_arrow_down[] = {
+    "7 4 2 1",
+    "   c None",
+    "*  c #BFBFBF",
+    "*******",
+    " ***** ",
+    "  ***  ",
+    "   *   "};
+
+static const int groupBoxBottomMargin    =  2;  // space below the groupbox
+static const int groupBoxTitleMargin     =  6;  // space between contents and title
+static const int groupBoxTopMargin       =  2;
+
+/*!
+  Returns the configuration string for \a value.
+  Returns \a fallback if \a value is not found.
+ */
+QString QGtkStyle::getGConfString(const QString &value, const QString &fallback)
+{
+    return QGtkStylePrivate::getGConfString(value, fallback);
+}
+
+/*!
+  Returns the configuration boolean for \a key.
+  Returns \a fallback if \a key is not found.
+ */
+bool QGtkStyle::getGConfBool(const QString &key, bool fallback)
+{
+    return QGtkStylePrivate::getGConfBool(key, fallback);
+}
+
+static QColor mergedColors(const QColor &colorA, const QColor &colorB, int factor = 50)
+{
+    const int maxFactor = 100;
+    QColor tmp = colorA;
+    tmp.setRed((tmp.red() * factor) / maxFactor + (colorB.red() * (maxFactor - factor)) / maxFactor);
+    tmp.setGreen((tmp.green() * factor) / maxFactor + (colorB.green() * (maxFactor - factor)) / maxFactor);
+    tmp.setBlue((tmp.blue() * factor) / maxFactor + (colorB.blue() * (maxFactor - factor)) / maxFactor);
+    return tmp;
+}
+
+static GdkColor fromQColor(const QColor &color)
+{
+    GdkColor retval;
+    retval.red = color.red() * 255;
+    retval.green = color.green() * 255;
+    retval.blue = color.blue() * 255;
+    return retval;
+}
+
+/*!
+    \class QGtkStyle
+    \brief The QGtkStyle class provides a widget style rendered by GTK+
+    \since 4.5
+
+    \internal
+    \inmodule QtWidgets
+
+    The QGtkStyle style provides a look and feel that integrates well
+    into GTK-based desktop environments such as the XFCe and GNOME.
+
+    It does this by making use of the GTK+ theme engine, ensuring
+    that Qt applications look and feel native on these platforms.
+
+    Note: The style requires GTK+ version 2.18 or later.
+          The Qt3-based "Qt" GTK+ theme engine will not work with QGtkStyle.
+
+    \sa QWindowsXPStyle, QMacStyle, QWindowsStyle, QFusionStyle
+*/
+
+/*!
+    Constructs a QGtkStyle object.
+*/
+QGtkStyle::QGtkStyle()
+    : QCommonStyle(*new QGtkStylePrivate)
+{
+    Q_D(QGtkStyle);
+    d->init();
+}
+
+/*!
+    \internal
+
+    Constructs a QGtkStyle object.
+*/
+QGtkStyle::QGtkStyle(QGtkStylePrivate &dd)
+     : QCommonStyle(dd)
+{
+    Q_D(QGtkStyle);
+    d->init();
+}
+
+
+/*!
+    Destroys the QGtkStyle object.
+*/
+QGtkStyle::~QGtkStyle()
+{
+}
+
+/*!
+    \reimp
+*/
+QPalette QGtkStyle::standardPalette() const
+{
+    Q_D(const QGtkStyle);
+
+    QPalette palette = QCommonStyle::standardPalette();
+    if (d->isThemeAvailable()) {
+        GtkStyle *style = d->gtkStyle();
+        GtkWidget *gtkButton = d->gtkWidget("GtkButton");
+        GtkWidget *gtkEntry = d->getTextColorWidget();
+        GdkColor gdkBg, gdkBase, gdkText, gdkForeground, gdkSbg, gdkSfg, gdkaSbg, gdkaSfg;
+        QColor bg, base, text, fg, highlight, highlightText, inactiveHighlight, inactiveHighlightedTExt;
+        gdkBg = style->bg[GTK_STATE_NORMAL];
+        gdkForeground = d->gtk_widget_get_style(gtkButton)->fg[GTK_STATE_NORMAL];
+
+        // Our base and selected color is primarily used for text
+        // so we assume a gtkEntry will have the most correct value
+        GtkStyle *gtkEntryStyle = d->gtk_widget_get_style(gtkEntry);
+        gdkBase = gtkEntryStyle->base[GTK_STATE_NORMAL];
+        gdkText = gtkEntryStyle->text[GTK_STATE_NORMAL];
+        gdkSbg = gtkEntryStyle->base[GTK_STATE_SELECTED];
+        gdkSfg = gtkEntryStyle->text[GTK_STATE_SELECTED];
+
+        // The ACTIVE base color is really used for inactive windows
+        gdkaSbg = gtkEntryStyle->base[GTK_STATE_ACTIVE];
+        gdkaSfg = gtkEntryStyle->text[GTK_STATE_ACTIVE];
+
+        bg = QColor(gdkBg.red>>8, gdkBg.green>>8, gdkBg.blue>>8);
+        text = QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
+        fg = QColor(gdkForeground.red>>8, gdkForeground.green>>8, gdkForeground.blue>>8);
+        base = QColor(gdkBase.red>>8, gdkBase.green>>8, gdkBase.blue>>8);
+        highlight = QColor(gdkSbg.red>>8, gdkSbg.green>>8, gdkSbg.blue>>8);
+        highlightText = QColor(gdkSfg.red>>8, gdkSfg.green>>8, gdkSfg.blue>>8);
+        inactiveHighlight = QColor(gdkaSbg.red>>8, gdkaSbg.green>>8, gdkaSbg.blue>>8);
+        inactiveHighlightedTExt = QColor(gdkaSfg.red>>8, gdkaSfg.green>>8, gdkaSfg.blue>>8);
+
+        palette.setColor(QPalette::HighlightedText, highlightText);
+
+
+        palette.setColor(QPalette::Light, bg.lighter(125));
+        palette.setColor(QPalette::Shadow, bg.darker(130));
+        palette.setColor(QPalette::Dark, bg.darker(120));
+        palette.setColor(QPalette::Text, text);
+        palette.setColor(QPalette::WindowText, fg);
+        palette.setColor(QPalette::ButtonText, fg);
+        palette.setColor(QPalette::Base, base);
+
+        QColor alternateRowColor = palette.base().color().lighter(93); // ref gtkstyle.c draw_flat_box
+        GtkWidget *gtkTreeView = d->gtkWidget("GtkTreeView");
+        GdkColor *gtkAltBase = NULL;
+        d->gtk_widget_style_get(gtkTreeView, "odd-row-color", &gtkAltBase, NULL);
+        if (gtkAltBase) {
+            alternateRowColor = QColor(gtkAltBase->red>>8, gtkAltBase->green>>8, gtkAltBase->blue>>8);
+            d->gdk_color_free(gtkAltBase);
+        }
+        palette.setColor(QPalette::AlternateBase, alternateRowColor);
+
+        palette.setColor(QPalette::Window, bg);
+        palette.setColor(QPalette::Button, bg);
+        palette.setColor(QPalette::Background, bg);
+        QColor disabled((fg.red()   + bg.red())  / 2,
+                        (fg.green() + bg.green())/ 2,
+                        (fg.blue()  + bg.blue()) / 2);
+        palette.setColor(QPalette::Disabled, QPalette::Text, disabled);
+        palette.setColor(QPalette::Disabled, QPalette::WindowText, disabled);
+        palette.setColor(QPalette::Disabled, QPalette::Foreground, disabled);
+        palette.setColor(QPalette::Disabled, QPalette::ButtonText, disabled);
+        palette.setColor(QPalette::Highlight, highlight);
+        // calculate disabled colors by removing saturation
+        highlight.setHsv(highlight.hue(), 0, highlight.value(), highlight.alpha());
+        highlightText.setHsv(highlightText.hue(), 0, highlightText.value(), highlightText.alpha());
+        palette.setColor(QPalette::Disabled, QPalette::Highlight, highlight);
+        palette.setColor(QPalette::Disabled, QPalette::HighlightedText, highlightText);
+
+        palette.setColor(QPalette::Inactive, QPalette::HighlightedText, inactiveHighlightedTExt);
+        palette.setColor(QPalette::Inactive, QPalette::Highlight, inactiveHighlight);
+
+        style = d->gtk_rc_get_style_by_paths(d->gtk_settings_get_default(), "gtk-tooltips", "GtkWindow",
+                d->gtk_window_get_type());
+        if (style) {
+            gdkText = style->fg[GTK_STATE_NORMAL];
+            text = QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
+            palette.setColor(QPalette::ToolTipText, text);
+        }
+    }
+    return palette;
+}
+
+/*!
+    \reimp
+*/
+void QGtkStyle::polish(QPalette &palette)
+{
+    Q_D(QGtkStyle);
+
+    if (!d->isThemeAvailable())
+        QCommonStyle::polish(palette);
+    else
+        palette = palette.resolve(standardPalette());
+}
+
+/*!
+    \reimp
+*/
+void QGtkStyle::polish(QApplication *app)
+{
+    Q_D(QGtkStyle);
+
+    QCommonStyle::polish(app);
+    // Custom fonts and palettes with QtConfig are intentionally
+    // not supported as these should be entirely determined by
+    // current Gtk settings
+    if (app->desktopSettingsAware() && d->isThemeAvailable()) {
+        QApplicationPrivate::setSystemPalette(standardPalette());
+        QApplicationPrivate::setSystemFont(d->getThemeFont());
+        d->applyCustomPaletteHash();
+        if (!d->isKDE4Session())
+            qApp->installEventFilter(&d->filter);
+    }
+}
+
+/*!
+    \reimp
+*/
+void QGtkStyle::unpolish(QApplication *app)
+{
+    Q_D(QGtkStyle);
+
+    QCommonStyle::unpolish(app);
+    QPixmapCache::clear();
+
+    if (app->desktopSettingsAware() && d->isThemeAvailable() && !d->isKDE4Session())
+        qApp->removeEventFilter(&d->filter);
+}
+
+/*!
+    \reimp
+*/
+
+void QGtkStyle::polish(QWidget *widget)
+{
+    Q_D(QGtkStyle);
+
+    QCommonStyle::polish(widget);
+    if (!d->isThemeAvailable())
+        return;
+    if (qobject_cast<QAbstractButton*>(widget)
+            || qobject_cast<QToolButton*>(widget)
+            || qobject_cast<QComboBox*>(widget)
+            || qobject_cast<QGroupBox*>(widget)
+            || qobject_cast<QScrollBar*>(widget)
+            || qobject_cast<QSlider*>(widget)
+            || qobject_cast<QAbstractSpinBox*>(widget)
+            || qobject_cast<QSpinBox*>(widget)
+            || qobject_cast<QHeaderView*>(widget))
+        widget->setAttribute(Qt::WA_Hover);
+#ifndef QT_NO_TREEVIEW
+    else if (QTreeView *tree = qobject_cast<QTreeView *> (widget))
+        tree->viewport()->setAttribute(Qt::WA_Hover);
+#endif
+}
+
+/*!
+    \reimp
+*/
+void QGtkStyle::unpolish(QWidget *widget)
+{
+    QCommonStyle::unpolish(widget);
+}
+
+/*!
+    \reimp
+*/
+int QGtkStyle::pixelMetric(PixelMetric metric,
+                           const QStyleOption *option,
+                           const QWidget *widget) const
+{
+    Q_D(const QGtkStyle);
+
+    if (!d->isThemeAvailable())
+        return QCommonStyle::pixelMetric(metric, option, widget);
+
+    switch (metric) {
+    case PM_DefaultFrameWidth:
+        if (qobject_cast<const QFrame*>(widget)) {
+            if (GtkStyle *style =
+                d->gtk_rc_get_style_by_paths(d->gtk_settings_get_default(),
+                                                "*.GtkScrolledWindow",
+                                                "*.GtkScrolledWindow",
+                                                d->gtk_window_get_type()))
+                return qMax(style->xthickness, style->ythickness);
+        }
+        return 2;
+
+    case PM_MenuButtonIndicator:
+        return 20;
+
+    case PM_TabBarBaseOverlap:
+        return 1;
+
+    case PM_ToolBarSeparatorExtent:
+        return 11;
+
+    case PM_ToolBarFrameWidth:
+        return 1;
+
+    case PM_ToolBarItemSpacing:
+        return 0;
+
+    case PM_ButtonShiftHorizontal: {
+        GtkWidget *gtkButton = d->gtkWidget("GtkButton");
+        guint horizontal_shift;
+        d->gtk_widget_style_get(gtkButton, "child-displacement-x", &horizontal_shift, NULL);
+        return horizontal_shift;
+    }
+
+    case PM_ButtonShiftVertical: {
+        GtkWidget *gtkButton = d->gtkWidget("GtkButton");
+        guint vertical_shift;
+        d->gtk_widget_style_get(gtkButton, "child-displacement-y", &vertical_shift, NULL);
+        return vertical_shift;
+    }
+
+    case PM_MenuBarPanelWidth:
+        return 0;
+
+    case PM_MenuPanelWidth: {
+        GtkWidget *gtkMenu = d->gtkWidget("GtkMenu");
+        guint horizontal_padding = 0;
+        // horizontal-padding is used by Maemo to get thicker borders
+        if (!d->gtk_check_version(2, 10, 0))
+            d->gtk_widget_style_get(gtkMenu, "horizontal-padding", &horizontal_padding, NULL);
+        int padding = qMax<int>(d->gtk_widget_get_style(gtkMenu)->xthickness, horizontal_padding);
+        return padding;
+    }
+
+    case PM_ButtonIconSize: {
+        int retVal = 24;
+        GtkSettings *settings = d->gtk_settings_get_default();
+        gchararray icon_sizes;
+        g_object_get(settings, "gtk-icon-sizes", &icon_sizes, NULL);
+        QStringList values = QString(QLS(icon_sizes)).split(QLatin1Char(':'));
+        g_free(icon_sizes);
+        QChar splitChar(QLatin1Char(','));
+        foreach (const QString &value, values) {
+            if (value.startsWith(QLS("gtk-button="))) {
+                QString iconSize = value.right(value.size() - 11);
+
+                if (iconSize.contains(splitChar))
+                    retVal = iconSize.split(splitChar)[0].toInt();
+                break;
+            }
+        }
+        return retVal;
+    }
+
+    case PM_MenuVMargin:
+
+    case PM_MenuHMargin:
+        return 0;
+
+    case PM_DockWidgetTitleMargin:
+        return 0;
+
+    case PM_DockWidgetTitleBarButtonMargin:
+        return 5;
+
+    case PM_TabBarTabVSpace:
+        return 12;
+
+    case PM_TabBarTabHSpace:
+        return 14;
+
+    case PM_TabBarTabShiftVertical:
+        return 2;
+
+    case PM_ToolBarHandleExtent:
+        return 9;
+
+    case PM_SplitterWidth:
+        return 6;
+
+    case PM_SliderThickness:
+    case PM_SliderControlThickness: {
+        GtkWidget *gtkScale = d->gtkWidget("GtkHScale");
+        gint val;
+        d->gtk_widget_style_get(gtkScale, "slider-width", &val, NULL);
+        if (metric == PM_SliderControlThickness)
+            return val + 2*d->gtk_widget_get_style(gtkScale)->ythickness;
+        return val;
+    }
+
+    case PM_ScrollBarExtent: {
+        gint sliderLength;
+        gint trough_border;
+        GtkWidget *hScrollbar = d->gtkWidget("GtkHScrollbar");
+        d->gtk_widget_style_get(hScrollbar,
+                               "trough-border",   &trough_border,
+                               "slider-width",    &sliderLength,
+                               NULL);
+        return sliderLength + trough_border*2;
+    }
+
+    case PM_ScrollBarSliderMin:
+        return 34;
+
+    case PM_SliderLength:
+        gint val;
+        d->gtk_widget_style_get(d->gtkWidget("GtkHScale"), "slider-length", &val, NULL);
+        return val;
+
+    case PM_ExclusiveIndicatorWidth:
+    case PM_ExclusiveIndicatorHeight:
+    case PM_IndicatorWidth:
+    case PM_IndicatorHeight: {
+        GtkWidget *gtkCheckButton = d->gtkWidget("GtkCheckButton");
+        gint size, spacing;
+        d->gtk_widget_style_get(gtkCheckButton, "indicator-spacing", &spacing, "indicator-size", &size, NULL);
+        return size + 2 * spacing;
+    }
+
+    case PM_MenuBarVMargin: {
+        GtkWidget *gtkMenubar = d->gtkWidget("GtkMenuBar");
+        return  qMax(0, d->gtk_widget_get_style(gtkMenubar)->ythickness);
+    }
+    case PM_ScrollView_ScrollBarSpacing:
+    {
+        gint spacing = 3;
+        GtkWidget *gtkScrollWindow = d->gtkWidget("GtkScrolledWindow");
+        Q_ASSERT(gtkScrollWindow);
+        d->gtk_widget_style_get(gtkScrollWindow, "scrollbar-spacing", &spacing, NULL);
+        return spacing;
+    }
+    case PM_SubMenuOverlap: {
+        gint offset = 0;
+        GtkWidget *gtkMenu = d->gtkWidget("GtkMenu");
+        d->gtk_widget_style_get(gtkMenu, "horizontal-offset", &offset, NULL);
+        return offset;
+    }
+    case PM_ToolTipLabelFrameWidth:
+        return 2;
+    case PM_ButtonDefaultIndicator:
+        return 0;
+    case PM_ListViewIconSize:
+        return 24;
+    case PM_DialogButtonsSeparator:
+        return 6;
+    case PM_TitleBarHeight:
+        return 24;
+    case PM_SpinBoxFrameWidth:
+        return 3;
+    case PM_MenuBarItemSpacing:
+        return 6;
+    case PM_MenuBarHMargin:
+        return 0;
+    case PM_ToolBarItemMargin:
+        return 1;
+    case PM_SmallIconSize:
+        return 16;
+    case PM_MaximumDragDistance:
+        return -1;
+    case PM_TabCloseIndicatorWidth:
+    case PM_TabCloseIndicatorHeight:
+        return 20;
+    default:
+        return QCommonStyle::pixelMetric(metric, option, widget);
+    }
+}
+
+/*!
+    \reimp
+*/
+int QGtkStyle::styleHint(StyleHint hint, const QStyleOption *option, const QWidget *widget,
+
+                         QStyleHintReturn *returnData = 0) const
+{
+    Q_D(const QGtkStyle);
+
+    if (!d->isThemeAvailable())
+        return QCommonStyle::styleHint(hint, option, widget, returnData);
+
+    switch (hint) {
+    case SH_ItemView_ChangeHighlightOnFocus:
+        return true;
+    case SH_ScrollBar_MiddleClickAbsolutePosition:
+        return true;
+    case SH_Menu_AllowActiveAndDisabled:
+        return false;
+    case SH_MainWindow_SpaceBelowMenuBar:
+        return false;
+    case SH_MenuBar_MouseTracking:
+        return true;
+    case SH_Menu_MouseTracking:
+        return true;
+    case SH_TitleBar_AutoRaise:
+        return true;
+    case SH_TitleBar_NoBorder:
+        return true;
+    case SH_ItemView_ShowDecorationSelected:
+        return true;
+    case SH_Table_GridLineColor:
+        if (option)
+            return option->palette.background().color().darker(120).rgb();
+        break;
+    case SH_WindowFrame_Mask:
+        if (QStyleHintReturnMask *mask = qstyleoption_cast<QStyleHintReturnMask *>(returnData)) {
+            //left rounded corner
+            mask->region = option->rect;
+            mask->region -= QRect(option->rect.left(), option->rect.top(), 5, 1);
+            mask->region -= QRect(option->rect.left(), option->rect.top() + 1, 3, 1);
+            mask->region -= QRect(option->rect.left(), option->rect.top() + 2, 2, 1);
+            mask->region -= QRect(option->rect.left(), option->rect.top() + 3, 1, 2);
+
+            //right rounded corner
+            mask->region -= QRect(option->rect.right() - 4, option->rect.top(), 5, 1);
+            mask->region -= QRect(option->rect.right() - 2, option->rect.top() + 1, 3, 1);
+            mask->region -= QRect(option->rect.right() - 1, option->rect.top() + 2, 2, 1);
+            mask->region -= QRect(option->rect.right() , option->rect.top() + 3, 1, 2);
+        }
+        return QCommonStyle::styleHint(hint, option, widget, returnData);
+    case SH_MessageBox_TextInteractionFlags:
+        return Qt::TextSelectableByMouse | Qt::LinksAccessibleByMouse;
+    case SH_MessageBox_CenterButtons:
+        return false;
+#ifndef QT_NO_WIZARD
+    case SH_WizardStyle:
+        return  QWizard::ClassicStyle;
+#endif
+    case SH_ItemView_ArrowKeysNavigateIntoChildren:
+        return false;
+    case SH_DialogButtonLayout: {
+        int ret = QDialogButtonBox::GnomeLayout;
+        gboolean alternateOrder = 0;
+        GtkSettings *settings = d->gtk_settings_get_default();
+        g_object_get(settings, "gtk-alternative-button-order", &alternateOrder, NULL);
+
+        if (alternateOrder)
+            ret = QDialogButtonBox::WinLayout;
+
+        return ret;
+    }
+    break;
+
+    case SH_ToolButtonStyle:
+    {
+        if (d->isKDE4Session())
+            return QCommonStyle::styleHint(hint, option, widget, returnData);
+        GtkWidget *gtkToolbar = d->gtkWidget("GtkToolbar");
+        GtkToolbarStyle toolbar_style = GTK_TOOLBAR_ICONS;
+        g_object_get(gtkToolbar, "toolbar-style", &toolbar_style, NULL);
+        switch (toolbar_style) {
+        case GTK_TOOLBAR_TEXT:
+            return Qt::ToolButtonTextOnly;
+        case GTK_TOOLBAR_BOTH:
+            return Qt::ToolButtonTextUnderIcon;
+        case GTK_TOOLBAR_BOTH_HORIZ:
+            return Qt::ToolButtonTextBesideIcon;
+        case GTK_TOOLBAR_ICONS:
+        default:
+            return Qt::ToolButtonIconOnly;
+        }
+    }
+    break;
+    case SH_SpinControls_DisableOnBounds:
+        return int(true);
+
+    case SH_DitherDisabledText:
+        return int(false);
+
+    case SH_ComboBox_Popup: {
+        GtkWidget *gtkComboBox = d->gtkWidget("GtkComboBox");
+        gboolean appears_as_list;
+        d->gtk_widget_style_get((GtkWidget*)gtkComboBox, "appears-as-list", &appears_as_list, NULL);
+        return appears_as_list ? 0 : 1;
+    }
+
+    case SH_MenuBar_AltKeyNavigation:
+        return int(false);
+
+    case SH_EtchDisabledText:
+        return int(false);
+
+    case SH_Menu_SubMenuPopupDelay: {
+        gint delay = 225;
+        GtkSettings *settings = d->gtk_settings_get_default();
+        g_object_get(settings, "gtk-menu-popup-delay", &delay, NULL);
+        return delay;
+    }
+
+    case SH_ScrollView_FrameOnlyAroundContents: {
+        gboolean scrollbars_within_bevel = false;
+        if (widget && widget->isWindow())
+            scrollbars_within_bevel = true;
+        else if (!d->gtk_check_version(2, 12, 0)) {
+            GtkWidget *gtkScrollWindow = d->gtkWidget("GtkScrolledWindow");
+            d->gtk_widget_style_get(gtkScrollWindow, "scrollbars-within-bevel", &scrollbars_within_bevel, NULL);
+        }
+        return !scrollbars_within_bevel;
+    }
+
+    case SH_DialogButtonBox_ButtonsHaveIcons: {
+        static bool buttonsHaveIcons = d->getGConfBool(QLS("/desktop/gnome/interface/buttons_have_icons"));
+        return buttonsHaveIcons;
+    }
+
+    case SH_UnderlineShortcut: {
+        gboolean underlineShortcut = true;
+        if (!d->gtk_check_version(2, 12, 0)) {
+            GtkSettings *settings = d->gtk_settings_get_default();
+            g_object_get(settings, "gtk-enable-mnemonics", &underlineShortcut, NULL);
+        }
+        return underlineShortcut;
+    }
+
+    default:
+        break;
+    }
+    return QCommonStyle::styleHint(hint, option, widget, returnData);
+}
+
+/*!
+    \reimp
+*/
+void QGtkStyle::drawPrimitive(PrimitiveElement element,
+                              const QStyleOption *option,
+                              QPainter *painter,
+                              const QWidget *widget) const
+{
+    Q_D(const QGtkStyle);
+
+    if (!d->isThemeAvailable()) {
+        QCommonStyle::drawPrimitive(element, option, painter, widget);
+        return;
+    }
+
+    GtkStyle* style = d->gtkStyle();
+    QGtkPainter* gtkPainter = d->gtkPainter(painter);
+
+    switch (element) {
+      case PE_Frame: {
+        if (widget && widget->inherits("QComboBoxPrivateContainer")){
+            QStyleOption copy = *option;
+            copy.state |= State_Raised;
+            proxy()->drawPrimitive(PE_PanelMenu, &copy, painter, widget);
+            break;
+        }
+        // Drawing the entire itemview frame is very expensive, especially on the native X11 engine
+        // Instead we cheat a bit and draw a border image without the center part, hence only scaling
+        // thin rectangular images
+        const int pmSize = 64;
+        const int border = proxy()->pixelMetric(PM_DefaultFrameWidth, option, widget);
+        const QString pmKey = QLatin1String("windowframe") % HexString<uint>(option->state);
+
+        QPixmap pixmap;
+        QRect pmRect(QPoint(0,0), QSize(pmSize, pmSize));
+
+        // Only draw through style once
+        if (!QPixmapCache::find(pmKey, pixmap)) {
+            pixmap = QPixmap(pmSize, pmSize);
+            pixmap.fill(Qt::transparent);
+            QPainter pmPainter(&pixmap);
+            gtkPainter->reset(&pmPainter);
+            gtkPainter->setUsePixmapCache(false); // Don't cache twice
+
+            GtkShadowType shadow_type = GTK_SHADOW_NONE;
+            if (option->state & State_Sunken)
+                shadow_type = GTK_SHADOW_IN;
+            else if (option->state & State_Raised)
+                shadow_type = GTK_SHADOW_OUT;
+
+            GtkStyle *style = d->gtk_rc_get_style_by_paths(d->gtk_settings_get_default(),
+                                     "*.GtkScrolledWindow", "*.GtkScrolledWindow", d->gtk_window_get_type());
+            if (style)
+                gtkPainter->paintShadow(d->gtkWidget("GtkFrame"), "viewport", pmRect,
+                                        option->state & State_Enabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE,
+                                        shadow_type, style);
+            QPixmapCache::insert(pmKey, pixmap);
+            gtkPainter->reset(painter);
+        }
+
+        QRect rect = option->rect;
+        const int rw = rect.width() - border;
+        const int rh = rect.height() - border;
+        const int pw = pmRect.width() - border;
+        const int ph = pmRect.height() - border;
+
+        // Sidelines
+        painter->drawPixmap(rect.adjusted(border, 0, -border, -rh), pixmap, pmRect.adjusted(border, 0, -border,-ph));
+        painter->drawPixmap(rect.adjusted(border, rh, -border, 0), pixmap, pmRect.adjusted(border, ph,-border,0));
+        painter->drawPixmap(rect.adjusted(0, border, -rw, -border), pixmap, pmRect.adjusted(0, border, -pw, -border));
+        painter->drawPixmap(rect.adjusted(rw, border, 0, -border), pixmap, pmRect.adjusted(pw, border, 0, -border));
+
+        // Corners
+        painter->drawPixmap(rect.adjusted(0, 0, -rw, -rh), pixmap, pmRect.adjusted(0, 0, -pw,-ph));
+        painter->drawPixmap(rect.adjusted(rw, 0, 0, -rh), pixmap, pmRect.adjusted(pw, 0, 0,-ph));
+        painter->drawPixmap(rect.adjusted(0, rh, -rw, 0), pixmap, pmRect.adjusted(0, ph, -pw,0));
+        painter->drawPixmap(rect.adjusted(rw, rh, 0, 0), pixmap, pmRect.adjusted(pw, ph, 0,0));
+    }
+    break;
+    case PE_FrameWindow:
+        painter->save();
+        {
+            QRect rect= option->rect;
+            painter->setPen(QPen(option->palette.dark().color().darker(150), 0));
+            painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
+            painter->setPen(QPen(option->palette.light(), 0));
+            painter->drawLine(QPoint(rect.left() + 1, rect.top() + 1),
+                              QPoint(rect.left() + 1, rect.bottom() - 1));
+            painter->setPen(QPen(option->palette.background().color().darker(120), 0));
+            painter->drawLine(QPoint(rect.left() + 1, rect.bottom() - 1),
+                              QPoint(rect.right() - 2, rect.bottom() - 1));
+            painter->drawLine(QPoint(rect.right() - 1, rect.top() + 1),
+                              QPoint(rect.right() - 1, rect.bottom() - 1));
+        }
+        painter->restore();
+        break;
+
+    case PE_PanelTipLabel: {
+        GtkWidget *gtkWindow = d->gtkWidget("GtkWindow"); // The Murrine Engine currently assumes a widget is passed
+        style = d->gtk_rc_get_style_by_paths(d->gtk_settings_get_default(), "gtk-tooltips", "GtkWindow",
+                d->gtk_window_get_type());
+        gtkPainter->paintFlatBox(gtkWindow, "tooltip", option->rect, GTK_STATE_NORMAL, GTK_SHADOW_NONE, style);
+    }
+    break;
+
+    case PE_PanelStatusBar: {
+        if (widget && widget->testAttribute(Qt::WA_SetPalette) &&
+            option->palette.resolve() & (1 << QPalette::Window)) {
+            // Respect custom palette
+            painter->fillRect(option->rect, option->palette.window());
+            break;
+        }
+        GtkShadowType shadow_type;
+        GtkWidget *gtkStatusbarFrame = d->gtkWidget("GtkStatusbar.GtkFrame");
+        d->gtk_widget_style_get(d->gtk_widget_get_parent(gtkStatusbarFrame), "shadow-type", &shadow_type, NULL);
+        gtkPainter->paintShadow(gtkStatusbarFrame, "frame", option->rect, GTK_STATE_NORMAL,
+                                shadow_type, d->gtk_widget_get_style(gtkStatusbarFrame));
+    }
+    break;
+
+    case PE_IndicatorHeaderArrow:
+        if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(option)) {
+            GtkWidget *gtkTreeHeader = d->gtkWidget("GtkTreeView.GtkButton");
+            GtkStateType state = qt_gtk_state(option);
+            style = d->gtk_widget_get_style(gtkTreeHeader);
+            GtkArrowType type = GTK_ARROW_UP;
+            // This sorting indicator inversion is intentional, and follows the GNOME HIG.
+            // See http://library.gnome.org/devel/hig-book/stable/controls-lists.html.en#controls-lists-sortable
+            if (header->sortIndicator & QStyleOptionHeader::SortUp)
+                type = GTK_ARROW_UP;
+            else if (header->sortIndicator & QStyleOptionHeader::SortDown)
+                type = GTK_ARROW_DOWN;
+
+            gtkPainter->paintArrow(gtkTreeHeader, "button", option->rect.adjusted(1, 1, -1, -1), type, state,
+                                   GTK_SHADOW_NONE, false, style);
+        }
+        break;
+
+    case PE_FrameDefaultButton: // fall through
+    case PE_FrameFocusRect: {
+            QRect frameRect = option->rect.adjusted(1, 1, -2, -2); // ### this mess should move to subcontrolrect
+            if (qobject_cast<const QAbstractItemView*>(widget)) {
+                // Don't draw anything
+            } else if (qobject_cast<const QTabBar*>(widget)) {
+                GtkWidget *gtkNotebook = d->gtkWidget("GtkNotebook");
+                style = d->gtk_widget_get_style(gtkNotebook);
+                gtkPainter->paintFocus(gtkNotebook, "tab", frameRect.adjusted(-1, 1, 1, 1), GTK_STATE_ACTIVE, style);
+            } else {
+                GtkWidget *gtkRadioButton = d->gtkWidget("GtkRadioButton");
+                gtkPainter->paintFocus(gtkRadioButton, "radiobutton", frameRect, GTK_STATE_ACTIVE, style);
+            }
+        }
+        break;
+
+    case PE_IndicatorBranch:
+        if (option->state & State_Children) {
+            QRect rect = option->rect;
+            rect = QRect(0, 0, 12, 12);
+            rect.moveCenter(option->rect.center());
+            rect.translate(2, 0);
+            GtkExpanderStyle openState = GTK_EXPANDER_EXPANDED;
+            GtkExpanderStyle closedState = GTK_EXPANDER_COLLAPSED;
+            GtkWidget *gtkTreeView = d->gtkWidget("GtkTreeView");
+
+            GtkStateType state = GTK_STATE_NORMAL;
+            if (!(option->state & State_Enabled))
+                state = GTK_STATE_INSENSITIVE;
+            else if (option->state & State_MouseOver)
+                state = GTK_STATE_PRELIGHT;
+
+            gtkPainter->paintExpander(gtkTreeView, "treeview", rect, state,
+                                      option->state & State_Open ? openState : closedState , d->gtk_widget_get_style(gtkTreeView));
+        }
+        break;
+
+    case PE_PanelItemViewRow:
+        // This primitive is only used to draw selection behind selected expander arrows.
+        // We try not to decorate the tree branch background unless you inherit from StyledItemDelegate
+        // The reason for this is that a lot of code that relies on custom item delegates will look odd having
+        // a gradient on the branch but a flat shaded color on the item itself.
+        QCommonStyle::drawPrimitive(element, option, painter, widget);
+        if (!option->state & State_Selected) {
+            break;
+        } else {
+            if (const QAbstractItemView *view = qobject_cast<const QAbstractItemView*>(widget)) {
+                if (!qobject_cast<QStyledItemDelegate*>(view->itemDelegate()))
+                    break;
+            }
+        } // fall through
+
+    case PE_PanelItemViewItem:
+        if (const QStyleOptionViewItem *vopt = qstyleoption_cast<const QStyleOptionViewItem *>(option)) {
+            uint resolve_mask = vopt->palette.resolve();
+            if (vopt->backgroundBrush.style() != Qt::NoBrush
+                    || (resolve_mask & (1 << QPalette::Base)))
+            {
+                QPointF oldBO = painter->brushOrigin();
+                painter->setBrushOrigin(vopt->rect.topLeft());
+                painter->fillRect(vopt->rect, vopt->backgroundBrush);
+                painter->setBrushOrigin(oldBO);
+                if (!(option->state & State_Selected))
+                    break;
+            }
+            if (GtkWidget *gtkTreeView = d->gtkWidget("GtkTreeView")) {
+                const char *detail = "cell_even_ruled";
+                if (vopt && vopt->features & QStyleOptionViewItem::Alternate)
+                    detail = "cell_odd_ruled";
+                bool isActive = option->state & State_Active;
+                QString key;
+                if (isActive ) {
+                    // Required for active/non-active window appearance
+                    key = QLS("a");
+                    QGtkStylePrivate::gtkWidgetSetFocus(gtkTreeView, true);
+                }
+                bool isEnabled = (widget ? widget->isEnabled() : (vopt->state & QStyle::State_Enabled));
+                gtkPainter->paintFlatBox(gtkTreeView, detail, option->rect,
+                                         option->state & State_Selected ? GTK_STATE_SELECTED :
+                                         isEnabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE,
+                                         GTK_SHADOW_OUT, d->gtk_widget_get_style(gtkTreeView), key);
+                if (isActive )
+                    QGtkStylePrivate::gtkWidgetSetFocus(gtkTreeView, false);
+            }
+        }
+        break;
+    case PE_IndicatorToolBarSeparator:
+        {
+            const int margin = 6;
+            GtkWidget *gtkSeparator = d->gtkWidget("GtkToolbar.GtkSeparatorToolItem");
+            if (option->state & State_Horizontal) {
+                const int offset = option->rect.width()/2;
+                QRect rect = option->rect.adjusted(offset, margin, 0, -margin);
+                painter->setPen(QPen(option->palette.background().color().darker(110)));
+                gtkPainter->paintVline(gtkSeparator, "vseparator",
+                                       rect, GTK_STATE_NORMAL, d->gtk_widget_get_style(gtkSeparator),
+                                       0, rect.height(), 0);
+            } else { //Draw vertical separator
+                const int offset = option->rect.height()/2;
+                QRect rect = option->rect.adjusted(margin, offset, -margin, 0);
+                painter->setPen(QPen(option->palette.background().color().darker(110)));
+                gtkPainter->paintHline(gtkSeparator, "hseparator",
+                                       rect, GTK_STATE_NORMAL, d->gtk_widget_get_style(gtkSeparator),
+                                       0, rect.width(), 0);
+            }
+       }
+       break;
+
+    case PE_IndicatorToolBarHandle: {
+        GtkWidget *gtkToolbar = d->gtkWidget("GtkToolbar");
+        GtkShadowType shadow_type;
+        d->gtk_widget_style_get(gtkToolbar, "shadow-type", &shadow_type, NULL);
+        //Note when the toolbar is horizontal, the handle is vertical
+        painter->setClipRect(option->rect);
+        gtkPainter->paintHandle(gtkToolbar, "toolbar", option->rect.adjusted(-1, -1 ,0 ,1),
+                                GTK_STATE_NORMAL, shadow_type, !(option->state & State_Horizontal) ?
+                                GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL, d->gtk_widget_get_style(gtkToolbar));
+    }
+    break;
+
+    case PE_IndicatorArrowUp:
+    case PE_IndicatorArrowDown:
+    case PE_IndicatorArrowLeft:
+    case PE_IndicatorArrowRight: {
+
+
+        GtkArrowType type = GTK_ARROW_UP;
+
+        switch (element) {
+
+        case PE_IndicatorArrowDown:
+            type = GTK_ARROW_DOWN;
+            break;
+
+        case PE_IndicatorArrowLeft:
+            type = GTK_ARROW_LEFT;
+            break;
+
+        case PE_IndicatorArrowRight:
+            type = GTK_ARROW_RIGHT;
+            break;
+
+        default:
+            break;
+        }
+        int size = qMin(option->rect.height(), option->rect.width());
+        int border = (size > 9) ? (size/4) : 0; //Allow small arrows to have exact dimensions
+        int bsx = 0, bsy = 0;
+        if (option->state & State_Sunken) {
+            bsx = proxy()->pixelMetric(PM_ButtonShiftHorizontal);
+            bsy = proxy()->pixelMetric(PM_ButtonShiftVertical);
+        }
+        QRect arrowRect = option->rect.adjusted(border + bsx, border + bsy, -border + bsx, -border + bsy);
+        GtkShadowType shadow = option->state & State_Sunken ? GTK_SHADOW_IN : GTK_SHADOW_OUT;
+        GtkStateType state = qt_gtk_state(option);
+
+        QColor arrowColor = option->palette.buttonText().color();
+        GtkWidget *gtkArrow = d->gtkWidget("GtkArrow");
+        GdkColor color = fromQColor(arrowColor);
+        d->gtk_widget_modify_fg (gtkArrow, state, &color);
+        gtkPainter->paintArrow(gtkArrow, "button", arrowRect,
+                               type, state, shadow, false, d->gtk_widget_get_style(gtkArrow),
+                               QString::number(arrowColor.rgba(), 16));
+        // Passing NULL will revert the color change
+        d->gtk_widget_modify_fg (gtkArrow, state, NULL);
+    }
+    break;
+
+    case PE_FrameGroupBox:
+        // Do nothing here, the GNOME groupboxes are flat
+        break;
+
+    case PE_PanelMenu: {
+            GtkWidget *gtkMenu = d->gtkWidget("GtkMenu");
+            gtkPainter->setAlphaSupport(false); // Note, alpha disabled for performance reasons
+            gtkPainter->paintBox(gtkMenu, "menu", option->rect, GTK_STATE_NORMAL, GTK_SHADOW_OUT, d->gtk_widget_get_style(gtkMenu), QString());
+        }
+        break;
+
+    case PE_FrameMenu:
+        //This is actually done by PE_Widget due to a clipping issue
+        //Otherwise Menu items will not be able to span the entire menu width
+
+        // This is only used by floating tool bars
+        if (qobject_cast<const QToolBar *>(widget)) {
+            GtkWidget *gtkMenubar = d->gtkWidget("GtkMenuBar");
+            gtkPainter->paintBox(gtkMenubar, "toolbar", option->rect,
+                                 GTK_STATE_NORMAL, GTK_SHADOW_OUT, style);
+            gtkPainter->paintBox(gtkMenubar, "menu", option->rect,
+                                 GTK_STATE_NORMAL, GTK_SHADOW_OUT, style);
+        }
+        break;
+
+    case PE_FrameLineEdit: {
+        GtkWidget *gtkEntry = d->gtkWidget("GtkEntry");
+
+
+        gboolean interior_focus;
+        gint focus_line_width;
+        QRect rect = option->rect;
+        d->gtk_widget_style_get(gtkEntry,
+                               "interior-focus", &interior_focus,
+                               "focus-line-width", &focus_line_width, NULL);
+
+        // See https://bugzilla.mozilla.org/show_bug.cgi?id=405421 for info about this hack
+        g_object_set_data(G_OBJECT(gtkEntry), "transparent-bg-hint", GINT_TO_POINTER(true));
+
+        if (!interior_focus && option->state & State_HasFocus)
+            rect.adjust(focus_line_width, focus_line_width, -focus_line_width, -focus_line_width);
+
+        if (option->state & State_HasFocus)
+            QGtkStylePrivate::gtkWidgetSetFocus(gtkEntry, true);
+        gtkPainter->paintShadow(gtkEntry, "entry", rect, option->state & State_Enabled ?
+                                GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE,
+                                GTK_SHADOW_IN, d->gtk_widget_get_style(gtkEntry),
+                                option->state & State_HasFocus ? QLS("focus") : QString());
+        if (!interior_focus && option->state & State_HasFocus)
+            gtkPainter->paintShadow(gtkEntry, "entry", option->rect, option->state & State_Enabled ?
+                                    GTK_STATE_ACTIVE : GTK_STATE_INSENSITIVE,
+                                    GTK_SHADOW_IN, d->gtk_widget_get_style(gtkEntry), QLS("GtkEntryShadowIn"));
+
+        if (option->state & State_HasFocus)
+            QGtkStylePrivate::gtkWidgetSetFocus(gtkEntry, false);
+    }
+    break;
+
+    case PE_PanelLineEdit:
+        if (const QStyleOptionFrame *panel = qstyleoption_cast<const QStyleOptionFrame *>(option)) {
+            GtkWidget *gtkEntry = d->gtkWidget("GtkEntry");
+            if (panel->lineWidth > 0)
+                proxy()->drawPrimitive(PE_FrameLineEdit, option, painter, widget);
+            uint resolve_mask = option->palette.resolve();
+            GtkStyle *gtkEntryStyle = d->gtk_widget_get_style(gtkEntry);
+            QRect textRect = option->rect.adjusted(gtkEntryStyle->xthickness, gtkEntryStyle->ythickness,
+                                                   -gtkEntryStyle->xthickness, -gtkEntryStyle->ythickness);
+
+            if (widget && widget->testAttribute(Qt::WA_SetPalette) &&
+                resolve_mask & (1 << QPalette::Base)) // Palette overridden by user
+                painter->fillRect(textRect, option->palette.base());
+            else
+                gtkPainter->paintFlatBox(gtkEntry, "entry_bg", textRect,
+                                         option->state & State_Enabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE, GTK_SHADOW_NONE, gtkEntryStyle);
+        }
+        break;
+
+    case PE_FrameTabWidget:
+        if (const QStyleOptionTabWidgetFrame *frame = qstyleoption_cast<const QStyleOptionTabWidgetFrame*>(option)) {
+            GtkWidget *gtkNotebook = d->gtkWidget("GtkNotebook");
+            style = d->gtk_widget_get_style(gtkNotebook);
+            gtkPainter->setAlphaSupport(false);
+            GtkShadowType shadow = GTK_SHADOW_OUT;
+            GtkStateType state = GTK_STATE_NORMAL; // Only state supported by gtknotebook
+            bool reverse = (option->direction == Qt::RightToLeft);
+            QGtkStylePrivate::gtk_widget_set_direction(gtkNotebook, reverse ? GTK_TEXT_DIR_RTL : GTK_TEXT_DIR_LTR);
+            if (const QStyleOptionTabWidgetFrameV2 *tabframe = qstyleoption_cast<const QStyleOptionTabWidgetFrameV2*>(option)) {
+                GtkPositionType frameType = GTK_POS_TOP;
+                QTabBar::Shape shape = frame->shape;
+                int gapStart = 0;
+                int gapSize = 0;
+                if (shape == QTabBar::RoundedNorth || shape == QTabBar::RoundedSouth) {
+                    frameType = (shape == QTabBar::RoundedNorth) ? GTK_POS_TOP : GTK_POS_BOTTOM;
+                    gapStart = tabframe->selectedTabRect.left();
+                    gapSize = tabframe->selectedTabRect.width();
+                } else {
+                    frameType = (shape == QTabBar::RoundedWest) ? GTK_POS_LEFT : GTK_POS_RIGHT;
+                    gapStart = tabframe->selectedTabRect.y();
+                    gapSize = tabframe->selectedTabRect.height();
+                }
+                gtkPainter->paintBoxGap(gtkNotebook, "notebook", option->rect, state, shadow, frameType,
+                                        gapStart, gapSize, style);
+                break; // done
+            }
+
+            // Note this is only the fallback option
+            gtkPainter->paintBox(gtkNotebook, "notebook", option->rect, state, shadow, style);
+        }
+        break;
+
+    case PE_PanelButtonCommand:
+    case PE_PanelButtonTool: {
+        bool isDefault = false;
+        bool isTool = (element == PE_PanelButtonTool);
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton*>(option))
+            isDefault = btn->features & QStyleOptionButton::DefaultButton;
+
+        // don't draw a frame for tool buttons that have the autoRaise flag and are not enabled or on
+        if (isTool && !(option->state & State_Enabled || option->state & State_On) && (option->state & State_AutoRaise))
+            break;
+        // don't draw a frame for dock widget buttons, unless we are hovering
+        if (widget && widget->inherits("QDockWidgetTitleButton") && !(option->state & State_MouseOver))
+            break;
+
+        GtkStateType state = qt_gtk_state(option);
+        if (option->state & State_On || option->state & State_Sunken)
+            state = GTK_STATE_ACTIVE;
+        GtkWidget *gtkButton = isTool ? d->gtkWidget("GtkToolButton.GtkButton") : d->gtkWidget("GtkButton");
+        gint focusWidth, focusPad;
+        gboolean interiorFocus = false;
+        d->gtk_widget_style_get (gtkButton,
+                                "focus-line-width", &focusWidth,
+                                "focus-padding", &focusPad,
+                                "interior-focus", &interiorFocus, NULL);
+
+        style = d->gtk_widget_get_style(gtkButton);
+
+        QRect buttonRect = option->rect;
+
+        QString key;
+        if (isDefault) {
+            key += QLS("def");
+            QGtkStylePrivate::gtk_widget_set_can_default(gtkButton, true);
+            QGtkStylePrivate::gtk_window_set_default((GtkWindow*)QGtkStylePrivate::gtk_widget_get_toplevel(gtkButton), gtkButton);
+            gtkPainter->paintBox(gtkButton, "buttondefault", buttonRect, state, GTK_SHADOW_IN,
+                                 style, isDefault ? QLS("d") : QString());
+        }
+
+        bool hasFocus = option->state & State_HasFocus;
+
+        if (hasFocus) {
+            key += QLS("def");
+            QGtkStylePrivate::gtkWidgetSetFocus(gtkButton, true);
+        }
+
+        if (!interiorFocus)
+            buttonRect = buttonRect.adjusted(focusWidth, focusWidth, -focusWidth, -focusWidth);
+
+        GtkShadowType shadow = (option->state & State_Sunken || option->state & State_On ) ?
+                               GTK_SHADOW_IN : GTK_SHADOW_OUT;
+
+        gtkPainter->paintBox(gtkButton, "button", buttonRect, state, shadow,
+                             style, key);
+        if (isDefault)
+            QGtkStylePrivate::gtk_window_set_default((GtkWindow*)QGtkStylePrivate::gtk_widget_get_toplevel(gtkButton), 0);
+        if (hasFocus)
+            QGtkStylePrivate::gtkWidgetSetFocus(gtkButton, false);
+    }
+    break;
+
+    case PE_IndicatorRadioButton: {
+        GtkShadowType shadow = GTK_SHADOW_OUT;
+        GtkStateType state = qt_gtk_state(option);
+
+        if (option->state & State_Sunken)
+            state = GTK_STATE_ACTIVE;
+
+        if (option->state & State_NoChange)
+            shadow = GTK_SHADOW_ETCHED_IN;
+        else if (option->state & State_On)
+            shadow = GTK_SHADOW_IN;
+        else
+            shadow = GTK_SHADOW_OUT;
+
+        GtkWidget *gtkRadioButton = d->gtkWidget("GtkRadioButton");
+        gint spacing;
+        d->gtk_widget_style_get(gtkRadioButton, "indicator-spacing", &spacing, NULL);
+        QRect buttonRect = option->rect.adjusted(spacing, spacing, -spacing, -spacing);
+        gtkPainter->setClipRect(option->rect);
+        // ### Note: Ubuntulooks breaks when the proper widget is passed
+        //           Murrine engine requires a widget not to get RGBA check - warnings
+        GtkWidget *gtkCheckButton = d->gtkWidget("GtkCheckButton");
+        QString key(QLS("radiobutton"));
+        if (option->state & State_HasFocus) { // Themes such as Nodoka check this flag
+            key += QLatin1Char('f');
+            QGtkStylePrivate::gtkWidgetSetFocus(gtkCheckButton, true);
+        }
+        gtkPainter->paintOption(gtkCheckButton , buttonRect, state, shadow, d->gtk_widget_get_style(gtkRadioButton), key);
+        if (option->state & State_HasFocus)
+            QGtkStylePrivate::gtkWidgetSetFocus(gtkCheckButton, false);
+    }
+    break;
+
+    case PE_IndicatorCheckBox: {
+        GtkShadowType shadow = GTK_SHADOW_OUT;
+        GtkStateType state = qt_gtk_state(option);
+
+        if (option->state & State_Sunken)
+            state = GTK_STATE_ACTIVE;
+
+        if (option->state & State_NoChange)
+            shadow = GTK_SHADOW_ETCHED_IN;
+        else if (option->state & State_On)
+            shadow = GTK_SHADOW_IN;
+        else
+            shadow = GTK_SHADOW_OUT;
+
+        int spacing;
+
+        GtkWidget *gtkCheckButton = d->gtkWidget("GtkCheckButton");
+        QString key(QLS("checkbutton"));
+        if (option->state & State_HasFocus) { // Themes such as Nodoka checks this flag
+            key += QLatin1Char('f');
+            QGtkStylePrivate::gtkWidgetSetFocus(gtkCheckButton, true);
+        }
+
+        // Some styles such as aero-clone assume they can paint in the spacing area
+        gtkPainter->setClipRect(option->rect);
+
+        d->gtk_widget_style_get(gtkCheckButton, "indicator-spacing", &spacing, NULL);
+
+        QRect checkRect = option->rect.adjusted(spacing, spacing, -spacing, -spacing);
+
+        gtkPainter->paintCheckbox(gtkCheckButton, checkRect, state, shadow, d->gtk_widget_get_style(gtkCheckButton),
+                                  key);
+        if (option->state & State_HasFocus)
+            QGtkStylePrivate::gtkWidgetSetFocus(gtkCheckButton, false);
+
+    }
+    break;
+
+#ifndef QT_NO_TABBAR
+
+    case PE_FrameTabBarBase:
+        if (const QStyleOptionTabBarBase *tbb
+                = qstyleoption_cast<const QStyleOptionTabBarBase *>(option)) {
+            QRect tabRect = tbb->rect;
+            painter->save();
+            painter->setPen(QPen(option->palette.dark().color().dark(110), 0));
+            switch (tbb->shape) {
+
+            case QTabBar::RoundedNorth:
+                painter->drawLine(tabRect.topLeft(), tabRect.topRight());
+                break;
+
+            case QTabBar::RoundedWest:
+                painter->drawLine(tabRect.left(), tabRect.top(), tabRect.left(), tabRect.bottom());
+                break;
+
+            case QTabBar::RoundedSouth:
+                painter->drawLine(tbb->rect.left(), tbb->rect.bottom(),
+                                  tabRect.right(), tabRect.bottom());
+                break;
+
+            case QTabBar::RoundedEast:
+                painter->drawLine(tabRect.topRight(), tabRect.bottomRight());
+                break;
+
+            case QTabBar::TriangularNorth:
+            case QTabBar::TriangularEast:
+            case QTabBar::TriangularWest:
+            case QTabBar::TriangularSouth:
+                painter->restore();
+                QCommonStyle::drawPrimitive(element, option, painter, widget);
+                return;
+            }
+
+            painter->restore();
+        }
+        return;
+
+#endif // QT_NO_TABBAR
+
+    case PE_Widget:
+        break;
+
+    default:
+        QCommonStyle::drawPrimitive(element, option, painter, widget);
+    }
+}
+
+/*!
+    \reimp
+*/
+void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
+
+                                   QPainter *painter, const QWidget *widget) const
+{
+    Q_D(const QGtkStyle);
+
+    if (!d->isThemeAvailable()) {
+        QCommonStyle::drawComplexControl(control, option, painter, widget);
+        return;
+    }
+
+    GtkStyle* style = d->gtkStyle();
+    QGtkPainter* gtkPainter = d->gtkPainter(painter);
+    QColor button = option->palette.button().color();
+    QColor dark;
+    QColor grooveColor;
+    QColor darkOutline;
+    dark.setHsv(button.hue(),
+                qMin(255, (int)(button.saturation()*1.9)),
+                qMin(255, (int)(button.value()*0.7)));
+    grooveColor.setHsv(button.hue(),
+                       qMin(255, (int)(button.saturation()*2.6)),
+                       qMin(255, (int)(button.value()*0.9)));
+    darkOutline.setHsv(button.hue(),
+                       qMin(255, (int)(button.saturation()*3.0)),
+                       qMin(255, (int)(button.value()*0.6)));
+
+    QColor alphaCornerColor;
+
+    if (widget)
+        alphaCornerColor = mergedColors(option->palette.color(widget->backgroundRole()), darkOutline);
+    else
+        alphaCornerColor = mergedColors(option->palette.background().color(), darkOutline);
+
+    switch (control) {
+
+    case CC_TitleBar:
+        painter->save();
+        if (const QStyleOptionTitleBar *titleBar = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {
+            // Since this is drawn by metacity and not Gtk we
+            // have to do custom drawing
+
+            GdkColor gdkBg = style->bg[GTK_STATE_SELECTED];
+            QColor bgColor(gdkBg.red>>8, gdkBg.green>>8, gdkBg.blue>>8);
+
+            const int buttonMargin = 5;
+            bool active = (titleBar->titleBarState & State_Active);
+            QRect fullRect = titleBar->rect;
+            QPalette palette = option->palette;
+            QColor highlight = bgColor;
+
+            QColor titleBarFrameBorder(active ? highlight.darker(180): dark.darker(110));
+            QColor titleBarHighlight(active ? highlight.lighter(120): palette.background().color().lighter(120));
+            QColor textColor(active ? 0xffffff : 0xff000000);
+            QColor textAlphaColor(active ? 0xffffff : 0xff000000 );
+
+            {
+                // Fill title bar gradient
+                QColor titlebarColor = QColor(active ? highlight: palette.background().color());
+                QLinearGradient gradient(option->rect.center().x(), option->rect.top(),
+                                         option->rect.center().x(), option->rect.bottom());
+
+                gradient.setColorAt(0, titlebarColor.lighter(114));
+                gradient.setColorAt(0.5, titlebarColor.lighter(102));
+                gradient.setColorAt(0.51, titlebarColor.darker(104));
+                gradient.setColorAt(1, titlebarColor);
+                painter->fillRect(option->rect.adjusted(1, 1, -1, 0), gradient);
+
+                // Frame and rounded corners
+                painter->setPen(titleBarFrameBorder);
+
+                // top outline
+                painter->drawLine(fullRect.left() + 5, fullRect.top(), fullRect.right() - 5, fullRect.top());
+                painter->drawLine(fullRect.left(), fullRect.top() + 4, fullRect.left(), fullRect.bottom());
+                const QPoint points[5] = {
+                    QPoint(fullRect.left() + 4, fullRect.top() + 1),
+                    QPoint(fullRect.left() + 3, fullRect.top() + 1),
+                    QPoint(fullRect.left() + 2, fullRect.top() + 2),
+                    QPoint(fullRect.left() + 1, fullRect.top() + 3),
+                    QPoint(fullRect.left() + 1, fullRect.top() + 4)
+                };
+                painter->drawPoints(points, 5);
+
+                painter->drawLine(fullRect.right(), fullRect.top() + 4, fullRect.right(), fullRect.bottom());
+                const QPoint points2[5] = {
+                    QPoint(fullRect.right() - 3, fullRect.top() + 1),
+                    QPoint(fullRect.right() - 4, fullRect.top() + 1),
+                    QPoint(fullRect.right() - 2, fullRect.top() + 2),
+                    QPoint(fullRect.right() - 1, fullRect.top() + 3),
+                    QPoint(fullRect.right() - 1, fullRect.top() + 4)
+                };
+                painter->drawPoints(points2, 5);
+
+                // draw bottomline
+                painter->drawLine(fullRect.right(), fullRect.bottom(), fullRect.left(), fullRect.bottom());
+
+                // top highlight
+                painter->setPen(titleBarHighlight);
+                painter->drawLine(fullRect.left() + 6, fullRect.top() + 1, fullRect.right() - 6, fullRect.top() + 1);
+            }
+            // draw title
+            QRect textRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarLabel, widget);
+            QFont font = painter->font();
+            font.setBold(true);
+            painter->setFont(font);
+            painter->setPen(active? (titleBar->palette.text().color().lighter(120)) :
+                                     titleBar->palette.text().color() );
+            // Note workspace also does elliding but it does not use the correct font
+            QString title = QFontMetrics(font).elidedText(titleBar->text, Qt::ElideRight, textRect.width() - 14);
+            painter->drawText(textRect.adjusted(1, 1, 1, 1), title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
+            painter->setPen(Qt::white);
+            if (active)
+                painter->drawText(textRect, title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
+            // min button
+            if ((titleBar->subControls & SC_TitleBarMinButton) && (titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
+                !(titleBar->titleBarState& Qt::WindowMinimized)) {
+                QRect minButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMinButton, widget);
+                if (minButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_Sunken);
+                    qt_gtk_draw_mdibutton(painter, titleBar, minButtonRect, hover, sunken);
+                    QRect minButtonIconRect = minButtonRect.adjusted(buttonMargin ,buttonMargin , -buttonMargin, -buttonMargin);
+                    painter->setPen(textColor);
+                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 3,
+                                    minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 3);
+                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 4,
+                                    minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 4);
+                    painter->setPen(textAlphaColor);
+                    painter->drawLine(minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 3,
+                                    minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 4);
+                    painter->drawLine(minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 3,
+                                    minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 4);
+                }
+            }
+            // max button
+            if ((titleBar->subControls & SC_TitleBarMaxButton) && (titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
+                !(titleBar->titleBarState & Qt::WindowMaximized)) {
+                QRect maxButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMaxButton, widget);
+                if (maxButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_Sunken);
+                    qt_gtk_draw_mdibutton(painter, titleBar, maxButtonRect, hover, sunken);
+
+                    QRect maxButtonIconRect = maxButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+
+                    painter->setPen(textColor);
+                    painter->drawRect(maxButtonIconRect.adjusted(0, 0, -1, -1));
+                    painter->drawLine(maxButtonIconRect.left() + 1, maxButtonIconRect.top() + 1,
+                                    maxButtonIconRect.right() - 1, maxButtonIconRect.top() + 1);
+                    painter->setPen(textAlphaColor);
+                    const QPoint points[4] = {
+                        maxButtonIconRect.topLeft(),
+                        maxButtonIconRect.topRight(),
+                        maxButtonIconRect.bottomLeft(),
+                        maxButtonIconRect.bottomRight()
+                    };
+                    painter->drawPoints(points, 4);
+                }
+            }
+
+            // close button
+            if ((titleBar->subControls & SC_TitleBarCloseButton) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
+                QRect closeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarCloseButton, widget);
+                if (closeButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_Sunken);
+                    qt_gtk_draw_mdibutton(painter, titleBar, closeButtonRect, hover, sunken);
+                    QRect closeIconRect = closeButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+                    painter->setPen(textAlphaColor);
+                    const QLine lines[4] = {
+                        QLine(closeIconRect.left() + 1, closeIconRect.top(),
+                              closeIconRect.right(), closeIconRect.bottom() - 1),
+                        QLine(closeIconRect.left(), closeIconRect.top() + 1,
+                              closeIconRect.right() - 1, closeIconRect.bottom()),
+                        QLine(closeIconRect.right() - 1, closeIconRect.top(),
+                              closeIconRect.left(), closeIconRect.bottom() - 1),
+                        QLine(closeIconRect.right(), closeIconRect.top() + 1,
+                              closeIconRect.left() + 1, closeIconRect.bottom())
+                    };
+                    painter->drawLines(lines, 4);
+                    const QPoint points[4] = {
+                        closeIconRect.topLeft(),
+                        closeIconRect.topRight(),
+                        closeIconRect.bottomLeft(),
+                        closeIconRect.bottomRight()
+                    };
+                    painter->drawPoints(points, 4);
+
+                    painter->setPen(textColor);
+                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.top() + 1,
+                                    closeIconRect.right() - 1, closeIconRect.bottom() - 1);
+                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.bottom() - 1,
+                                    closeIconRect.right() - 1, closeIconRect.top() + 1);
+                }
+            }
+
+            // normalize button
+            if ((titleBar->subControls & SC_TitleBarNormalButton) &&
+               (((titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
+               (titleBar->titleBarState & Qt::WindowMinimized)) ||
+               ((titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
+               (titleBar->titleBarState & Qt::WindowMaximized)))) {
+                QRect normalButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarNormalButton, widget);
+                if (normalButtonRect.isValid()) {
+
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_Sunken);
+                    QRect normalButtonIconRect = normalButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+                    qt_gtk_draw_mdibutton(painter, titleBar, normalButtonRect, hover, sunken);
+
+                    QRect frontWindowRect = normalButtonIconRect.adjusted(0, 3, -3, 0);
+                    painter->setPen(textColor);
+                    painter->drawRect(frontWindowRect.adjusted(0, 0, -1, -1));
+                    painter->drawLine(frontWindowRect.left() + 1, frontWindowRect.top() + 1,
+                                    frontWindowRect.right() - 1, frontWindowRect.top() + 1);
+                    painter->setPen(textAlphaColor);
+                    const QPoint points[4] = {
+                        frontWindowRect.topLeft(),
+                        frontWindowRect.topRight(),
+                        frontWindowRect.bottomLeft(),
+                        frontWindowRect.bottomRight()
+                    };
+                    painter->drawPoints(points, 4);
+
+                    QRect backWindowRect = normalButtonIconRect.adjusted(3, 0, 0, -3);
+                    QRegion clipRegion = backWindowRect;
+                    clipRegion -= frontWindowRect;
+                    painter->save();
+                    painter->setClipRegion(clipRegion);
+                    painter->setPen(textColor);
+                    painter->drawRect(backWindowRect.adjusted(0, 0, -1, -1));
+                    painter->drawLine(backWindowRect.left() + 1, backWindowRect.top() + 1,
+                                    backWindowRect.right() - 1, backWindowRect.top() + 1);
+                    painter->setPen(textAlphaColor);
+                    const QPoint points2[4] = {
+                        backWindowRect.topLeft(),
+                        backWindowRect.topRight(),
+                        backWindowRect.bottomLeft(),
+                        backWindowRect.bottomRight()
+                    };
+                    painter->drawPoints(points2, 4);
+                    painter->restore();
+                }
+            }
+
+            // context help button
+            if (titleBar->subControls & SC_TitleBarContextHelpButton
+                && (titleBar->titleBarFlags & Qt::WindowContextHelpButtonHint)) {
+                QRect contextHelpButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarContextHelpButton, widget);
+                if (contextHelpButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_Sunken);
+                    qt_gtk_draw_mdibutton(painter, titleBar, contextHelpButtonRect, hover, sunken);
+
+                    QColor blend;
+                    QImage image(qt_titlebar_context_help);
+                    QColor alpha = textColor;
+                    alpha.setAlpha(128);
+                    image.setColor(1, textColor.rgba());
+                    image.setColor(2, alpha.rgba());
+                    painter->setRenderHint(QPainter::SmoothPixmapTransform);
+                    painter->drawImage(contextHelpButtonRect.adjusted(4, 4, -4, -4), image);
+                }
+            }
+
+            // shade button
+            if (titleBar->subControls & SC_TitleBarShadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
+                QRect shadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarShadeButton, widget);
+                if (shadeButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_Sunken);
+                    qt_gtk_draw_mdibutton(painter, titleBar, shadeButtonRect, hover, sunken);
+                    QImage image(qt_scrollbar_button_arrow_up);
+                    image.setColor(1, textColor.rgba());
+                    painter->drawImage(shadeButtonRect.adjusted(5, 7, -5, -7), image);
+                }
+            }
+
+            // unshade button
+            if (titleBar->subControls & SC_TitleBarUnshadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
+                QRect unshadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarUnshadeButton, widget);
+                if (unshadeButtonRect.isValid()) {
+                    bool hover = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_MouseOver);
+                    bool sunken = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_Sunken);
+                    qt_gtk_draw_mdibutton(painter, titleBar, unshadeButtonRect, hover, sunken);
+                    QImage image(qt_scrollbar_button_arrow_down);
+                    image.setColor(1, textColor.rgba());
+                    painter->drawImage(unshadeButtonRect.adjusted(5, 7, -5, -7), image);
+                }
+            }
+
+            if ((titleBar->subControls & SC_TitleBarSysMenu) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
+                QRect iconRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarSysMenu, widget);
+                if (iconRect.isValid()) {
+                    if (!titleBar->icon.isNull()) {
+                        titleBar->icon.paint(painter, iconRect);
+                    } else {
+                        QStyleOption tool(0);
+                        tool.palette = titleBar->palette;
+                        QPixmap pm = standardIcon(SP_TitleBarMenuButton, &tool, widget).pixmap(16, 16);
+                        tool.rect = iconRect;
+                        painter->save();
+                        proxy()->drawItemPixmap(painter, iconRect, Qt::AlignCenter, pm);
+                        painter->restore();
+                    }
+                }
+            }
+        }
+        painter->restore();
+        break;
+
+#ifndef QT_NO_GROUPBOX
+
+    case CC_GroupBox:
+        painter->save();
+
+        if (const QStyleOptionGroupBox *groupBox = qstyleoption_cast<const QStyleOptionGroupBox *>(option)) {
+            QRect textRect = proxy()->subControlRect(CC_GroupBox, groupBox, SC_GroupBoxLabel, widget);
+            QRect checkBoxRect = proxy()->subControlRect(CC_GroupBox, groupBox, SC_GroupBoxCheckBox, widget);
+            // Draw title
+
+            if ((groupBox->subControls & QStyle::SC_GroupBoxLabel) && !groupBox->text.isEmpty()) {
+                // Draw prelight background
+                GtkWidget *gtkCheckButton = d->gtkWidget("GtkCheckButton");
+
+                if (option->state & State_MouseOver) {
+                    QRect bgRect = textRect | checkBoxRect;
+                    gtkPainter->paintFlatBox(gtkCheckButton, "checkbutton", bgRect.adjusted(0, 0, 0, -2),
+                                             GTK_STATE_PRELIGHT, GTK_SHADOW_ETCHED_OUT, d->gtk_widget_get_style(gtkCheckButton));
+                }
+
+                if (!groupBox->text.isEmpty()) {
+                    int alignment = int(groupBox->textAlignment);
+                    if (!proxy()->styleHint(QStyle::SH_UnderlineShortcut, option, widget))
+                        alignment |= Qt::TextHideMnemonic;
+                    QColor textColor = groupBox->textColor; // Note: custom textColor is currently ignored
+                    int labelState = GTK_STATE_INSENSITIVE;
+
+                    if (option->state & State_Enabled)
+                        labelState = (option->state & State_MouseOver) ? GTK_STATE_PRELIGHT : GTK_STATE_NORMAL;
+
+                    GdkColor gdkText = d->gtk_widget_get_style(gtkCheckButton)->fg[labelState];
+                    textColor = QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
+                    painter->setPen(textColor);
+                    QFont font = painter->font();
+                    font.setBold(true);
+                    painter->setFont(font);
+                    painter->drawText(textRect, Qt::TextShowMnemonic | Qt::AlignLeft| alignment, groupBox->text);
+
+                    if (option->state & State_HasFocus)
+                        gtkPainter->paintFocus(gtkCheckButton, "checkbutton", textRect.adjusted(-4, -1, 0, -3), GTK_STATE_ACTIVE, style);
+                }
+            }
+
+            if (groupBox->subControls & SC_GroupBoxCheckBox) {
+                QStyleOptionButton box;
+                box.QStyleOption::operator=(*groupBox);
+                box.rect = checkBoxRect;
+                proxy()->drawPrimitive(PE_IndicatorCheckBox, &box, painter, widget);
+            }
+        }
+
+        painter->restore();
+        break;
+#endif // QT_NO_GROUPBOX
+
+#ifndef QT_NO_COMBOBOX
+
+    case CC_ComboBox:
+        // See: http://live.gnome.org/GnomeArt/Tutorials/GtkThemes/GtkComboBox
+        // and http://live.gnome.org/GnomeArt/Tutorials/GtkThemes/GtkComboBoxEntry
+        if (const QStyleOptionComboBox *comboBox = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
+            bool sunken = comboBox->state & State_On; // play dead, if combobox has no items
+            BEGIN_STYLE_PIXMAPCACHE(QString::fromLatin1("cb-%0-%1").arg(sunken).arg(comboBox->editable));
+            gtkPainter->reset(p);
+            gtkPainter->setUsePixmapCache(false); // cached externally
+
+            bool isEnabled = (comboBox->state & State_Enabled);
+            bool focus = isEnabled && (comboBox->state & State_HasFocus);
+            GtkStateType state = qt_gtk_state(option);
+            int appears_as_list = !proxy()->styleHint(QStyle::SH_ComboBox_Popup, comboBox, widget);
+            QStyleOptionComboBox comboBoxCopy = *comboBox;
+            comboBoxCopy.rect = option->rect;
+
+            bool reverse = (option->direction == Qt::RightToLeft);
+            QRect rect = option->rect;
+            QRect arrowButtonRect = proxy()->subControlRect(CC_ComboBox, &comboBoxCopy,
+                                                   SC_ComboBoxArrow, widget);
+
+            GtkShadowType shadow = (option->state & State_Sunken || option->state & State_On ) ?
+                                   GTK_SHADOW_IN : GTK_SHADOW_OUT;
+            const QHashableLatin1Literal comboBoxPath = comboBox->editable ? QHashableLatin1Literal("GtkComboBoxEntry") : QHashableLatin1Literal("GtkComboBox");
+
+            // We use the gtk widget to position arrows and separators for us
+            GtkWidget *gtkCombo = d->gtkWidget(comboBoxPath);
+            GtkAllocation geometry = {0, 0, option->rect.width(), option->rect.height()};
+            d->gtk_widget_set_direction(gtkCombo, reverse ? GTK_TEXT_DIR_RTL : GTK_TEXT_DIR_LTR);
+            d->gtk_widget_size_allocate(gtkCombo, &geometry);
+
+            QHashableLatin1Literal buttonPath = comboBox->editable ? QHashableLatin1Literal("GtkComboBoxEntry.GtkToggleButton")
+                                : QHashableLatin1Literal("GtkComboBox.GtkToggleButton");
+            GtkWidget *gtkToggleButton = d->gtkWidget(buttonPath);
+            d->gtk_widget_set_direction(gtkToggleButton, reverse ? GTK_TEXT_DIR_RTL : GTK_TEXT_DIR_LTR);
+            if (gtkToggleButton && (appears_as_list || comboBox->editable)) {
+                if (focus)
+                    QGtkStylePrivate::gtkWidgetSetFocus(gtkToggleButton, true);
+                // Draw the combo box as a line edit with a button next to it
+                if (comboBox->editable || appears_as_list) {
+                    GtkStateType frameState = (state == GTK_STATE_PRELIGHT) ? GTK_STATE_NORMAL : state;
+                    QHashableLatin1Literal entryPath = comboBox->editable ? QHashableLatin1Literal("GtkComboBoxEntry.GtkEntry") : QHashableLatin1Literal("GtkComboBox.GtkFrame");
+                    GtkWidget *gtkEntry = d->gtkWidget(entryPath);
+                    d->gtk_widget_set_direction(gtkEntry, reverse ? GTK_TEXT_DIR_RTL : GTK_TEXT_DIR_LTR);
+                    QRect frameRect = option->rect;
+
+                    if (reverse)
+                        frameRect.setLeft(arrowButtonRect.right());
+                    else
+                        frameRect.setRight(arrowButtonRect.left());
+
+                    // Fill the line edit background
+                    // We could have used flat_box with "entry_bg" but that is probably not worth the overhead
+                    uint resolve_mask = option->palette.resolve();
+                    GtkStyle *gtkEntryStyle = d->gtk_widget_get_style(gtkEntry);
+                    QRect contentRect = frameRect.adjusted(gtkEntryStyle->xthickness, gtkEntryStyle->ythickness,
+                                                           -gtkEntryStyle->xthickness, -gtkEntryStyle->ythickness);
+                    // Required for inner blue highlight with clearlooks
+                    if (focus)
+                        QGtkStylePrivate::gtkWidgetSetFocus(gtkEntry, true);
+
+                    if (widget && widget->testAttribute(Qt::WA_SetPalette) &&
+                        resolve_mask & (1 << QPalette::Base)) // Palette overridden by user
+                        p->fillRect(contentRect, option->palette.base().color());
+                    else {
+                        gtkPainter->paintFlatBox(gtkEntry, "entry_bg", contentRect,
+                                                 option->state & State_Enabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE,
+                                                 GTK_SHADOW_NONE, gtkEntryStyle, entryPath.toString() + QString::number(focus));
+                    }
+
+                    gtkPainter->paintShadow(gtkEntry, comboBox->editable ? "entry" : "frame", frameRect, frameState,
+                                            GTK_SHADOW_IN, gtkEntryStyle, entryPath.toString() +
+                                            QString::number(focus) + QString::number(comboBox->editable) +
+                                            QString::number(option->direction));
+                    if (focus)
+                        QGtkStylePrivate::gtkWidgetSetFocus(gtkEntry, false);
+                }
+
+                GtkStateType buttonState = GTK_STATE_NORMAL;
+
+                if (!(option->state & State_Enabled))
+                    buttonState = GTK_STATE_INSENSITIVE;
+                else if (option->state & State_Sunken || option->state & State_On)
+                    buttonState = GTK_STATE_ACTIVE;
+                else if (option->state & State_MouseOver && comboBox->activeSubControls & SC_ComboBoxArrow)
+                    buttonState = GTK_STATE_PRELIGHT;
+
+                Q_ASSERT(gtkToggleButton);
+                gtkPainter->paintBox(gtkToggleButton, "button", arrowButtonRect, buttonState,
+                                     shadow, d->gtk_widget_get_style(gtkToggleButton), buttonPath.toString() +
+                                     QString::number(focus) + QString::number(option->direction));
+                if (focus)
+                    QGtkStylePrivate::gtkWidgetSetFocus(gtkToggleButton, false);
+            } else {
+                // Draw combo box as a button
+                QRect buttonRect = option->rect;
+                GtkStyle *gtkToggleButtonStyle = d->gtk_widget_get_style(gtkToggleButton);
+
+                if (focus) // Clearlooks actually check the widget for the default state
+                    QGtkStylePrivate::gtkWidgetSetFocus(gtkToggleButton, true);
+                gtkPainter->paintBox(gtkToggleButton, "button",
+                                     buttonRect, state,
+                                     shadow, gtkToggleButtonStyle,
+                                     buttonPath.toString() + QString::number(focus));
+                if (focus)
+                    QGtkStylePrivate::gtkWidgetSetFocus(gtkToggleButton, false);
+
+
+                // Draw the separator between label and arrows
+                QHashableLatin1Literal vSeparatorPath = comboBox->editable
+                    ? QHashableLatin1Literal("GtkComboBoxEntry.GtkToggleButton.GtkHBox.GtkVSeparator")
+                    : QHashableLatin1Literal("GtkComboBox.GtkToggleButton.GtkHBox.GtkVSeparator");
+
+                if (GtkWidget *gtkVSeparator = d->gtkWidget(vSeparatorPath)) {
+                    GtkAllocation allocation;
+                    d->gtk_widget_get_allocation(gtkVSeparator, &allocation);
+                    QRect vLineRect(allocation.x, allocation.y, allocation.width, allocation.height);
+
+                    gtkPainter->paintVline(gtkVSeparator, "vseparator",
+                                           vLineRect, state, d->gtk_widget_get_style(gtkVSeparator),
+                                           0, vLineRect.height(), 0, vSeparatorPath.toString());
+
+
+                    gint interiorFocus = true;
+                    d->gtk_widget_style_get(gtkToggleButton, "interior-focus", &interiorFocus, NULL);
+                    int xt = interiorFocus ? gtkToggleButtonStyle->xthickness : 0;
+                    int yt = interiorFocus ? gtkToggleButtonStyle->ythickness : 0;
+                    if (focus && ((option->state & State_KeyboardFocusChange) || styleHint(SH_UnderlineShortcut, option, widget)))
+                        gtkPainter->paintFocus(gtkToggleButton, "button",
+                                               option->rect.adjusted(xt, yt, -xt, -yt),
+                                               option->state & State_Sunken ? GTK_STATE_ACTIVE : GTK_STATE_NORMAL,
+                                               gtkToggleButtonStyle);
+                }
+            }
+
+            if (comboBox->subControls & SC_ComboBoxArrow) {
+                if (!isEnabled)
+                    state = GTK_STATE_INSENSITIVE;
+                else if (sunken)
+                    state = GTK_STATE_ACTIVE;
+                else if (option->state & State_MouseOver)
+                    state = GTK_STATE_PRELIGHT;
+                else
+                    state = GTK_STATE_NORMAL;
+
+                QHashableLatin1Literal arrowPath("");
+                if (comboBox->editable) {
+                    if (appears_as_list)
+                        arrowPath = QHashableLatin1Literal("GtkComboBoxEntry.GtkToggleButton.GtkArrow");
+                    else
+                        arrowPath = QHashableLatin1Literal("GtkComboBoxEntry.GtkToggleButton.GtkHBox.GtkArrow");
+                } else {
+                    if (appears_as_list)
+                        arrowPath = QHashableLatin1Literal("GtkComboBox.GtkToggleButton.GtkArrow");
+                    else
+                        arrowPath = QHashableLatin1Literal("GtkComboBox.GtkToggleButton.GtkHBox.GtkArrow");
+                }
+
+                GtkWidget *gtkArrow = d->gtkWidget(arrowPath);
+                gfloat scale = 0.7;
+                gint minSize = 15;
+                QRect arrowWidgetRect;
+
+                if (gtkArrow && !d->gtk_check_version(2, 12, 0)) {
+                    d->gtk_widget_style_get(gtkArrow, "arrow-scaling", &scale, NULL);
+                    d->gtk_widget_style_get(gtkCombo, "arrow-size", &minSize, NULL);
+                }
+                if (gtkArrow) {
+                    GtkAllocation allocation;
+                    d->gtk_widget_get_allocation(gtkArrow, &allocation);
+                    arrowWidgetRect = QRect(allocation.x, allocation.y, allocation.width, allocation.height);
+                    style = d->gtk_widget_get_style(gtkArrow);
+                }
+
+                // Note that for some reason the arrow-size is not properly respected with Hildon
+                // Hence we enforce the minimum "arrow-size" ourselves
+                int arrowSize = qMax(qMin(rect.height() - d->gtk_widget_get_style(gtkCombo)->ythickness * 2, minSize),
+                                     qMin(arrowWidgetRect.width(), arrowWidgetRect.height()));
+                QRect arrowRect(0, 0, static_cast<int>(arrowSize * scale), static_cast<int>(arrowSize * scale));
+
+                arrowRect.moveCenter(arrowWidgetRect.center());
+
+                if (sunken) {
+                    int xoff, yoff;
+                    const QHashableLatin1Literal toggleButtonPath = comboBox->editable
+                            ? QHashableLatin1Literal("GtkComboBoxEntry.GtkToggleButton")
+                            : QHashableLatin1Literal("GtkComboBox.GtkToggleButton");
+
+                    GtkWidget *gtkButton = d->gtkWidget(toggleButtonPath);
+                    d->gtk_widget_style_get(gtkButton, "child-displacement-x", &xoff, NULL);
+                    d->gtk_widget_style_get(gtkButton, "child-displacement-y", &yoff, NULL);
+                    arrowRect = arrowRect.adjusted(xoff, yoff, xoff, yoff);
+                }
+
+                // Some styles such as Nimbus paint outside the arrowRect
+                // hence we have provide the whole widget as the cliprect
+                if (gtkArrow) {
+                    gtkPainter->setClipRect(option->rect);
+                    gtkPainter->paintArrow(gtkArrow, "arrow", arrowRect,
+                                           GTK_ARROW_DOWN, state, GTK_SHADOW_NONE, true,
+                                           style, arrowPath.toString() + QString::number(option->direction));
+                }
+            }
+            END_STYLE_PIXMAPCACHE;
+        }
+        break;
+#endif // QT_NO_COMBOBOX
+#ifndef QT_NO_TOOLBUTTON
+
+    case CC_ToolButton:
+        if (const QStyleOptionToolButton *toolbutton
+                = qstyleoption_cast<const QStyleOptionToolButton *>(option)) {
+            QRect button, menuarea;
+            button = proxy()->subControlRect(control, toolbutton, SC_ToolButton, widget);
+            menuarea = proxy()->subControlRect(control, toolbutton, SC_ToolButtonMenu, widget);
+            State bflags = toolbutton->state & ~(State_Sunken | State_MouseOver);
+
+            if (bflags & State_AutoRaise)
+                if (!(bflags & State_MouseOver))
+                    bflags &= ~State_Raised;
+
+            State mflags = bflags;
+
+            if (toolbutton->state & State_Sunken) {
+                if (toolbutton->activeSubControls & SC_ToolButton)
+                    bflags |= State_Sunken;
+                if (toolbutton->activeSubControls & SC_ToolButtonMenu)
+                    mflags |= State_Sunken;
+            } else if (toolbutton->state & State_MouseOver) {
+                if (toolbutton->activeSubControls & SC_ToolButton)
+                    bflags |= State_MouseOver;
+                if (toolbutton->activeSubControls & SC_ToolButtonMenu)
+                    mflags |= State_MouseOver;
+            }
+
+            QStyleOption tool(0);
+
+            tool.palette = toolbutton->palette;
+
+            if (toolbutton->subControls & SC_ToolButton) {
+                if (bflags & (State_Sunken | State_On | State_Raised | State_MouseOver)) {
+                    tool.rect = button;
+                    tool.state = bflags;
+                    proxy()->drawPrimitive(PE_PanelButtonTool, &tool, painter, widget);
+                }
+            }
+
+            bool drawMenuArrow = toolbutton->features & QStyleOptionToolButton::HasMenu &&
+                                 !(toolbutton->features & QStyleOptionToolButton::MenuButtonPopup);
+            int popupArrowSize = drawMenuArrow ? 7 : 0;
+
+            if (toolbutton->state & State_HasFocus) {
+                QStyleOptionFocusRect fr;
+                fr.QStyleOption::operator=(*toolbutton);
+                fr.rect = proxy()->subControlRect(CC_ToolButton, toolbutton, SC_ToolButton, widget);
+                fr.rect.adjust(1, 1, -1, -1);
+                proxy()->drawPrimitive(PE_FrameFocusRect, &fr, painter, widget);
+            }
+
+            QStyleOptionToolButton label = *toolbutton;
+            label.state = bflags;
+            GtkWidget *gtkButton = d->gtkWidget("GtkToolButton.GtkButton");
+            QPalette pal = toolbutton->palette;
+            if (option->state & State_Enabled &&
+                option->state & State_MouseOver && !(widget && widget->testAttribute(Qt::WA_SetPalette))) {
+                GdkColor gdkText = d->gtk_widget_get_style(gtkButton)->fg[GTK_STATE_PRELIGHT];
+                QColor textColor = QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
+                pal.setBrush(QPalette::All, QPalette::ButtonText, textColor);
+                label.palette = pal;
+            }
+            label.rect = button.adjusted(style->xthickness, style->ythickness,
+                                        -style->xthickness - popupArrowSize, -style->ythickness);
+            proxy()->drawControl(CE_ToolButtonLabel, &label, painter, widget);
+
+            if (toolbutton->subControls & SC_ToolButtonMenu) {
+                tool.rect = menuarea;
+                tool.state = mflags;
+                if ((mflags & State_Enabled && (mflags & (State_Sunken | State_Raised | State_MouseOver))) || !(mflags & State_AutoRaise))
+                    proxy()->drawPrimitive(PE_IndicatorButtonDropDown, &tool, painter, widget);
+
+                proxy()->drawPrimitive(PE_IndicatorArrowDown, &tool, painter, widget);
+
+            } else if (drawMenuArrow) {
+                QRect ir = toolbutton->rect;
+                QStyleOptionToolButton newBtn = *toolbutton;
+                newBtn.rect = QRect(ir.right() - popupArrowSize - style->xthickness - 3, ir.height()/2 - 1, popupArrowSize, popupArrowSize);
+                proxy()->drawPrimitive(PE_IndicatorArrowDown, &newBtn, painter, widget);
+            }
+        }
+        break;
+
+#endif // QT_NO_TOOLBUTTON
+#ifndef QT_NO_SCROLLBAR
+
+    case CC_ScrollBar:
+        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+            GtkWidget *gtkHScrollBar = d->gtkWidget("GtkHScrollbar");
+            GtkWidget *gtkVScrollBar = d->gtkWidget("GtkVScrollbar");
+
+            // Fill background in case the scrollbar is partially transparent
+            painter->fillRect(option->rect, option->palette.background());
+
+            QRect rect = scrollBar->rect;
+            QRect scrollBarSubLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSubLine, widget);
+            QRect scrollBarAddLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarAddLine, widget);
+            QRect scrollBarSlider = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSlider, widget);
+            QRect grooveRect = proxy()->subControlRect(control, scrollBar, SC_ScrollBarGroove, widget);
+            bool horizontal = scrollBar->orientation == Qt::Horizontal;
+            GtkWidget * scrollbarWidget = horizontal ? gtkHScrollBar : gtkVScrollBar;
+            style = d->gtk_widget_get_style(scrollbarWidget);
+            gboolean trough_under_steppers = true;
+            gboolean trough_side_details = false;
+            gboolean activate_slider = false;
+            gboolean stepper_size = 14;
+            gint trough_border = 1;
+            if (!d->gtk_check_version(2, 10, 0)) {
+                d->gtk_widget_style_get((GtkWidget*)(scrollbarWidget),
+                                           "trough-border",         &trough_border,
+                                           "trough-side-details",   &trough_side_details,
+                                           "trough-under-steppers", &trough_under_steppers,
+                                           "activate-slider",       &activate_slider,
+                                           "stepper-size",          &stepper_size, NULL);
+            }
+            if (trough_under_steppers) {
+                scrollBarAddLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
+                scrollBarSubLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
+                scrollBarSlider.adjust(horizontal ? -trough_border : 0, horizontal ? 0 : -trough_border,
+                                       horizontal ? trough_border : 0, horizontal ? 0 : trough_border);
+            }
+
+            // Some styles check the position of scrollbars in order to determine
+            // if lines should be painted when the scrollbar is in max or min positions.
+            int maximum = 2;
+            int fakePos = 0;
+            bool reverse = (option->direction == Qt::RightToLeft);
+            if (scrollBar->minimum == scrollBar->maximum)
+                maximum = 0;
+            if (scrollBar->sliderPosition == scrollBar->maximum)
+                fakePos = maximum;
+            else if (scrollBar->sliderPosition > scrollBar->minimum)
+                fakePos = maximum - 1;
+
+
+            GtkRange *range = (GtkRange*)(horizontal ? gtkHScrollBar : gtkVScrollBar);
+            GtkAdjustment *adjustment = 0;
+
+            if (d->gtk_adjustment_configure)
+                adjustment = d->gtk_range_get_adjustment(range);
+            if (adjustment) {
+                d->gtk_adjustment_configure(adjustment, fakePos, 0, maximum, 0, 0, 0);
+            } else {
+                adjustment = (GtkAdjustment*)d->gtk_adjustment_new(fakePos, 0, maximum, 0, 0, 0);
+                d->gtk_range_set_adjustment(range, adjustment);
+            }
+
+            if (scrollBar->subControls & SC_ScrollBarGroove) {
+                GtkStateType state = GTK_STATE_ACTIVE;
+
+                if (!(option->state & State_Enabled))
+                    state = GTK_STATE_INSENSITIVE;
+
+                if (trough_under_steppers)
+                    grooveRect = option->rect;
+
+                gtkPainter->paintBox(scrollbarWidget, "trough", grooveRect, state, GTK_SHADOW_IN, style);
+            }
+
+            //paint slider
+            if (scrollBar->subControls & SC_ScrollBarSlider) {
+                GtkStateType state = GTK_STATE_NORMAL;
+
+                if (!(option->state & State_Enabled))
+                    state = GTK_STATE_INSENSITIVE;
+                else if (activate_slider &&
+                         option->state & State_Sunken && (scrollBar->activeSubControls & SC_ScrollBarSlider))
+                    state = GTK_STATE_ACTIVE;
+                else if (option->state & State_MouseOver && (scrollBar->activeSubControls & SC_ScrollBarSlider))
+                    state = GTK_STATE_PRELIGHT;
+
+                GtkShadowType shadow = GTK_SHADOW_OUT;
+
+                if (trough_under_steppers) {
+                    if (!horizontal)
+                        scrollBarSlider.adjust(trough_border, 0, -trough_border, 0);
+                    else
+                        scrollBarSlider.adjust(0, trough_border, 0, -trough_border);
+                }
+
+                gtkPainter->paintSlider(scrollbarWidget, "slider", scrollBarSlider, state, shadow, style,
+                                        horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL, QString(QLS("%0%1")).arg(fakePos).arg(maximum));
+            }
+
+            if (scrollBar->subControls & SC_ScrollBarAddLine) {
+                GtkAllocation vAllocation;
+                vAllocation.y = scrollBarAddLine.top();
+                vAllocation.height = scrollBarAddLine.height() - rect.height() + 6;
+                d->gtk_widget_set_allocation(gtkVScrollBar, &vAllocation);
+
+                GtkAllocation hAllocation;
+                hAllocation.x = scrollBarAddLine.right();
+                hAllocation.width = scrollBarAddLine.width() - rect.width();
+                d->gtk_widget_set_allocation(gtkHScrollBar, &hAllocation);
+
+                GtkShadowType shadow = GTK_SHADOW_OUT;
+                GtkStateType state = GTK_STATE_NORMAL;
+
+                if (!(option->state & State_Enabled) || (fakePos == maximum))
+                    state = GTK_STATE_INSENSITIVE;
+                else if (option->state & State_Sunken && (scrollBar->activeSubControls & SC_ScrollBarAddLine)) {
+                    state = GTK_STATE_ACTIVE;
+                    shadow = GTK_SHADOW_IN;
+
+                } else if (option->state & State_MouseOver && (scrollBar->activeSubControls & SC_ScrollBarAddLine))
+                    state = GTK_STATE_PRELIGHT;
+
+                gtkPainter->paintBox(scrollbarWidget,
+                                     horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine,
+                                     state, shadow, style, QLS("add"));
+
+                gtkPainter->paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine.adjusted(4, 4, -4, -4),
+                                       horizontal ? (reverse ? GTK_ARROW_LEFT : GTK_ARROW_RIGHT) :
+                                       GTK_ARROW_DOWN, state, GTK_SHADOW_NONE, false, style);
+            }
+
+            if (scrollBar->subControls & SC_ScrollBarSubLine) {
+                GtkAllocation vAllocation;
+                vAllocation.y = 0;
+                vAllocation.height = scrollBarSubLine.height();
+                d->gtk_widget_set_allocation(gtkVScrollBar, &vAllocation);
+
+                GtkAllocation hAllocation;
+                hAllocation.x = 0;
+                hAllocation.width = scrollBarSubLine.width();
+                d->gtk_widget_set_allocation(gtkHScrollBar, &hAllocation);
+
+                GtkShadowType shadow = GTK_SHADOW_OUT;
+                GtkStateType state = GTK_STATE_NORMAL;
+
+                if (!(option->state & State_Enabled) || (fakePos == 0))
+                    state = GTK_STATE_INSENSITIVE;
+                else if (option->state & State_Sunken && (scrollBar->activeSubControls & SC_ScrollBarSubLine)) {
+                    shadow = GTK_SHADOW_IN;
+                    state = GTK_STATE_ACTIVE;
+
+                } else if (option->state & State_MouseOver && (scrollBar->activeSubControls & SC_ScrollBarSubLine))
+                    state = GTK_STATE_PRELIGHT;
+
+                gtkPainter->paintBox(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine,
+                                     state, shadow, style, QLS("sub"));
+
+                gtkPainter->paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine.adjusted(4, 4, -4, -4),
+                                       horizontal ? (reverse ? GTK_ARROW_RIGHT : GTK_ARROW_LEFT) :
+                                       GTK_ARROW_UP, state, GTK_SHADOW_NONE, false, style);
+            }
+        }
+        break;
+
+#endif //QT_NO_SCROLLBAR
+#ifndef QT_NO_SPINBOX
+
+    case CC_SpinBox:
+        if (const QStyleOptionSpinBox *spinBox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
+
+            GtkWidget *gtkSpinButton = spinBox->buttonSymbols == QAbstractSpinBox::NoButtons
+                        ? d->gtkWidget("GtkEntry")
+                        : d->gtkWidget("GtkSpinButton");
+            bool isEnabled = (spinBox->state & State_Enabled);
+            bool hover = isEnabled && (spinBox->state & State_MouseOver);
+            bool sunken = (spinBox->state & State_Sunken);
+            bool upIsActive = (spinBox->activeSubControls == SC_SpinBoxUp);
+            bool downIsActive = (spinBox->activeSubControls == SC_SpinBoxDown);
+            bool reverse = (spinBox->direction == Qt::RightToLeft);
+
+            QRect editArea = option->rect;
+            QRect editRect = proxy()->subControlRect(CC_SpinBox, option, SC_SpinBoxEditField, widget);
+            QRect upRect, downRect, buttonRect;
+            if (spinBox->buttonSymbols != QAbstractSpinBox::NoButtons) {
+                upRect = proxy()->subControlRect(CC_SpinBox, option, SC_SpinBoxUp, widget);
+                downRect = proxy()->subControlRect(CC_SpinBox, option, SC_SpinBoxDown, widget);
+
+                //### Move this to subControlRect
+                upRect.setTop(option->rect.top());
+
+                if (reverse)
+                    upRect.setLeft(option->rect.left());
+                else
+                    upRect.setRight(option->rect.right());
+
+                downRect.setBottom(option->rect.bottom());
+
+                if (reverse)
+                    downRect.setLeft(option->rect.left());
+                else
+                    downRect.setRight(option->rect.right());
+
+                buttonRect = upRect | downRect;
+
+                if (reverse)
+                    editArea.setLeft(upRect.right());
+                else
+                    editArea.setRight(upRect.left());
+            }
+            if (spinBox->frame) {
+                GtkStateType state = qt_gtk_state(option);
+
+                if (!(option->state & State_Enabled))
+                    state = GTK_STATE_INSENSITIVE;
+                else if (option->state & State_HasFocus)
+                    state = GTK_STATE_NORMAL;
+                else if (state == GTK_STATE_PRELIGHT)
+                    state = GTK_STATE_NORMAL;
+
+                style = d->gtk_widget_get_style(gtkSpinButton);
+
+
+                QString key;
+
+                if (option->state & State_HasFocus) {
+                    key += QLatin1Char('f');
+                    QGtkStylePrivate::gtkWidgetSetFocus(gtkSpinButton, true);
+                }
+
+                uint resolve_mask = option->palette.resolve();
+
+                if (resolve_mask & (1 << QPalette::Base)) // Palette overridden by user
+                    painter->fillRect(editRect, option->palette.base().color());
+                else
+                    gtkPainter->paintFlatBox(gtkSpinButton, "entry_bg", editArea.adjusted(style->xthickness, style->ythickness,
+                                             -style->xthickness, -style->ythickness),
+                                             option->state & State_Enabled ?
+                                             GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE, GTK_SHADOW_NONE, style, key);
+
+                gtkPainter->paintShadow(gtkSpinButton, "entry", editArea, state, GTK_SHADOW_IN, d->gtk_widget_get_style(gtkSpinButton), key);
+                if (spinBox->buttonSymbols != QAbstractSpinBox::NoButtons) {
+                    gtkPainter->paintBox(gtkSpinButton, "spinbutton", buttonRect, state, GTK_SHADOW_IN, style, key);
+
+                    upRect.setSize(downRect.size());
+                    if (!(option->state & State_Enabled))
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_up", upRect, GTK_STATE_INSENSITIVE, GTK_SHADOW_IN, style, key);
+                    else if (upIsActive && sunken)
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_up", upRect, GTK_STATE_ACTIVE, GTK_SHADOW_IN, style, key);
+                    else if (upIsActive && hover)
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_up", upRect, GTK_STATE_PRELIGHT, GTK_SHADOW_OUT, style, key);
+                    else
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_up", upRect, GTK_STATE_NORMAL, GTK_SHADOW_OUT, style, key);
+
+                    if (!(option->state & State_Enabled))
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_down", downRect, GTK_STATE_INSENSITIVE, GTK_SHADOW_IN, style, key);
+                    else if (downIsActive && sunken)
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_down", downRect, GTK_STATE_ACTIVE, GTK_SHADOW_IN, style, key);
+                    else if (downIsActive && hover)
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_down", downRect, GTK_STATE_PRELIGHT, GTK_SHADOW_OUT, style, key);
+                    else
+                        gtkPainter->paintBox(gtkSpinButton, "spinbutton_down", downRect, GTK_STATE_NORMAL, GTK_SHADOW_OUT, style, key);
+
+                    if (option->state & State_HasFocus)
+                        QGtkStylePrivate::gtkWidgetSetFocus(gtkSpinButton, false);
+                }
+            }
+
+            if (spinBox->buttonSymbols == QAbstractSpinBox::PlusMinus) {
+                int centerX = upRect.center().x();
+                int centerY = upRect.center().y();
+                // plus/minus
+
+                if (spinBox->activeSubControls == SC_SpinBoxUp && sunken) {
+                    painter->drawLine(1 + centerX - 2, 1 + centerY, 1 + centerX + 2, 1 + centerY);
+                    painter->drawLine(1 + centerX, 1 + centerY - 2, 1 + centerX, 1 + centerY + 2);
+
+                } else {
+                    painter->drawLine(centerX - 2, centerY, centerX + 2, centerY);
+                    painter->drawLine(centerX, centerY - 2, centerX, centerY + 2);
+                }
+                centerX = downRect.center().x();
+                centerY = downRect.center().y();
+
+                if (spinBox->activeSubControls == SC_SpinBoxDown && sunken) {
+                    painter->drawLine(1 + centerX - 2, 1 + centerY, 1 + centerX + 2, 1 + centerY);
+                } else {
+                    painter->drawLine(centerX - 2, centerY, centerX + 2, centerY);
+                }
+
+            } else if (spinBox->buttonSymbols == QAbstractSpinBox::UpDownArrows) {
+                int size = d->getSpinboxArrowSize();
+                int w = size / 2 - 1;
+                w -= w % 2 - 1; // force odd
+                int h = (w + 1)/2;
+                QRect arrowRect(0, 0, w, h);
+                arrowRect.moveCenter(upRect.center());
+                // arrows
+                GtkStateType state = GTK_STATE_NORMAL;
+
+                if (!(option->state & State_Enabled) || !(spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled))
+                    state = GTK_STATE_INSENSITIVE;
+
+                gtkPainter->paintArrow(gtkSpinButton, "spinbutton", arrowRect, GTK_ARROW_UP, state,
+                                       GTK_SHADOW_NONE, false, style);
+
+                arrowRect.moveCenter(downRect.center());
+
+                if (!(option->state & State_Enabled) || !(spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled))
+                    state = GTK_STATE_INSENSITIVE;
+
+                gtkPainter->paintArrow(gtkSpinButton, "spinbutton", arrowRect, GTK_ARROW_DOWN, state,
+                                       GTK_SHADOW_NONE, false, style);
+            }
+        }
+        break;
+
+#endif // QT_NO_SPINBOX
+
+#ifndef QT_NO_SLIDER
+
+    case CC_Slider:
+        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+            GtkWidget *hScaleWidget = d->gtkWidget("GtkHScale");
+            GtkWidget *vScaleWidget = d->gtkWidget("GtkVScale");
+
+            QRect groove = proxy()->subControlRect(CC_Slider, option, SC_SliderGroove, widget);
+            QRect handle = proxy()->subControlRect(CC_Slider, option, SC_SliderHandle, widget);
+
+            bool horizontal = slider->orientation == Qt::Horizontal;
+            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
+            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
+
+            QBrush oldBrush = painter->brush();
+            QPen oldPen = painter->pen();
+
+            QColor shadowAlpha(Qt::black);
+            shadowAlpha.setAlpha(10);
+            QColor highlightAlpha(Qt::white);
+            highlightAlpha.setAlpha(80);
+
+            QGtkStylePrivate::gtk_widget_set_direction(hScaleWidget, slider->upsideDown ?
+                                                       GTK_TEXT_DIR_RTL : GTK_TEXT_DIR_LTR);
+            GtkWidget *scaleWidget = horizontal ? hScaleWidget : vScaleWidget;
+            style = d->gtk_widget_get_style(scaleWidget);
+
+            if ((option->subControls & SC_SliderGroove) && groove.isValid()) {
+
+                GtkRange *range = (GtkRange*)scaleWidget;
+                GtkAdjustment *adjustment = 0;
+                if (d->gtk_adjustment_configure)
+                    adjustment = d->gtk_range_get_adjustment(range);
+                if (adjustment) {
+                    d->gtk_adjustment_configure(adjustment,
+                                                slider->sliderPosition,
+                                                slider->minimum,
+                                                slider->maximum,
+                                                slider->singleStep,
+                                                slider->singleStep,
+                                                slider->pageStep);
+                } else {
+                    adjustment = (GtkAdjustment*)d->gtk_adjustment_new(slider->sliderPosition,
+                                                                       slider->minimum,
+                                                                       slider->maximum,
+                                                                       slider->singleStep,
+                                                                       slider->singleStep,
+                                                                       slider->pageStep);
+                    d->gtk_range_set_adjustment(range, adjustment);
+                }
+
+                int outerSize;
+                d->gtk_range_set_inverted(range, !horizontal);
+                d->gtk_widget_style_get(scaleWidget, "trough-border", &outerSize, NULL);
+                outerSize++;
+
+                GtkStateType state = qt_gtk_state(option);
+                int focusFrameMargin = 2;
+                QRect grooveRect = option->rect.adjusted(focusFrameMargin, outerSize + focusFrameMargin,
+                                   -focusFrameMargin, -outerSize - focusFrameMargin);
+
+                gboolean trough_side_details = false; // Indicates if the upper or lower scale background differs
+                if (!d->gtk_check_version(2, 10, 0))
+                    d->gtk_widget_style_get((GtkWidget*)(scaleWidget), "trough-side-details", &trough_side_details, NULL);
+
+                if (!trough_side_details) {
+                    gtkPainter->paintBox(scaleWidget, "trough", grooveRect, state,
+                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
+                } else {
+                    QRect upperGroove = grooveRect;
+                    QRect lowerGroove = grooveRect;
+
+                    if (horizontal) {
+                        if (slider->upsideDown) {
+                            lowerGroove.setLeft(handle.center().x());
+                            upperGroove.setRight(handle.center().x());
+                        } else {
+                            upperGroove.setLeft(handle.center().x());
+                            lowerGroove.setRight(handle.center().x());
+                        }
+                    } else {
+                        if (!slider->upsideDown) {
+                            lowerGroove.setBottom(handle.center().y());
+                            upperGroove.setTop(handle.center().y());
+                        } else {
+                            upperGroove.setBottom(handle.center().y());
+                            lowerGroove.setTop(handle.center().y());
+                        }
+                    }
+
+                    gtkPainter->paintBox(scaleWidget, "trough-upper", upperGroove, state,
+                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
+                    gtkPainter->paintBox(scaleWidget, "trough-lower", lowerGroove, state,
+                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
+                }
+            }
+
+            if (option->subControls & SC_SliderTickmarks) {
+                painter->setPen(darkOutline);
+                int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
+                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
+                int interval = slider->tickInterval;
+
+                if (interval <= 0) {
+                    interval = slider->singleStep;
+
+                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
+                                                        available)
+                            - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
+                                                              0, available) < 3)
+                        interval = slider->pageStep;
+                }
+
+                if (interval <= 0)
+                    interval = 1;
+
+                int v = slider->minimum;
+                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
+                while (v <= slider->maximum + 1) {
+                    if (v == slider->maximum + 1 && interval == 1)
+                        break;
+                    const int v_ = qMin(v, slider->maximum);
+                    int pos = sliderPositionFromValue(slider->minimum, slider->maximum,
+                                                      v_, (horizontal
+                                                           ? slider->rect.width()
+                                                           : slider->rect.height()) - len,
+                                                      slider->upsideDown) + len / 2;
+                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
+                    if (horizontal) {
+                        if (ticksAbove)
+                            painter->drawLine(pos, slider->rect.top() + extra,
+                                              pos, slider->rect.top() + tickSize);
+                        if (ticksBelow)
+                            painter->drawLine(pos, slider->rect.bottom() - extra,
+                                              pos, slider->rect.bottom() - tickSize);
+
+                    } else {
+                        if (ticksAbove)
+                            painter->drawLine(slider->rect.left() + extra, pos,
+                                              slider->rect.left() + tickSize, pos);
+                        if (ticksBelow)
+                            painter->drawLine(slider->rect.right() - extra, pos,
+                                              slider->rect.right() - tickSize, pos);
+                    }
+
+                    // In the case where maximum is max int
+                    int nextInterval = v + interval;
+                    if (nextInterval < v)
+                        break;
+                    v = nextInterval;
+                }
+            }
+
+            // Draw slider handle
+            if (option->subControls & SC_SliderHandle) {
+                GtkShadowType shadow =  GTK_SHADOW_OUT;
+                GtkStateType state = GTK_STATE_NORMAL;
+
+                if (!(option->state & State_Enabled))
+                    state = GTK_STATE_INSENSITIVE;
+                else if (option->state & State_MouseOver && option->activeSubControls & SC_SliderHandle)
+                    state = GTK_STATE_PRELIGHT;
+
+                bool horizontal = option->state & State_Horizontal;
+
+                if (slider->state & State_HasFocus) {
+                    QStyleOptionFocusRect fropt;
+                    fropt.QStyleOption::operator=(*slider);
+                    fropt.rect = slider->rect.adjusted(-1, -1 ,1, 1);
+
+                    if (horizontal) {
+                        fropt.rect.setTop(handle.top() - 3);
+                        fropt.rect.setBottom(handle.bottom() + 4);
+
+                    } else {
+                        fropt.rect.setLeft(handle.left() - 3);
+                        fropt.rect.setRight(handle.right() + 3);
+                    }
+                    proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
+                }
+                gtkPainter->paintSlider(scaleWidget, horizontal ? "hscale" : "vscale", handle, state, shadow, style,
+                                        horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL);
+            }
+            painter->setBrush(oldBrush);
+            painter->setPen(oldPen);
+        }
+        break;
+    case CC_Dial:
+        if (const QStyleOptionSlider *dial = qstyleoption_cast<const QStyleOptionSlider *>(option))
+            QStyleHelper::drawDial(dial, painter);
+        break;
+
+#endif // QT_NO_SLIDER
+
+    default:
+        QCommonStyle::drawComplexControl(control, option, painter, widget);
+
+        break;
+    }
+}
+
+
+/*!
+    \reimp
+*/
+void QGtkStyle::drawControl(ControlElement element,
+                            const QStyleOption *option,
+                            QPainter *painter,
+                            const QWidget *widget) const
+{
+    Q_D(const QGtkStyle);
+
+    if (!d->isThemeAvailable()) {
+        QCommonStyle::drawControl(element, option, painter, widget);
+        return;
+    }
+
+    GtkStyle* style = d->gtkStyle();
+    QGtkPainter* gtkPainter = d->gtkPainter(painter);
+
+    switch (element) {
+    case CE_ProgressBarLabel:
+        if (const QStyleOptionProgressBar *bar = qstyleoption_cast<const QStyleOptionProgressBar *>(option)) {
+            GtkWidget *gtkProgressBar = d->gtkWidget("GtkProgressBar");
+            if (!gtkProgressBar)
+                return;
+
+            QRect leftRect;
+            QRect rect = bar->rect;
+            GtkStyle *gtkProgressBarStyle = d->gtk_widget_get_style(gtkProgressBar);
+            GdkColor gdkText = gtkProgressBarStyle->fg[GTK_STATE_NORMAL];
+            QColor textColor = QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
+            gdkText = gtkProgressBarStyle->fg[GTK_STATE_PRELIGHT];
+            QColor alternateTextColor= QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
+
+            painter->save();
+            bool vertical = false, inverted = false;
+            if (const QStyleOptionProgressBarV2 *bar2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(option)) {
+                vertical = (bar2->orientation == Qt::Vertical);
+                inverted = bar2->invertedAppearance;
+            }
+            if (vertical)
+                rect = QRect(rect.left(), rect.top(), rect.height(), rect.width()); // flip width and height
+            const int progressIndicatorPos = (bar->progress - qreal(bar->minimum)) * rect.width() /
+                                              qMax(qreal(1.0), qreal(bar->maximum) - bar->minimum);
+            if (progressIndicatorPos >= 0 && progressIndicatorPos <= rect.width())
+                leftRect = QRect(rect.left(), rect.top(), progressIndicatorPos, rect.height());
+            if (vertical)
+                leftRect.translate(rect.width() - progressIndicatorPos, 0);
+
+            bool flip = (!vertical && (((bar->direction == Qt::RightToLeft) && !inverted) ||
+                                       ((bar->direction == Qt::LeftToRight) && inverted)));
+
+            QRegion rightRect = rect;
+            rightRect = rightRect.subtracted(leftRect);
+            painter->setClipRegion(rightRect);
+            painter->setPen(flip ? alternateTextColor : textColor);
+            painter->drawText(rect, bar->text, QTextOption(Qt::AlignAbsolute | Qt::AlignHCenter | Qt::AlignVCenter));
+            if (!leftRect.isNull()) {
+                painter->setPen(flip ? textColor : alternateTextColor);
+                painter->setClipRect(leftRect);
+                painter->drawText(rect, bar->text, QTextOption(Qt::AlignAbsolute | Qt::AlignHCenter | Qt::AlignVCenter));
+            }
+            painter->restore();
+        }
+        break;
+    case CE_PushButtonLabel:
+        if (const QStyleOptionButton *button = qstyleoption_cast<const QStyleOptionButton *>(option)) {
+            QRect ir = button->rect;
+            uint tf = Qt::AlignVCenter | Qt::TextShowMnemonic;
+            QPoint buttonShift;
+
+            if (option->state & State_Sunken)
+                buttonShift = QPoint(pixelMetric(PM_ButtonShiftHorizontal, option, widget),
+                                     proxy()->pixelMetric(PM_ButtonShiftVertical, option, widget));
+
+            if (proxy()->styleHint(SH_UnderlineShortcut, button, widget))
+                tf |= Qt::TextShowMnemonic;
+            else
+                tf |= Qt::TextHideMnemonic;
+
+            if (!button->icon.isNull()) {
+                //Center both icon and text
+                QPoint point;
+
+                QIcon::Mode mode = button->state & State_Enabled ? QIcon::Normal : QIcon::Disabled;
+                if (mode == QIcon::Normal && button->state & State_HasFocus)
+                    mode = QIcon::Active;
+
+                QIcon::State state = QIcon::Off;
+
+                if (button->state & State_On)
+                    state = QIcon::On;
+
+                QPixmap pixmap = button->icon.pixmap(button->iconSize, mode, state);
+                int w = pixmap.width();
+                int h = pixmap.height();
+
+                if (!button->text.isEmpty())
+                    w += button->fontMetrics.boundingRect(option->rect, tf, button->text).width() + 4;
+
+                point = QPoint(ir.x() + ir.width() / 2 - w / 2,
+                               ir.y() + ir.height() / 2 - h / 2);
+
+                if (button->direction == Qt::RightToLeft)
+                    point.rx() += pixmap.width();
+
+                painter->drawPixmap(visualPos(button->direction, button->rect, point + buttonShift), pixmap);
+
+                if (button->direction == Qt::RightToLeft)
+                    ir.translate(-point.x() - 2, 0);
+                else
+                    ir.translate(point.x() + pixmap.width() + 2, 0);
+
+                // left-align text if there is
+                if (!button->text.isEmpty())
+                    tf |= Qt::AlignLeft;
+
+            } else {
+                tf |= Qt::AlignHCenter;
+            }
+
+            ir.translate(buttonShift);
+
+            if (button->features & QStyleOptionButton::HasMenu)
+                ir = ir.adjusted(0, 0, -pixelMetric(PM_MenuButtonIndicator, button, widget), 0);
+
+            GtkWidget *gtkButton = d->gtkWidget("GtkButton");
+            QPalette pal = button->palette;
+            int labelState = GTK_STATE_INSENSITIVE;
+            if (option->state & State_Enabled)
+                labelState = (option->state & State_MouseOver && !(option->state & State_Sunken)) ?
+                             GTK_STATE_PRELIGHT : GTK_STATE_NORMAL;
+
+            GdkColor gdkText = d->gtk_widget_get_style(gtkButton)->fg[labelState];
+            QColor textColor = QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
+            pal.setBrush(QPalette::ButtonText, textColor);
+            proxy()->drawItemText(painter, ir, tf, pal, (button->state & State_Enabled),
+                         button->text, QPalette::ButtonText);
+        }
+        break;
+
+    case CE_RadioButton: // Fall through
+    case CE_CheckBox:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(option)) {
+            bool isRadio = (element == CE_RadioButton);
+
+            // Draw prelight background
+            GtkWidget *gtkRadioButton = d->gtkWidget("GtkRadioButton");
+
+            if (option->state & State_MouseOver) {
+                gtkPainter->paintFlatBox(gtkRadioButton, "checkbutton", option->rect,
+                                         GTK_STATE_PRELIGHT, GTK_SHADOW_ETCHED_OUT, d->gtk_widget_get_style(gtkRadioButton));
+            }
+
+            QStyleOptionButton subopt = *btn;
+            subopt.rect = subElementRect(isRadio ? SE_RadioButtonIndicator
+                                         : SE_CheckBoxIndicator, btn, widget);
+            proxy()->drawPrimitive(isRadio ? PE_IndicatorRadioButton : PE_IndicatorCheckBox,
+                          &subopt, painter, widget);
+            subopt.rect = subElementRect(isRadio ? SE_RadioButtonContents
+                                         : SE_CheckBoxContents, btn, widget);
+            // Get label text color
+            QPalette pal = subopt.palette;
+            int labelState = GTK_STATE_INSENSITIVE;
+            if (option->state & State_Enabled)
+                labelState = (option->state & State_MouseOver) ? GTK_STATE_PRELIGHT : GTK_STATE_NORMAL;
+
+            GdkColor gdkText = d->gtk_widget_get_style(gtkRadioButton)->fg[labelState];
+            QColor textColor = QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
+            pal.setBrush(QPalette::WindowText, textColor);
+            subopt.palette = pal;
+            proxy()->drawControl(isRadio ? CE_RadioButtonLabel : CE_CheckBoxLabel, &subopt, painter, widget);
+
+            if (btn->state & State_HasFocus) {
+                QStyleOptionFocusRect fropt;
+                fropt.QStyleOption::operator=(*btn);
+                fropt.rect = subElementRect(isRadio ? SE_RadioButtonFocusRect
+                                            : SE_CheckBoxFocusRect, btn, widget);
+                proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
+            }
+        }
+        break;
+
+#ifndef QT_NO_COMBOBOX
+
+    case CE_ComboBoxLabel:
+        if (const QStyleOptionComboBox *cb = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
+            QRect editRect = proxy()->subControlRect(CC_ComboBox, cb, SC_ComboBoxEditField, widget);
+            bool appearsAsList = !proxy()->styleHint(QStyle::SH_ComboBox_Popup, cb, widget);
+            painter->save();
+            painter->setClipRect(editRect);
+
+            if (!cb->currentIcon.isNull()) {
+                QIcon::Mode mode = cb->state & State_Enabled ? QIcon::Normal
+                                   : QIcon::Disabled;
+                QPixmap pixmap = cb->currentIcon.pixmap(cb->iconSize, mode);
+                QRect iconRect(editRect);
+                iconRect.setWidth(cb->iconSize.width() + 4);
+
+                iconRect = alignedRect(cb->direction,
+                                       Qt::AlignLeft | Qt::AlignVCenter,
+                                       iconRect.size(), editRect);
+
+                if (cb->editable)
+                    painter->fillRect(iconRect, option->palette.brush(QPalette::Base));
+
+                proxy()->drawItemPixmap(painter, iconRect, Qt::AlignCenter, pixmap);
+
+                if (cb->direction == Qt::RightToLeft)
+                    editRect.translate(-4 - cb->iconSize.width(), 0);
+                else
+                    editRect.translate(cb->iconSize.width() + 4, 0);
+            }
+
+            if (!cb->currentText.isEmpty() && !cb->editable) {
+                GtkWidget *gtkCombo = d->gtkWidget("GtkComboBox");
+                QPalette pal = cb->palette;
+                int labelState = GTK_STATE_INSENSITIVE;
+
+                if (option->state & State_Enabled)
+                    labelState = (option->state & State_MouseOver && !appearsAsList) ? GTK_STATE_PRELIGHT : GTK_STATE_NORMAL;
+
+                GdkColor gdkText = d->gtk_widget_get_style(gtkCombo)->fg[labelState];
+
+                QColor textColor = QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
+
+                pal.setBrush(QPalette::ButtonText, textColor);
+
+                proxy()->drawItemText(painter, editRect.adjusted(1, 0, -1, 0),
+                             visualAlignment(cb->direction, Qt::AlignLeft | Qt::AlignVCenter),
+                             pal, cb->state & State_Enabled, cb->currentText, QPalette::ButtonText);
+            }
+
+            painter->restore();
+        }
+        break;
+
+#endif // QT_NO_COMBOBOX
+
+    case CE_DockWidgetTitle:
+        painter->save();
+        if (const QStyleOptionDockWidget *dwOpt = qstyleoption_cast<const QStyleOptionDockWidget *>(option)) {
+            const QStyleOptionDockWidgetV2 *v2
+                = qstyleoption_cast<const QStyleOptionDockWidgetV2*>(dwOpt);
+            bool verticalTitleBar = v2 == 0 ? false : v2->verticalTitleBar;
+
+            QRect rect = dwOpt->rect;
+            QRect titleRect = subElementRect(SE_DockWidgetTitleBarText, option, widget).adjusted(-2, 0, -2, 0);
+            QRect r = rect.adjusted(0, 0, -1, -1);
+            if (verticalTitleBar)
+                r.adjust(0, 0, 0, -1);
+
+            if (verticalTitleBar) {
+                QRect r = rect;
+                QSize s = r.size();
+                s.transpose();
+                r.setSize(s);
+
+                titleRect = QRect(r.left() + rect.bottom()
+                                    - titleRect.bottom(),
+                                r.top() + titleRect.left() - rect.left(),
+                                titleRect.height(), titleRect.width());
+
+                painter->translate(r.left(), r.top() + r.width());
+                painter->rotate(-90);
+                painter->translate(-r.left(), -r.top());
+
+                rect = r;
+            }
+
+            if (!dwOpt->title.isEmpty()) {
+                QString titleText
+                    = painter->fontMetrics().elidedText(dwOpt->title,
+                                            Qt::ElideRight, titleRect.width());
+                proxy()->drawItemText(painter,
+                             titleRect,
+                             Qt::AlignLeft | Qt::AlignVCenter | Qt::TextShowMnemonic, dwOpt->palette,
+                             dwOpt->state & State_Enabled, titleText,
+                             QPalette::WindowText);
+                }
+        }
+        painter->restore();
+        break;
+
+
+
+    case CE_HeaderSection:
+        painter->save();
+
+        // Draws the header in tables.
+        if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(option)) {
+            Q_UNUSED(header);
+            GtkWidget *gtkTreeView = d->gtkWidget("GtkTreeView");
+            // Get the middle column
+            GtkTreeViewColumn *column = d->gtk_tree_view_get_column((GtkTreeView*)gtkTreeView, 1);
+            Q_ASSERT(column);
+
+            GtkWidget *gtkTreeHeader = column->button;
+            GtkStateType state = qt_gtk_state(option);
+            GtkShadowType shadow = GTK_SHADOW_OUT;
+
+            if (option->state & State_Sunken)
+                shadow = GTK_SHADOW_IN;
+
+            gtkPainter->paintBox(gtkTreeHeader, "button", option->rect.adjusted(-1, 0, 0, 0), state, shadow, d->gtk_widget_get_style(gtkTreeHeader));
+        }
+
+        painter->restore();
+        break;
+
+#ifndef QT_NO_SIZEGRIP
+
+    case CE_SizeGrip: {
+        GtkWidget *gtkStatusbar = d->gtkWidget("GtkStatusbar.GtkFrame");
+        GtkStyle *gtkStatusbarStyle = d->gtk_widget_get_style(gtkStatusbar);
+        QRect gripRect = option->rect.adjusted(0, 0, -gtkStatusbarStyle->xthickness, -gtkStatusbarStyle->ythickness);
+        gtkPainter->paintResizeGrip(gtkStatusbar, "statusbar", gripRect, GTK_STATE_NORMAL,
+                                    GTK_SHADOW_OUT, option->direction == Qt::RightToLeft ?
+                                    GDK_WINDOW_EDGE_SOUTH_WEST : GDK_WINDOW_EDGE_SOUTH_EAST,
+                                    gtkStatusbarStyle);
+    }
+    break;
+
+#endif // QT_NO_SIZEGRIP
+
+    case CE_MenuBarEmptyArea: {
+        GtkWidget *gtkMenubar = d->gtkWidget("GtkMenuBar");
+        GdkColor gdkBg = d->gtk_widget_get_style(gtkMenubar)->bg[GTK_STATE_NORMAL]; // Theme can depend on transparency
+        painter->fillRect(option->rect, QColor(gdkBg.red>>8, gdkBg.green>>8, gdkBg.blue>>8));
+        if (widget) { // See CE_MenuBarItem
+            QRect menuBarRect = widget->rect();
+            QPixmap pixmap(menuBarRect.size());
+            pixmap.fill(Qt::transparent);
+            QPainter pmPainter(&pixmap);
+            gtkPainter->reset(&pmPainter);
+            GtkShadowType shadow_type;
+            d->gtk_widget_style_get(gtkMenubar, "shadow-type", &shadow_type, NULL);
+            gtkPainter->paintBox(gtkMenubar, "menubar", menuBarRect,
+                                 GTK_STATE_NORMAL, shadow_type, d->gtk_widget_get_style(gtkMenubar));
+            pmPainter.end();
+            painter->drawPixmap(option->rect, pixmap, option->rect);
+            gtkPainter->reset(painter);
+        }
+    }
+    break;
+
+    case CE_MenuBarItem:
+        painter->save();
+
+        if (const QStyleOptionMenuItem *mbi = qstyleoption_cast<const QStyleOptionMenuItem *>(option)) {
+            GtkWidget *gtkMenubarItem = d->gtkWidget("GtkMenuBar.GtkMenuItem");
+            GtkWidget *gtkMenubar = d->gtkWidget("GtkMenuBar");
+
+            style = d->gtk_widget_get_style(gtkMenubarItem);
+
+            if (widget) {
+                // Since Qt does not currently allow filling the entire background
+                // we use a hack for this by making a complete menubar each time and
+                // paint with the correct offset inside it. Pixmap caching should resolve
+                // most of the performance penalty.
+                QRect menuBarRect = widget->rect();
+                QPixmap pixmap(menuBarRect.size());
+                pixmap.fill(Qt::transparent);
+                QPainter pmPainter(&pixmap);
+                gtkPainter->reset(&pmPainter);
+                GtkShadowType shadow_type;
+                d->gtk_widget_style_get(gtkMenubar, "shadow-type", &shadow_type, NULL);
+                GdkColor gdkBg = d->gtk_widget_get_style(gtkMenubar)->bg[GTK_STATE_NORMAL]; // Theme can depend on transparency
+                painter->fillRect(option->rect, QColor(gdkBg.red>>8, gdkBg.green>>8, gdkBg.blue>>8));
+                gtkPainter->paintBox(gtkMenubar, "menubar", menuBarRect,
+                                     GTK_STATE_NORMAL, shadow_type, d->gtk_widget_get_style(gtkMenubar));
+                pmPainter.end();
+                painter->drawPixmap(option->rect, pixmap, option->rect);
+                gtkPainter->reset(painter);
+            }
+
+            QStyleOptionMenuItem item = *mbi;
+            bool act = mbi->state & State_Selected && mbi->state & State_Sunken;
+            bool dis = !(mbi->state & State_Enabled);
+            item.rect = mbi->rect;
+            GdkColor gdkText = style->fg[dis ? GTK_STATE_INSENSITIVE : GTK_STATE_NORMAL];
+            GdkColor gdkHText = style->fg[GTK_STATE_PRELIGHT];
+            QColor normalTextColor = QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
+            QColor highlightedTextColor = QColor(gdkHText.red>>8, gdkHText.green>>8, gdkHText.blue>>8);
+            item.palette.setBrush(QPalette::HighlightedText, highlightedTextColor);
+            item.palette.setBrush(QPalette::Text, normalTextColor);
+            item.palette.setBrush(QPalette::ButtonText, normalTextColor);
+            QCommonStyle::drawControl(element, &item, painter, widget);
+
+            if (act) {
+                GtkShadowType shadowType = GTK_SHADOW_NONE;
+                d->gtk_widget_style_get (gtkMenubarItem, "selected-shadow-type", &shadowType, NULL);
+                gtkPainter->paintBox(gtkMenubarItem, "menuitem", option->rect.adjusted(0, 0, 0, 3),
+                                     GTK_STATE_PRELIGHT, shadowType, style);
+                //draw text
+                QPalette::ColorRole textRole = dis ? QPalette::Text : QPalette::HighlightedText;
+                uint alignment = Qt::AlignCenter | Qt::TextShowMnemonic | Qt::TextDontClip | Qt::TextSingleLine;
+
+                if (!proxy()->styleHint(SH_UnderlineShortcut, mbi, widget))
+                    alignment |= Qt::TextHideMnemonic;
+
+                proxy()->drawItemText(painter, item.rect, alignment, item.palette, mbi->state & State_Enabled, mbi->text, textRole);
+            }
+        }
+        painter->restore();
+        break;
+
+    case CE_Splitter: {
+        GtkWidget *gtkWindow = d->gtkWidget("GtkWindow"); // The Murrine Engine currently assumes a widget is passed
+        gtkPainter->paintHandle(gtkWindow, "splitter", option->rect, qt_gtk_state(option), GTK_SHADOW_NONE,
+                                !(option->state & State_Horizontal) ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL,
+                                style);
+    }
+    break;
+
+#ifndef QT_NO_TOOLBAR
+
+    case CE_ToolBar:
+        if (const QStyleOptionToolBar *toolbar = qstyleoption_cast<const QStyleOptionToolBar *>(option)) {
+            // Reserve the beveled appearance only for mainwindow toolbars
+            if (!(widget && qobject_cast<const QMainWindow*> (widget->parentWidget())))
+                break;
+
+            QRect rect = option->rect;
+            // There is a 1 pixel gap between toolbar lines in some styles (i.e Human)
+            if (toolbar->positionWithinLine != QStyleOptionToolBar::End)
+                rect.adjust(0, 0, 1, 0);
+
+            GtkWidget *gtkToolbar = d->gtkWidget("GtkToolbar");
+            GtkShadowType shadow_type = GTK_SHADOW_NONE;
+            d->gtk_widget_style_get(gtkToolbar, "shadow-type", &shadow_type, NULL);
+            gtkPainter->paintBox(gtkToolbar, "toolbar", rect,
+                                 GTK_STATE_NORMAL, shadow_type, d->gtk_widget_get_style(gtkToolbar));
+        }
+        break;
+
+#endif // QT_NO_TOOLBAR
+
+    case CE_MenuItem:
+        painter->save();
+
+        // Draws one item in a popup menu.
+        if (const QStyleOptionMenuItem *menuItem = qstyleoption_cast<const QStyleOptionMenuItem *>(option)) {
+            const int windowsItemHMargin      =  3; // menu item hor text margin
+            const int windowsItemVMargin      = 26; // menu item ver text margin
+            GtkWidget *gtkMenuItem = menuItem->checked ? d->gtkWidget("GtkMenu.GtkCheckMenuItem") :
+                                     d->gtkWidget("GtkMenu.GtkMenuItem");
+
+            style = d->gtk_widget_get_style(gtkMenuItem);
+            QColor shadow = option->palette.dark().color();
+
+            if (menuItem->menuItemType == QStyleOptionMenuItem::Separator) {
+                GtkWidget *gtkMenuSeparator = d->gtkWidget("GtkMenu.GtkSeparatorMenuItem");
+                painter->setPen(shadow.lighter(106));
+                gboolean wide_separators = 0;
+                gint     separator_height = 0;
+                guint    horizontal_padding = 3;
+                QRect separatorRect = option->rect;
+                if (!d->gtk_check_version(2, 10, 0)) {
+                    d->gtk_widget_style_get(gtkMenuSeparator,
+                                           "wide-separators",    &wide_separators,
+                                           "separator-height",   &separator_height,
+                                           "horizontal-padding", &horizontal_padding,
+                                           NULL);
+                }
+                GtkStyle *gtkMenuSeparatorStyle = d->gtk_widget_get_style(gtkMenuSeparator);
+                separatorRect.setHeight(option->rect.height() - 2 * gtkMenuSeparatorStyle->ythickness);
+                separatorRect.setWidth(option->rect.width() - 2 * (horizontal_padding + gtkMenuSeparatorStyle->xthickness));
+                separatorRect.moveCenter(option->rect.center());
+                if (wide_separators)
+                   gtkPainter->paintBox(gtkMenuSeparator, "hseparator",
+                                        separatorRect, GTK_STATE_NORMAL, GTK_SHADOW_NONE, gtkMenuSeparatorStyle);
+                else
+                    gtkPainter->paintHline(gtkMenuSeparator, "hseparator",
+                                           separatorRect, GTK_STATE_NORMAL, gtkMenuSeparatorStyle,
+                                           0, option->rect.right() - 1, 1);
+                painter->restore();
+                break;
+            }
+
+            bool selected = menuItem->state & State_Selected && menuItem->state & State_Enabled;
+
+            if (selected) {
+                QRect rect = option->rect;
+#ifndef QT_NO_COMBOBOX
+                if (qobject_cast<const QComboBox*>(widget))
+                    rect = option->rect;
+#endif
+                gtkPainter->paintBox(gtkMenuItem, "menuitem", rect, GTK_STATE_PRELIGHT, GTK_SHADOW_OUT, style);
+            }
+
+            bool checkable = menuItem->checkType != QStyleOptionMenuItem::NotCheckable;
+            bool checked = menuItem->checked;
+            bool enabled = menuItem->state & State_Enabled;
+            bool ignoreCheckMark = false;
+
+            gint checkSize;
+            d->gtk_widget_style_get(d->gtkWidget("GtkMenu.GtkCheckMenuItem"), "indicator-size", &checkSize, NULL);
+
+            int checkcol = qMax(menuItem->maxIconWidth, qMax(20, checkSize));
+
+#ifndef QT_NO_COMBOBOX
+
+            if (qobject_cast<const QComboBox*>(widget) ||
+                (option->styleObject && option->styleObject->property("_q_isComboBoxPopupItem").toBool()))
+                ignoreCheckMark = true; // Ignore the checkmarks provided by the QComboMenuDelegate
+
+#endif
+            if (!ignoreCheckMark) {
+                // Check
+                QRect checkRect(option->rect.left() + 7, option->rect.center().y() - checkSize/2 + 1, checkSize, checkSize);
+                checkRect = visualRect(menuItem->direction, menuItem->rect, checkRect);
+
+                if (checkable && menuItem->icon.isNull()) {
+                    // Some themes such as aero-clone draw slightly outside the paint rect
+                    int spacing = 1; // ### Consider using gtkCheckBox : "indicator-spacing" instead
+
+                    if (menuItem->checkType & QStyleOptionMenuItem::Exclusive) {
+                        // Radio button
+                        GtkShadowType shadow = GTK_SHADOW_OUT;
+                        GtkStateType state = qt_gtk_state(option);
+
+                        if (selected)
+                            state = GTK_STATE_PRELIGHT;
+                        if (checked)
+                            shadow = GTK_SHADOW_IN;
+
+                        gtkPainter->setClipRect(checkRect.adjusted(-spacing, -spacing, spacing, spacing));
+                        gtkPainter->paintOption(gtkMenuItem, checkRect.translated(-spacing, -spacing), state, shadow,
+                                                style, QLS("option"));
+                        gtkPainter->setClipRect(QRect());
+
+                    } else {
+                        // Check box
+                        if (menuItem->icon.isNull()) {
+                            GtkShadowType shadow = GTK_SHADOW_OUT;
+                            GtkStateType state = qt_gtk_state(option);
+
+                            if (selected)
+                                state = GTK_STATE_PRELIGHT;
+                            if (checked)
+                                shadow = GTK_SHADOW_IN;
+
+                            gtkPainter->setClipRect(checkRect.adjusted(-spacing, -spacing, -spacing, -spacing));
+                            gtkPainter->paintCheckbox(gtkMenuItem, checkRect.translated(-spacing, -spacing), state, shadow,
+                                                      style, QLS("check"));
+                            gtkPainter->setClipRect(QRect());
+                        }
+                    }
+                }
+
+            } else {
+                // Ignore checkmark
+                if (menuItem->icon.isNull())
+                    checkcol = 0;
+                else
+                    checkcol = menuItem->maxIconWidth;
+            }
+
+            bool dis = !(menuItem->state & State_Enabled);
+            bool act = menuItem->state & State_Selected;
+            const QStyleOption *opt = option;
+            const QStyleOptionMenuItem *menuitem = menuItem;
+            QPainter *p = painter;
+            QRect vCheckRect = visualRect(opt->direction, menuitem->rect,
+                                          QRect(menuitem->rect.x() + 3, menuitem->rect.y(),
+                                                checkcol, menuitem->rect.height()));
+
+            if (!menuItem->icon.isNull()) {
+                QIcon::Mode mode = dis ? QIcon::Disabled : QIcon::Normal;
+
+                if (act && !dis)
+                    mode = QIcon::Active;
+
+                QPixmap pixmap;
+                int smallIconSize = proxy()->pixelMetric(PM_SmallIconSize, option, widget);
+                QSize iconSize(smallIconSize, smallIconSize);
+
+#ifndef QT_NO_COMBOBOX
+                if (const QComboBox *combo = qobject_cast<const QComboBox*>(widget))
+                    iconSize = combo->iconSize();
+
+#endif // QT_NO_COMBOBOX
+                if (checked)
+                    pixmap = menuItem->icon.pixmap(iconSize, mode, QIcon::On);
+                else
+                    pixmap = menuItem->icon.pixmap(iconSize, mode);
+
+                int pixw = pixmap.width();
+                int pixh = pixmap.height();
+                QRect pmr(0, 0, pixw, pixh);
+                pmr.moveCenter(vCheckRect.center() - QPoint(0, 1));
+                painter->setPen(menuItem->palette.text().color());
+                if (!ignoreCheckMark && checkable && checked) {
+                    QStyleOption opt = *option;
+
+                    if (act) {
+                        QColor activeColor = mergedColors(option->palette.background().color(),
+                                                          option->palette.highlight().color());
+                        opt.palette.setBrush(QPalette::Button, activeColor);
+                    }
+                    opt.state |= State_Sunken;
+                    opt.rect = vCheckRect;
+                    proxy()->drawPrimitive(PE_PanelButtonCommand, &opt, painter, widget);
+                }
+                painter->drawPixmap(pmr.topLeft(), pixmap);
+            }
+
+            GdkColor gdkText = style->fg[GTK_STATE_NORMAL];
+            GdkColor gdkDText = style->fg[GTK_STATE_INSENSITIVE];
+            GdkColor gdkHText = style->fg[GTK_STATE_PRELIGHT];
+            uint resolve_mask = option->palette.resolve();
+            QColor textColor = QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
+            QColor disabledTextColor = QColor(gdkDText.red>>8, gdkDText.green>>8, gdkDText.blue>>8);
+            if (resolve_mask & (1 << QPalette::ButtonText)) {
+                textColor = option->palette.buttonText().color();
+                disabledTextColor = option->palette.brush(QPalette::Disabled, QPalette::ButtonText).color();
+            }
+
+            QColor highlightedTextColor = QColor(gdkHText.red>>8, gdkHText.green>>8, gdkHText.blue>>8);
+            if (resolve_mask & (1 << QPalette::HighlightedText)) {
+                highlightedTextColor = option->palette.highlightedText().color();
+            }
+
+            if (selected)
+                painter->setPen(highlightedTextColor);
+            else
+                painter->setPen(textColor);
+
+            int x, y, w, h;
+            menuitem->rect.getRect(&x, &y, &w, &h);
+            int tab = menuitem->tabWidth;
+            int xm = QGtkStylePrivate::menuItemFrame + checkcol + windowsItemHMargin;
+            int xpos = menuitem->rect.x() + xm + 1;
+            QRect textRect(xpos, y + windowsItemVMargin, w - xm - QGtkStylePrivate::menuRightBorder - tab + 1, h - 2 * windowsItemVMargin);
+            QRect vTextRect = visualRect(opt->direction, menuitem->rect, textRect);
+            QString s = menuitem->text;
+
+            if (!s.isEmpty()) { // Draw text
+                p->save();
+                int t = s.indexOf(QLatin1Char('\t'));
+                int text_flags = Qt::AlignVCenter | Qt::TextShowMnemonic | Qt::TextDontClip | Qt::TextSingleLine;
+
+                if (!proxy()->styleHint(SH_UnderlineShortcut, menuitem, widget))
+                    text_flags |= Qt::TextHideMnemonic;
+
+                // Draw shortcut right aligned
+                text_flags |= Qt::AlignRight;
+
+                if (t >= 0) {
+                    int rightMargin = 12; // Hardcode for now
+                    QRect vShortcutRect = visualRect(opt->direction, menuitem->rect,
+                                                     QRect(textRect.topRight(), QPoint(menuitem->rect.right() - rightMargin, textRect.bottom())));
+
+                    if (dis)
+                        p->setPen(disabledTextColor);
+                    p->drawText(vShortcutRect, text_flags , s.mid(t + 1));
+                    s = s.left(t);
+                }
+
+                text_flags &= ~Qt::AlignRight;
+                text_flags |= Qt::AlignLeft;
+                QFont font = menuitem->font;
+                if (menuitem->menuItemType == QStyleOptionMenuItem::DefaultItem)
+                    font.setBold(true);
+                p->setFont(font);
+
+                if (dis)
+                    p->setPen(disabledTextColor);
+                p->drawText(vTextRect, text_flags, s.left(t));
+                p->restore();
+            }
+
+            // Arrow
+            if (menuItem->menuItemType == QStyleOptionMenuItem::SubMenu) {// draw sub menu arrow
+
+                QFontMetrics fm(menuitem->font);
+                int arrow_size = fm.ascent() + fm.descent() - 2 * style->ythickness;
+                gfloat arrow_scaling = 0.8;
+                int extra = 0;
+                if (!d->gtk_check_version(2, 16, 0)) {
+                    // "arrow-scaling" is actually hardcoded and fails on hardy (see gtk+-2.12/gtkmenuitem.c)
+                    // though the current documentation states otherwise
+                    d->gtk_widget_style_get(gtkMenuItem, "arrow-scaling", &arrow_scaling, NULL);
+                    // in versions < 2.16 ythickness was previously subtracted from the arrow_size
+                    extra = 2 * style->ythickness;
+                }
+
+                int horizontal_padding;
+                d->gtk_widget_style_get(gtkMenuItem, "horizontal-padding", &horizontal_padding, NULL);
+
+                const int dim = static_cast<int>(arrow_size * arrow_scaling) + extra;
+                int xpos = menuItem->rect.left() + menuItem->rect.width() - horizontal_padding - dim;
+                QRect  vSubMenuRect = visualRect(option->direction, menuItem->rect,
+                                                 QRect(xpos, menuItem->rect.top() +
+                                                       menuItem->rect.height() / 2 - dim / 2, dim, dim));
+                GtkStateType state = enabled ? (act ? GTK_STATE_PRELIGHT: GTK_STATE_NORMAL) : GTK_STATE_INSENSITIVE;
+                GtkShadowType shadowType = (state == GTK_STATE_PRELIGHT) ? GTK_SHADOW_OUT : GTK_SHADOW_IN;
+                gtkPainter->paintArrow(gtkMenuItem, "menuitem", vSubMenuRect, option->direction == Qt::RightToLeft ? GTK_ARROW_LEFT : GTK_ARROW_RIGHT, state,
+                                       shadowType, false, style);
+            }
+        }
+        painter->restore();
+        break;
+
+    case CE_PushButton:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(option)) {
+            GtkWidget *gtkButton = d->gtkWidget("GtkButton");
+            proxy()->drawControl(CE_PushButtonBevel, btn, painter, widget);
+            QStyleOptionButton subopt = *btn;
+            subopt.rect = subElementRect(SE_PushButtonContents, btn, widget);
+            gint interiorFocus = true;
+            d->gtk_widget_style_get(gtkButton, "interior-focus", &interiorFocus, NULL);
+            GtkStyle *gtkButtonStyle = d->gtk_widget_get_style(gtkButton);
+            int xt = interiorFocus ? gtkButtonStyle->xthickness : 0;
+            int yt = interiorFocus ? gtkButtonStyle->ythickness : 0;
+
+            if (btn->features & QStyleOptionButton::Flat && btn->state & State_HasFocus)
+                // The normal button focus rect does not work well for flat buttons in Clearlooks
+                proxy()->drawPrimitive(PE_FrameFocusRect, option, painter, widget);
+            else if (btn->state & State_HasFocus)
+                gtkPainter->paintFocus(gtkButton, "button",
+                                       option->rect.adjusted(xt, yt, -xt, -yt),
+                                       btn->state & State_Sunken ? GTK_STATE_ACTIVE : GTK_STATE_NORMAL,
+                                       gtkButtonStyle);
+
+            proxy()->drawControl(CE_PushButtonLabel, &subopt, painter, widget);
+        }
+        break;
+
+#ifndef QT_NO_TABBAR
+
+    case CE_TabBarTabShape:
+        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(option)) {
+            GtkWidget *gtkNotebook = d->gtkWidget("GtkNotebook");
+            style = d->gtk_widget_get_style(gtkNotebook);
+
+            QRect rect = option->rect;
+            GtkShadowType shadow = GTK_SHADOW_OUT;
+            GtkStateType state = GTK_STATE_ACTIVE;
+            if (tab->state & State_Selected)
+                state = GTK_STATE_NORMAL;
+
+            bool selected = (tab->state & State_Selected);
+            bool first = false, last = false;
+            if (widget) {
+                // This is most accurate and avoids resizing tabs while moving
+                first = tab->rect.left() == widget->rect().left();
+                last = tab->rect.right() == widget->rect().right();
+            } else if (option->direction == Qt::RightToLeft) {
+                bool tmp = first;
+                first = last;
+                last = tmp;
+            }
+            int topIndent = 3;
+            int bottomIndent = 1;
+            int tabOverlap = 1;
+            painter->save();
+
+            switch (tab->shape) {
+            case QTabBar::RoundedNorth:
+                if (!selected)
+                    rect.adjust(first ? 0 : -tabOverlap, topIndent, last ? 0 : tabOverlap, -bottomIndent);
+                gtkPainter->paintExtention(gtkNotebook, "tab", rect,
+                                           state, shadow, GTK_POS_BOTTOM, style);
+                break;
+
+            case QTabBar::RoundedSouth:
+                if (!selected)
+                    rect.adjust(first ? 0 : -tabOverlap, 0, last ? 0 : tabOverlap, -topIndent);
+                gtkPainter->paintExtention(gtkNotebook, "tab", rect.adjusted(0, 1, 0, 0),
+                                           state, shadow, GTK_POS_TOP, style);
+                break;
+
+            case QTabBar::RoundedWest:
+                if (!selected)
+                    rect.adjust(topIndent, 0, -bottomIndent, 0);
+                gtkPainter->paintExtention(gtkNotebook, "tab", rect, state, shadow, GTK_POS_RIGHT, style);
+                break;
+
+            case QTabBar::RoundedEast:
+                if (!selected)
+                    rect.adjust(bottomIndent, 0, -topIndent, 0);
+                gtkPainter->paintExtention(gtkNotebook, "tab", rect, state, shadow, GTK_POS_LEFT, style);
+                break;
+
+            default:
+                QCommonStyle::drawControl(element, option, painter, widget);
+                break;
+            }
+
+            painter->restore();
+        }
+
+        break;
+
+#endif //QT_NO_TABBAR
+
+    case CE_ProgressBarGroove:
+        if (const QStyleOptionProgressBar *bar = qstyleoption_cast<const QStyleOptionProgressBar *>(option)) {
+            Q_UNUSED(bar);
+            GtkWidget *gtkProgressBar = d->gtkWidget("GtkProgressBar");
+            GtkStateType state = qt_gtk_state(option);
+            gtkPainter->paintBox(gtkProgressBar, "trough", option->rect, state, GTK_SHADOW_IN, d->gtk_widget_get_style(gtkProgressBar));
+        }
+
+        break;
+
+    case CE_ProgressBarContents:
+        if (const QStyleOptionProgressBar *bar = qstyleoption_cast<const QStyleOptionProgressBar *>(option)) {
+            GtkStateType state = option->state & State_Enabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE;
+            GtkWidget *gtkProgressBar = d->gtkWidget("GtkProgressBar");
+            style = d->gtk_widget_get_style(gtkProgressBar);
+            gtkPainter->paintBox(gtkProgressBar, "trough", option->rect, state, GTK_SHADOW_IN, style);
+            int xt = style->xthickness;
+            int yt = style->ythickness;
+            QRect rect = bar->rect.adjusted(xt, yt, -xt, -yt);
+            bool vertical = false;
+            bool inverted = false;
+            bool indeterminate = (bar->minimum == 0 && bar->maximum == 0);
+            // Get extra style options if version 2
+
+            if (const QStyleOptionProgressBarV2 *bar2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(option)) {
+                vertical = (bar2->orientation == Qt::Vertical);
+                inverted = bar2->invertedAppearance;
+            }
+
+            // If the orientation is vertical, we use a transform to rotate
+            // the progress bar 90 degrees clockwise.  This way we can use the
+            // same rendering code for both orientations.
+            if (vertical) {
+                rect.translate(xt, -yt * 2);
+                rect = QRect(rect.left(), rect.top(), rect.height(), rect.width()); // Flip width and height
+                QTransform m = QTransform::fromTranslate(rect.height(), 0);
+                m.rotate(90.0);
+                painter->setTransform(m);
+            }
+
+            int maxWidth = rect.width();
+            int minWidth = 4;
+
+            qint64 progress = (qint64)qMax(bar->progress, bar->minimum); // Workaround for bug in QProgressBar
+            double vc6_workaround = ((progress - qint64(bar->minimum)) / double(qint64(bar->maximum) - qint64(bar->minimum))) * maxWidth;
+            int progressBarWidth = (int(vc6_workaround) > minWidth ) ? int(vc6_workaround) : minWidth;
+            int width = indeterminate ? maxWidth : progressBarWidth;
+            bool reverse = (!vertical && (bar->direction == Qt::RightToLeft)) || vertical;
+
+            if (inverted)
+                reverse = !reverse;
+
+            int maximum = 2;
+            int fakePos = 0;
+            if (bar->minimum == bar->maximum)
+                maximum = 0;
+            if (bar->progress == bar->maximum)
+                fakePos = maximum;
+            else if (bar->progress > bar->minimum)
+                fakePos = maximum - 1;
+
+            QRect progressBar;
+
+            if (!indeterminate) {
+                if (!reverse)
+                    progressBar.setRect(rect.left(), rect.top(), width, rect.height());
+                else
+                    progressBar.setRect(rect.right() - width, rect.top(), width, rect.height());
+                d->stopAnimation(option->styleObject);
+            } else {
+                Q_D(const QGtkStyle);
+                int slideWidth = ((rect.width() - 4) * 2) / 3;
+                int step = 0;
+                if (QProgressStyleAnimation *animation = qobject_cast<QProgressStyleAnimation*>(d->animation(option->styleObject)))
+                    step = animation->progressStep(slideWidth);
+                else
+                    d->startAnimation(new QProgressStyleAnimation(d->animationFps, option->styleObject));
+                progressBar.setRect(rect.left() + step, rect.top(), slideWidth / 2, rect.height());
+            }
+
+            QString key = QString(QLS("%0")).arg(fakePos);
+            if (inverted) {
+                key += QLatin1String("inv");
+                gtkPainter->setFlipHorizontal(true);
+            }
+            gtkPainter->paintBox(gtkProgressBar, "bar", progressBar, GTK_STATE_SELECTED, GTK_SHADOW_OUT, style, key);
+        }
+
+        break;
+
+    default:
+        QCommonStyle::drawControl(element, option, painter, widget);
+    }
+}
+
+/*!
+  \reimp
+*/
+QRect QGtkStyle::subControlRect(ComplexControl control, const QStyleOptionComplex *option,
+                                SubControl subControl, const QWidget *widget) const
+{
+    Q_D(const QGtkStyle);
+
+    QRect rect = QCommonStyle::subControlRect(control, option, subControl, widget);
+    if (!d->isThemeAvailable())
+        return QCommonStyle::subControlRect(control, option, subControl, widget);
+
+    switch (control) {
+    case CC_ScrollBar:
+        break;
+    case CC_Slider:
+        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+            int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
+            switch (subControl) {
+            case SC_SliderHandle: {
+                if (slider->orientation == Qt::Horizontal) {
+                    rect.setHeight(proxy()->pixelMetric(PM_SliderThickness));
+                    rect.setWidth(proxy()->pixelMetric(PM_SliderLength));
+                    int centerY = slider->rect.center().y() - rect.height() / 2;
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        centerY += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        centerY -= tickSize;
+                    rect.moveTop(centerY);
+                } else {
+                    rect.setWidth(proxy()->pixelMetric(PM_SliderThickness));
+                    rect.setHeight(proxy()->pixelMetric(PM_SliderLength));
+                    int centerX = slider->rect.center().x() - rect.width() / 2;
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        centerX += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        centerX -= tickSize;
+                    rect.moveLeft(centerX);
+                }
+            }
+                break;
+            case SC_SliderGroove: {
+                QPoint grooveCenter = slider->rect.center();
+                if (slider->orientation == Qt::Horizontal) {
+                    rect.setHeight(7);
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        grooveCenter.ry() += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        grooveCenter.ry() -= tickSize;
+                } else {
+                    rect.setWidth(7);
+                    if (slider->tickPosition & QSlider::TicksAbove)
+                        grooveCenter.rx() += tickSize;
+                    if (slider->tickPosition & QSlider::TicksBelow)
+                        grooveCenter.rx() -= tickSize;
+                }
+                rect.moveCenter(grooveCenter);
+                break;
+            }
+            default:
+                break;
+            }
+        }
+        break;
+
+#ifndef QT_NO_GROUPBOX
+
+    case CC_GroupBox:
+        if (const QStyleOptionGroupBox * groupBox = qstyleoption_cast<const QStyleOptionGroupBox *>(option)) {
+            rect = option->rect.adjusted(0, groupBoxTopMargin, 0, -groupBoxBottomMargin);
+            int topMargin = 0;
+            int topHeight = 0;
+            topHeight = 10;
+            QRect frameRect = rect;
+            frameRect.setTop(topMargin);
+
+            if (subControl == SC_GroupBoxFrame)
+                return rect;
+            else if (subControl == SC_GroupBoxContents) {
+                int margin = 0;
+                int leftMarginExtension = 8;
+                return frameRect.adjusted(leftMarginExtension + margin, margin + topHeight + groupBoxTitleMargin, -margin, -margin);
+            }
+
+            QFontMetrics fontMetrics = option->fontMetrics;
+            if (qobject_cast<const QGroupBox *>(widget)) {
+                //Prepare metrics for a bold font
+                QFont font = widget->font();
+                font.setBold(true);
+                fontMetrics = QFontMetrics(font);
+            }
+
+            QSize textRect = fontMetrics.boundingRect(groupBox->text).size() + QSize(4, 4);
+            int indicatorWidth = proxy()->pixelMetric(PM_IndicatorWidth, option, widget);
+            int indicatorHeight = proxy()->pixelMetric(PM_IndicatorHeight, option, widget);
+
+            if (subControl == SC_GroupBoxCheckBox) {
+                rect.setWidth(indicatorWidth);
+                rect.setHeight(indicatorHeight);
+                rect.moveTop((textRect.height() - indicatorHeight) / 2);
+
+            } else if (subControl == SC_GroupBoxLabel) {
+                if (groupBox->subControls & SC_GroupBoxCheckBox)
+                    rect.adjust(indicatorWidth + 4, 0, 0, 0);
+                rect.setSize(textRect);
+            }
+            rect = visualRect(option->direction, option->rect, rect);
+        }
+
+        return rect;
+
+#endif
+#ifndef QT_NO_SPINBOX
+
+    case CC_SpinBox:
+        if (const QStyleOptionSpinBox *spinbox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
+            GtkWidget *gtkSpinButton = d->gtkWidget("GtkSpinButton");
+            int center = spinbox->rect.height() / 2;
+            GtkStyle *gtkSpinButtonStyle = d->gtk_widget_get_style(gtkSpinButton);
+            int xt = spinbox->frame ? gtkSpinButtonStyle->xthickness : 0;
+            int yt = spinbox->frame ? gtkSpinButtonStyle->ythickness : 0;
+            int y = yt;
+
+            QSize bs;
+            bs.setHeight(qMax(8, spinbox->rect.height()/2 - y));
+            bs.setWidth(d->getSpinboxArrowSize());
+            int x, lx, rx;
+            x = spinbox->rect.width() - y - bs.width() + 2;
+            lx = xt;
+            rx = x - xt;
+
+            switch (subControl) {
+
+            case SC_SpinBoxUp:
+                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons)
+                    return QRect();
+                rect = QRect(x, xt, bs.width(), center - yt);
+                break;
+
+            case SC_SpinBoxDown:
+                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons)
+                    return QRect();
+                rect = QRect(x, center, bs.width(), spinbox->rect.bottom() - center - yt + 1);
+                break;
+
+            case SC_SpinBoxEditField:
+                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons)
+                    rect = QRect(lx, yt, spinbox->rect.width() - 2*xt, spinbox->rect.height() - 2*yt);
+                else
+                    rect = QRect(lx, yt, rx - qMax(xt - 1, 0), spinbox->rect.height() - 2*yt);
+                break;
+
+            case SC_SpinBoxFrame:
+                rect = spinbox->rect;
+
+            default:
+                break;
+            }
+
+            rect = visualRect(spinbox->direction, spinbox->rect, rect);
+        }
+
+        break;
+
+#endif // Qt_NO_SPINBOX
+#ifndef QT_NO_COMBOBOX
+
+    case CC_TitleBar:
+    if (const QStyleOptionTitleBar *tb = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {
+        SubControl sc = subControl;
+        QRect &ret = rect;
+        const int indent = 3;
+        const int controlTopMargin = 3;
+        const int controlBottomMargin = 3;
+        const int controlWidthMargin = 2;
+        const int controlHeight = tb->rect.height() - controlTopMargin - controlBottomMargin ;
+        const int delta = controlHeight + controlWidthMargin;
+        int offset = 0;
+
+        bool isMinimized = tb->titleBarState & Qt::WindowMinimized;
+        bool isMaximized = tb->titleBarState & Qt::WindowMaximized;
+
+        switch (sc) {
+        case SC_TitleBarLabel:
+            if (tb->titleBarFlags & (Qt::WindowTitleHint | Qt::WindowSystemMenuHint)) {
+                ret = tb->rect;
+                if (tb->titleBarFlags & Qt::WindowSystemMenuHint)
+                    ret.adjust(delta, 0, -delta, 0);
+                if (tb->titleBarFlags & Qt::WindowMinimizeButtonHint)
+                    ret.adjust(0, 0, -delta, 0);
+                if (tb->titleBarFlags & Qt::WindowMaximizeButtonHint)
+                    ret.adjust(0, 0, -delta, 0);
+                if (tb->titleBarFlags & Qt::WindowShadeButtonHint)
+                    ret.adjust(0, 0, -delta, 0);
+                if (tb->titleBarFlags & Qt::WindowContextHelpButtonHint)
+                    ret.adjust(0, 0, -delta, 0);
+            }
+            break;
+        case SC_TitleBarContextHelpButton:
+            if (tb->titleBarFlags & Qt::WindowContextHelpButtonHint)
+                offset += delta;
+        case SC_TitleBarMinButton:
+            if (!isMinimized && (tb->titleBarFlags & Qt::WindowMinimizeButtonHint))
+                offset += delta;
+            else if (sc == SC_TitleBarMinButton)
+                break;
+        case SC_TitleBarNormalButton:
+            if (isMinimized && (tb->titleBarFlags & Qt::WindowMinimizeButtonHint))
+                offset += delta;
+            else if (isMaximized && (tb->titleBarFlags & Qt::WindowMaximizeButtonHint))
+                offset += delta;
+            else if (sc == SC_TitleBarNormalButton)
+                break;
+        case SC_TitleBarMaxButton:
+            if (!isMaximized && (tb->titleBarFlags & Qt::WindowMaximizeButtonHint))
+                offset += delta;
+            else if (sc == SC_TitleBarMaxButton)
+                break;
+        case SC_TitleBarShadeButton:
+            if (!isMinimized && (tb->titleBarFlags & Qt::WindowShadeButtonHint))
+                offset += delta;
+            else if (sc == SC_TitleBarShadeButton)
+                break;
+        case SC_TitleBarUnshadeButton:
+            if (isMinimized && (tb->titleBarFlags & Qt::WindowShadeButtonHint))
+                offset += delta;
+            else if (sc == SC_TitleBarUnshadeButton)
+                break;
+        case SC_TitleBarCloseButton:
+            if (tb->titleBarFlags & Qt::WindowSystemMenuHint)
+                offset += delta;
+            else if (sc == SC_TitleBarCloseButton)
+                break;
+            ret.setRect(tb->rect.right() - indent - offset, tb->rect.top() + controlTopMargin,
+                        controlHeight, controlHeight);
+            break;
+        case SC_TitleBarSysMenu:
+            if (tb->titleBarFlags & Qt::WindowSystemMenuHint) {
+                ret.setRect(tb->rect.left() + controlWidthMargin + indent, tb->rect.top() + controlTopMargin,
+                            controlHeight, controlHeight);
+            }
+            break;
+        default:
+            break;
+        }
+        ret = visualRect(tb->direction, tb->rect, ret);
+    }
+    break;
+    case CC_ComboBox:
+        if (const QStyleOptionComboBox *box = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
+            // We employ the gtk widget to position arrows and separators for us
+            GtkWidget *gtkCombo = box->editable ? d->gtkWidget("GtkComboBoxEntry")
+                                                : d->gtkWidget("GtkComboBox");
+            d->gtk_widget_set_direction(gtkCombo, (option->direction == Qt::RightToLeft) ? GTK_TEXT_DIR_RTL : GTK_TEXT_DIR_LTR);
+            GtkAllocation geometry = {0, 0, qMax(0, option->rect.width()), qMax(0, option->rect.height())};
+            d->gtk_widget_size_allocate(gtkCombo, &geometry);
+            int appears_as_list = !proxy()->styleHint(QStyle::SH_ComboBox_Popup, option, widget);
+            QHashableLatin1Literal arrowPath("GtkComboBoxEntry.GtkToggleButton");
+            if (!box->editable) {
+                if (appears_as_list)
+                    arrowPath = "GtkComboBox.GtkToggleButton";
+                else
+                    arrowPath = "GtkComboBox.GtkToggleButton.GtkHBox.GtkArrow";
+            }
+
+            GtkWidget *arrowWidget = d->gtkWidget(arrowPath);
+            if (!arrowWidget)
+                return QCommonStyle::subControlRect(control, option, subControl, widget);
+
+            GtkAllocation allocation;
+            d->gtk_widget_get_allocation(arrowWidget, &allocation);
+            QRect buttonRect(option->rect.left() + allocation.x,
+                             option->rect.top() + allocation.y,
+                             allocation.width, allocation.height);
+
+            switch (subControl) {
+
+            case SC_ComboBoxArrow: // Note: this indicates the arrowbutton for editable combos
+                rect = buttonRect;
+                break;
+
+            case SC_ComboBoxEditField: {
+                rect = visualRect(option->direction, option->rect, rect);
+                int xMargin = box->editable ? 1 : 4, yMargin = 2;
+                GtkStyle *gtkComboStyle = d->gtk_widget_get_style(gtkCombo);
+                rect.setRect(option->rect.left() + gtkComboStyle->xthickness + xMargin,
+                             option->rect.top()  + gtkComboStyle->ythickness + yMargin,
+                             option->rect.width() - buttonRect.width() - 2*(gtkComboStyle->xthickness + xMargin),
+                             option->rect.height() - 2*(gtkComboStyle->ythickness + yMargin));
+                rect = visualRect(option->direction, option->rect, rect);
+                break;
+            }
+
+            default:
+                break;
+            }
+        }
+
+        break;
+#endif // QT_NO_COMBOBOX
+
+    default:
+        break;
+    }
+
+    return rect;
+}
+
+/*!
+  \reimp
+*/
+QSize QGtkStyle::sizeFromContents(ContentsType type, const QStyleOption *option,
+                                  const QSize &size, const QWidget *widget) const
+{
+    Q_D(const QGtkStyle);
+
+    QSize newSize = QCommonStyle::sizeFromContents(type, option, size, widget);
+    if (!d->isThemeAvailable())
+        return newSize;
+
+    switch (type) {
+    case CT_GroupBox:
+        // Since we use a bold font we have to recalculate base width
+        if (const QGroupBox *gb = qobject_cast<const QGroupBox*>(widget)) {
+            QFont font = gb->font();
+            font.setBold(true);
+            QFontMetrics metrics(font);
+            int baseWidth = metrics.width(gb->title()) + metrics.width(QLatin1Char(' '));
+            if (gb->isCheckable()) {
+                baseWidth += proxy()->pixelMetric(QStyle::PM_IndicatorWidth, option, widget);
+                baseWidth += proxy()->pixelMetric(QStyle::PM_CheckBoxLabelSpacing, option, widget);
+            }
+            newSize.setWidth(qMax(baseWidth, newSize.width()));
+        }
+        newSize += QSize(4, 1 + groupBoxBottomMargin + groupBoxTopMargin + groupBoxTitleMargin); // Add some space below the groupbox
+        break;
+    case CT_ToolButton:
+        if (const QStyleOptionToolButton *toolbutton = qstyleoption_cast<const QStyleOptionToolButton *>(option)) {
+            GtkWidget *gtkButton = d->gtkWidget("GtkToolButton.GtkButton");
+            GtkStyle *gtkButtonStyle = d->gtk_widget_get_style(gtkButton);
+            newSize = size + QSize(2 * gtkButtonStyle->xthickness, 2 + 2 * gtkButtonStyle->ythickness);
+            if (widget && qobject_cast<QToolBar *>(widget->parentWidget())) {
+                QSize minSize(0, 25);
+                if (toolbutton->toolButtonStyle != Qt::ToolButtonTextOnly)
+                    minSize = toolbutton->iconSize + QSize(12, 12);
+                newSize = newSize.expandedTo(minSize);
+            }
+
+            if (toolbutton->features & QStyleOptionToolButton::HasMenu)
+                newSize += QSize(6, 0);
+        }
+        break;
+    case CT_SpinBox:
+        // QSpinBox does some nasty things that depends on CT_LineEdit
+        newSize = newSize + QSize(0, -d->gtk_widget_get_style(d->gtkWidget("GtkSpinButton"))->ythickness * 2);
+        break;
+    case CT_RadioButton:
+    case CT_CheckBox:
+        newSize += QSize(0, 1);
+        break;
+    case CT_PushButton:
+        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(option)) {
+            if (!btn->icon.isNull() && btn->iconSize.height() > 16)
+                newSize -= QSize(0, 2); // From cleanlooksstyle
+            newSize += QSize(0, 1);
+            GtkWidget *gtkButton = d->gtkWidget("GtkButton");
+            gint focusPadding, focusWidth;
+            d->gtk_widget_style_get(gtkButton, "focus-padding", &focusPadding, NULL);
+            d->gtk_widget_style_get(gtkButton, "focus-line-width", &focusWidth, NULL);
+            newSize = size;
+            GtkStyle *gtkButtonStyle = d->gtk_widget_get_style(gtkButton);
+            newSize += QSize(2*gtkButtonStyle->xthickness + 4, 2*gtkButtonStyle->ythickness);
+            newSize += QSize(2*(focusWidth + focusPadding + 2), 2*(focusWidth + focusPadding));
+
+            GtkWidget *gtkButtonBox = d->gtkWidget("GtkHButtonBox");
+            gint minWidth = 85, minHeight = 0;
+            d->gtk_widget_style_get(gtkButtonBox, "child-min-width", &minWidth,
+                                   "child-min-height", &minHeight, NULL);
+            if (!btn->text.isEmpty() && newSize.width() < minWidth)
+                newSize.setWidth(minWidth);
+            if (newSize.height() < minHeight)
+                newSize.setHeight(minHeight);
+        }
+        break;
+    case CT_Slider: {
+        GtkWidget *gtkSlider = d->gtkWidget("GtkHScale");
+        GtkStyle *gtkSliderStyle = d->gtk_widget_get_style(gtkSlider);
+        newSize = size + QSize(2*gtkSliderStyle->xthickness, 2*gtkSliderStyle->ythickness); }
+        break;
+    case CT_LineEdit: {
+        GtkWidget *gtkEntry = d->gtkWidget("GtkEntry");
+        GtkStyle *gtkEntryStyle = d->gtk_widget_get_style(gtkEntry);
+        newSize = size + QSize(2*gtkEntryStyle->xthickness, 2 + 2*gtkEntryStyle->ythickness); }
+        break;
+    case CT_ItemViewItem:
+        newSize += QSize(0, 2);
+        break;
+    case CT_ComboBox:
+        if (const QStyleOptionComboBox *combo = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
+            GtkWidget *gtkCombo = d->gtkWidget("GtkComboBox");
+            QRect arrowButtonRect = proxy()->subControlRect(CC_ComboBox, combo, SC_ComboBoxArrow, widget);
+            GtkStyle *gtkComboStyle = d->gtk_widget_get_style(gtkCombo);
+            newSize = size + QSize(12 + arrowButtonRect.width() + 2*gtkComboStyle->xthickness, 4 + 2*gtkComboStyle->ythickness);
+
+            if (!(widget && qobject_cast<QToolBar *>(widget->parentWidget())))
+                newSize += QSize(0, 2);
+        }
+        break;
+    case CT_TabBarTab:
+        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(option)) {
+            if (!tab->icon.isNull())
+                newSize += QSize(6, 0);
+        }
+        newSize += QSize(1, 1);
+        break;
+    case CT_MenuBarItem:
+        newSize += QSize(QGtkStylePrivate::menuItemHMargin * 4, QGtkStylePrivate::menuItemVMargin * 2 + 2);
+        break;
+    case CT_SizeGrip:
+        newSize += QSize(4, 4);
+        break;
+    case CT_MdiControls:
+        if (const QStyleOptionComplex *styleOpt = qstyleoption_cast<const QStyleOptionComplex *>(option)) {
+            int width = 0;
+            if (styleOpt->subControls & SC_MdiMinButton)
+                width += 19 + 1;
+            if (styleOpt->subControls & SC_MdiNormalButton)
+                width += 19 + 1;
+            if (styleOpt->subControls & SC_MdiCloseButton)
+                width += 19 + 1;
+            newSize = QSize(width, 19);
+        } else {
+            newSize = QSize(60, 19);
+        }
+    break;
+    case CT_MenuItem:
+        if (const QStyleOptionMenuItem *menuItem = qstyleoption_cast<const QStyleOptionMenuItem *>(option)) {
+            int w = newSize.width();
+            int maxpmw = menuItem->maxIconWidth;
+            int tabSpacing = 20;
+            if (menuItem->text.contains(QLatin1Char('\t')))
+                w += tabSpacing;
+            else if (menuItem->menuItemType == QStyleOptionMenuItem::SubMenu)
+                w += 2 * QGtkStylePrivate::menuArrowHMargin;
+            else if (menuItem->menuItemType == QStyleOptionMenuItem::DefaultItem) {
+                // adjust the font and add the difference in size.
+                // it would be better if the font could be adjusted in the initStyleOption qmenu func!!
+                QFontMetrics fm(menuItem->font);
+                QFont fontBold = menuItem->font;
+                fontBold.setBold(true);
+                QFontMetrics fmBold(fontBold);
+                w += fmBold.width(menuItem->text) - fm.width(menuItem->text);
+            }
+
+            int checkcol = qMax<int>(maxpmw, QGtkStylePrivate::menuCheckMarkWidth); // Windows always shows a check column
+            w += checkcol;
+            w += int(QGtkStylePrivate::menuRightBorder) + 10;
+
+            newSize.setWidth(w);
+
+            int textMargin = 8;
+            if (menuItem->menuItemType == QStyleOptionMenuItem::Separator) {
+                GtkWidget *gtkMenuSeparator = d->gtkWidget("GtkMenu.GtkSeparatorMenuItem");
+                GtkRequisition sizeReq = {0, 0};
+                d->gtk_widget_size_request(gtkMenuSeparator, &sizeReq);
+                newSize = QSize(newSize.width(), sizeReq.height);
+                break;
+            }
+
+            GtkWidget *gtkMenuItem = d->gtkWidget("GtkMenu.GtkCheckMenuItem");
+            GtkStyle* style = d->gtk_widget_get_style(gtkMenuItem);
+
+            // Note we get the perfect height for the default font since we
+            // set a fake text label on the gtkMenuItem
+            // But if custom fonts are used on the widget we need a minimum size
+            GtkRequisition sizeReq = {0, 0};
+            d->gtk_widget_size_request(gtkMenuItem, &sizeReq);
+            newSize.setHeight(qMax(newSize.height() - 4, sizeReq.height));
+            newSize += QSize(textMargin + style->xthickness - 1, 0);
+
+            gint checkSize;
+            d->gtk_widget_style_get(gtkMenuItem, "indicator-size", &checkSize, NULL);
+            newSize.setWidth(newSize.width() + qMax(0, checkSize - 20));
+        }
+        break;
+    default:
+        break;
+    }
+
+    return newSize;
+}
+
+
+/*! \reimp */
+QPixmap QGtkStyle::standardPixmap(StandardPixmap sp, const QStyleOption *option,
+                                  const QWidget *widget) const
+{
+    Q_D(const QGtkStyle);
+
+    if (!d->isThemeAvailable())
+        return QCommonStyle::standardPixmap(sp, option, widget);
+
+    QPixmap pixmap;
+    switch (sp) {
+
+    case SP_TitleBarNormalButton: {
+        QImage restoreButton((const char **)dock_widget_restore_xpm);
+        QColor alphaCorner = restoreButton.color(2);
+        alphaCorner.setAlpha(80);
+        restoreButton.setColor(2, alphaCorner.rgba());
+        alphaCorner.setAlpha(180);
+        restoreButton.setColor(4, alphaCorner.rgba());
+        return QPixmap::fromImage(restoreButton);
+    }
+    break;
+
+    case SP_TitleBarCloseButton: // Fall through
+    case SP_DockWidgetCloseButton: {
+
+        QImage closeButton((const char **)dock_widget_close_xpm);
+        QColor alphaCorner = closeButton.color(2);
+        alphaCorner.setAlpha(80);
+        closeButton.setColor(2, alphaCorner.rgba());
+        return QPixmap::fromImage(closeButton);
+    }
+    break;
+
+    case SP_DialogDiscardButton:
+        return qt_gtk_get_icon(GTK_STOCK_DELETE);
+    case SP_DialogOkButton:
+        return qt_gtk_get_icon(GTK_STOCK_OK);
+    case SP_DialogCancelButton:
+        return qt_gtk_get_icon(GTK_STOCK_CANCEL);
+    case SP_DialogYesButton:
+        return qt_gtk_get_icon(GTK_STOCK_YES);
+    case SP_DialogNoButton:
+        return qt_gtk_get_icon(GTK_STOCK_NO);
+    case SP_DialogOpenButton:
+        return qt_gtk_get_icon(GTK_STOCK_OPEN);
+    case SP_DialogCloseButton:
+        return qt_gtk_get_icon(GTK_STOCK_CLOSE);
+    case SP_DialogApplyButton:
+        return qt_gtk_get_icon(GTK_STOCK_APPLY);
+    case SP_DialogSaveButton:
+        return qt_gtk_get_icon(GTK_STOCK_SAVE);
+    case SP_MessageBoxWarning:
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_WARNING, GTK_ICON_SIZE_DIALOG);
+    case SP_MessageBoxQuestion:
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG);
+    case SP_MessageBoxInformation:
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_INFO, GTK_ICON_SIZE_DIALOG);
+    case SP_MessageBoxCritical:
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_ERROR, GTK_ICON_SIZE_DIALOG);
+    default:
+        return QCommonStyle::standardPixmap(sp, option, widget);
+    }
+    return pixmap;
+}
+
+/*!
+    \reimp
+*/
+QIcon QGtkStyle::standardIcon(StandardPixmap standardIcon,
+                              const QStyleOption *option,
+                              const QWidget *widget) const
+{
+    Q_D(const QGtkStyle);
+
+    if (!d->isThemeAvailable())
+        return QCommonStyle::standardIcon(standardIcon, option, widget);
+    switch (standardIcon) {
+    case SP_DialogDiscardButton:
+        return qt_gtk_get_icon(GTK_STOCK_DELETE);
+    case SP_DialogOkButton:
+        return qt_gtk_get_icon(GTK_STOCK_OK);
+    case SP_DialogCancelButton:
+        return qt_gtk_get_icon(GTK_STOCK_CANCEL);
+    case SP_DialogYesButton:
+        return qt_gtk_get_icon(GTK_STOCK_YES);
+    case SP_DialogNoButton:
+        return qt_gtk_get_icon(GTK_STOCK_NO);
+    case SP_DialogOpenButton:
+        return qt_gtk_get_icon(GTK_STOCK_OPEN);
+    case SP_DialogCloseButton:
+        return qt_gtk_get_icon(GTK_STOCK_CLOSE);
+    case SP_DialogApplyButton:
+        return qt_gtk_get_icon(GTK_STOCK_APPLY);
+    case SP_DialogSaveButton:
+        return qt_gtk_get_icon(GTK_STOCK_SAVE);
+    case SP_MessageBoxWarning:
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_WARNING, GTK_ICON_SIZE_DIALOG);
+    case SP_MessageBoxQuestion:
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG);
+    case SP_MessageBoxInformation:
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_INFO, GTK_ICON_SIZE_DIALOG);
+    case SP_MessageBoxCritical:
+        return qt_gtk_get_icon(GTK_STOCK_DIALOG_ERROR, GTK_ICON_SIZE_DIALOG);
+    default:
+        return QCommonStyle::standardIcon(standardIcon, option, widget);
+    }
+}
+
+
+/*! \reimp */
+QRect QGtkStyle::subElementRect(SubElement element, const QStyleOption *option, const QWidget *widget) const
+{
+    Q_D(const QGtkStyle);
+
+    QRect r = QCommonStyle::subElementRect(element, option, widget);
+    if (!d->isThemeAvailable())
+        return r;
+
+    switch (element) {
+    case SE_PushButtonFocusRect:
+        r.adjust(0, 1, 0, -1);
+        break;
+    case SE_DockWidgetTitleBarText: {
+        const QStyleOptionDockWidgetV2 *v2
+            = qstyleoption_cast<const QStyleOptionDockWidgetV2*>(option);
+        bool verticalTitleBar = v2 == 0 ? false : v2->verticalTitleBar;
+        if (verticalTitleBar) {
+            r.adjust(0, 0, 0, -4);
+        } else {
+            if (option->direction == Qt::LeftToRight)
+                r.adjust(4, 0, 0, 0);
+            else
+                r.adjust(0, 0, -4, 0);
+        }
+
+        break;
+    }
+    case SE_ProgressBarLabel:
+    case SE_ProgressBarContents:
+    case SE_ProgressBarGroove:
+        return option->rect;
+    case SE_PushButtonContents:
+        if (!d->gtk_check_version(2, 10, 0)) {
+            GtkWidget *gtkButton = d->gtkWidget("GtkButton");
+            GtkBorder *border = 0;
+            d->gtk_widget_style_get(gtkButton, "inner-border", &border, NULL);
+            if (border) {
+                r = option->rect.adjusted(border->left, border->top, -border->right, -border->bottom);
+                d->gtk_border_free(border);
+            } else {
+                r = option->rect.adjusted(1, 1, -1, -1);
+            }
+            r = visualRect(option->direction, option->rect, r);
+        }
+        break;
+    default:
+        break;
+    }
+
+    return r;
+}
+
+/*!
+  \reimp
+*/
+QRect QGtkStyle::itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const
+{
+    return QCommonStyle::itemPixmapRect(r, flags, pixmap);
+}
+
+/*!
+  \reimp
+*/
+void QGtkStyle::drawItemPixmap(QPainter *painter, const QRect &rect,
+                            int alignment, const QPixmap &pixmap) const
+{
+    QCommonStyle::drawItemPixmap(painter, rect, alignment, pixmap);
+}
+
+/*!
+  \reimp
+*/
+QStyle::SubControl QGtkStyle::hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
+                              const QPoint &pt, const QWidget *w) const
+{
+    return QCommonStyle::hitTestComplexControl(cc, opt, pt, w);
+}
+
+/*!
+  \reimp
+*/
+QPixmap QGtkStyle::generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
+                                        const QStyleOption *opt) const
+{
+    return QCommonStyle::generatedIconPixmap(iconMode, pixmap, opt);
+}
+
+/*!
+  \reimp
+*/
+void QGtkStyle::drawItemText(QPainter *painter, const QRect &rect, int alignment, const QPalette &pal,
+                                    bool enabled, const QString& text, QPalette::ColorRole textRole) const
+{
+    return QCommonStyle::drawItemText(painter, rect, alignment, pal, enabled, text, textRole);
+}
+
+QT_END_NAMESPACE
+
+#endif //!defined(QT_NO_STYLE_QGTK)
diff --git a/.pc/inendi.patch/src/widgets/styles/qstyle.cpp b/.pc/inendi.patch/src/widgets/styles/qstyle.cpp
new file mode 100644
index 0000000..4c5c7cd
--- /dev/null
+++ b/.pc/inendi.patch/src/widgets/styles/qstyle.cpp
@@ -0,0 +1,2397 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtWidgets module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qstyle.h"
+#include "qapplication.h"
+#include "qpainter.h"
+#include "qwidget.h"
+#include "qbitmap.h"
+#include "qpixmapcache.h"
+#include "qstyleoption.h"
+#include "private/qstyle_p.h"
+#include "private/qguiapplication_p.h"
+#ifndef QT_NO_DEBUG
+#include "qdebug.h"
+#endif
+
+#include <limits.h>
+#include <algorithm>
+
+QT_BEGIN_NAMESPACE
+
+static const int MaxBits = 8 * sizeof(QSizePolicy::ControlType);
+
+static int unpackControlTypes(QSizePolicy::ControlTypes controls, QSizePolicy::ControlType *array)
+{
+    if (!controls)
+        return 0;
+
+    // optimization: exactly one bit is set
+    if ((controls & (controls - 1)) == 0) {
+        array[0] = QSizePolicy::ControlType(uint(controls));
+        return 1;
+    }
+
+    int count = 0;
+    for (int i = 0; i < MaxBits; ++i) {
+        if (uint bit = (controls & (0x1 << i)))
+            array[count++] = QSizePolicy::ControlType(bit);
+    }
+    return count;
+}
+
+/*!
+    \page qwidget-styling.html
+    \title Styling
+
+    Qt's built-in widgets use the QStyle class to perform nearly all
+    of their drawing.  QStyle is an abstract base class that
+    encapsulates the look and feel of a GUI, and can be used to make
+    the widgets look exactly like the equivalent native widgets or to
+    give the widgets a custom look.
+
+    Qt provides a set of QStyle subclasses that emulate the native
+    look of the different platforms supported by Qt (QWindowsStyle,
+    QMacStyle, etc.). These styles are built into the
+    Qt GUI module, other styles can be made available using Qt's
+    plugin mechansim.
+
+    Most functions for drawing style elements take four arguments:
+
+    \list
+    \li an enum value specifying which graphical element to draw
+    \li a QStyleOption object specifying how and where to render that element
+    \li a QPainter object that should be used to draw the element
+    \li a QWidget object on which the drawing is performed (optional)
+    \endlist
+
+    The style gets all the information it needs to render the
+    graphical element from the QStyleOption class. The widget is
+    passed as the last argument in case the style needs it to perform
+    special effects (such as animated default buttons on Mac OS X),
+    but it isn't mandatory. In fact, QStyle can be used to draw on any
+    paint device (not just widgets), in which case the widget argument
+    is a zero pointer.
+
+    \image paintsystem-stylepainter.png
+
+    The paint system also provides the QStylePainter class inheriting
+    from QPainter.  QStylePainter is a convenience class for drawing
+    QStyle elements inside a widget, and extends QPainter with a set
+    of high-level drawing functions implemented on top of QStyle's
+    API. The advantage of using QStylePainter is that the parameter
+    lists get considerably shorter.
+
+    \table 100%
+    \row
+    \li \inlineimage paintsystem-icon.png
+    \li \b QIcon
+
+    The QIcon class provides scalable icons in different modes and states.
+
+    QIcon can generate pixmaps reflecting an icon's state, mode and
+    size. These pixmaps are generated from the set of pixmaps
+    made available to the icon, and are used by Qt widgets to show an
+    icon representing a particular action.
+
+    The rendering of a QIcon object is handled by the QIconEngine
+    class. Each icon has a corresponding icon engine that is
+    responsible for drawing the icon with a requested size, mode and
+    state.
+
+    \endtable
+
+    For more information about widget styling and appearance, see the
+    \l{Styles and Style Aware Widgets}.
+*/
+
+
+/*!
+    \class QStyle
+    \brief The QStyle class is an abstract base class that encapsulates the look and feel of a GUI.
+
+    \ingroup appearance
+    \inmodule QtWidgets
+
+    Qt contains a set of QStyle subclasses that emulate the styles of
+    the different platforms supported by Qt (QWindowsStyle,
+    QMacStyle etc.). By default, these styles are built
+    into the Qt GUI module. Styles can also be made available as
+    plugins.
+
+    Qt's built-in widgets use QStyle to perform nearly all of their
+    drawing, ensuring that they look exactly like the equivalent
+    native widgets. The diagram below shows a QComboBox in eight
+    different styles.
+
+    \image qstyle-comboboxes.png Eight combo boxes
+
+    Topics:
+
+    \tableofcontents
+
+    \section1 Setting a Style
+
+    The style of the entire application can be set using the
+    QApplication::setStyle() function. It can also be specified by the
+    user of the application, using the \c -style command-line option:
+
+    \snippet code/src_gui_styles_qstyle.cpp 0
+
+    If no style is specified, Qt will choose the most appropriate
+    style for the user's platform or desktop environment.
+
+    A style can also be set on an individual widget using the
+    QWidget::setStyle() function.
+
+    \section1 Developing Style-Aware Custom Widgets
+
+    If you are developing custom widgets and want them to look good on
+    all platforms, you can use QStyle functions to perform parts of
+    the widget drawing, such as drawItemText(), drawItemPixmap(),
+    drawPrimitive(), drawControl(), and drawComplexControl().
+
+    Most QStyle draw functions take four arguments:
+    \list
+    \li an enum value specifying which graphical element to draw
+    \li a QStyleOption specifying how and where to render that element
+    \li a QPainter that should be used to draw the element
+    \li a QWidget on which the drawing is performed (optional)
+    \endlist
+
+    For example, if you want to draw a focus rectangle on your
+    widget, you can write:
+
+    \snippet styles/styles.cpp 1
+
+    QStyle gets all the information it needs to render the graphical
+    element from QStyleOption. The widget is passed as the last
+    argument in case the style needs it to perform special effects
+    (such as animated default buttons on Mac OS X), but it isn't
+    mandatory. In fact, you can use QStyle to draw on any paint
+    device, not just widgets, by setting the QPainter properly.
+
+    QStyleOption has various subclasses for the various types of
+    graphical elements that can be drawn. For example,
+    PE_FrameFocusRect expects a QStyleOptionFocusRect argument.
+
+    To ensure that drawing operations are as fast as possible,
+    QStyleOption and its subclasses have public data members. See the
+    QStyleOption class documentation for details on how to use it.
+
+    For convenience, Qt provides the QStylePainter class, which
+    combines a QStyle, a QPainter, and a QWidget. This makes it
+    possible to write
+
+    \snippet styles/styles.cpp 5
+    \dots
+    \snippet styles/styles.cpp 7
+
+    instead of
+
+    \snippet styles/styles.cpp 2
+    \dots
+    \snippet styles/styles.cpp 3
+
+    \section1 Creating a Custom Style
+
+    You can create a custom look and feel for your application by
+    creating a custom style. There are two approaches to creating a
+    custom style. In the static approach, you either choose an
+    existing QStyle class, subclass it, and reimplement virtual
+    functions to provide the custom behavior, or you create an entire
+    QStyle class from scratch. In the dynamic approach, you modify the
+    behavior of your system style at runtime. The static approach is
+    described below. The dynamic approach is described in QProxyStyle.
+
+    The first step in the static approach is to pick one of the styles
+    provided by Qt from which you will build your custom style. Your
+    choice of QStyle class will depend on which style resembles your
+    desired style the most. The most general class that you can use as
+    a base is QCommonStyle (not QStyle). This is because Qt requires
+    its styles to be \l{QCommonStyle}s.
+
+    Depending on which parts of the base style you want to change,
+    you must reimplement the functions that are used to draw those
+    parts of the interface. To illustrate this, we will modify the
+    look of the spin box arrows drawn by QWindowsStyle. The arrows
+    are \e{primitive elements} that are drawn by the drawPrimitive()
+    function, so we need to reimplement that function. We need the
+    following class declaration:
+
+    \snippet customstyle/customstyle.h 0
+
+    To draw its up and down arrows, QSpinBox uses the
+    PE_IndicatorSpinUp and PE_IndicatorSpinDown primitive elements.
+    Here's how to reimplement the drawPrimitive() function to draw
+    them differently:
+
+    \snippet customstyle/customstyle.cpp 2
+    \snippet customstyle/customstyle.cpp 3
+    \snippet customstyle/customstyle.cpp 4
+
+    Notice that we don't use the \c widget argument, except to pass it
+    on to the QWindowStyle::drawPrimitive() function. As mentioned
+    earlier, the information about what is to be drawn and how it
+    should be drawn is specified by a QStyleOption object, so there is
+    no need to ask the widget.
+
+    If you need to use the \c widget argument to obtain additional
+    information, be careful to ensure that it isn't 0 and that it is
+    of the correct type before using it. For example:
+
+    \snippet customstyle/customstyle.cpp 0
+    \dots
+    \snippet customstyle/customstyle.cpp 1
+
+    When implementing a custom style, you cannot assume that the
+    widget is a QSpinBox just because the enum value is called
+    PE_IndicatorSpinUp or PE_IndicatorSpinDown.
+
+    The documentation for the \l{widgets/styles}{Styles} example
+    covers this topic in more detail.
+
+    \warning Qt style sheets are currently not supported for custom QStyle
+    subclasses. We plan to address this in some future release.
+
+
+    \section1 Using a Custom Style
+
+    There are several ways of using a custom style in a Qt
+    application. The simplest way is to pass the custom style to the
+    QApplication::setStyle() static function before creating the
+    QApplication object:
+
+    \snippet customstyle/main.cpp using a custom style
+
+    You can call QApplication::setStyle() at any time, but by calling
+    it before the constructor, you ensure that the user's preference,
+    set using the \c -style command-line option, is respected.
+
+    You may want to make your custom style available for use in other
+    applications, which may not be yours and hence not available for
+    you to recompile. The Qt Plugin system makes it possible to create
+    styles as plugins. Styles created as plugins are loaded as shared
+    objects at runtime by Qt itself. Please refer to the \l{plugins-howto.html}{Qt Plugin} documentation for more
+    information on how to go about creating a style plugin.
+
+    Compile your plugin and put it into Qt's \c plugins/styles
+    directory. We now have a pluggable style that Qt can load
+    automatically. To use your new style with existing applications,
+    simply start the application with the following argument:
+
+    \snippet code/src_gui_styles_qstyle.cpp 1
+
+    The application will use the look and feel from the custom style you
+    implemented.
+
+    \section1 Right-to-Left Desktops
+
+    Languages written from right to left (such as Arabic and Hebrew)
+    usually also mirror the whole layout of widgets, and require the
+    light to come from the screen's top-right corner instead of
+    top-left.
+
+    If you create a custom style, you should take special care when
+    drawing asymmetric elements to make sure that they also look
+    correct in a mirrored layout. An easy way to test your styles is
+    to run applications with the \c -reverse command-line option or
+    to call QApplication::setLayoutDirection() in your \c main()
+    function.
+
+    Here are some things to keep in mind when making a style work well in a
+    right-to-left environment:
+
+    \list
+    \li subControlRect() and subElementRect() return rectangles in screen coordinates
+    \li QStyleOption::direction indicates in which direction the item should be drawn in
+    \li If a style is not right-to-left aware it will display items as if it were left-to-right
+    \li visualRect(), visualPos(), and visualAlignment() are helpful functions that will
+       translate from logical to screen representations.
+    \li alignedRect() will return a logical rect aligned for the current direction
+    \endlist
+
+    \section1 Styles in Item Views
+
+    The painting of items in views is performed by a delegate. Qt's
+    default delegate, QStyledItemDelegate, is also used for calculating bounding
+    rectangles of items, and their sub-elements for the various kind
+    of item \l{Qt::ItemDataRole}{data roles}
+    QStyledItemDelegate supports. See the QStyledItemDelegate class
+    description to find out which datatypes and roles are supported. You
+    can read more about item data roles in \l{Model/View Programming}.
+
+    When QStyledItemDelegate paints its items, it draws
+    CE_ItemViewItem, and calculates their size with CT_ItemViewItem.
+    Note also that it uses SE_ItemViewItemText to set the size of
+    editors. When implementing a style to customize drawing of item
+    views, you need to check the implementation of QCommonStyle (and
+    any other subclasses from which your style
+    inherits). This way, you find out which and how
+    other style elements are painted, and you can then reimplement the
+    painting of elements that should be drawn differently.
+
+    We include a small example where we customize the drawing of item
+    backgrounds.
+
+    \snippet customviewstyle.cpp 0
+
+    The primitive element PE_PanelItemViewItem is responsible for
+    painting the background of items, and is called from
+    \l{QCommonStyle}'s implementation of CE_ItemViewItem.
+
+    To add support for drawing of new datatypes and item data roles,
+    it is necessary to create a custom delegate. But if you only
+    need to support the datatypes implemented by the default
+    delegate, a custom style does not need an accompanying
+    delegate. The QStyledItemDelegate class description gives more
+    information on custom delegates.
+
+    The drawing of item view headers is also done by the style, giving
+    control over size of header items and row and column sizes.
+
+    \sa QStyleOption, QStylePainter, {Styles Example},
+        {Styles and Style Aware Widgets}, QStyledItemDelegate, {Styling}
+*/
+
+/*!
+    Constructs a style object.
+*/
+QStyle::QStyle()
+    : QObject(*new QStylePrivate)
+{
+    Q_D(QStyle);
+    d->proxyStyle = this;
+}
+
+/*!
+    \internal
+
+    Constructs a style object.
+*/
+QStyle::QStyle(QStylePrivate &dd)
+    : QObject(dd)
+{
+  Q_D(QStyle);
+  d->proxyStyle = this;
+}
+
+/*!
+    Destroys the style object.
+*/
+QStyle::~QStyle()
+{
+}
+
+/*!
+    Initializes the appearance of the given \a widget.
+
+    This function is called for every widget at some point after it
+    has been fully created but just \e before it is shown for the very
+    first time.
+
+    Note that the default implementation does nothing. Reasonable
+    actions in this function might be to call the
+    QWidget::setBackgroundMode() function for the widget. Do not use
+    the function to set, for example, the geometry. Reimplementing
+    this function provides a back-door through which the appearance
+    of a widget can be changed, but with Qt's style engine it is
+    rarely necessary to implement this function; reimplement
+    drawItemPixmap(), drawItemText(), drawPrimitive(), etc. instead.
+
+    The QWidget::inherits() function may provide enough information to
+    allow class-specific customizations. But because new QStyle
+    subclasses are expected to work reasonably with all current and \e
+    future widgets, limited use of hard-coded customization is
+    recommended.
+
+    \sa unpolish()
+*/
+void QStyle::polish(QWidget * /* widget */)
+{
+}
+
+/*!
+    Uninitialize the given \a{widget}'s appearance.
+
+    This function is the counterpart to polish(). It is called for
+    every polished widget whenever the style is dynamically changed;
+    the former style has to unpolish its settings before the new style
+    can polish them again.
+
+    Note that unpolish() will only be called if the widget is
+    destroyed.  This can cause problems in some cases, e.g, if you
+    remove a widget from the UI, cache it, and then reinsert it after
+    the style has changed; some of Qt's classes cache their widgets.
+
+    \sa polish()
+*/
+void QStyle::unpolish(QWidget * /* widget */)
+{
+}
+
+/*!
+    \fn void QStyle::polish(QApplication * application)
+    \overload
+
+    Late initialization of the given \a application object.
+*/
+void QStyle::polish(QApplication * /* app */)
+{
+}
+
+/*!
+    \fn void QStyle::unpolish(QApplication * application)
+    \overload
+
+    Uninitialize the given \a application.
+*/
+void QStyle::unpolish(QApplication * /* app */)
+{
+}
+
+/*!
+    \fn void QStyle::polish(QPalette & palette)
+    \overload
+
+    Changes the \a palette according to style specific requirements
+    for color palettes (if any).
+
+    \sa QPalette, QApplication::setPalette()
+*/
+void QStyle::polish(QPalette & /* pal */)
+{
+}
+
+/*!
+    \fn QRect QStyle::itemTextRect(const QFontMetrics &metrics, const QRect &rectangle, int alignment, bool enabled, const QString &text) const
+
+    Returns the area within the given \a rectangle in which to draw
+    the provided \a text according to the specified font \a metrics
+    and \a alignment. The \a enabled parameter indicates whether or
+    not the associated item is enabled.
+
+    If the given \a rectangle is larger than the area needed to render
+    the \a text, the rectangle that is returned will be offset within
+    \a rectangle according to the specified \a alignment.  For
+    example, if \a alignment is Qt::AlignCenter, the returned
+    rectangle will be centered within \a rectangle. If the given \a
+    rectangle is smaller than the area needed, the returned rectangle
+    will be the smallest rectangle large enough to render the \a text.
+
+    \sa Qt::Alignment
+*/
+QRect QStyle::itemTextRect(const QFontMetrics &metrics, const QRect &rect, int alignment, bool enabled,
+                       const QString &text) const
+{
+    QRect result;
+    int x, y, w, h;
+    rect.getRect(&x, &y, &w, &h);
+    if (!text.isEmpty()) {
+        result = metrics.boundingRect(x, y, w, h, alignment, text);
+        if (!enabled && proxy()->styleHint(SH_EtchDisabledText)) {
+            result.setWidth(result.width()+1);
+            result.setHeight(result.height()+1);
+        }
+    } else {
+        result = QRect(x, y, w, h);
+    }
+    return result;
+}
+
+/*!
+    \fn QRect QStyle::itemPixmapRect(const QRect &rectangle, int alignment, const QPixmap &pixmap) const
+
+    Returns the area within the given \a rectangle in which to draw
+    the specified \a pixmap according to the defined \a alignment.
+*/
+QRect QStyle::itemPixmapRect(const QRect &rect, int alignment, const QPixmap &pixmap) const
+{
+    QRect result;
+    int x, y, w, h;
+    rect.getRect(&x, &y, &w, &h);
+    if ((alignment & Qt::AlignVCenter) == Qt::AlignVCenter)
+        y += h/2 - pixmap.height()/2;
+    else if ((alignment & Qt::AlignBottom) == Qt::AlignBottom)
+        y += h - pixmap.height();
+    if ((alignment & Qt::AlignRight) == Qt::AlignRight)
+        x += w - pixmap.width();
+    else if ((alignment & Qt::AlignHCenter) == Qt::AlignHCenter)
+        x += w/2 - pixmap.width()/2;
+    else if ((alignment & Qt::AlignLeft) != Qt::AlignLeft && QApplication::isRightToLeft())
+        x += w - pixmap.width();
+    result = QRect(x, y, pixmap.width(), pixmap.height());
+    return result;
+}
+
+/*!
+    \fn void QStyle::drawItemText(QPainter *painter, const QRect &rectangle, int alignment, const QPalette &palette, bool enabled, const QString& text, QPalette::ColorRole textRole) const
+
+    Draws the given \a text in the specified \a rectangle using the
+    provided \a painter and \a palette.
+
+    The text is drawn using the painter's pen, and aligned and wrapped
+    according to the specified \a alignment. If an explicit \a
+    textRole is specified, the text is drawn using the \a palette's
+    color for the given role. The \a enabled parameter indicates
+    whether or not the item is enabled; when reimplementing this
+    function, the \a enabled parameter should influence how the item is
+    drawn.
+
+    \sa Qt::Alignment, drawItemPixmap()
+*/
+void QStyle::drawItemText(QPainter *painter, const QRect &rect, int alignment, const QPalette &pal,
+                          bool enabled, const QString& text, QPalette::ColorRole textRole) const
+{
+    if (text.isEmpty())
+        return;
+    QPen savedPen;
+    if (textRole != QPalette::NoRole) {
+        savedPen = painter->pen();
+        painter->setPen(QPen(pal.brush(textRole), savedPen.widthF()));
+    }
+    if (!enabled) {
+        if (proxy()->styleHint(SH_DitherDisabledText)) {
+            QRect br;
+            painter->drawText(rect, alignment, text, &br);
+            painter->fillRect(br, QBrush(painter->background().color(), Qt::Dense5Pattern));
+            return;
+        } else if (proxy()->styleHint(SH_EtchDisabledText)) {
+            QPen pen = painter->pen();
+            painter->setPen(pal.light().color());
+            painter->drawText(rect.adjusted(1, 1, 1, 1), alignment, text);
+            painter->setPen(pen);
+        }
+    }
+    painter->drawText(rect, alignment, text);
+    if (textRole != QPalette::NoRole)
+        painter->setPen(savedPen);
+}
+
+/*!
+    \fn void QStyle::drawItemPixmap(QPainter *painter, const QRect &rectangle, int alignment,
+                            const QPixmap &pixmap) const
+
+    Draws the given \a pixmap in the specified \a rectangle, according
+    to the specified \a alignment, using the provided \a painter.
+
+    \sa drawItemText()
+*/
+
+void QStyle::drawItemPixmap(QPainter *painter, const QRect &rect, int alignment,
+                            const QPixmap &pixmap) const
+{
+    qreal scale = pixmap.devicePixelRatio();
+    QRect aligned = alignedRect(QApplication::layoutDirection(), QFlag(alignment), pixmap.size() / scale, rect);
+    QRect inter = aligned.intersected(rect);
+
+    painter->drawPixmap(inter.x(), inter.y(), pixmap, inter.x() - aligned.x(), inter.y() - aligned.y(), inter.width() * scale, inter.height() *scale);
+}
+
+/*!
+    \enum QStyle::PrimitiveElement
+
+    This enum describes the various primitive elements. A
+    primitive element is a common GUI element, such as a checkbox
+    indicator or button bevel.
+
+    \omitvalue PE_IndicatorViewItemCheck
+    \value PE_FrameStatusBar Frame
+
+    \value PE_PanelButtonCommand  Button used to initiate an action, for
+        example, a QPushButton.
+
+    \value PE_FrameDefaultButton  This frame around a default button, e.g. in a dialog.
+    \value PE_PanelButtonBevel  Generic panel with a button bevel.
+    \value PE_PanelButtonTool  Panel for a Tool button, used with QToolButton.
+    \value PE_PanelLineEdit  Panel for a QLineEdit.
+    \value PE_IndicatorButtonDropDown  Indicator for a drop down button, for example, a tool
+                                       button that displays a menu.
+
+    \value PE_FrameFocusRect  Generic focus indicator.
+
+    \value PE_IndicatorArrowUp  Generic Up arrow.
+    \value PE_IndicatorArrowDown  Generic Down arrow.
+    \value PE_IndicatorArrowRight  Generic Right arrow.
+    \value PE_IndicatorArrowLeft  Generic Left arrow.
+
+    \value PE_IndicatorSpinUp  Up symbol for a spin widget, for example a QSpinBox.
+    \value PE_IndicatorSpinDown  Down symbol for a spin widget.
+    \value PE_IndicatorSpinPlus  Increase symbol for a spin widget.
+    \value PE_IndicatorSpinMinus  Decrease symbol for a spin widget.
+
+    \value PE_IndicatorItemViewItemCheck On/off indicator for a view item.
+
+    \value PE_IndicatorCheckBox  On/off indicator, for example, a QCheckBox.
+    \value PE_IndicatorRadioButton  Exclusive on/off indicator, for example, a QRadioButton.
+
+    \value PE_IndicatorDockWidgetResizeHandle  Resize handle for dock windows.
+
+    \value PE_Frame  Generic frame
+    \value PE_FrameMenu  Frame for popup windows/menus; see also QMenu.
+    \value PE_PanelMenuBar  Panel for menu bars.
+    \value PE_PanelScrollAreaCorner  Panel at the bottom-right (or
+        bottom-left) corner of a scroll area.
+
+    \value PE_FrameDockWidget  Panel frame for dock windows and toolbars.
+    \value PE_FrameTabWidget  Frame for tab widgets.
+    \value PE_FrameLineEdit  Panel frame for line edits.
+    \value PE_FrameGroupBox  Panel frame around group boxes.
+    \value PE_FrameButtonBevel  Panel frame for a button bevel.
+    \value PE_FrameButtonTool  Panel frame for a tool button.
+
+    \value PE_IndicatorHeaderArrow  Arrow used to indicate sorting on a list or table
+        header.
+    \value PE_FrameStatusBarItem Frame for an item of a status bar; see also QStatusBar.
+
+    \value PE_FrameWindow  Frame around a MDI window or a docking window.
+
+    \value PE_IndicatorMenuCheckMark  Check mark used in a menu.
+
+    \value PE_IndicatorProgressChunk  Section of a progress bar indicator; see also QProgressBar.
+
+    \value PE_IndicatorBranch  Lines used to represent the branch of a tree in a tree view.
+    \value PE_IndicatorToolBarHandle  The handle of a toolbar.
+    \value PE_IndicatorToolBarSeparator  The separator in a toolbar.
+    \value PE_PanelToolBar  The panel for a toolbar.
+    \value PE_PanelTipLabel The panel for a tip label.
+    \value PE_FrameTabBarBase The frame that is drawn for a tab bar, ususally drawn for a tab bar that isn't part of a tab widget.
+    \value PE_IndicatorTabTear An indicator that a tab is partially scrolled out of the visible tab bar when there are many tabs.
+    \value PE_IndicatorColumnViewArrow An arrow in a QColumnView.
+
+    \value PE_Widget  A plain QWidget.
+
+    \value PE_CustomBase Base value for custom primitive elements.
+    All values above this are reserved for custom use. Custom values
+    must be greater than this value.
+
+    \value PE_IndicatorItemViewItemDrop An indicator that is drawn to show where an item in an item view is about to be dropped
+    during a drag-and-drop operation in an item view.
+    \value PE_PanelItemViewItem The background for an item in an item view.
+    \value PE_PanelItemViewRow The background of a row in an item view.
+
+    \value PE_PanelStatusBar The panel for a status bar.
+
+    \value PE_IndicatorTabClose The close button on a tab bar.
+    \value PE_PanelMenu The panel for a menu.
+
+    \sa drawPrimitive()
+*/
+
+
+/*!
+    \enum QStyle::StateFlag
+
+    This enum describes flags that are used when drawing primitive
+    elements.
+
+    Note that not all primitives use all of these flags, and that the
+    flags may mean different things to different items.
+
+    \value State_None Indicates that the widget does not have a state.
+    \value State_Active Indicates that the widget is active.
+    \value State_AutoRaise Used to indicate if auto-raise appearance should be usd on a tool button.
+    \value State_Children Used to indicate if an item view branch has children.
+    \value State_DownArrow Used to indicate if a down arrow should be visible on the widget.
+    \value State_Editing Used to indicate if an editor is opened on the widget.
+    \value State_Enabled Used to indicate if the widget is enabled.
+    \value State_HasEditFocus Used to indicate if the widget currently has edit focus.
+    \value State_HasFocus Used to indicate if the widget has focus.
+    \value State_Horizontal Used to indicate if the widget is laid out horizontally, for example. a tool bar.
+    \value State_KeyboardFocusChange Used to indicate if the focus was changed with the keyboard, e.g., tab, backtab or shortcut.
+    \value State_MouseOver Used to indicate if the widget is under the mouse.
+    \value State_NoChange Used to indicate a tri-state checkbox.
+    \value State_Off Used to indicate if the widget is not checked.
+    \value State_On Used to indicate if the widget is checked.
+    \value State_Raised Used to indicate if a button is raised.
+    \value State_ReadOnly Used to indicate if a widget is read-only.
+    \value State_Selected Used to indicate if a widget is selected.
+    \value State_Item Used by item views to indicate if a horizontal branch should be drawn.
+    \value State_Open Used by item views to indicate if the tree branch is open.
+    \value State_Sibling Used by item views to indicate if a vertical line needs to be drawn (for siblings).
+    \value State_Sunken Used to indicate if the widget is sunken or pressed.
+    \value State_UpArrow Used to indicate if an up arrow should be visible on the widget.
+    \value State_Mini Used to indicate a mini style Mac widget or button.
+    \value State_Small Used to indicate a small style Mac widget or button.
+    \omitvalue State_Window
+    \omitvalue State_Bottom
+    \omitvalue State_FocusAtBorder
+    \omitvalue State_Top
+
+    \sa drawPrimitive()
+*/
+
+/*!
+    \fn void QStyle::drawPrimitive(PrimitiveElement element, const QStyleOption *option, \
+                                   QPainter *painter, const QWidget *widget) const
+
+    Draws the given primitive \a element with the provided \a painter using the style
+    options specified by \a option.
+
+    The \a widget argument is optional and may contain a widget that may
+    aid in drawing the primitive element.
+
+    The table below is listing the primitive elements and their
+    associated style option subclasses. The style options contain all
+    the parameters required to draw the elements, including
+    QStyleOption::state which holds the style flags that are used when
+    drawing. The table also describes which flags that are set when
+    casting the given option to the appropriate subclass.
+
+    Note that if a primitive element is not listed here, it is because
+    it uses a plain QStyleOption object.
+
+    \table
+    \header \li Primitive Element \li QStyleOption Subclass \li Style Flag \li Remark
+    \row \li \l PE_FrameFocusRect \li \l QStyleOptionFocusRect
+         \li \l State_FocusAtBorder
+         \li Whether the focus is is at the border or inside the widget.
+    \row \li{1,2} \l PE_IndicatorCheckBox \li{1,2} \l QStyleOptionButton
+          \li \l State_NoChange \li Indicates a "tri-state" checkbox.
+    \row \li \l State_On \li Indicates the indicator is checked.
+    \row \li \l PE_IndicatorRadioButton \li \l QStyleOptionButton
+          \li \l State_On \li Indicates that a radio button is selected.
+    \row \li \l State_NoChange \li Indicates a "tri-state" controller.
+    \row \li \l State_Enabled \li Indicates the controller is enabled.
+    \row \li{1,4} \l PE_IndicatorBranch \li{1,4} \l QStyleOption
+         \li \l State_Children \li Indicates that the control for expanding the tree to show child items, should be drawn.
+    \row \li \l State_Item \li Indicates that a horizontal branch (to show a child item), should be drawn.
+    \row \li \l State_Open \li Indicates that the tree branch is expanded.
+    \row \li \l State_Sibling \li Indicates that a vertical line (to show a sibling item), should be drawn.
+    \row \li \l PE_IndicatorHeaderArrow \li \l QStyleOptionHeader
+         \li \l State_UpArrow \li Indicates that the arrow should be drawn up;
+         otherwise it should be down.
+    \row \li \l PE_FrameGroupBox, \l PE_Frame, \l PE_FrameLineEdit,
+            \l PE_FrameMenu, \l PE_FrameDockWidget, \l PE_FrameWindow
+         \li \l QStyleOptionFrame \li \l State_Sunken
+         \li Indicates that the Frame should be sunken.
+    \row \li \l PE_IndicatorToolBarHandle \li \l QStyleOption
+         \li \l State_Horizontal \li Indicates that the window handle is horizontal
+         instead of vertical.
+    \row \li \l PE_IndicatorSpinPlus, \l PE_IndicatorSpinMinus, \l PE_IndicatorSpinUp,
+            \l PE_IndicatorSpinDown,
+         \li \l QStyleOptionSpinBox
+         \li \l State_Sunken \li Indicates that the button is pressed.
+    \row \li{1,5} \l PE_PanelButtonCommand
+         \li{1,5} \l QStyleOptionButton
+         \li \l State_Enabled \li Set if the button is enabled.
+    \row \li \l State_HasFocus \li Set if the button has input focus.
+    \row \li \l State_Raised \li Set if the button is not down, not on and not flat.
+    \row \li \l State_On \li Set if the button is a toggle button and is toggled on.
+    \row \li \l State_Sunken
+         \li Set if the button is down (i.e., the mouse button or the
+         space bar is pressed on the button).
+    \endtable
+
+    \sa drawComplexControl(), drawControl()
+*/
+
+/*!
+    \enum QStyle::ControlElement
+
+    This enum represents a control element. A control element is a
+    part of a widget that performs some action or displays information
+    to the user.
+
+    \value CE_PushButton  A QPushButton, draws CE_PushButtonBevel, CE_PushButtonLabel and PE_FrameFocusRect.
+    \value CE_PushButtonBevel  The bevel and default indicator of a QPushButton.
+    \value CE_PushButtonLabel  The label (an icon with text or pixmap) of a QPushButton.
+
+    \value CE_DockWidgetTitle  Dock window title.
+    \value CE_Splitter  Splitter handle; see also QSplitter.
+
+
+    \value CE_CheckBox  A QCheckBox, draws a PE_IndicatorCheckBox, a CE_CheckBoxLabel and a PE_FrameFocusRect.
+    \value CE_CheckBoxLabel  The label (text or pixmap) of a QCheckBox.
+
+    \value CE_RadioButton  A QRadioButton, draws a PE_IndicatorRadioButton, a CE_RadioButtonLabel and a PE_FrameFocusRect.
+    \value CE_RadioButtonLabel  The label (text or pixmap) of a QRadioButton.
+
+    \value CE_TabBarTab       The tab and label within a QTabBar.
+    \value CE_TabBarTabShape  The tab shape within a tab bar.
+    \value CE_TabBarTabLabel  The label within a tab.
+
+    \value CE_ProgressBar  A QProgressBar, draws CE_ProgressBarGroove, CE_ProgressBarContents and CE_ProgressBarLabel.
+    \value CE_ProgressBarGroove  The groove where the progress
+        indicator is drawn in a QProgressBar.
+    \value CE_ProgressBarContents  The progress indicator of a QProgressBar.
+    \value CE_ProgressBarLabel  The text label of a QProgressBar.
+
+    \value CE_ToolButtonLabel  A tool button's label.
+
+    \value CE_MenuBarItem  A menu item in a QMenuBar.
+    \value CE_MenuBarEmptyArea  The empty area of a QMenuBar.
+
+    \value CE_MenuItem  A menu item in a QMenu.
+    \value CE_MenuScroller  Scrolling areas in a QMenu when the
+        style supports scrolling.
+    \value CE_MenuTearoff  A menu item representing the tear off section of
+        a QMenu.
+    \value CE_MenuEmptyArea  The area in a menu without menu items.
+    \value CE_MenuHMargin  The horizontal extra space on the left/right of a menu.
+    \value CE_MenuVMargin  The vertical extra space on the top/bottom of a menu.
+
+    \value CE_ToolBoxTab  The toolbox's tab and label within a QToolBox.
+    \value CE_SizeGrip  Window resize handle; see also QSizeGrip.
+
+    \value CE_Header         A header.
+    \value CE_HeaderSection  A header section.
+    \value CE_HeaderLabel    The header's label.
+
+    \value CE_ScrollBarAddLine  Scroll bar line increase indicator.
+                                (i.e., scroll down); see also QScrollBar.
+    \value CE_ScrollBarSubLine  Scroll bar line decrease indicator (i.e., scroll up).
+    \value CE_ScrollBarAddPage  Scolllbar page increase indicator (i.e., page down).
+    \value CE_ScrollBarSubPage  Scroll bar page decrease indicator (i.e., page up).
+    \value CE_ScrollBarSlider   Scroll bar slider.
+    \value CE_ScrollBarFirst    Scroll bar first line indicator (i.e., home).
+    \value CE_ScrollBarLast     Scroll bar last line indicator (i.e., end).
+
+    \value CE_RubberBand        Rubber band used in for example an icon view.
+
+    \value CE_FocusFrame        Focus frame that is style controlled.
+
+    \value CE_ItemViewItem      An item inside an item view.
+
+    \value CE_CustomBase  Base value for custom control elements;
+    custom values must be greater than this value.
+    \value CE_ComboBoxLabel The label of a non-editable QComboBox.
+    \value CE_ToolBar A toolbar like QToolBar.
+    \value CE_ToolBoxTabShape  The toolbox's tab shape.
+    \value CE_ToolBoxTabLabel  The toolbox's tab label.
+    \value CE_HeaderEmptyArea  The area of a header view where there are no header sections.
+
+    \value CE_ShapedFrame The frame with the shape specified in the QStyleOptionFrameV3; see QFrame.
+
+    \omitvalue CE_ColumnViewGrip
+
+    \sa drawControl()
+*/
+
+/*!
+    \fn void QStyle::drawControl(ControlElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget) const
+
+    Draws the given \a element with the provided  \a painter with the
+    style options specified by \a option.
+
+    The \a widget argument is optional and can be used as aid in
+    drawing the control. The \a option parameter is a pointer to a
+    QStyleOption object that can be cast to the correct subclass
+    using the qstyleoption_cast() function.
+
+    The table below is listing the control elements and their
+    associated style option subclass. The style options contain all
+    the parameters required to draw the controls, including
+    QStyleOption::state which holds the style flags that are used when
+    drawing. The table also describes which flags that are set when
+    casting the given option to the appropriate subclass.
+
+    Note that if a control element is not listed here, it is because
+    it uses a plain QStyleOption object.
+
+    \table
+    \header \li Control Element \li QStyleOption Subclass \li Style Flag \li Remark
+    \row \li{1,5} \l CE_MenuItem, \l CE_MenuBarItem
+         \li{1,5} \l QStyleOptionMenuItem
+         \li \l State_Selected \li The menu item is currently selected item.
+    \row \li \l State_Enabled \li The item is enabled.
+    \row \li \l State_DownArrow \li Indicates that a scroll down arrow should be drawn.
+    \row \li \l State_UpArrow \li Indicates that a scroll up arrow should be drawn
+    \row \li \l State_HasFocus \li Set if the menu bar has input focus.
+
+    \row \li{1,5} \l CE_PushButton, \l CE_PushButtonBevel, \l CE_PushButtonLabel
+         \li{1,5} \l QStyleOptionButton
+         \li \l State_Enabled \li Set if the button is enabled.
+    \row \li \l State_HasFocus \li Set if the button has input focus.
+    \row \li \l State_Raised \li Set if the button is not down, not on and not flat.
+    \row \li \l State_On \li Set if the button is a toggle button and is toggled on.
+    \row \li \l State_Sunken
+         \li Set if the button is down (i.e., the mouse button or the
+         space bar is pressed on the button).
+
+    \row \li{1,6} \l CE_RadioButton, \l CE_RadioButtonLabel,
+                 \l CE_CheckBox, \l CE_CheckBoxLabel
+         \li{1,6} \l QStyleOptionButton
+         \li \l State_Enabled \li Set if the button is enabled.
+    \row \li \l State_HasFocus \li Set if the button has input focus.
+    \row \li \l State_On \li Set if the button is checked.
+    \row \li \l State_Off \li Set if the button is not checked.
+    \row \li \l State_NoChange \li Set if the button is in the NoChange state.
+    \row \li \l State_Sunken
+         \li Set if the button is down (i.e., the mouse button or
+         the space bar is pressed on the button).
+
+   \row \li{1,2} \l CE_ProgressBarContents, \l CE_ProgressBarLabel,
+                 \l CE_ProgressBarGroove
+         \li{1,2} \l QStyleOptionProgressBar
+         \li \l State_Enabled \li Set if the progress bar is enabled.
+    \row \li \l State_HasFocus \li Set if the progress bar has input focus.
+
+    \row \li \l CE_Header, \l CE_HeaderSection, \l CE_HeaderLabel \li \l QStyleOptionHeader \li \li
+
+    \row \li{1,3} \l CE_TabBarTab, CE_TabBarTabShape, CE_TabBarTabLabel
+        \li{1,3} \l QStyleOptionTab
+        \li \l State_Enabled \li Set if the tab bar is enabled.
+    \row \li \l State_Selected \li The tab bar is the currently selected tab bar.
+    \row \li \l State_HasFocus \li Set if the tab bar tab has input focus.
+
+    \row \li{1,7} \l CE_ToolButtonLabel
+         \li{1,7} \l QStyleOptionToolButton
+         \li \l State_Enabled \li Set if the tool button is enabled.
+    \row \li \l State_HasFocus \li Set if the tool button has input focus.
+    \row \li \l State_Sunken
+         \li Set if the tool button is down (i.e., a mouse button or
+         the space bar is pressed).
+    \row \li \l State_On \li Set if the tool button is a toggle button and is toggled on.
+    \row \li \l State_AutoRaise \li Set if the tool button has auto-raise enabled.
+    \row \li \l State_MouseOver \li Set if the mouse pointer is over the tool button.
+    \row \li \l State_Raised \li Set if the button is not down and is not on.
+
+    \row \li \l CE_ToolBoxTab \li \l QStyleOptionToolBox
+         \li \l State_Selected \li The tab is the currently selected tab.
+    \row \li{1,3} \l CE_HeaderSection \li{1,3} \l QStyleOptionHeader
+         \li \l State_Sunken \li Indicates that the section is pressed.
+    \row \li \l State_UpArrow \li Indicates that the sort indicator should be pointing up.
+    \row \li \l State_DownArrow \li Indicates that the sort indicator should be pointing down.
+    \endtable
+
+    \sa drawPrimitive(), drawComplexControl()
+*/
+
+/*!
+    \enum QStyle::SubElement
+
+    This enum represents a sub-area of a widget. Style implementations
+    use these areas to draw the different parts of a widget.
+
+    \value SE_PushButtonContents  Area containing the label (icon
+        with text or pixmap).
+    \value SE_PushButtonFocusRect  Area for the focus rect (usually
+        larger than the contents rect).
+    \value SE_PushButtonLayoutItem  Area that counts for the parent layout.
+
+    \value SE_CheckBoxIndicator  Area for the state indicator (e.g., check mark).
+    \value SE_CheckBoxContents  Area for the label (text or pixmap).
+    \value SE_CheckBoxFocusRect  Area for the focus indicator.
+    \value SE_CheckBoxClickRect  Clickable area, defaults to SE_CheckBoxFocusRect.
+    \value SE_CheckBoxLayoutItem  Area that counts for the parent layout.
+
+    \value SE_DateTimeEditLayoutItem  Area that counts for the parent layout.
+
+    \value SE_RadioButtonIndicator  Area for the state indicator.
+    \value SE_RadioButtonContents  Area for the label.
+    \value SE_RadioButtonFocusRect  Area for the focus indicator.
+    \value SE_RadioButtonClickRect  Clickable area, defaults to SE_RadioButtonFocusRect.
+    \value SE_RadioButtonLayoutItem  Area that counts for the parent layout.
+
+    \value SE_ComboBoxFocusRect  Area for the focus indicator.
+
+    \value SE_SliderFocusRect  Area for the focus indicator.
+    \value SE_SliderLayoutItem  Area that counts for the parent layout.
+
+    \value SE_SpinBoxLayoutItem  Area that counts for the parent layout.
+
+    \value SE_ProgressBarGroove  Area for the groove.
+    \value SE_ProgressBarContents  Area for the progress indicator.
+    \value SE_ProgressBarLabel  Area for the text label.
+    \value SE_ProgressBarLayoutItem Area that counts for the parent layout.
+
+    \omitvalue SE_ViewItemCheckIndicator
+
+    \value SE_FrameContents  Area for a frame's contents.
+    \value SE_ShapedFrameContents Area for a frame's contents using the shape in QStyleOptionFrameV3; see QFrame
+    \value SE_FrameLayoutItem  Area that counts for the parent layout.
+
+    \value SE_HeaderArrow Area for the sort indicator for a header.
+    \value SE_HeaderLabel Area for the label in a header.
+
+    \value SE_LabelLayoutItem  Area that counts for the parent layout.
+
+    \value SE_LineEditContents  Area for a line edit's contents.
+
+    \value SE_TabWidgetLeftCorner Area for the left corner widget in a tab widget.
+    \value SE_TabWidgetRightCorner Area for the right corner widget in a tab widget.
+    \value SE_TabWidgetTabBar Area for the tab bar widget in a tab widget.
+    \value SE_TabWidgetTabContents Area for the contents of the tab widget.
+    \value SE_TabWidgetTabPane Area for the pane of a tab widget.
+    \value SE_TabWidgetLayoutItem  Area that counts for the parent layout.
+
+    \value SE_ToolBoxTabContents  Area for a toolbox tab's icon and label.
+
+    \value SE_ToolButtonLayoutItem  Area that counts for the parent layout.
+
+    \value SE_ItemViewItemCheckIndicator Area for a view item's check mark.
+
+    \value SE_TabBarTearIndicator Area for the tear indicator on a tab bar with scroll arrows.
+
+    \value SE_TreeViewDisclosureItem Area for the actual disclosure item in a tree branch.
+
+    \value SE_DialogButtonBoxLayoutItem  Area that counts for the parent layout.
+
+    \value SE_GroupBoxLayoutItem  Area that counts for the parent layout.
+
+    \value SE_CustomBase  Base value for custom sub-elements.
+    Custom values must be greater than this value.
+
+    \value SE_DockWidgetFloatButton The float button of a dock
+                                    widget.
+    \value SE_DockWidgetTitleBarText The text bounds of the dock
+                                     widgets title.
+    \value SE_DockWidgetCloseButton The close button of a dock
+                                    widget.
+    \value SE_DockWidgetIcon The icon of a dock widget.
+    \value SE_ComboBoxLayoutItem Area that counts for the parent layout.
+
+
+    \value SE_ItemViewItemDecoration Area for a view item's decoration (icon).
+    \value SE_ItemViewItemText Area for a view item's text.
+    \value SE_ItemViewItemFocusRect Area for a view item's focus rect.
+
+    \value SE_TabBarTabLeftButton Area for a widget on the left side of a tab in a tab bar.
+    \value SE_TabBarTabRightButton Area for a widget on the right side of a tab in a tab bar.
+    \value SE_TabBarTabText Area for the text on a tab in a tab bar.
+
+    \value SE_ToolBarHandle Area for the handle of a tool bar.
+
+    \sa subElementRect()
+*/
+
+/*!
+    \fn QRect QStyle::subElementRect(SubElement element, const QStyleOption *option, const QWidget *widget) const
+
+    Returns the sub-area for the given \a element as described in the
+    provided style \a option. The returned rectangle is defined in
+    screen coordinates.
+
+    The \a widget argument is optional and can be used to aid
+    determining the area. The QStyleOption object can be cast to the
+    appropriate type using the qstyleoption_cast() function. See the
+    table below for the appropriate \a option casts:
+
+    \table
+    \header \li Sub Element \li QStyleOption Subclass
+    \row \li \l SE_PushButtonContents   \li \l QStyleOptionButton
+    \row \li \l SE_PushButtonFocusRect  \li \l QStyleOptionButton
+    \row \li \l SE_CheckBoxIndicator    \li \l QStyleOptionButton
+    \row \li \l SE_CheckBoxContents     \li \l QStyleOptionButton
+    \row \li \l SE_CheckBoxFocusRect    \li \l QStyleOptionButton
+    \row \li \l SE_RadioButtonIndicator \li \l QStyleOptionButton
+    \row \li \l SE_RadioButtonContents  \li \l QStyleOptionButton
+    \row \li \l SE_RadioButtonFocusRect \li \l QStyleOptionButton
+    \row \li \l SE_ComboBoxFocusRect    \li \l QStyleOptionComboBox
+    \row \li \l SE_ProgressBarGroove    \li \l QStyleOptionProgressBar
+    \row \li \l SE_ProgressBarContents  \li \l QStyleOptionProgressBar
+    \row \li \l SE_ProgressBarLabel     \li \l QStyleOptionProgressBar
+    \endtable
+*/
+
+/*!
+    \enum QStyle::ComplexControl
+
+    This enum describes the available complex controls. Complex
+    controls have different behavior depending upon where the user
+    clicks on them or which keys are pressed.
+
+    \value CC_SpinBox           A spinbox, like QSpinBox.
+    \value CC_ComboBox          A combobox, like QComboBox.
+    \value CC_ScrollBar         A scroll bar, like QScrollBar.
+    \value CC_Slider            A slider, like QSlider.
+    \value CC_ToolButton        A tool button, like QToolButton.
+    \value CC_TitleBar          A Title bar, like those used in QMdiSubWindow.
+    \value CC_GroupBox          A group box, like QGroupBox.
+    \value CC_Dial              A dial, like QDial.
+    \value CC_MdiControls       The minimize, close, and normal
+                                button in the menu bar for a
+                                maximized MDI subwindow.
+
+    \value CC_CustomBase Base value for custom complex controls. Custom
+    values must be greater than this value.
+
+    \sa SubControl, drawComplexControl()
+*/
+
+/*!
+    \enum QStyle::SubControl
+
+    This enum describes the available sub controls. A subcontrol is a
+    control element within a complex control (ComplexControl).
+
+    \value SC_None  Special value that matches no other sub control.
+
+    \value SC_ScrollBarAddLine  Scroll bar add line (i.e., down/right
+        arrow); see also QScrollBar.
+    \value SC_ScrollBarSubLine  Scroll bar sub line (i.e., up/left arrow).
+    \value SC_ScrollBarAddPage  Scroll bar add page (i.e., page down).
+    \value SC_ScrollBarSubPage  Scroll bar sub page (i.e., page up).
+    \value SC_ScrollBarFirst  Scroll bar first line (i.e., home).
+    \value SC_ScrollBarLast  Scroll bar last line (i.e., end).
+    \value SC_ScrollBarSlider  Scroll bar slider handle.
+    \value SC_ScrollBarGroove  Special sub-control which contains the
+        area in which the slider handle may move.
+
+    \value SC_SpinBoxUp  Spin widget up/increase; see also QSpinBox.
+    \value SC_SpinBoxDown  Spin widget down/decrease.
+    \value SC_SpinBoxFrame  Spin widget frame.
+    \value SC_SpinBoxEditField  Spin widget edit field.
+
+    \value SC_ComboBoxEditField  Combobox edit field; see also QComboBox.
+    \value SC_ComboBoxArrow  Combobox arrow button.
+    \value SC_ComboBoxFrame  Combobox frame.
+    \value SC_ComboBoxListBoxPopup  The reference rectangle for the combobox popup.
+        Used to calculate the position of the popup.
+
+    \value SC_SliderGroove  Special sub-control which contains the area
+        in which the slider handle may move.
+    \value SC_SliderHandle  Slider handle.
+    \value SC_SliderTickmarks  Slider tickmarks.
+
+    \value SC_ToolButton  Tool button (see also QToolButton).
+    \value SC_ToolButtonMenu  Sub-control for opening a popup menu in a
+        tool button.
+
+    \value SC_TitleBarSysMenu  System menu button (i.e., restore, close, etc.).
+    \value SC_TitleBarMinButton  Minimize button.
+    \value SC_TitleBarMaxButton  Maximize button.
+    \value SC_TitleBarCloseButton  Close button.
+    \value SC_TitleBarLabel  Window title label.
+    \value SC_TitleBarNormalButton  Normal (restore) button.
+    \value SC_TitleBarShadeButton  Shade button.
+    \value SC_TitleBarUnshadeButton  Unshade button.
+    \value SC_TitleBarContextHelpButton Context Help button.
+
+    \value SC_DialHandle The handle of the dial (i.e. what you use to control the dial).
+    \value SC_DialGroove The groove for the dial.
+    \value SC_DialTickmarks The tickmarks for the dial.
+
+    \value SC_GroupBoxFrame The frame of a group box.
+    \value SC_GroupBoxLabel The title of a group box.
+    \value SC_GroupBoxCheckBox The optional check box of a group box.
+    \value SC_GroupBoxContents The group box contents.
+
+    \value SC_MdiNormalButton The normal button for a MDI
+                              subwindow in the menu bar.
+    \value SC_MdiMinButton The minimize button for a MDI
+                           subwindow in the menu bar.
+    \value SC_MdiCloseButton The close button for a MDI subwindow
+                             in the menu bar.
+
+    \value SC_All  Special value that matches all sub-controls.
+    \omitvalue SC_CustomBase
+
+    \sa ComplexControl
+*/
+
+/*!
+    \fn void QStyle::drawComplexControl(ComplexControl control, const QStyleOptionComplex *option, QPainter *painter, const QWidget *widget) const
+
+    Draws the given \a control using the provided \a painter with the
+    style options specified by \a option.
+
+    The \a widget argument is optional and can be used as aid in
+    drawing the control.
+
+    The \a option parameter is a pointer to a QStyleOptionComplex
+    object that can be cast to the correct subclass using the
+    qstyleoption_cast() function. Note that the \c rect member of the
+    specified \a option must be in logical
+    coordinates. Reimplementations of this function should use
+    visualRect() to change the logical coordinates into screen
+    coordinates before calling the drawPrimitive() or drawControl()
+    function.
+
+    The table below is listing the complex control elements and their
+    associated style option subclass. The style options contain all
+    the parameters required to draw the controls, including
+    QStyleOption::state which holds the \l {QStyle::StateFlag}{style
+    flags} that are used when drawing. The table also describes which
+    flags that are set when casting the given \a option to the
+    appropriate subclass.
+
+    \table
+    \header \li Complex Control \li QStyleOptionComplex Subclass \li Style Flag \li Remark
+    \row \li{1,2} \l{CC_SpinBox} \li{1,2} \l QStyleOptionSpinBox
+         \li \l State_Enabled \li Set if the spin box is enabled.
+    \row \li \l State_HasFocus \li Set if the spin box has input focus.
+
+    \row \li{1,2} \l {CC_ComboBox} \li{1,2} \l QStyleOptionComboBox
+         \li \l State_Enabled \li Set if the combobox is enabled.
+    \row \li \l State_HasFocus \li Set if the combobox has input focus.
+
+    \row \li{1,2} \l {CC_ScrollBar} \li{1,2} \l QStyleOptionSlider
+         \li \l State_Enabled \li Set if the scroll bar is enabled.
+    \row \li \l State_HasFocus \li Set if the scroll bar has input focus.
+
+    \row \li{1,2} \l {CC_Slider} \li{1,2} \l QStyleOptionSlider
+         \li \l State_Enabled \li Set if the slider is enabled.
+    \row \li \l State_HasFocus \li Set if the slider has input focus.
+
+    \row \li{1,2} \l {CC_Dial} \li{1,2} \l QStyleOptionSlider
+         \li \l State_Enabled \li Set if the dial is enabled.
+    \row \li \l State_HasFocus \li Set if the dial has input focus.
+
+    \row \li{1,6} \l {CC_ToolButton} \li{1,6} \l QStyleOptionToolButton
+         \li \l State_Enabled \li Set if the tool button is enabled.
+    \row \li \l State_HasFocus \li Set if the tool button has input focus.
+    \row \li \l State_DownArrow \li Set if the tool button is down (i.e., a mouse
+        button or the space bar is pressed).
+    \row \li \l State_On \li Set if the tool button is a toggle button
+        and is toggled on.
+    \row \li \l State_AutoRaise \li Set if the tool button has auto-raise enabled.
+    \row \li \l State_Raised \li Set if the button is not down, not on, and doesn't
+        contain the mouse when auto-raise is enabled.
+
+    \row \li \l{CC_TitleBar} \li \l QStyleOptionTitleBar
+         \li \l State_Enabled \li Set if the title bar is enabled.
+
+    \endtable
+
+    \sa drawPrimitive(), drawControl()
+*/
+
+
+/*!
+    \fn QRect QStyle::subControlRect(ComplexControl control,
+        const QStyleOptionComplex *option, SubControl subControl,
+        const QWidget *widget) const = 0
+
+    Returns the rectangle containing the specified \a subControl of
+    the given complex \a control (with the style specified by \a
+    option). The rectangle is defined in screen coordinates.
+
+    The \a option argument is a pointer to QStyleOptionComplex or
+    one of its subclasses, and can be cast to the appropriate type
+    using the qstyleoption_cast() function. See drawComplexControl()
+    for details. The \a widget is optional and can contain additional
+    information for the function.
+
+    \sa drawComplexControl()
+*/
+
+/*!
+    \fn QStyle::SubControl QStyle::hitTestComplexControl(ComplexControl control,
+        const QStyleOptionComplex *option, const QPoint &position,
+        const QWidget *widget) const = 0
+
+    Returns the sub control at the given \a position in the given
+    complex \a control (with the style options specified by \a
+    option).
+
+    Note that the \a position is expressed in screen coordinates.
+
+    The \a option argument is a pointer to a QStyleOptionComplex
+    object (or one of its subclasses). The object can be cast to the
+    appropriate type using the qstyleoption_cast() function. See
+    drawComplexControl() for details. The \a widget argument is
+    optional and can contain additional information for the function.
+
+    \sa drawComplexControl(), subControlRect()
+*/
+
+/*!
+    \enum QStyle::PixelMetric
+
+    This enum describes the various available pixel metrics. A pixel
+    metric is a style dependent size represented by a single pixel
+    value.
+
+    \value PM_ButtonMargin  Amount of whitespace between push button
+        labels and the frame.
+    \value PM_DockWidgetTitleBarButtonMargin Amount of whitespace between dock widget's
+        title bar button labels and the frame.
+    \value PM_ButtonDefaultIndicator  Width of the default-button indicator frame.
+    \value PM_MenuButtonIndicator  Width of the menu button indicator
+        proportional to the widget height.
+    \value PM_ButtonShiftHorizontal  Horizontal contents shift of a
+        button when the button is down.
+    \value PM_ButtonShiftVertical  Vertical contents shift of a button when the
+        button is down.
+
+    \value PM_DefaultFrameWidth  Default frame width (usually 2).
+    \value PM_SpinBoxFrameWidth  Frame width of a spin box, defaults to PM_DefaultFrameWidth.
+    \value PM_ComboBoxFrameWidth Frame width of a combo box, defaults to PM_DefaultFrameWidth.
+
+    \value PM_MDIFrameWidth  Obsolete. Use PM_MdiSubWindowFrameWidth instead.
+    \value PM_MdiSubWindowFrameWidth  Frame width of an MDI window.
+    \value PM_MDIMinimizedWidth  Obsolete. Use PM_MdiSubWindowMinimizedWidth instead.
+    \value PM_MdiSubWindowMinimizedWidth  Width of a minimized MDI window.
+
+    \value PM_LayoutLeftMargin  Default \l{QLayout::setContentsMargins()}{left margin} for a
+                                QLayout.
+    \value PM_LayoutTopMargin  Default \l{QLayout::setContentsMargins()}{top margin} for a QLayout.
+    \value PM_LayoutRightMargin  Default \l{QLayout::setContentsMargins()}{right margin} for a
+                                 QLayout.
+    \value PM_LayoutBottomMargin  Default \l{QLayout::setContentsMargins()}{bottom margin} for a
+                                  QLayout.
+    \value PM_LayoutHorizontalSpacing  Default \l{QLayout::spacing}{horizontal spacing} for a
+                                       QLayout.
+    \value PM_LayoutVerticalSpacing  Default \l{QLayout::spacing}{vertical spacing} for a QLayout.
+
+    \value PM_MaximumDragDistance The maximum allowed distance between
+    the mouse and a scrollbar when dragging. Exceeding the specified
+    distance will cause the slider to jump back to the original
+    position; a value of -1 disables this behavior.
+
+    \value PM_ScrollBarExtent  Width of a vertical scroll bar and the
+        height of a horizontal scroll bar.
+    \value PM_ScrollBarSliderMin  The minimum height of a vertical
+        scroll bar's slider and the minimum width of a horizontal
+        scroll bar's slider.
+
+    \value PM_SliderThickness  Total slider thickness.
+    \value PM_SliderControlThickness  Thickness of the slider handle.
+    \value PM_SliderLength  Length of the slider.
+    \value PM_SliderTickmarkOffset  The offset between the tickmarks
+        and the slider.
+    \value PM_SliderSpaceAvailable  The available space for the slider to move.
+
+    \value PM_DockWidgetSeparatorExtent  Width of a separator in a
+        horizontal dock window and the height of a separator in a
+        vertical dock window.
+    \value PM_DockWidgetHandleExtent  Width of the handle in a
+        horizontal dock window and the height of the handle in a
+        vertical dock window.
+    \value PM_DockWidgetFrameWidth  Frame width of a dock window.
+    \value PM_DockWidgetTitleMargin Margin of the dock window title.
+
+    \value PM_MenuBarPanelWidth  Frame width of a menu bar, defaults to PM_DefaultFrameWidth.
+    \value PM_MenuBarItemSpacing  Spacing between menu bar items.
+    \value PM_MenuBarHMargin  Spacing between menu bar items and left/right of bar.
+    \value PM_MenuBarVMargin  Spacing between menu bar items and top/bottom of bar.
+
+    \value PM_ToolBarFrameWidth  Width of the frame around toolbars.
+    \value PM_ToolBarHandleExtent Width of a toolbar handle in a
+        horizontal toolbar and the height of the handle in a vertical toolbar.
+    \value PM_ToolBarItemMargin  Spacing between the toolbar frame and the items.
+    \value PM_ToolBarItemSpacing  Spacing between toolbar items.
+    \value PM_ToolBarSeparatorExtent Width of a toolbar separator in a
+        horizontal toolbar and the height of a separator in a vertical toolbar.
+    \value PM_ToolBarExtensionExtent Width of a toolbar extension
+         button in a horizontal toolbar and the height of the button in a
+         vertical toolbar.
+
+    \value PM_TabBarTabOverlap  Number of pixels the tabs should overlap.
+        (Currently only used in styles, not inside of QTabBar)
+    \value PM_TabBarTabHSpace  Extra space added to the tab width.
+    \value PM_TabBarTabVSpace  Extra space added to the tab height.
+    \value PM_TabBarBaseHeight  Height of the area between the tab bar
+        and the tab pages.
+    \value PM_TabBarBaseOverlap  Number of pixels the tab bar overlaps
+        the tab bar base.
+    \value PM_TabBarScrollButtonWidth
+    \value PM_TabBarTabShiftHorizontal  Horizontal pixel shift when a
+        tab is selected.
+    \value PM_TabBarTabShiftVertical  Vertical pixel shift when a
+        tab is selected.
+
+    \value PM_ProgressBarChunkWidth  Width of a chunk in a progress bar indicator.
+
+    \value PM_SplitterWidth  Width of a splitter.
+
+    \value PM_TitleBarHeight  Height of the title bar.
+
+    \value PM_IndicatorWidth  Width of a check box indicator.
+    \value PM_IndicatorHeight  Height of a checkbox indicator.
+    \value PM_ExclusiveIndicatorWidth  Width of a radio button indicator.
+    \value PM_ExclusiveIndicatorHeight  Height of a radio button indicator.
+
+    \value PM_MenuPanelWidth  Border width (applied on all sides) for a QMenu.
+    \value PM_MenuHMargin  Additional border (used on left and right) for a QMenu.
+    \value PM_MenuVMargin  Additional border (used for bottom and top) for a QMenu.
+    \value PM_MenuScrollerHeight  Height of the scroller area in a QMenu.
+    \value PM_MenuTearoffHeight  Height of a tear off area in a QMenu.
+    \value PM_MenuDesktopFrameWidth The frame width for the menu on the desktop.
+
+    \omitvalue PM_DialogButtonsSeparator
+    \omitvalue PM_DialogButtonsButtonWidth
+    \omitvalue PM_DialogButtonsButtonHeight
+
+    \value PM_HeaderMarkSize The size of the sort indicator in a header.
+    \value PM_HeaderGripMargin The size of the resize grip in a header.
+    \value PM_HeaderMargin The size of the margin between the sort indicator and the text.
+    \value PM_SpinBoxSliderHeight The height of the optional spin box slider.
+
+    \value PM_ToolBarIconSize Default tool bar icon size
+    \value PM_SmallIconSize Default small icon size
+    \value PM_LargeIconSize Default large icon size
+
+    \value PM_FocusFrameHMargin Horizontal margin that the focus frame will outset the widget by.
+    \value PM_FocusFrameVMargin Vertical margin that the focus frame will outset the widget by.
+    \value PM_IconViewIconSize The default size for icons in an icon view.
+    \value PM_ListViewIconSize The default size for icons in a list view.
+
+    \value PM_ToolTipLabelFrameWidth The frame width for a tool tip label.
+    \value PM_CheckBoxLabelSpacing The spacing between a check box indicator and its label.
+    \value PM_RadioButtonLabelSpacing The spacing between a radio button indicator and its label.
+    \value PM_TabBarIconSize The default icon size for a tab bar.
+    \value PM_SizeGripSize The size of a size grip.
+    \value PM_MessageBoxIconSize The size of the standard icons in a message box
+    \value PM_ButtonIconSize The default size of button icons
+    \value PM_TextCursorWidth The width of the cursor in a line edit or text edit
+    \value PM_TabBar_ScrollButtonOverlap The distance between the left and right buttons in a tab bar.
+
+    \value PM_TabCloseIndicatorWidth The default width of a close button on a tab in a tab bar.
+    \value PM_TabCloseIndicatorHeight The default height of a close button on a tab in a tab bar.
+
+    \value PM_CustomBase Base value for custom pixel metrics.  Custom
+    values must be greater than this value.
+
+    The following values are obsolete:
+
+    \value PM_DefaultTopLevelMargin  Use PM_LayoutLeftMargin,
+                                     PM_LayoutTopMargin,
+                                     PM_LayoutRightMargin, and
+                                     PM_LayoutBottomMargin instead.
+    \value PM_DefaultChildMargin  Use PM_LayoutLeftMargin,
+                                  PM_LayoutTopMargin,
+                                  PM_LayoutRightMargin, and
+                                  PM_LayoutBottomMargin instead.
+    \value PM_DefaultLayoutSpacing  Use PM_LayoutHorizontalSpacing
+                                    and PM_LayoutVerticalSpacing
+                                    instead.
+
+    \value PM_ScrollView_ScrollBarSpacing  Distance between frame and scrollbar
+                                                with SH_ScrollView_FrameOnlyAroundContents set.
+    \value PM_ScrollView_ScrollBarOverlap  Overlap between scroll bars and scroll content
+
+    \value PM_SubMenuOverlap The horizontal overlap between a submenu and its parent.
+
+
+    \sa pixelMetric()
+*/
+
+/*!
+    \fn int QStyle::pixelMetric(PixelMetric metric, const QStyleOption *option, const QWidget *widget) const;
+
+    Returns the value of the given pixel \a metric.
+
+    The specified \a option and \a widget can be used for calculating
+    the metric. In general, the \a widget argument is not used. The \a
+    option can be cast to the appropriate type using the
+    qstyleoption_cast() function. Note that the \a option may be zero
+    even for PixelMetrics that can make use of it. See the table below
+    for the appropriate \a option casts:
+
+    \table
+    \header \li Pixel Metric \li QStyleOption Subclass
+    \row \li \l PM_SliderControlThickness \li \l QStyleOptionSlider
+    \row \li \l PM_SliderLength           \li \l QStyleOptionSlider
+    \row \li \l PM_SliderTickmarkOffset   \li \l QStyleOptionSlider
+    \row \li \l PM_SliderSpaceAvailable   \li \l QStyleOptionSlider
+    \row \li \l PM_ScrollBarExtent        \li \l QStyleOptionSlider
+    \row \li \l PM_TabBarTabOverlap       \li \l QStyleOptionTab
+    \row \li \l PM_TabBarTabHSpace        \li \l QStyleOptionTab
+    \row \li \l PM_TabBarTabVSpace        \li \l QStyleOptionTab
+    \row \li \l PM_TabBarBaseHeight       \li \l QStyleOptionTab
+    \row \li \l PM_TabBarBaseOverlap      \li \l QStyleOptionTab
+    \endtable
+
+    Some pixel metrics are called from widgets and some are only called
+    internally by the style. If the metric is not called by a widget, it is the
+    discretion of the style author to make use of it.  For some styles, this
+    may not be appropriate.
+*/
+
+/*!
+    \enum QStyle::ContentsType
+
+    This enum describes the available contents types. These are used to
+    calculate sizes for the contents of various widgets.
+
+    \value CT_CheckBox A check box, like QCheckBox.
+    \value CT_ComboBox A combo box, like QComboBox.
+    \omitvalue CT_DialogButtons
+    \value CT_HeaderSection A header section, like QHeader.
+    \value CT_LineEdit A line edit, like QLineEdit.
+    \value CT_Menu A menu, like QMenu.
+    \value CT_MenuBar A menu bar, like QMenuBar.
+    \value CT_MenuBarItem A menu bar item, like the buttons in a QMenuBar.
+    \value CT_MenuItem A menu item, like QMenuItem.
+    \value CT_ProgressBar A progress bar, like QProgressBar.
+    \value CT_PushButton A push button, like QPushButton.
+    \value CT_RadioButton A radio button, like QRadioButton.
+    \value CT_SizeGrip A size grip, like QSizeGrip.
+    \value CT_Slider A slider, like QSlider.
+    \value CT_ScrollBar A scroll bar, like QScrollBar.
+    \value CT_SpinBox A spin box, like QSpinBox.
+    \value CT_Splitter A splitter, like QSplitter.
+    \value CT_TabBarTab A tab on a tab bar, like QTabBar.
+    \value CT_TabWidget A tab widget, like QTabWidget.
+    \value CT_ToolButton A tool button, like QToolButton.
+    \value CT_GroupBox A group box, like QGroupBox.
+    \value CT_ItemViewItem An item inside an item view.
+
+    \value CT_CustomBase  Base value for custom contents types.
+    Custom values must be greater than this value.
+
+    \value CT_MdiControls The minimize, normal, and close button
+                          in the menu bar for a maximized MDI
+                          subwindow.
+
+    \sa sizeFromContents()
+*/
+
+/*!
+    \fn QSize QStyle::sizeFromContents(ContentsType type, const QStyleOption *option, \
+                                       const QSize &contentsSize, const QWidget *widget) const
+
+    Returns the size of the element described by the specified
+    \a option and \a type, based on the provided \a contentsSize.
+
+    The \a option argument is a pointer to a QStyleOption or one of
+    its subclasses. The \a option can be cast to the appropriate type
+    using the qstyleoption_cast() function. The \a widget is an
+    optional argument and can contain extra information used for
+    calculating the size.
+
+    See the table below for the appropriate \a option casts:
+
+    \table
+    \header \li Contents Type    \li QStyleOption Subclass
+    \row \li \l CT_CheckBox      \li \l QStyleOptionButton
+    \row \li \l CT_ComboBox      \li \l QStyleOptionComboBox
+    \row \li \l CT_GroupBox      \li \l QStyleOptionGroupBox
+    \row \li \l CT_HeaderSection \li \l QStyleOptionHeader
+    \row \li \l CT_ItemViewItem  \li \l QStyleOptionViewItem
+    \row \li \l CT_LineEdit      \li \l QStyleOptionFrame
+    \row \li \l CT_MdiControls   \li \l QStyleOptionComplex
+    \row \li \l CT_Menu          \li \l QStyleOption
+    \row \li \l CT_MenuItem      \li \l QStyleOptionMenuItem
+    \row \li \l CT_MenuBar       \li \l QStyleOptionMenuItem
+    \row \li \l CT_MenuBarItem   \li \l QStyleOptionMenuItem
+    \row \li \l CT_ProgressBar   \li \l QStyleOptionProgressBar
+    \row \li \l CT_PushButton    \li \l QStyleOptionButton
+    \row \li \l CT_RadioButton   \li \l QStyleOptionButton
+    \row \li \l CT_ScrollBar     \li \l QStyleOptionSlider
+    \row \li \l CT_SizeGrip      \li \l QStyleOption
+    \row \li \l CT_Slider        \li \l QStyleOptionSlider
+    \row \li \l CT_SpinBox       \li \l QStyleOptionSpinBox
+    \row \li \l CT_Splitter      \li \l QStyleOption
+    \row \li \l CT_TabBarTab     \li \l QStyleOptionTab
+    \row \li \l CT_TabWidget     \li \l QStyleOptionTabWidgetFrame
+    \row \li \l CT_ToolButton    \li \l QStyleOptionToolButton
+    \endtable
+
+    \sa ContentsType, QStyleOption
+*/
+
+/*!
+    \enum QStyle::RequestSoftwareInputPanel
+
+    This enum describes under what circumstances a software input panel will be
+    requested by input capable widgets.
+
+    \value RSIP_OnMouseClickAndAlreadyFocused Requests an input panel if the user
+           clicks on the widget, but only if it is already focused.
+    \value RSIP_OnMouseClick Requests an input panel if the user clicks on the
+           widget.
+
+    \sa QInputMethod
+*/
+
+/*!
+    \enum QStyle::StyleHint
+
+    This enum describes the available style hints. A style hint is a general look
+    and/or feel hint.
+
+    \value SH_EtchDisabledText Disabled text is "etched" as it is on Windows.
+
+    \value SH_DitherDisabledText Disabled text is dithered as it is on Motif.
+
+    \value SH_ScrollBar_ContextMenu Whether or not a scroll bar has a context menu.
+
+    \value SH_ScrollBar_MiddleClickAbsolutePosition  A boolean value.
+        If true, middle clicking on a scroll bar causes the slider to
+        jump to that position. If false, middle clicking is
+        ignored.
+
+    \value SH_ScrollBar_LeftClickAbsolutePosition  A boolean value.
+        If true, left clicking on a scroll bar causes the slider to
+        jump to that position. If false, left clicking will
+        behave as appropriate for each control.
+
+    \value SH_ScrollBar_ScrollWhenPointerLeavesControl  A boolean
+        value. If true, when clicking a scroll bar SubControl, holding
+        the mouse button down and moving the pointer outside the
+        SubControl, the scroll bar continues to scroll. If false, the
+        scollbar stops scrolling when the pointer leaves the
+        SubControl.
+
+    \value SH_ScrollBar_RollBetweenButtons A boolean value.
+        If true, when clicking a scroll bar button (SC_ScrollBarAddLine or
+        SC_ScrollBarSubLine) and dragging over to the opposite button (rolling)
+        will press the new button and release the old one. When it is false, the
+        original button is released and nothing happens (like a push button).
+
+    \value SH_TabBar_Alignment  The alignment for tabs in a
+        QTabWidget. Possible values are Qt::AlignLeft,
+        Qt::AlignCenter and Qt::AlignRight.
+
+    \value SH_Header_ArrowAlignment The placement of the sorting
+        indicator may appear in list or table headers. Possible values
+        are Qt::Left or Qt::Right.
+
+    \value SH_Slider_SnapToValue  Sliders snap to values while moving,
+        as they do on Windows.
+
+    \value SH_Slider_SloppyKeyEvents  Key presses handled in a sloppy
+        manner, i.e., left on a vertical slider subtracts a line.
+
+    \value SH_ProgressDialog_CenterCancelButton  Center button on
+        progress dialogs, otherwise right aligned.
+
+    \value SH_ProgressDialog_TextLabelAlignment The alignment for text
+    labels in progress dialogs; Qt::AlignCenter on Windows,
+    Qt::AlignVCenter otherwise.
+
+    \value SH_PrintDialog_RightAlignButtons  Right align buttons in
+        the print dialog, as done on Windows.
+
+    \value SH_MainWindow_SpaceBelowMenuBar One or two pixel space between
+        the menu bar and the dockarea, as done on Windows.
+
+    \value SH_FontDialog_SelectAssociatedText Select the text in the
+        line edit, or when selecting an item from the listbox, or when
+        the line edit receives focus, as done on Windows.
+
+    \value SH_Menu_KeyboardSearch Typing causes a menu to be search
+        for relevant items, otherwise only mnemnonic is considered.
+
+    \value SH_Menu_AllowActiveAndDisabled  Allows disabled menu
+        items to be active.
+
+    \value SH_Menu_SpaceActivatesItem  Pressing the space bar activates
+        the item, as done on Motif.
+
+    \value SH_Menu_SubMenuPopupDelay  The number of milliseconds
+        to wait before opening a submenu (256 on Windows, 96 on Motif).
+
+    \value SH_Menu_Scrollable Whether popup menus must support scrolling.
+
+    \value SH_Menu_SloppySubMenus  Whether popup menus must support
+        the user moving the mouse cursor to a submenu while crossing
+        other items of the menu. This is supported on most modern
+        desktop platforms.
+
+    \value SH_ScrollView_FrameOnlyAroundContents  Whether scrollviews
+        draw their frame only around contents (like Motif), or around
+        contents, scroll bars and corner widgets (like Windows).
+
+    \value SH_MenuBar_AltKeyNavigation  Menu bars items are navigable
+        by pressing Alt, followed by using the arrow keys to select
+        the desired item.
+
+    \value SH_ComboBox_ListMouseTracking  Mouse tracking in combobox
+        drop-down lists.
+
+    \value SH_Menu_MouseTracking  Mouse tracking in popup menus.
+
+    \value SH_MenuBar_MouseTracking  Mouse tracking in menu bars.
+
+    \value SH_Menu_FillScreenWithScroll Whether scrolling popups
+       should fill the screen as they are scrolled.
+
+    \value SH_Menu_SelectionWrap Whether popups should allow the selections
+        to wrap, that is when selection should the next item be the first item.
+
+    \value SH_ItemView_ChangeHighlightOnFocus  Gray out selected items
+        when losing focus.
+
+    \value SH_Widget_ShareActivation  Turn on sharing activation with
+        floating modeless dialogs.
+
+    \value SH_TabBar_SelectMouseType  Which type of mouse event should
+        cause a tab to be selected.
+
+    \value SH_ListViewExpand_SelectMouseType  Which type of mouse event should
+        cause a list view expansion to be selected.
+
+    \value SH_TabBar_PreferNoArrows  Whether a tab bar should suggest a size
+        to prevent scoll arrows.
+
+    \value SH_ComboBox_Popup  Allows popups as a combobox drop-down
+        menu.
+
+    \omitvalue SH_ComboBox_UseNativePopup  Whether we should use a native popup.
+        Only supported for non-editable combo boxes on Mac OS X so far.
+
+    \value SH_Workspace_FillSpaceOnMaximize  The workspace should
+        maximize the client area.
+
+    \value SH_TitleBar_NoBorder  The title bar has no border.
+
+    \value SH_ScrollBar_StopMouseOverSlider  Obsolete. Use
+        SH_Slider_StopMouseOverSlider instead.
+
+    \value SH_Slider_StopMouseOverSlider  Stops auto-repeat when
+        the slider reaches the mouse position.
+
+    \value SH_BlinkCursorWhenTextSelected  Whether cursor should blink
+        when text is selected.
+
+    \value SH_RichText_FullWidthSelection  Whether richtext selections
+        should extend to the full width of the document.
+
+    \value SH_GroupBox_TextLabelVerticalAlignment  How to vertically align a
+        group box's text label.
+
+    \value SH_GroupBox_TextLabelColor  How to paint a group box's text label.
+
+    \value SH_DialogButtons_DefaultButton  Which button gets the
+        default status in a dialog's button widget.
+
+    \value SH_ToolBox_SelectedPageTitleBold  Boldness of the selected
+    page title in a QToolBox.
+
+    \value SH_LineEdit_PasswordCharacter  The Unicode character to be
+    used for passwords.
+
+    \value SH_Table_GridLineColor The RGB value of the grid for a table.
+
+    \value SH_UnderlineShortcut  Whether shortcuts are underlined.
+
+    \value SH_SpellCheckUnderlineStyle  A
+        QTextCharFormat::UnderlineStyle value that specifies the way
+        misspelled words should be underlined.
+
+    \value SH_SpinBox_AnimateButton  Animate a click when up or down is
+    pressed in a spin box.
+    \value SH_SpinBox_KeyPressAutoRepeatRate  Auto-repeat interval for
+    spinbox key presses.
+    \value SH_SpinBox_ClickAutoRepeatRate  Auto-repeat interval for
+    spinbox mouse clicks.
+    \value SH_SpinBox_ClickAutoRepeatThreshold  Auto-repeat threshold for
+    spinbox mouse clicks.
+    \value SH_ToolTipLabel_Opacity  An integer indicating the opacity for
+    the tip label, 0 is completely transparent, 255 is completely
+    opaque.
+    \value SH_DrawMenuBarSeparator  Indicates whether or not the menu bar draws separators.
+    \value SH_TitleBar_ModifyNotification  Indicates if the title bar should show
+    a '*' for windows that are modified.
+
+    \value SH_Button_FocusPolicy The default focus policy for buttons.
+
+    \value SH_CustomBase  Base value for custom style hints.
+    Custom values must be greater than this value.
+
+    \value SH_MessageBox_UseBorderForButtonSpacing A boolean indicating what the to
+    use the border of the buttons (computed as half the button height) for the spacing
+    of the button in a message box.
+
+    \value SH_MessageBox_CenterButtons A boolean indicating whether the buttons in the
+    message box should be centered or not (see QDialogButtonBox::setCentered()).
+
+    \value SH_MessageBox_TextInteractionFlags A boolean indicating if
+    the text in a message box should allow user interfactions (e.g.
+    selection) or not.
+
+    \value SH_TitleBar_AutoRaise A boolean indicating whether
+    controls on a title bar ought to update when the mouse is over them.
+
+    \value SH_ToolButton_PopupDelay An int indicating the popup delay in milliseconds
+    for menus attached to tool buttons.
+
+    \value SH_FocusFrame_Mask The mask of the focus frame.
+
+    \value SH_RubberBand_Mask The mask of the rubber band.
+
+    \value SH_WindowFrame_Mask The mask of the window frame.
+
+    \value SH_SpinControls_DisableOnBounds Determines if the spin controls will shown
+    as disabled when reaching the spin range boundary.
+
+    \value SH_Dial_BackgroundRole Defines the style's preferred
+    background role (as QPalette::ColorRole) for a dial widget.
+
+    \value SH_ComboBox_LayoutDirection The layout direction for the
+    combo box.  By default it should be the same as indicated by the
+    QStyleOption::direction variable.
+
+    \value SH_ItemView_EllipsisLocation The location where ellipses should be
+    added for item text that is too long to fit in an view item.
+
+    \value SH_ItemView_ShowDecorationSelected When an item in an item
+    view is selected, also highlight the branch or other decoration.
+
+    \value SH_ItemView_ActivateItemOnSingleClick Emit the activated signal
+    when the user single clicks on an item in an item in an item view.
+    Otherwise the signal is emitted when the user double clicks on an item.
+
+    \value SH_Slider_AbsoluteSetButtons Which mouse buttons cause a slider
+    to set the value to the position clicked on.
+
+    \value SH_Slider_PageSetButtons Which mouse buttons cause a slider
+    to page step the value.
+
+    \value SH_TabBar_ElideMode The default eliding style for a tab bar.
+
+    \value SH_DialogButtonLayout  Controls how buttons are laid out in a QDialogButtonBox, returns a QDialogButtonBox::ButtonLayout enum.
+
+    \value SH_WizardStyle Controls the look and feel of a QWizard. Returns a QWizard::WizardStyle enum.
+
+    \value SH_FormLayoutWrapPolicy Provides a default for how rows are wrapped in a QFormLayout. Returns a QFormLayout::RowWrapPolicy enum.
+    \value SH_FormLayoutFieldGrowthPolicy Provides a default for how fields can grow in a QFormLayout. Returns a QFormLayout::FieldGrowthPolicy enum.
+    \value SH_FormLayoutFormAlignment Provides a default for how a QFormLayout aligns its contents within the available space. Returns a Qt::Alignment enum.
+    \value SH_FormLayoutLabelAlignment Provides a default for how a QFormLayout aligns labels within the available space. Returns a Qt::Alignment enum.
+
+    \value SH_ItemView_ArrowKeysNavigateIntoChildren Controls whether the tree view will select the first child when it is exapanded and the right arrow key is pressed.
+    \value SH_ComboBox_PopupFrameStyle  The frame style used when drawing a combobox popup menu.
+
+    \value SH_DialogButtonBox_ButtonsHaveIcons Indicates whether or not StandardButtons in QDialogButtonBox should have icons or not.
+    \value SH_ItemView_MovementWithoutUpdatingSelection The item view is able to indicate a current item without changing the selection.
+    \value SH_ToolTip_Mask The mask of a tool tip.
+
+    \value SH_FocusFrame_AboveWidget The FocusFrame is stacked above the widget that it is "focusing on".
+
+    \value SH_TextControl_FocusIndicatorTextCharFormat Specifies the text format used to highlight focused anchors in rich text
+    documents displayed for example in QTextBrowser. The format has to be a QTextCharFormat returned in the variant of the
+    QStyleHintReturnVariant return value. The QTextFormat::OutlinePen property is used for the outline and QTextFormat::BackgroundBrush
+    for the background of the highlighted area.
+
+    \value SH_Menu_FlashTriggeredItem Flash triggered item.
+    \value SH_Menu_FadeOutOnHide Fade out the menu instead of hiding it immediately.
+
+    \value SH_TabWidget_DefaultTabPosition Default position of the tab bar in a tab widget.
+
+    \value SH_ToolBar_Movable Determines if the tool bar is movable by default.
+
+    \value SH_ItemView_PaintAlternatingRowColorsForEmptyArea Whether QTreeView paints alternating row colors for the area that does not have any items.
+
+    \value SH_Menu_Mask The mask for a popup menu.
+
+    \value SH_ItemView_DrawDelegateFrame Determines if there should be a frame for a delegate widget.
+
+    \value SH_TabBar_CloseButtonPosition Determines the position of the close button on a tab in a tab bar.
+
+    \value SH_DockWidget_ButtonsHaveFrame Determines if dockwidget buttons should have frames. Default is true.
+
+    \value SH_ToolButtonStyle Determines the default system style for tool buttons that uses Qt::ToolButtonFollowStyle.
+
+    \value SH_RequestSoftwareInputPanel Determines when a software input panel should
+           be requested by input widgets. Returns an enum of type QStyle::RequestSoftwareInputPanel.
+
+    \value SH_ScrollBar_Transient Determines if the style supports transient scroll bars. Transient
+           scroll bars appear when the content is scrolled and disappear when they are no longer needed.
+
+    \value SH_Menu_SupportsSections Determines if the style displays sections in menus or treat them as
+           plain separators. Sections are separators with a text and icon hint.
+
+    \value SH_ToolTip_WakeUpDelay Determines the delay before a tooltip is shown, in milliseconds.
+
+    \value SH_ToolTip_FallAsleepDelay Determines the delay (in milliseconds) before a new wake time is needed when
+           a tooltip is shown (notice: shown, not hidden). When a new wake isn't needed, a user-requested tooltip
+           will be shown nearly instantly.
+
+    \value SH_Widget_Animate Determines if the widget should show animations or not, for example
+           a transition between checked and unchecked statuses in a checkbox.
+           This enum value has been introduced in Qt 5.2.
+
+    \value SH_Splitter_OpaqueResize Determines if resizing is opaque
+           This enum value has been introduced in Qt 5.2
+
+    \sa styleHint()
+*/
+
+/*!
+    \fn int QStyle::styleHint(StyleHint hint, const QStyleOption *option, \
+                              const QWidget *widget, QStyleHintReturn *returnData) const
+
+    Returns an integer representing the specified style \a hint for
+    the given \a widget described by the provided style \a option.
+
+    \a returnData is used when the querying widget needs more detailed data than
+    the integer that styleHint() returns. See the QStyleHintReturn class
+    description for details.
+*/
+
+/*!
+    \enum QStyle::StandardPixmap
+
+    This enum describes the available standard pixmaps. A standard pixmap is a pixmap that
+    can follow some existing GUI style or guideline.
+
+    \value SP_TitleBarMinButton  Minimize button on title bars (e.g.,
+        in QMdiSubWindow).
+    \value SP_TitleBarMenuButton Menu button on a title bar.
+    \value SP_TitleBarMaxButton  Maximize button on title bars.
+    \value SP_TitleBarCloseButton  Close button on title bars.
+    \value SP_TitleBarNormalButton  Normal (restore) button on title bars.
+    \value SP_TitleBarShadeButton  Shade button on title bars.
+    \value SP_TitleBarUnshadeButton  Unshade button on title bars.
+    \value SP_TitleBarContextHelpButton The Context help button on title bars.
+    \value SP_MessageBoxInformation  The "information" icon.
+    \value SP_MessageBoxWarning  The "warning" icon.
+    \value SP_MessageBoxCritical  The "critical" icon.
+    \value SP_MessageBoxQuestion  The "question" icon.
+    \value SP_DesktopIcon The "desktop" icon.
+    \value SP_TrashIcon The "trash" icon.
+    \value SP_ComputerIcon The "My computer" icon.
+    \value SP_DriveFDIcon The floppy icon.
+    \value SP_DriveHDIcon The harddrive icon.
+    \value SP_DriveCDIcon The CD icon.
+    \value SP_DriveDVDIcon The DVD icon.
+    \value SP_DriveNetIcon The network icon.
+    \value SP_DirHomeIcon The home directory icon.
+    \value SP_DirOpenIcon The open directory icon.
+    \value SP_DirClosedIcon The closed directory icon.
+    \value SP_DirIcon The directory icon.
+    \value SP_DirLinkIcon The link to directory icon.
+    \value SP_DirLinkOpenIcon The link to open directory icon.
+    \value SP_FileIcon The file icon.
+    \value SP_FileLinkIcon The link to file icon.
+    \value SP_FileDialogStart The "start" icon in a file dialog.
+    \value SP_FileDialogEnd The "end" icon in a file dialog.
+    \value SP_FileDialogToParent The "parent directory" icon in a file dialog.
+    \value SP_FileDialogNewFolder The "create new folder" icon in a file dialog.
+    \value SP_FileDialogDetailedView The detailed view icon in a file dialog.
+    \value SP_FileDialogInfoView The file info icon in a file dialog.
+    \value SP_FileDialogContentsView The contents view icon in a file dialog.
+    \value SP_FileDialogListView The list view icon in a file dialog.
+    \value SP_FileDialogBack The back arrow in a file dialog.
+    \value SP_DockWidgetCloseButton  Close button on dock windows (see also QDockWidget).
+    \value SP_ToolBarHorizontalExtensionButton Extension button for horizontal toolbars.
+    \value SP_ToolBarVerticalExtensionButton Extension button for vertical toolbars.
+    \value SP_DialogOkButton Icon for a standard OK button in a QDialogButtonBox.
+    \value SP_DialogCancelButton Icon for a standard Cancel button in a QDialogButtonBox.
+    \value SP_DialogHelpButton Icon for a standard Help button in a QDialogButtonBox.
+    \value SP_DialogOpenButton Icon for a standard Open button in a QDialogButtonBox.
+    \value SP_DialogSaveButton Icon for a standard Save button in a QDialogButtonBox.
+    \value SP_DialogCloseButton Icon for a standard Close button in a QDialogButtonBox.
+    \value SP_DialogApplyButton Icon for a standard Apply button in a QDialogButtonBox.
+    \value SP_DialogResetButton Icon for a standard Reset button in a QDialogButtonBox.
+    \value SP_DialogDiscardButton Icon for a standard Discard button in a QDialogButtonBox.
+    \value SP_DialogYesButton Icon for a standard Yes button in a QDialogButtonBox.
+    \value SP_DialogNoButton Icon for a standard No button in a QDialogButtonBox.
+    \value SP_ArrowUp Icon arrow pointing up.
+    \value SP_ArrowDown Icon arrow pointing down.
+    \value SP_ArrowLeft Icon arrow pointing left.
+    \value SP_ArrowRight Icon arrow pointing right.
+    \value SP_ArrowBack Equivalent to SP_ArrowLeft when the current layout direction is Qt::LeftToRight, otherwise SP_ArrowRight.
+    \value SP_ArrowForward Equivalent to SP_ArrowRight when the current layout direction is Qt::LeftToRight, otherwise SP_ArrowLeft.
+    \value SP_CommandLink Icon used to indicate a Vista style command link glyph.
+    \value SP_VistaShield Icon used to indicate UAC prompts on Windows Vista. This will return a null pixmap or icon on all other platforms.
+    \value SP_BrowserReload  Icon indicating that the current page should be reloaded.
+    \value SP_BrowserStop  Icon indicating that the page loading should stop.
+    \value SP_MediaPlay   Icon indicating that media should begin playback.
+    \value SP_MediaStop   Icon indicating that media should stop playback.
+    \value SP_MediaPause  Icon indicating that media should pause playback.
+    \value SP_MediaSkipForward Icon indicating that media should skip forward.
+    \value SP_MediaSkipBackward Icon indicating that media should skip backward.
+    \value SP_MediaSeekForward Icon indicating that media should seek forward.
+    \value SP_MediaSeekBackward Icon indicating that media should seek backward.
+    \value SP_MediaVolume Icon indicating a volume control.
+    \value SP_MediaVolumeMuted Icon indicating a muted volume control.
+    \value SP_LineEditClearButton Icon for a standard clear button in a QLineEdit. This enum value was added in Qt 5.2.
+    \value SP_CustomBase  Base value for custom standard pixmaps;
+    custom values must be greater than this value.
+
+    \sa standardIcon()
+*/
+
+/*!
+    \fn QPixmap QStyle::generatedIconPixmap(QIcon::Mode iconMode,
+        const QPixmap &pixmap, const QStyleOption *option) const
+
+    Returns a copy of the given \a pixmap, styled to conform to the
+    specified \a iconMode and taking into account the palette
+    specified by \a option.
+
+    The \a option parameter can pass extra information, but
+    it must contain a palette.
+
+    Note that not all pixmaps will conform, in which case the returned
+    pixmap is a plain copy.
+
+    \sa QIcon
+*/
+
+/*!
+    \fn QPixmap QStyle::standardPixmap(StandardPixmap standardPixmap, const QStyleOption *option, \
+                                       const QWidget *widget) const
+
+    \obsolete
+    Returns a pixmap for the given \a standardPixmap.
+
+    A standard pixmap is a pixmap that can follow some existing GUI
+    style or guideline. The \a option argument can be used to pass
+    extra information required when defining the appropriate
+    pixmap. The \a widget argument is optional and can also be used to
+    aid the determination of the pixmap.
+
+    Developers calling standardPixmap() should instead call standardIcon()
+    Developers who re-implemented standardPixmap() should instead re-implement
+    standardIcon().
+
+    \sa standardIcon()
+*/
+
+
+/*!
+    \fn QRect QStyle::visualRect(Qt::LayoutDirection direction, const QRect &boundingRectangle, const QRect &logicalRectangle)
+
+    Returns the given \a logicalRectangle converted to screen
+    coordinates based on the specified \a direction. The \a
+    boundingRectangle is used when performing the translation.
+
+    This function is provided to support right-to-left desktops, and
+    is typically used in implementations of the subControlRect()
+    function.
+
+    \sa QWidget::layoutDirection
+*/
+QRect QStyle::visualRect(Qt::LayoutDirection direction, const QRect &boundingRect, const QRect &logicalRect)
+{
+    if (direction == Qt::LeftToRight)
+        return logicalRect;
+    QRect rect = logicalRect;
+    rect.translate(2 * (boundingRect.right() - logicalRect.right()) +
+                   logicalRect.width() - boundingRect.width(), 0);
+    return rect;
+}
+
+/*!
+    \fn QPoint QStyle::visualPos(Qt::LayoutDirection direction, const QRect &boundingRectangle, const QPoint &logicalPosition)
+
+    Returns the given \a logicalPosition converted to screen
+    coordinates based on the specified \a direction.  The \a
+    boundingRectangle is used when performing the translation.
+
+    \sa QWidget::layoutDirection
+*/
+QPoint QStyle::visualPos(Qt::LayoutDirection direction, const QRect &boundingRect, const QPoint &logicalPos)
+{
+    if (direction == Qt::LeftToRight)
+        return logicalPos;
+    return QPoint(boundingRect.right() - logicalPos.x(), logicalPos.y());
+}
+
+/*!
+     Returns a new rectangle of the specified \a size that is aligned to the given \a
+     rectangle according to the specified \a alignment and \a direction.
+ */
+QRect QStyle::alignedRect(Qt::LayoutDirection direction, Qt::Alignment alignment, const QSize &size, const QRect &rectangle)
+{
+    alignment = visualAlignment(direction, alignment);
+    int x = rectangle.x();
+    int y = rectangle.y();
+    int w = size.width();
+    int h = size.height();
+    if ((alignment & Qt::AlignVCenter) == Qt::AlignVCenter)
+        y += rectangle.size().height()/2 - h/2;
+    else if ((alignment & Qt::AlignBottom) == Qt::AlignBottom)
+        y += rectangle.size().height() - h;
+    if ((alignment & Qt::AlignRight) == Qt::AlignRight)
+        x += rectangle.size().width() - w;
+    else if ((alignment & Qt::AlignHCenter) == Qt::AlignHCenter)
+        x += rectangle.size().width()/2 - w/2;
+    return QRect(x, y, w, h);
+}
+
+/*!
+  Transforms an \a alignment of Qt::AlignLeft or Qt::AlignRight
+  without Qt::AlignAbsolute into Qt::AlignLeft or Qt::AlignRight with
+  Qt::AlignAbsolute according to the layout \a direction. The other
+  alignment flags are left untouched.
+
+  If no horizontal alignment was specified, the function returns the
+  default alignment for the given layout \a direction.
+
+  QWidget::layoutDirection
+*/
+Qt::Alignment QStyle::visualAlignment(Qt::LayoutDirection direction, Qt::Alignment alignment)
+{
+    return QGuiApplicationPrivate::visualAlignment(direction, alignment);
+}
+
+/*!
+    Converts the given \a logicalValue to a pixel position. The \a min
+    parameter maps to 0, \a max maps to \a span and other values are
+    distributed evenly in-between.
+
+    This function can handle the entire integer range without
+    overflow, providing that \a span is less than 4096.
+
+    By default, this function assumes that the maximum value is on the
+    right for horizontal items and on the bottom for vertical items.
+    Set the \a upsideDown parameter to true to reverse this behavior.
+
+    \sa sliderValueFromPosition()
+*/
+
+int QStyle::sliderPositionFromValue(int min, int max, int logicalValue, int span, bool upsideDown)
+{
+    if (span <= 0 || logicalValue < min || max <= min)
+        return 0;
+    if (logicalValue > max)
+        return upsideDown ? span : min;
+
+    uint range = max - min;
+    uint p = upsideDown ? max - logicalValue : logicalValue - min;
+
+    if (range > (uint)INT_MAX/4096) {
+        double dpos = (double(p))/(double(range)/span);
+        return int(dpos);
+    } else if (range > (uint)span) {
+        return (2 * p * span + range) / (2*range);
+    } else {
+        uint div = span / range;
+        uint mod = span % range;
+        return p * div + (2 * p * mod + range) / (2 * range);
+    }
+    // equiv. to (p * span) / range + 0.5
+    // no overflow because of this implicit assumption:
+    // span <= 4096
+}
+
+/*!
+    \fn int QStyle::sliderValueFromPosition(int min, int max, int position, int span, bool upsideDown)
+
+    Converts the given pixel \a position to a logical value. 0 maps to
+    the \a min parameter, \a span maps to \a max and other values are
+    distributed evenly in-between.
+
+    This function can handle the entire integer range without
+    overflow.
+
+    By default, this function assumes that the maximum value is on the
+    right for horizontal items and on the bottom for vertical
+    items. Set the \a upsideDown parameter to true to reverse this
+    behavior.
+
+    \sa sliderPositionFromValue()
+*/
+
+int QStyle::sliderValueFromPosition(int min, int max, int pos, int span, bool upsideDown)
+{
+    if (span <= 0 || pos <= 0)
+        return upsideDown ? max : min;
+    if (pos >= span)
+        return upsideDown ? min : max;
+
+    uint range = max - min;
+
+    if ((uint)span > range) {
+        int tmp = (2 * pos * range + span) / (2 * span);
+        return upsideDown ? max - tmp : tmp + min;
+    } else {
+        uint div = range / span;
+        uint mod = range % span;
+        int tmp = pos * div + (2 * pos * mod + span) / (2 * span);
+        return upsideDown ? max - tmp : tmp + min;
+    }
+    // equiv. to min + (pos*range)/span + 0.5
+    // no overflow because of this implicit assumption:
+    // pos <= span < sqrt(INT_MAX+0.0625)+0.25 ~ sqrt(INT_MAX)
+}
+
+/*!
+     Returns the style's standard palette.
+
+    Note that on systems that support system colors, the style's
+    standard palette is not used. In particular, the Windows XP,
+    Vista, and Mac styles do not use the standard palette, but make
+    use of native theme engines. With these styles, you should not set
+    the palette with QApplication::setStandardPalette().
+
+ */
+QPalette QStyle::standardPalette() const
+{
+    QColor background = QColor(0xd4, 0xd0, 0xc8); // win 2000 grey
+
+    QColor light(background.lighter());
+    QColor dark(background.darker());
+    QColor mid(Qt::gray);
+    QPalette palette(Qt::black, background, light, dark, mid, Qt::black, Qt::white);
+    palette.setBrush(QPalette::Disabled, QPalette::WindowText, dark);
+    palette.setBrush(QPalette::Disabled, QPalette::Text, dark);
+    palette.setBrush(QPalette::Disabled, QPalette::ButtonText, dark);
+    palette.setBrush(QPalette::Disabled, QPalette::Base, background);
+    return palette;
+}
+
+/*!
+    \since 4.1
+
+    \fn QIcon QStyle::standardIcon(StandardPixmap standardIcon, const QStyleOption *option = 0,
+                                   const QWidget *widget = 0) const = 0;
+
+    Returns an icon for the given \a standardIcon.
+
+    The \a standardIcon is a standard pixmap which can follow some
+    existing GUI style or guideline. The \a option argument can be
+    used to pass extra information required when defining the
+    appropriate icon. The \a widget argument is optional and can also
+    be used to aid the determination of the icon.
+*/
+
+/*!
+    \since 4.3
+
+    \fn int QStyle::layoutSpacing(QSizePolicy::ControlType control1,
+                                  QSizePolicy::ControlType control2, Qt::Orientation orientation,
+                                  const QStyleOption *option = 0, const QWidget *widget = 0) const
+
+    Returns the spacing that should be used between \a control1 and
+    \a control2 in a layout. \a orientation specifies whether the
+    controls are laid out side by side or stacked vertically. The \a
+    option parameter can be used to pass extra information about the
+    parent widget. The \a widget parameter is optional and can also
+    be used if \a option is 0.
+
+    This function is called by the layout system. It is used only if
+    PM_LayoutHorizontalSpacing or PM_LayoutVerticalSpacing returns a
+    negative value.
+
+    \sa combinedLayoutSpacing()
+*/
+
+/*!
+    \since 4.3
+
+    Returns the spacing that should be used between \a controls1 and
+    \a controls2 in a layout. \a orientation specifies whether the
+    controls are laid out side by side or stacked vertically. The \a
+    option parameter can be used to pass extra information about the
+    parent widget. The \a widget parameter is optional and can also
+    be used if \a option is 0.
+
+    \a controls1 and \a controls2 are OR-combination of zero or more
+    \l{QSizePolicy::ControlTypes}{control types}.
+
+    This function is called by the layout system. It is used only if
+    PM_LayoutHorizontalSpacing or PM_LayoutVerticalSpacing returns a
+    negative value.
+
+    \sa layoutSpacing()
+*/
+int QStyle::combinedLayoutSpacing(QSizePolicy::ControlTypes controls1,
+                                  QSizePolicy::ControlTypes controls2, Qt::Orientation orientation,
+                                  QStyleOption *option, QWidget *widget) const
+{
+    QSizePolicy::ControlType array1[MaxBits];
+    QSizePolicy::ControlType array2[MaxBits];
+    int count1 = unpackControlTypes(controls1, array1);
+    int count2 = unpackControlTypes(controls2, array2);
+    int result = -1;
+
+    for (int i = 0; i < count1; ++i) {
+        for (int j = 0; j < count2; ++j) {
+            int spacing = layoutSpacing(array1[i], array2[j], orientation, option, widget);
+            result = qMax(spacing, result);
+        }
+    }
+    return result;
+}
+
+QT_BEGIN_INCLUDE_NAMESPACE
+#include <QDebug>
+QT_END_INCLUDE_NAMESPACE
+
+#if !defined(QT_NO_DEBUG_STREAM)
+QDebug operator<<(QDebug debug, QStyle::State state)
+{
+#if !defined(QT_NO_DEBUG)
+    debug << "QStyle::State(";
+
+    QStringList states;
+    if (state & QStyle::State_Active) states << QLatin1String("Active");
+    if (state & QStyle::State_AutoRaise) states << QLatin1String("AutoRaise");
+    if (state & QStyle::State_Bottom) states << QLatin1String("Bottom");
+    if (state & QStyle::State_Children) states << QLatin1String("Children");
+    if (state & QStyle::State_DownArrow) states << QLatin1String("DownArrow");
+    if (state & QStyle::State_Editing) states << QLatin1String("Editing");
+    if (state & QStyle::State_Enabled) states << QLatin1String("Enabled");
+    if (state & QStyle::State_FocusAtBorder) states << QLatin1String("FocusAtBorder");
+    if (state & QStyle::State_HasFocus) states << QLatin1String("HasFocus");
+    if (state & QStyle::State_Horizontal) states << QLatin1String("Horizontal");
+    if (state & QStyle::State_Item) states << QLatin1String("Item");
+    if (state & QStyle::State_KeyboardFocusChange) states << QLatin1String("KeyboardFocusChange");
+    if (state & QStyle::State_MouseOver) states << QLatin1String("MouseOver");
+    if (state & QStyle::State_NoChange) states << QLatin1String("NoChange");
+    if (state & QStyle::State_Off) states << QLatin1String("Off");
+    if (state & QStyle::State_On) states << QLatin1String("On");
+    if (state & QStyle::State_Open) states << QLatin1String("Open");
+    if (state & QStyle::State_Raised) states << QLatin1String("Raised");
+    if (state & QStyle::State_ReadOnly) states << QLatin1String("ReadOnly");
+    if (state & QStyle::State_Selected) states << QLatin1String("Selected");
+    if (state & QStyle::State_Sibling) states << QLatin1String("Sibling");
+    if (state & QStyle::State_Sunken) states << QLatin1String("Sunken");
+    if (state & QStyle::State_Top) states << QLatin1String("Top");
+    if (state & QStyle::State_UpArrow) states << QLatin1String("UpArrow");
+
+    std::sort(states.begin(), states.end());
+    debug << states.join(QLatin1String(" | "));
+    debug << ')';
+#else
+    Q_UNUSED(state);
+#endif
+    return debug;
+}
+#endif
+
+/*!
+    \since 4.6
+
+    \fn const QStyle *QStyle::proxy() const
+
+    This function returns the current proxy for this style.
+    By default most styles will return themselves. However
+    when a proxy style is in use, it will allow the style to
+    call back into its proxy.
+*/
+const QStyle * QStyle::proxy() const
+{
+    Q_D(const QStyle);
+    return d->proxyStyle;
+}
+
+/* \internal
+
+    This function sets the base style that style calls will be
+    redirected to. Note that ownership is not transferred.
+*/
+void QStyle::setProxy(QStyle *style)
+{
+    Q_D(QStyle);
+    d->proxyStyle = style;
+}
+
+QT_END_NAMESPACE
diff --git a/.pc/inendi.patch/src/widgets/styles/qstyle.h b/.pc/inendi.patch/src/widgets/styles/qstyle.h
new file mode 100644
index 0000000..136daa9
--- /dev/null
+++ b/.pc/inendi.patch/src/widgets/styles/qstyle.h
@@ -0,0 +1,839 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtWidgets module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QSTYLE_H
+#define QSTYLE_H
+
+#include <QtCore/qobject.h>
+#include <QtCore/qrect.h>
+#include <QtCore/qsize.h>
+#include <QtGui/qicon.h>
+#include <QtGui/qpixmap.h>
+#include <QtGui/qpalette.h>
+#include <QtWidgets/qsizepolicy.h>
+
+QT_BEGIN_NAMESPACE
+
+
+class QAction;
+class QDebug;
+class QTab;
+class QFontMetrics;
+class QStyleHintReturn;
+class QStyleOption;
+class QStyleOptionComplex;
+class QStylePrivate;
+
+class Q_WIDGETS_EXPORT QStyle : public QObject
+{
+    Q_OBJECT
+    Q_DECLARE_PRIVATE(QStyle)
+
+protected:
+    QStyle(QStylePrivate &dd);
+
+public:
+    QStyle();
+    virtual ~QStyle();
+
+    virtual void polish(QWidget *);
+    virtual void unpolish(QWidget *);
+
+    virtual void polish(QApplication *);
+    virtual void unpolish(QApplication *);
+
+    virtual void polish(QPalette &);
+
+    virtual QRect itemTextRect(const QFontMetrics &fm, const QRect &r,
+                           int flags, bool enabled,
+                           const QString &text) const;
+
+    virtual QRect itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const;
+
+    virtual void drawItemText(QPainter *painter, const QRect &rect,
+                              int flags, const QPalette &pal, bool enabled,
+                              const QString &text, QPalette::ColorRole textRole = QPalette::NoRole) const;
+
+    virtual void drawItemPixmap(QPainter *painter, const QRect &rect,
+                                int alignment, const QPixmap &pixmap) const;
+
+    virtual QPalette standardPalette() const;
+
+    enum StateFlag {
+        State_None =                0x00000000,
+        State_Enabled =             0x00000001,
+        State_Raised =              0x00000002,
+        State_Sunken =              0x00000004,
+        State_Off =                 0x00000008,
+        State_NoChange =            0x00000010,
+        State_On =                  0x00000020,
+        State_DownArrow =           0x00000040,
+        State_Horizontal =          0x00000080,
+        State_HasFocus =            0x00000100,
+        State_Top =                 0x00000200,
+        State_Bottom =              0x00000400,
+        State_FocusAtBorder =       0x00000800,
+        State_AutoRaise =           0x00001000,
+        State_MouseOver =           0x00002000,
+        State_UpArrow =             0x00004000,
+        State_Selected =            0x00008000,
+        State_Active =              0x00010000,
+        State_Window =              0x00020000,
+        State_Open =                0x00040000,
+        State_Children =            0x00080000,
+        State_Item =                0x00100000,
+        State_Sibling =             0x00200000,
+        State_Editing =             0x00400000,
+        State_KeyboardFocusChange = 0x00800000,
+#ifdef QT_KEYPAD_NAVIGATION
+        State_HasEditFocus =        0x01000000,
+#endif
+        State_ReadOnly =            0x02000000,
+        State_Small =               0x04000000,
+        State_Mini =                0x08000000
+    };
+    Q_DECLARE_FLAGS(State, StateFlag)
+
+
+    enum PrimitiveElement {
+        PE_Frame,
+        PE_FrameDefaultButton,
+        PE_FrameDockWidget,
+        PE_FrameFocusRect,
+        PE_FrameGroupBox,
+        PE_FrameLineEdit,
+        PE_FrameMenu,
+        PE_FrameStatusBar, // obsolete
+        PE_FrameStatusBarItem = PE_FrameStatusBar,
+        PE_FrameTabWidget,
+        PE_FrameWindow,
+        PE_FrameButtonBevel,
+        PE_FrameButtonTool,
+        PE_FrameTabBarBase,
+
+        PE_PanelButtonCommand,
+        PE_PanelButtonBevel,
+        PE_PanelButtonTool,
+        PE_PanelMenuBar,
+        PE_PanelToolBar,
+        PE_PanelLineEdit,
+
+        PE_IndicatorArrowDown,
+        PE_IndicatorArrowLeft,
+        PE_IndicatorArrowRight,
+        PE_IndicatorArrowUp,
+        PE_IndicatorBranch,
+        PE_IndicatorButtonDropDown,
+        PE_IndicatorViewItemCheck,
+        PE_IndicatorItemViewItemCheck = PE_IndicatorViewItemCheck,
+        PE_IndicatorCheckBox,
+        PE_IndicatorDockWidgetResizeHandle,
+        PE_IndicatorHeaderArrow,
+        PE_IndicatorMenuCheckMark,
+        PE_IndicatorProgressChunk,
+        PE_IndicatorRadioButton,
+        PE_IndicatorSpinDown,
+        PE_IndicatorSpinMinus,
+        PE_IndicatorSpinPlus,
+        PE_IndicatorSpinUp,
+        PE_IndicatorToolBarHandle,
+        PE_IndicatorToolBarSeparator,
+        PE_PanelTipLabel,
+        PE_IndicatorTabTear,
+        PE_PanelScrollAreaCorner,
+
+        PE_Widget,
+
+        PE_IndicatorColumnViewArrow,
+        PE_IndicatorItemViewItemDrop,
+
+        PE_PanelItemViewItem,
+        PE_PanelItemViewRow, // ### Qt 6: remove
+
+        PE_PanelStatusBar,
+
+        PE_IndicatorTabClose,
+        PE_PanelMenu,
+
+        // do not add any values below/greater this
+        PE_CustomBase = 0xf000000
+    };
+
+    virtual void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
+                               const QWidget *w = 0) const = 0;
+    enum ControlElement {
+        CE_PushButton,
+        CE_PushButtonBevel,
+        CE_PushButtonLabel,
+
+        CE_CheckBox,
+        CE_CheckBoxLabel,
+
+        CE_RadioButton,
+        CE_RadioButtonLabel,
+
+        CE_TabBarTab,
+        CE_TabBarTabShape,
+        CE_TabBarTabLabel,
+
+        CE_ProgressBar,
+        CE_ProgressBarGroove,
+        CE_ProgressBarContents,
+        CE_ProgressBarLabel,
+
+        CE_MenuItem,
+        CE_MenuScroller,
+        CE_MenuVMargin,
+        CE_MenuHMargin,
+        CE_MenuTearoff,
+        CE_MenuEmptyArea,
+
+        CE_MenuBarItem,
+        CE_MenuBarEmptyArea,
+
+        CE_ToolButtonLabel,
+
+        CE_Header,
+        CE_HeaderSection,
+        CE_HeaderLabel,
+
+        CE_ToolBoxTab,
+        CE_SizeGrip,
+        CE_Splitter,
+        CE_RubberBand,
+        CE_DockWidgetTitle,
+
+        CE_ScrollBarAddLine,
+        CE_ScrollBarSubLine,
+        CE_ScrollBarAddPage,
+        CE_ScrollBarSubPage,
+        CE_ScrollBarSlider,
+        CE_ScrollBarFirst,
+        CE_ScrollBarLast,
+
+        CE_FocusFrame,
+        CE_ComboBoxLabel,
+
+        CE_ToolBar,
+        CE_ToolBoxTabShape,
+        CE_ToolBoxTabLabel,
+        CE_HeaderEmptyArea,
+
+        CE_ColumnViewGrip,
+
+        CE_ItemViewItem,
+
+        CE_ShapedFrame,
+
+        // do not add any values below/greater than this
+        CE_CustomBase = 0xf0000000
+    };
+
+    virtual void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
+                             const QWidget *w = 0) const = 0;
+
+    enum SubElement {
+        SE_PushButtonContents,
+        SE_PushButtonFocusRect,
+
+        SE_CheckBoxIndicator,
+        SE_CheckBoxContents,
+        SE_CheckBoxFocusRect,
+        SE_CheckBoxClickRect,
+
+        SE_RadioButtonIndicator,
+        SE_RadioButtonContents,
+        SE_RadioButtonFocusRect,
+        SE_RadioButtonClickRect,
+
+        SE_ComboBoxFocusRect,
+
+        SE_SliderFocusRect,
+
+        SE_ProgressBarGroove,
+        SE_ProgressBarContents,
+        SE_ProgressBarLabel,
+
+        SE_ToolBoxTabContents,
+
+        SE_HeaderLabel,
+        SE_HeaderArrow,
+
+        SE_TabWidgetTabBar,
+        SE_TabWidgetTabPane,
+        SE_TabWidgetTabContents,
+        SE_TabWidgetLeftCorner,
+        SE_TabWidgetRightCorner,
+
+        SE_ViewItemCheckIndicator,
+        SE_ItemViewItemCheckIndicator = SE_ViewItemCheckIndicator,
+
+        SE_TabBarTearIndicator,
+
+        SE_TreeViewDisclosureItem,
+
+        SE_LineEditContents,
+        SE_FrameContents,
+
+        SE_DockWidgetCloseButton,
+        SE_DockWidgetFloatButton,
+        SE_DockWidgetTitleBarText,
+        SE_DockWidgetIcon,
+
+        SE_CheckBoxLayoutItem,
+        SE_ComboBoxLayoutItem,
+        SE_DateTimeEditLayoutItem,
+        SE_DialogButtonBoxLayoutItem, // ### Qt 6: remove
+        SE_LabelLayoutItem,
+        SE_ProgressBarLayoutItem,
+        SE_PushButtonLayoutItem,
+        SE_RadioButtonLayoutItem,
+        SE_SliderLayoutItem,
+        SE_SpinBoxLayoutItem,
+        SE_ToolButtonLayoutItem,
+
+        SE_FrameLayoutItem,
+        SE_GroupBoxLayoutItem,
+        SE_TabWidgetLayoutItem,
+
+        SE_ItemViewItemDecoration,
+        SE_ItemViewItemText,
+        SE_ItemViewItemFocusRect,
+
+        SE_TabBarTabLeftButton,
+        SE_TabBarTabRightButton,
+        SE_TabBarTabText,
+
+        SE_ShapedFrameContents,
+
+        SE_ToolBarHandle,
+
+        // do not add any values below/greater than this
+        SE_CustomBase = 0xf0000000
+    };
+
+    virtual QRect subElementRect(SubElement subElement, const QStyleOption *option,
+                                 const QWidget *widget = 0) const = 0;
+
+
+    enum ComplexControl {
+        CC_SpinBox,
+        CC_ComboBox,
+        CC_ScrollBar,
+        CC_Slider,
+        CC_ToolButton,
+        CC_TitleBar,
+        CC_Dial,
+        CC_GroupBox,
+        CC_MdiControls,
+
+        // do not add any values below/greater than this
+        CC_CustomBase = 0xf0000000
+    };
+
+    enum SubControl {
+        SC_None =                  0x00000000,
+
+        SC_ScrollBarAddLine =      0x00000001,
+        SC_ScrollBarSubLine =      0x00000002,
+        SC_ScrollBarAddPage =      0x00000004,
+        SC_ScrollBarSubPage =      0x00000008,
+        SC_ScrollBarFirst =        0x00000010,
+        SC_ScrollBarLast =         0x00000020,
+        SC_ScrollBarSlider =       0x00000040,
+        SC_ScrollBarGroove =       0x00000080,
+
+        SC_SpinBoxUp =             0x00000001,
+        SC_SpinBoxDown =           0x00000002,
+        SC_SpinBoxFrame =          0x00000004,
+        SC_SpinBoxEditField =      0x00000008,
+
+        SC_ComboBoxFrame =         0x00000001,
+        SC_ComboBoxEditField =     0x00000002,
+        SC_ComboBoxArrow =         0x00000004,
+        SC_ComboBoxListBoxPopup =  0x00000008,
+
+        SC_SliderGroove =          0x00000001,
+        SC_SliderHandle =          0x00000002,
+        SC_SliderTickmarks =       0x00000004,
+
+        SC_ToolButton =            0x00000001,
+        SC_ToolButtonMenu =        0x00000002,
+
+        SC_TitleBarSysMenu =       0x00000001,
+        SC_TitleBarMinButton =     0x00000002,
+        SC_TitleBarMaxButton =     0x00000004,
+        SC_TitleBarCloseButton =   0x00000008,
+        SC_TitleBarNormalButton =  0x00000010,
+        SC_TitleBarShadeButton =   0x00000020,
+        SC_TitleBarUnshadeButton = 0x00000040,
+        SC_TitleBarContextHelpButton = 0x00000080,
+        SC_TitleBarLabel =         0x00000100,
+
+        SC_DialGroove =            0x00000001,
+        SC_DialHandle =            0x00000002,
+        SC_DialTickmarks =         0x00000004,
+
+        SC_GroupBoxCheckBox =      0x00000001,
+        SC_GroupBoxLabel =         0x00000002,
+        SC_GroupBoxContents =      0x00000004,
+        SC_GroupBoxFrame =         0x00000008,
+
+        SC_MdiMinButton     =      0x00000001,
+        SC_MdiNormalButton  =      0x00000002,
+        SC_MdiCloseButton   =      0x00000004,
+
+        SC_CustomBase =            0xf0000000,
+        SC_All =                   0xffffffff
+    };
+    Q_DECLARE_FLAGS(SubControls, SubControl)
+
+
+    virtual void drawComplexControl(ComplexControl cc, const QStyleOptionComplex *opt, QPainter *p,
+                                    const QWidget *widget = 0) const = 0;
+    virtual SubControl hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
+                                             const QPoint &pt, const QWidget *widget = 0) const = 0;
+    virtual QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
+                                 SubControl sc, const QWidget *widget = 0) const = 0;
+
+    enum PixelMetric {
+        PM_ButtonMargin,
+        PM_ButtonDefaultIndicator,
+        PM_MenuButtonIndicator,
+        PM_ButtonShiftHorizontal,
+        PM_ButtonShiftVertical,
+
+        PM_DefaultFrameWidth,
+        PM_SpinBoxFrameWidth,
+        PM_ComboBoxFrameWidth,
+
+        PM_MaximumDragDistance,
+
+        PM_ScrollBarExtent,
+        PM_ScrollBarSliderMin,
+
+        PM_SliderThickness,             // total slider thickness
+        PM_SliderControlThickness,      // thickness of the business part
+        PM_SliderLength,                // total length of slider
+        PM_SliderTickmarkOffset,        //
+        PM_SliderSpaceAvailable,        // available space for slider to move
+
+        PM_DockWidgetSeparatorExtent,
+        PM_DockWidgetHandleExtent,
+        PM_DockWidgetFrameWidth,
+
+        PM_TabBarTabOverlap,
+        PM_TabBarTabHSpace,
+        PM_TabBarTabVSpace,
+        PM_TabBarBaseHeight,
+        PM_TabBarBaseOverlap,
+
+        PM_ProgressBarChunkWidth,
+
+        PM_SplitterWidth,
+        PM_TitleBarHeight,
+
+        PM_MenuScrollerHeight,
+        PM_MenuHMargin,
+        PM_MenuVMargin,
+        PM_MenuPanelWidth,
+        PM_MenuTearoffHeight,
+        PM_MenuDesktopFrameWidth,
+
+        PM_MenuBarPanelWidth,
+        PM_MenuBarItemSpacing,
+        PM_MenuBarVMargin,
+        PM_MenuBarHMargin,
+
+        PM_IndicatorWidth,
+        PM_IndicatorHeight,
+        PM_ExclusiveIndicatorWidth,
+        PM_ExclusiveIndicatorHeight,
+
+        PM_DialogButtonsSeparator,
+        PM_DialogButtonsButtonWidth,
+        PM_DialogButtonsButtonHeight,
+
+        PM_MdiSubWindowFrameWidth,
+        PM_MDIFrameWidth = PM_MdiSubWindowFrameWidth,            //obsolete
+        PM_MdiSubWindowMinimizedWidth,
+        PM_MDIMinimizedWidth = PM_MdiSubWindowMinimizedWidth,    //obsolete
+
+        PM_HeaderMargin,
+        PM_HeaderMarkSize,
+        PM_HeaderGripMargin,
+        PM_TabBarTabShiftHorizontal,
+        PM_TabBarTabShiftVertical,
+        PM_TabBarScrollButtonWidth,
+
+        PM_ToolBarFrameWidth,
+        PM_ToolBarHandleExtent,
+        PM_ToolBarItemSpacing,
+        PM_ToolBarItemMargin,
+        PM_ToolBarSeparatorExtent,
+        PM_ToolBarExtensionExtent,
+
+        PM_SpinBoxSliderHeight,
+
+        PM_DefaultTopLevelMargin,
+        PM_DefaultChildMargin,
+        PM_DefaultLayoutSpacing,
+
+        PM_ToolBarIconSize,
+        PM_ListViewIconSize,
+        PM_IconViewIconSize,
+        PM_SmallIconSize,
+        PM_LargeIconSize,
+
+        PM_FocusFrameVMargin,
+        PM_FocusFrameHMargin,
+
+        PM_ToolTipLabelFrameWidth,
+        PM_CheckBoxLabelSpacing,
+        PM_TabBarIconSize,
+        PM_SizeGripSize,
+        PM_DockWidgetTitleMargin,
+        PM_MessageBoxIconSize,
+        PM_ButtonIconSize,
+
+        PM_DockWidgetTitleBarButtonMargin,
+
+        PM_RadioButtonLabelSpacing,
+        PM_LayoutLeftMargin,
+        PM_LayoutTopMargin,
+        PM_LayoutRightMargin,
+        PM_LayoutBottomMargin,
+        PM_LayoutHorizontalSpacing,
+        PM_LayoutVerticalSpacing,
+        PM_TabBar_ScrollButtonOverlap,
+
+        PM_TextCursorWidth,
+
+        PM_TabCloseIndicatorWidth,
+        PM_TabCloseIndicatorHeight,
+
+        PM_ScrollView_ScrollBarSpacing,
+        PM_ScrollView_ScrollBarOverlap,
+        PM_SubMenuOverlap,
+
+        // do not add any values below/greater than this
+        PM_CustomBase = 0xf0000000
+    };
+
+    virtual int pixelMetric(PixelMetric metric, const QStyleOption *option = 0,
+                            const QWidget *widget = 0) const = 0;
+
+    enum ContentsType {
+        CT_PushButton,
+        CT_CheckBox,
+        CT_RadioButton,
+        CT_ToolButton,
+        CT_ComboBox,
+        CT_Splitter,
+        CT_ProgressBar,
+        CT_MenuItem,
+        CT_MenuBarItem,
+        CT_MenuBar,
+        CT_Menu,
+        CT_TabBarTab,
+        CT_Slider,
+        CT_ScrollBar,
+        CT_LineEdit,
+        CT_SpinBox,
+        CT_SizeGrip,
+        CT_TabWidget,
+        CT_DialogButtons,
+        CT_HeaderSection,
+        CT_GroupBox,
+        CT_MdiControls,
+        CT_ItemViewItem,
+        // do not add any values below/greater than this
+        CT_CustomBase = 0xf0000000
+    };
+
+    virtual QSize sizeFromContents(ContentsType ct, const QStyleOption *opt,
+                                   const QSize &contentsSize, const QWidget *w = 0) const = 0;
+
+    enum RequestSoftwareInputPanel {
+        RSIP_OnMouseClickAndAlreadyFocused,
+        RSIP_OnMouseClick
+    };
+
+    enum StyleHint {
+        SH_EtchDisabledText,
+        SH_DitherDisabledText,
+        SH_ScrollBar_MiddleClickAbsolutePosition,
+        SH_ScrollBar_ScrollWhenPointerLeavesControl,
+        SH_TabBar_SelectMouseType,
+        SH_TabBar_Alignment,
+        SH_Header_ArrowAlignment,
+        SH_Slider_SnapToValue,
+        SH_Slider_SloppyKeyEvents,
+        SH_ProgressDialog_CenterCancelButton,
+        SH_ProgressDialog_TextLabelAlignment,
+        SH_PrintDialog_RightAlignButtons,
+        SH_MainWindow_SpaceBelowMenuBar,
+        SH_FontDialog_SelectAssociatedText,
+        SH_Menu_AllowActiveAndDisabled,
+        SH_Menu_SpaceActivatesItem,
+        SH_Menu_SubMenuPopupDelay,
+        SH_ScrollView_FrameOnlyAroundContents,
+        SH_MenuBar_AltKeyNavigation,
+        SH_ComboBox_ListMouseTracking,
+        SH_Menu_MouseTracking,
+        SH_MenuBar_MouseTracking,
+        SH_ItemView_ChangeHighlightOnFocus,
+        SH_Widget_ShareActivation,
+        SH_Workspace_FillSpaceOnMaximize,
+        SH_ComboBox_Popup,
+        SH_TitleBar_NoBorder,
+        SH_Slider_StopMouseOverSlider,
+        SH_ScrollBar_StopMouseOverSlider = SH_Slider_StopMouseOverSlider, // obsolete
+        SH_BlinkCursorWhenTextSelected,
+        SH_RichText_FullWidthSelection,
+        SH_Menu_Scrollable,
+        SH_GroupBox_TextLabelVerticalAlignment,
+        SH_GroupBox_TextLabelColor,
+        SH_Menu_SloppySubMenus,
+        SH_Table_GridLineColor,
+        SH_LineEdit_PasswordCharacter,
+        SH_DialogButtons_DefaultButton,
+        SH_ToolBox_SelectedPageTitleBold,
+        SH_TabBar_PreferNoArrows,
+        SH_ScrollBar_LeftClickAbsolutePosition,
+        SH_ListViewExpand_SelectMouseType,
+        SH_UnderlineShortcut,
+        SH_SpinBox_AnimateButton,
+        SH_SpinBox_KeyPressAutoRepeatRate,
+        SH_SpinBox_ClickAutoRepeatRate,
+        SH_Menu_FillScreenWithScroll,
+        SH_ToolTipLabel_Opacity,
+        SH_DrawMenuBarSeparator,
+        SH_TitleBar_ModifyNotification,
+        SH_Button_FocusPolicy,
+        SH_MessageBox_UseBorderForButtonSpacing,
+        SH_TitleBar_AutoRaise,
+        SH_ToolButton_PopupDelay,
+        SH_FocusFrame_Mask,
+        SH_RubberBand_Mask,
+        SH_WindowFrame_Mask,
+        SH_SpinControls_DisableOnBounds,
+        SH_Dial_BackgroundRole,
+        SH_ComboBox_LayoutDirection,
+        SH_ItemView_EllipsisLocation,
+        SH_ItemView_ShowDecorationSelected,
+        SH_ItemView_ActivateItemOnSingleClick,
+        SH_ScrollBar_ContextMenu,
+        SH_ScrollBar_RollBetweenButtons,
+        SH_Slider_AbsoluteSetButtons,
+        SH_Slider_PageSetButtons,
+        SH_Menu_KeyboardSearch,
+        SH_TabBar_ElideMode,
+        SH_DialogButtonLayout,
+        SH_ComboBox_PopupFrameStyle,
+        SH_MessageBox_TextInteractionFlags,
+        SH_DialogButtonBox_ButtonsHaveIcons,
+        SH_SpellCheckUnderlineStyle,
+        SH_MessageBox_CenterButtons,
+        SH_Menu_SelectionWrap,
+        SH_ItemView_MovementWithoutUpdatingSelection,
+        SH_ToolTip_Mask,
+        SH_FocusFrame_AboveWidget,
+        SH_TextControl_FocusIndicatorTextCharFormat,
+        SH_WizardStyle,
+        SH_ItemView_ArrowKeysNavigateIntoChildren,
+        SH_Menu_Mask,
+        SH_Menu_FlashTriggeredItem,
+        SH_Menu_FadeOutOnHide,
+        SH_SpinBox_ClickAutoRepeatThreshold,
+        SH_ItemView_PaintAlternatingRowColorsForEmptyArea,
+        SH_FormLayoutWrapPolicy,
+        SH_TabWidget_DefaultTabPosition,
+        SH_ToolBar_Movable,
+        SH_FormLayoutFieldGrowthPolicy,
+        SH_FormLayoutFormAlignment,
+        SH_FormLayoutLabelAlignment,
+        SH_ItemView_DrawDelegateFrame,
+        SH_TabBar_CloseButtonPosition,
+        SH_DockWidget_ButtonsHaveFrame,
+        SH_ToolButtonStyle,
+        SH_RequestSoftwareInputPanel,
+        SH_ScrollBar_Transient,
+        SH_Menu_SupportsSections,
+        SH_ToolTip_WakeUpDelay,
+        SH_ToolTip_FallAsleepDelay,
+        SH_Widget_Animate,
+        SH_Splitter_OpaqueResize,
+        SH_ComboBox_UseNativePopup,
+        // Add new style hint values here
+
+        SH_CustomBase = 0xf0000000
+    };
+
+    virtual int styleHint(StyleHint stylehint, const QStyleOption *opt = 0,
+                          const QWidget *widget = 0, QStyleHintReturn* returnData = 0) const = 0;
+
+    enum StandardPixmap {
+        SP_TitleBarMenuButton,
+        SP_TitleBarMinButton,
+        SP_TitleBarMaxButton,
+        SP_TitleBarCloseButton,
+        SP_TitleBarNormalButton,
+        SP_TitleBarShadeButton,
+        SP_TitleBarUnshadeButton,
+        SP_TitleBarContextHelpButton,
+        SP_DockWidgetCloseButton,
+        SP_MessageBoxInformation,
+        SP_MessageBoxWarning,
+        SP_MessageBoxCritical,
+        SP_MessageBoxQuestion,
+        SP_DesktopIcon,
+        SP_TrashIcon,
+        SP_ComputerIcon,
+        SP_DriveFDIcon,
+        SP_DriveHDIcon,
+        SP_DriveCDIcon,
+        SP_DriveDVDIcon,
+        SP_DriveNetIcon,
+        SP_DirOpenIcon,
+        SP_DirClosedIcon,
+        SP_DirLinkIcon,
+        SP_DirLinkOpenIcon,
+        SP_FileIcon,
+        SP_FileLinkIcon,
+        SP_ToolBarHorizontalExtensionButton,
+        SP_ToolBarVerticalExtensionButton,
+        SP_FileDialogStart,
+        SP_FileDialogEnd,
+        SP_FileDialogToParent,
+        SP_FileDialogNewFolder,
+        SP_FileDialogDetailedView,
+        SP_FileDialogInfoView,
+        SP_FileDialogContentsView,
+        SP_FileDialogListView,
+        SP_FileDialogBack,
+        SP_DirIcon,
+        SP_DialogOkButton,
+        SP_DialogCancelButton,
+        SP_DialogHelpButton,
+        SP_DialogOpenButton,
+        SP_DialogSaveButton,
+        SP_DialogCloseButton,
+        SP_DialogApplyButton,
+        SP_DialogResetButton,
+        SP_DialogDiscardButton,
+        SP_DialogYesButton,
+        SP_DialogNoButton,
+        SP_ArrowUp,
+        SP_ArrowDown,
+        SP_ArrowLeft,
+        SP_ArrowRight,
+        SP_ArrowBack,
+        SP_ArrowForward,
+        SP_DirHomeIcon,
+        SP_CommandLink,
+        SP_VistaShield,
+        SP_BrowserReload,
+        SP_BrowserStop,
+        SP_MediaPlay,
+        SP_MediaStop,
+        SP_MediaPause,
+        SP_MediaSkipForward,
+        SP_MediaSkipBackward,
+        SP_MediaSeekForward,
+        SP_MediaSeekBackward,
+        SP_MediaVolume,
+        SP_MediaVolumeMuted,
+        SP_LineEditClearButton,
+        // do not add any values below/greater than this
+        SP_CustomBase = 0xf0000000
+    };
+
+    virtual QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt = 0,
+                                   const QWidget *widget = 0) const = 0;
+
+    virtual QIcon standardIcon(StandardPixmap standardIcon, const QStyleOption *option = 0,
+                               const QWidget *widget = 0) const = 0;
+
+    virtual QPixmap generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
+                                        const QStyleOption *opt) const = 0;
+
+    static QRect visualRect(Qt::LayoutDirection direction, const QRect &boundingRect,
+                            const QRect &logicalRect);
+    static QPoint visualPos(Qt::LayoutDirection direction, const QRect &boundingRect,
+                            const QPoint &logicalPos);
+    static int sliderPositionFromValue(int min, int max, int val, int space,
+                                       bool upsideDown = false);
+    static int sliderValueFromPosition(int min, int max, int pos, int space,
+                                       bool upsideDown = false);
+    static Qt::Alignment visualAlignment(Qt::LayoutDirection direction, Qt::Alignment alignment);
+    static QRect alignedRect(Qt::LayoutDirection direction, Qt::Alignment alignment,
+                             const QSize &size, const QRect &rectangle);
+
+    virtual int layoutSpacing(QSizePolicy::ControlType control1,
+                              QSizePolicy::ControlType control2, Qt::Orientation orientation,
+                              const QStyleOption *option = 0, const QWidget *widget = 0) const = 0;
+    int combinedLayoutSpacing(QSizePolicy::ControlTypes controls1,
+                              QSizePolicy::ControlTypes controls2, Qt::Orientation orientation,
+                              QStyleOption *option = 0, QWidget *widget = 0) const;
+
+    const QStyle * proxy() const;
+
+private:
+    Q_DISABLE_COPY(QStyle)
+    friend class QWidget;
+    friend class QWidgetPrivate;
+    friend class QApplication;
+    friend class QProxyStyle;
+    friend class QProxyStylePrivate;
+    void setProxy(QStyle *style);
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QStyle::State)
+Q_DECLARE_OPERATORS_FOR_FLAGS(QStyle::SubControls)
+
+#if !defined(QT_NO_DEBUG_STREAM)
+Q_WIDGETS_EXPORT QDebug operator<<(QDebug debug, QStyle::State state);
+#endif
+
+QT_END_NAMESPACE
+
+#endif // QSTYLE_H
diff --git a/.pc/inendi.patch/src/widgets/styles/qstyleoption.cpp b/.pc/inendi.patch/src/widgets/styles/qstyleoption.cpp
new file mode 100644
index 0000000..5913b2f
--- /dev/null
+++ b/.pc/inendi.patch/src/widgets/styles/qstyleoption.cpp
@@ -0,0 +1,4094 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtWidgets module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qstyleoption.h"
+#include "qapplication.h"
+#ifdef Q_OS_MAC
+# include "qmacstyle_mac_p.h"
+#endif
+#include <qdebug.h>
+#include <QtCore/qmath.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QStyleOption
+    \brief The QStyleOption class stores the parameters used by QStyle functions.
+
+    \ingroup appearance
+    \inmodule QtWidgets
+
+    QStyleOption and its subclasses contain all the information that
+    QStyle functions need to draw a graphical element.
+
+    For performance reasons, there are few member functions and the
+    access to the member variables is direct (i.e., using the \c . or
+    \c -> operator). This low-level feel makes the structures
+    straightforward to use and emphasizes that these are simply
+    parameters used by the style functions.
+
+    The caller of a QStyle function usually creates QStyleOption
+    objects on the stack. This combined with Qt's extensive use of
+    \l{implicit sharing} for types such as QString, QPalette, and
+    QColor ensures that no memory allocation needlessly takes place.
+
+    The following code snippet shows how to use a specific
+    QStyleOption subclass to paint a push button:
+
+    \snippet qstyleoption/main.cpp 0
+
+    In our example, the control is a QStyle::CE_PushButton, and
+    according to the QStyle::drawControl() documentation the
+    corresponding class is QStyleOptionButton.
+
+    When reimplementing QStyle functions that take a QStyleOption
+    parameter, you often need to cast the QStyleOption to a subclass.
+    For safety, you can use qstyleoption_cast() to ensure that the
+    pointer type is correct. For example:
+
+    \snippet qstyleoption/main.cpp 4
+
+    The qstyleoption_cast() function will return 0 if the object to
+    which \c option points is not of the correct type.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyle, QStylePainter
+*/
+
+/*!
+    \enum QStyleOption::OptionType
+
+    This enum is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \value SO_Button \l QStyleOptionButton
+    \value SO_ComboBox \l QStyleOptionComboBox
+    \value SO_Complex \l QStyleOptionComplex
+    \value SO_Default QStyleOption
+    \value SO_DockWidget \l QStyleOptionDockWidget
+    \value SO_FocusRect \l QStyleOptionFocusRect
+    \value SO_Frame \l QStyleOptionFrame
+    \value SO_GraphicsItem \l QStyleOptionGraphicsItem
+    \value SO_GroupBox \l QStyleOptionGroupBox
+    \value SO_Header \l QStyleOptionHeader
+    \value SO_MenuItem \l QStyleOptionMenuItem
+    \value SO_ProgressBar \l QStyleOptionProgressBar
+    \value SO_RubberBand \l QStyleOptionRubberBand
+    \value SO_SizeGrip \l QStyleOptionSizeGrip
+    \value SO_Slider \l QStyleOptionSlider
+    \value SO_SpinBox \l QStyleOptionSpinBox
+    \value SO_Tab \l QStyleOptionTab
+    \value SO_TabBarBase \l QStyleOptionTabBarBase
+    \value SO_TabWidgetFrame \l QStyleOptionTabWidgetFrame
+    \value SO_TitleBar \l QStyleOptionTitleBar
+    \value SO_ToolBar \l QStyleOptionToolBar
+    \value SO_ToolBox \l QStyleOptionToolBox
+    \value SO_ToolButton \l QStyleOptionToolButton
+    \value SO_ViewItem \l QStyleOptionViewItem (used in Interviews)
+
+    The following values are used for custom controls:
+
+    \value SO_CustomBase Reserved for custom QStyleOptions;
+                         all custom controls values must be above this value
+    \value SO_ComplexCustomBase Reserved for custom QStyleOptions;
+                         all custom complex controls values must be above this value
+
+    \sa type
+*/
+
+/*!
+    Constructs a QStyleOption with the specified \a version and \a
+    type.
+
+    The version has no special meaning for QStyleOption; it can be
+    used by subclasses to distinguish between different version of
+    the same option type.
+
+    The \l state member variable is initialized to
+    QStyle::State_None.
+
+    \sa version, type
+*/
+
+QStyleOption::QStyleOption(int version, int type)
+    : version(version), type(type), state(QStyle::State_None),
+      direction(QApplication::layoutDirection()), fontMetrics(QFont()), styleObject(0)
+{
+}
+
+
+/*!
+    Destroys this style option object.
+*/
+QStyleOption::~QStyleOption()
+{
+}
+
+/*!
+    \fn void QStyleOption::initFrom(const QWidget *widget)
+    \since 4.1
+
+    Initializes the \l state, \l direction, \l rect, \l palette, \l fontMetrics
+    and \l styleObject member variables based on the specified \a widget.
+
+    This is a convenience function; the member variables can also be
+    initialized manually.
+
+    \sa QWidget::layoutDirection(), QWidget::rect(),
+        QWidget::palette(), QWidget::fontMetrics()
+*/
+
+/*!
+    \obsolete
+
+    Use initFrom(\a widget) instead.
+*/
+void QStyleOption::init(const QWidget *widget)
+{
+    QWidget *window = widget->window();
+    state = QStyle::State_None;
+    if (widget->isEnabled())
+        state |= QStyle::State_Enabled;
+    if (widget->hasFocus())
+        state |= QStyle::State_HasFocus;
+    if (window->testAttribute(Qt::WA_KeyboardFocusChange))
+        state |= QStyle::State_KeyboardFocusChange;
+    if (widget->underMouse())
+        state |= QStyle::State_MouseOver;
+    if (window->isActiveWindow())
+        state |= QStyle::State_Active;
+    if (widget->isWindow())
+        state |= QStyle::State_Window;
+#ifdef Q_WS_MAC
+    extern bool qt_mac_can_clickThrough(const QWidget *w); //qwidget_mac.cpp
+    if (!(state & QStyle::State_Active) && !qt_mac_can_clickThrough(widget))
+        state &= ~QStyle::State_Enabled;
+#endif
+#if defined(Q_OS_MACX)
+    switch (QMacStyle::widgetSizePolicy(widget)) {
+    case QMacStyle::SizeSmall:
+        state |= QStyle::State_Small;
+        break;
+    case QMacStyle::SizeMini:
+        state |= QStyle::State_Mini;
+        break;
+    default:
+        ;
+    }
+#endif
+#ifdef QT_KEYPAD_NAVIGATION
+    if (widget->hasEditFocus())
+        state |= QStyle::State_HasEditFocus;
+#endif
+
+    direction = widget->layoutDirection();
+    rect = widget->rect();
+    palette = widget->palette();
+    fontMetrics = widget->fontMetrics();
+    styleObject = const_cast<QWidget*>(widget);
+}
+
+/*!
+   Constructs a copy of \a other.
+*/
+QStyleOption::QStyleOption(const QStyleOption &other)
+    : version(Version), type(Type), state(other.state),
+      direction(other.direction), rect(other.rect), fontMetrics(other.fontMetrics),
+      palette(other.palette), styleObject(other.styleObject)
+{
+}
+
+/*!
+    Assign \a other to this QStyleOption.
+*/
+QStyleOption &QStyleOption::operator=(const QStyleOption &other)
+{
+    state = other.state;
+    direction = other.direction;
+    rect = other.rect;
+    fontMetrics = other.fontMetrics;
+    palette = other.palette;
+    styleObject = other.styleObject;
+    return *this;
+}
+
+/*!
+    \enum QStyleOption::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_Default} for
+           this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOption::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOption::palette
+    \brief the palette that should be used when painting the control
+
+    By default, the application's default palette is used.
+
+    \sa initFrom()
+*/
+
+/*!
+    \variable QStyleOption::direction
+    \brief the text layout direction that should be used when drawing text in the control
+
+    By default, the layout direction is Qt::LeftToRight.
+
+    \sa initFrom()
+*/
+
+/*!
+    \variable QStyleOption::fontMetrics
+    \brief the font metrics that should be used when drawing text in the control
+
+    By default, the application's default font is used.
+
+    \sa initFrom()
+*/
+
+/*!
+    \variable QStyleOption::styleObject
+    \brief the object being styled
+
+    The built-in styles support the following types: QWidget, QGraphicsObject and QQuickItem.
+
+    \sa initFrom()
+*/
+
+/*!
+    \variable QStyleOption::rect
+    \brief the area that should be used for various calculations and painting
+
+    This can have different meanings for different types of elements.
+    For example, for a \l QStyle::CE_PushButton element it would be
+    the rectangle for the entire button, while for a \l
+    QStyle::CE_PushButtonLabel element it would be just the area for
+    the push button label.
+
+    The default value is a null rectangle, i.e. a rectangle with both
+    the width and the height set to 0.
+
+    \sa initFrom()
+*/
+
+/*!
+    \variable QStyleOption::state
+    \brief the style flags that are used when drawing the control
+
+    The default value is QStyle::State_None.
+
+    \sa initFrom(), QStyle::drawPrimitive(), QStyle::drawControl(),
+    QStyle::drawComplexControl(), QStyle::State
+*/
+
+/*!
+    \variable QStyleOption::type
+    \brief the option type of the style option
+
+    The default value is SO_Default.
+
+    \sa OptionType
+*/
+
+/*!
+    \variable QStyleOption::version
+    \brief the version of the style option
+
+    This value can be used by subclasses to implement extensions
+    without breaking compatibility. If you use the qstyleoption_cast()
+    function, you normally do not need to check it.
+
+    The default value is 1.
+*/
+
+/*!
+    \class QStyleOptionFocusRect
+    \brief The QStyleOptionFocusRect class is used to describe the
+    parameters for drawing a focus rectangle with QStyle.
+
+    \inmodule QtWidgets
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption
+*/
+
+/*!
+    Constructs a QStyleOptionFocusRect, initializing the members
+    variables to their default values.
+*/
+
+QStyleOptionFocusRect::QStyleOptionFocusRect()
+    : QStyleOption(Version, SO_FocusRect)
+{
+    state |= QStyle::State_KeyboardFocusChange; // assume we had one, will be corrected in initFrom()
+}
+
+/*!
+    \internal
+*/
+QStyleOptionFocusRect::QStyleOptionFocusRect(int version)
+    : QStyleOption(version, SO_FocusRect)
+{
+    state |= QStyle::State_KeyboardFocusChange;  // assume we had one, will be corrected in initFrom()
+}
+
+/*!
+    \enum QStyleOptionFocusRect::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_FocusRect} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionFocusRect::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \fn QStyleOptionFocusRect::QStyleOptionFocusRect(const QStyleOptionFocusRect &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \variable QStyleOptionFocusRect::backgroundColor
+    \brief the background color on which the focus rectangle is being drawn
+
+    The default value is an invalid color with the RGB value (0, 0,
+    0). An invalid color is a color that is not properly set up for
+    the underlying window system.
+*/
+
+/*!
+    \class QStyleOptionFrame
+    \brief The QStyleOptionFrame class is used to describe the
+    parameters for drawing a frame.
+
+    \inmodule QtWidgets
+
+    QStyleOptionFrame is used for drawing several built-in Qt widgets,
+    including QFrame, QGroupBox, QLineEdit, and QMenu.
+
+    An instance of the QStyleOptionFrame class has
+    \l{QStyleOption::type} {type} SO_Frame and \l{QStyleOption::version}
+    {version} 3.
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.  The
+    version is used by QStyleOption subclasses to implement extensions
+    without breaking compatibility. If you use qstyleoption_cast(),
+    you normally do not need to check it.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption
+*/
+
+/*!
+    \typedef QStyleOptionFrameV2
+    \relates QStyleOptionFrame
+
+    Synonym for QStyleOptionFrame.
+*/
+
+/*!
+    \typedef QStyleOptionFrameV3
+    \relates QStyleOptionFrame
+
+    Synonym for QStyleOptionFrame.
+*/
+
+/*!
+    Constructs a QStyleOptionFrame, initializing the members
+    variables to their default values.
+*/
+
+QStyleOptionFrame::QStyleOptionFrame()
+    : QStyleOption(Version, SO_Frame), lineWidth(0), midLineWidth(0),
+      features(None), frameShape(QFrame::NoFrame)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionFrame::QStyleOptionFrame(int version)
+    : QStyleOption(version, SO_Frame), lineWidth(0), midLineWidth(0),
+      features(None), frameShape(QFrame::NoFrame)
+{
+}
+
+/*!
+    \fn QStyleOptionFrame::QStyleOptionFrame(const QStyleOptionFrame &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionFrame::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_Frame} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionFrame::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 3
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionFrame::lineWidth
+    \brief the line width for drawing the frame
+
+    The default value is 0.
+
+    \sa QFrame::lineWidth
+*/
+
+/*!
+    \variable QStyleOptionFrame::midLineWidth
+    \brief the mid-line width for drawing the frame
+
+    This is usually used in drawing sunken or raised frames.
+
+    The default value is 0.
+
+    \sa QFrame::midLineWidth
+*/
+
+/*!
+    \enum QStyleOptionFrame::FrameFeature
+
+    This enum describes the different types of features a frame can have.
+
+    \value None Indicates a normal frame.
+    \value Flat Indicates a flat frame.
+    \value Rounded Indicates a rounded frame.
+*/
+
+/*!
+    \variable QStyleOptionFrame::features
+    \brief a bitwise OR of the features that describe this frame.
+
+    \sa FrameFeature
+*/
+
+/*!
+    \variable QStyleOptionFrame::frameShape
+    \brief This property holds the frame shape value of the frame.
+
+    \sa QFrame::frameShape
+*/
+
+/*!
+    \class QStyleOptionGroupBox
+    \brief The QStyleOptionGroupBox class describes the parameters for
+    drawing a group box.
+
+    \since 4.1
+    \inmodule QtWidgets
+
+    QStyleOptionButton contains all the information that QStyle
+    functions need the various graphical elements of a group box.
+
+    It holds the lineWidth and the midLineWidth for drawing the panel,
+    the group box's \l {text}{title} and the title's \l
+    {textAlignment}{alignment} and \l {textColor}{color}.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption, QStyleOptionComplex, QGroupBox
+*/
+
+/*!
+    \enum QStyleOptionGroupBox::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_GroupBox} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionGroupBox::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionGroupBox::lineWidth
+    \brief the line width for drawing the panel
+
+    The value of this variable is, currently, always 1.
+
+    \sa QFrame::lineWidth
+*/
+
+/*!
+    \variable QStyleOptionGroupBox::midLineWidth
+    \brief the mid-line width for drawing the panel
+
+    The mid-line width is usually used when drawing sunken or raised
+    group box frames. The value of this variable is, currently, always 0.
+
+    \sa QFrame::midLineWidth
+*/
+
+/*!
+    \variable QStyleOptionGroupBox::text
+    \brief the text of the group box
+
+    The default value is an empty string.
+
+    \sa QGroupBox::title
+*/
+
+/*!
+    \variable QStyleOptionGroupBox::textAlignment
+    \brief the alignment of the group box title
+
+    The default value is Qt::AlignLeft.
+
+    \sa QGroupBox::alignment
+*/
+
+/*!
+    \variable QStyleOptionGroupBox::features
+    \brief the features of the group box frame
+
+    The frame is flat by default.
+
+    \sa QStyleOptionFrame::FrameFeature
+*/
+
+/*!
+    \variable QStyleOptionGroupBox::textColor
+    \brief the color of the group box title
+
+    The default value is an invalid color with the RGB value (0, 0,
+    0). An invalid color is a color that is not properly set up for
+    the underlying window system.
+*/
+
+/*!
+    Constructs a QStyleOptionGroupBox, initializing the members
+    variables to their default values.
+*/
+QStyleOptionGroupBox::QStyleOptionGroupBox()
+    : QStyleOptionComplex(Version, Type), features(QStyleOptionFrame::None),
+      textAlignment(Qt::AlignLeft), lineWidth(0), midLineWidth(0)
+{
+}
+
+/*!
+    \fn QStyleOptionGroupBox::QStyleOptionGroupBox(const QStyleOptionGroupBox &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \internal
+*/
+QStyleOptionGroupBox::QStyleOptionGroupBox(int version)
+    : QStyleOptionComplex(version, Type), features(QStyleOptionFrame::None),
+      textAlignment(Qt::AlignLeft), lineWidth(0), midLineWidth(0)
+{
+}
+
+/*!
+    \class QStyleOptionHeader
+    \brief The QStyleOptionHeader class is used to describe the
+    parameters for drawing a header.
+
+    \inmodule QtWidgets
+
+    QStyleOptionHeader contains all the information that QStyle
+    functions need to draw the item views' header pane, header sort
+    arrow, and header label.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption
+*/
+
+/*!
+    Constructs a QStyleOptionHeader, initializing the members
+    variables to their default values.
+*/
+
+QStyleOptionHeader::QStyleOptionHeader()
+    : QStyleOption(QStyleOptionHeader::Version, SO_Header),
+      section(0), textAlignment(Qt::AlignLeft), iconAlignment(Qt::AlignLeft),
+      position(QStyleOptionHeader::Beginning),
+      selectedPosition(QStyleOptionHeader::NotAdjacent), sortIndicator(None),
+      orientation(Qt::Horizontal)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionHeader::QStyleOptionHeader(int version)
+    : QStyleOption(version, SO_Header),
+      section(0), textAlignment(Qt::AlignLeft), iconAlignment(Qt::AlignLeft),
+      position(QStyleOptionHeader::Beginning),
+      selectedPosition(QStyleOptionHeader::NotAdjacent), sortIndicator(None),
+      orientation(Qt::Horizontal)
+{
+}
+
+/*!
+    \variable QStyleOptionHeader::orientation
+    \brief the header's orientation (horizontal or vertical)
+
+    The default orientation is Qt::Horizontal
+*/
+
+/*!
+    \fn QStyleOptionHeader::QStyleOptionHeader(const QStyleOptionHeader &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionHeader::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_Header} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionHeader::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionHeader::section
+    \brief which section of the header is being painted
+
+    The default value is 0.
+*/
+
+/*!
+    \variable QStyleOptionHeader::text
+    \brief the text of the header
+
+    The default value is an empty string.
+*/
+
+/*!
+    \variable QStyleOptionHeader::textAlignment
+    \brief the alignment flags for the text of the header
+
+    The default value is Qt::AlignLeft.
+*/
+
+/*!
+    \variable QStyleOptionHeader::icon
+    \brief the icon of the header
+
+    The default value is an empty icon, i.e. an icon with neither a
+    pixmap nor a filename.
+*/
+
+/*!
+    \variable QStyleOptionHeader::iconAlignment
+    \brief the alignment flags for the icon of the header
+
+    The default value is Qt::AlignLeft.
+*/
+
+/*!
+    \variable QStyleOptionHeader::position
+    \brief the section's position in relation to the other sections
+
+    The default value is QStyleOptionHeader::Beginning.
+*/
+
+/*!
+    \variable QStyleOptionHeader::selectedPosition
+    \brief the section's position in relation to the selected section
+
+    The default value is QStyleOptionHeader::NotAdjacent
+*/
+
+/*!
+    \variable QStyleOptionHeader::sortIndicator
+    \brief the direction the sort indicator should be drawn
+
+    The default value is QStyleOptionHeader::None.
+*/
+
+/*!
+    \enum QStyleOptionHeader::SectionPosition
+
+    This enum lets you know where the section's position is in relation to the other sections.
+
+    \value Beginning At the beginining of the header
+    \value Middle In the middle of the header
+    \value End At the end of the header
+    \value OnlyOneSection Only one header section
+
+    \sa position
+*/
+
+/*!
+    \enum QStyleOptionHeader::SelectedPosition
+
+    This enum lets you know where the section's position is in relation to the selected section.
+
+    \value NotAdjacent Not adjacent to the selected section
+    \value NextIsSelected The next section is selected
+    \value PreviousIsSelected The previous section is selected
+    \value NextAndPreviousAreSelected Both the next and previous section are selected
+
+    \sa selectedPosition
+*/
+
+/*!
+    \enum QStyleOptionHeader::SortIndicator
+
+    Indicates which direction the sort indicator should be drawn
+
+    \value None No sort indicator is needed
+    \value SortUp Draw an up indicator
+    \value SortDown Draw a down indicator
+
+    \sa sortIndicator
+*/
+
+/*!
+    \class QStyleOptionButton
+    \brief The QStyleOptionButton class is used to describe the
+    parameters for drawing buttons.
+
+    \inmodule QtWidgets
+
+    QStyleOptionButton contains all the information that QStyle
+    functions need to draw graphical elements like QPushButton,
+    QCheckBox, and QRadioButton.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption, QStyleOptionToolButton
+*/
+
+/*!
+    \enum QStyleOptionButton::ButtonFeature
+
+    This enum describes the different types of features a push button can have.
+
+    \value None Indicates a normal push button.
+    \value Flat Indicates a flat push button.
+    \value HasMenu Indicates that the button has a drop down menu.
+    \value DefaultButton Indicates that the button is a default button.
+    \value AutoDefaultButton Indicates that the button is an auto default button.
+    \value CommandLinkButton Indicates that the button is a Windows Vista type command link.
+
+    \sa features
+*/
+
+/*!
+    Constructs a QStyleOptionButton, initializing the members
+    variables to their default values.
+*/
+
+QStyleOptionButton::QStyleOptionButton()
+    : QStyleOption(QStyleOptionButton::Version, SO_Button), features(None)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionButton::QStyleOptionButton(int version)
+    : QStyleOption(version, SO_Button), features(None)
+{
+}
+
+/*!
+    \fn QStyleOptionButton::QStyleOptionButton(const QStyleOptionButton &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionButton::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_Button} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionButton::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionButton::features
+    \brief a bitwise OR of the features that describe this button
+
+    \sa ButtonFeature
+*/
+
+/*!
+    \variable QStyleOptionButton::text
+    \brief the text of the button
+
+    The default value is an empty string.
+*/
+
+/*!
+    \variable QStyleOptionButton::icon
+    \brief the icon of the button
+
+    The default value is an empty icon, i.e. an icon with neither a
+    pixmap nor a filename.
+
+    \sa iconSize
+*/
+
+/*!
+    \variable QStyleOptionButton::iconSize
+    \brief the size of the icon for the button
+
+    The default value is QSize(-1, -1), i.e. an invalid size.
+*/
+
+
+#ifndef QT_NO_TOOLBAR
+/*!
+    \class QStyleOptionToolBar
+    \brief The QStyleOptionToolBar class is used to describe the
+    parameters for drawing a toolbar.
+
+    \since 4.1
+    \inmodule QtWidgets
+
+    QStyleOptionToolBar contains all the information that QStyle
+    functions need to draw QToolBar.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    The QStyleOptionToolBar class holds the lineWidth and the
+    midLineWidth for drawing the widget. It also stores information
+    about which \l {toolBarArea}{area} the toolbar should be located
+    in, whether it is movable or not, which position the toolbar line
+    should have (positionOfLine), and the toolbar's position within
+    the line (positionWithinLine).
+
+    In addition, the class provides a couple of enums: The
+    ToolBarFeature enum is used to describe whether a toolbar is
+    movable or not, and the ToolBarPosition enum is used to describe
+    the position of a toolbar line, as well as the toolbar's position
+    within the line.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption
+*/
+
+/*!
+    Constructs a QStyleOptionToolBar, initializing the members
+    variables to their default values.
+*/
+
+QStyleOptionToolBar::QStyleOptionToolBar()
+    : QStyleOption(Version, SO_ToolBar), positionOfLine(OnlyOne), positionWithinLine(OnlyOne),
+      toolBarArea(Qt::TopToolBarArea), features(None), lineWidth(0), midLineWidth(0)
+{
+}
+
+/*!
+    \fn QStyleOptionToolBar::QStyleOptionToolBar(const QStyleOptionToolBar &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \internal
+*/
+QStyleOptionToolBar::QStyleOptionToolBar(int version)
+: QStyleOption(version, SO_ToolBar), positionOfLine(OnlyOne), positionWithinLine(OnlyOne),
+  toolBarArea(Qt::TopToolBarArea), features(None), lineWidth(0), midLineWidth(0)
+{
+
+}
+
+/*!
+    \enum QStyleOptionToolBar::ToolBarPosition
+
+    \image qstyleoptiontoolbar-position.png
+
+    This enum is used to describe the position of a toolbar line, as
+    well as the toolbar's position within the line.
+
+    The order of the positions within a line starts at the top of a
+    vertical line, and from the left within a horizontal line. The
+    order of the positions for the lines is always from the
+    parent widget's boundary edges.
+
+    \value Beginning The toolbar is located at the beginning of the line,
+           or the toolbar line is the first of several lines. There can
+           only be one toolbar (and only one line) with this position.
+    \value Middle The toolbar is located in the middle of the line,
+           or the toolbar line is in the middle of several lines. There can
+           several toolbars (and lines) with this position.
+    \value End The toolbar is located at the end of the line,
+           or the toolbar line is the last of several lines. There can
+           only be one toolbar (and only one line) with this position.
+    \value OnlyOne There is only one toolbar or line. This is the default value
+           of the positionOfLine and positionWithinLine variables.
+
+    \sa positionWithinLine, positionOfLine
+*/
+
+/*!
+    \enum QStyleOptionToolBar::ToolBarFeature
+
+    This enum is used to describe whether a toolbar is movable or not.
+
+    \value None The toolbar cannot be moved. The default value.
+    \value Movable The toolbar is movable, and a handle will appear when
+           holding the cursor over the toolbar's boundary.
+
+    \sa features, QToolBar::isMovable()
+*/
+
+/*!
+    \variable QStyleOptionToolBar::positionOfLine
+
+    This variable holds the position of the toolbar line.
+
+    The default value is QStyleOptionToolBar::OnlyOne.
+*/
+
+/*!
+    \variable QStyleOptionToolBar::positionWithinLine
+
+    This variable holds the position of the toolbar within a line.
+
+    The default value is QStyleOptionToolBar::OnlyOne.
+*/
+
+/*!
+    \variable QStyleOptionToolBar::toolBarArea
+
+    This variable holds the location for drawing the toolbar.
+
+    The default value is Qt::TopToolBarArea.
+
+    \sa Qt::ToolBarArea
+*/
+
+/*!
+    \variable QStyleOptionToolBar::features
+
+    This variable holds whether the toolbar is movable or not.
+
+    The default value is \l None.
+*/
+
+/*!
+    \variable QStyleOptionToolBar::lineWidth
+
+    This variable holds the line width for drawing the toolbar.
+
+    The default value is 0.
+*/
+
+/*!
+    \variable QStyleOptionToolBar::midLineWidth
+
+    This variable holds the mid-line width for drawing the toolbar.
+
+    The default value is 0.
+*/
+
+/*!
+    \enum QStyleOptionToolBar::StyleOptionType
+
+    This enum is used to hold information about the type of the style
+    option, and is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_ToolBar} for
+    this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionToolBar::StyleOptionVersion
+
+    This enum is used to hold information about the version of the
+    style option, and is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+#endif
+
+#ifndef QT_NO_TABBAR
+/*!
+    \class QStyleOptionTab
+    \brief The QStyleOptionTab class is used to describe the
+    parameters for drawing a tab bar.
+
+    \inmodule QtWidgets
+
+    The QStyleOptionTab class is used for drawing several built-in Qt
+    widgets including \l QTabBar and the panel for \l QTabWidget.
+
+    An instance of the QStyleOptionTab class has
+    \l{QStyleOption::type} {type} \l SO_Tab and
+    \l{QStyleOption::version} {version} 3. The type is used internally
+    by QStyleOption, its subclasses, and qstyleoption_cast() to
+    determine the type of style option. In general you do not need to
+    worry about this unless you want to create your own QStyleOption
+    subclass and your own styles. The version is used by QStyleOption
+    subclasses to implement extensions without breaking
+    compatibility. If you use qstyleoption_cast(), you normally do not
+    need to check it.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption
+*/
+
+/*!
+    \typedef QStyleOptionTabV2
+    \relates QStyleOptionTab
+
+    Synonym for QStyleOptionTab.
+*/
+
+/*!
+    \typedef QStyleOptionTabV3
+    \relates QStyleOptionTab
+
+    Synonym for QStyleOptionTab.
+*/
+
+/*!
+    Constructs a QStyleOptionTab object, initializing the members
+    variables to their default values.
+*/
+
+QStyleOptionTab::QStyleOptionTab()
+    : QStyleOption(QStyleOptionTab::Version, SO_Tab),
+      shape(QTabBar::RoundedNorth),
+      row(0),
+      position(Beginning),
+      selectedPosition(NotAdjacent), cornerWidgets(QStyleOptionTab::NoCornerWidgets),
+      documentMode(false),
+      features(QStyleOptionTab::None)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionTab::QStyleOptionTab(int version)
+    : QStyleOption(version, SO_Tab),
+      shape(QTabBar::RoundedNorth),
+      row(0),
+      position(Beginning),
+      selectedPosition(NotAdjacent), cornerWidgets(QStyleOptionTab::NoCornerWidgets),
+      documentMode(false),
+      features(QStyleOptionTab::None)
+{
+}
+
+/*!
+    \fn QStyleOptionTab::QStyleOptionTab(const QStyleOptionTab &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionTab::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_Tab} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionTab::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 3
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \enum QStyleOptionTab::TabPosition
+
+    This enum describes the position of the tab.
+
+    \value Beginning The tab is the first tab in the tab bar.
+    \value Middle The tab is neither the first nor the last tab in the tab bar.
+    \value End The tab is the last tab in the tab bar.
+    \value OnlyOneTab The tab is both the first and the last tab in the tab bar.
+
+    \sa position
+*/
+
+/*!
+    \enum QStyleOptionTab::CornerWidget
+
+    These flags indicate the corner widgets in a tab.
+
+    \value NoCornerWidgets  There are no corner widgets
+    \value LeftCornerWidget  Left corner widget
+    \value RightCornerWidget Right corner widget
+
+    \sa cornerWidgets
+*/
+
+/*! \enum QStyleOptionTab::SelectedPosition
+
+    This enum describes the position of the selected tab. Some styles
+    need to draw a tab differently depending on whether or not it is
+    adjacent to the selected tab.
+
+    \value NotAdjacent The tab is not adjacent to a selected tab (or is the selected tab).
+    \value NextIsSelected The next tab (typically the tab on the right) is selected.
+    \value PreviousIsSelected The previous tab (typically the tab on the left) is selected.
+
+    \sa selectedPosition
+*/
+
+/*!
+    \variable QStyleOptionTab::selectedPosition
+    \brief the position of the selected tab in relation to this tab
+
+    The default value is NotAdjacent, i.e. the tab is not adjacent to
+    a selected tab nor is it the selected tab.
+*/
+
+/*!
+    \variable QStyleOptionTab::cornerWidgets
+    \brief an OR combination of CornerWidget values indicating the
+    corner widgets of the tab bar
+
+    The default value is NoCornerWidgets.
+
+    \sa CornerWidget
+*/
+
+
+/*!
+    \variable QStyleOptionTab::shape
+    \brief the tab shape used to draw the tab; by default
+    QTabBar::RoundedNorth
+
+    \sa QTabBar::Shape
+*/
+
+/*!
+    \variable QStyleOptionTab::text
+    \brief the text of the tab
+
+    The default value is an empty string.
+*/
+
+/*!
+    \variable QStyleOptionTab::icon
+    \brief the icon for the tab
+
+    The default value is an empty icon, i.e. an icon with neither a
+    pixmap nor a filename.
+*/
+
+/*!
+    \variable QStyleOptionTab::row
+    \brief which row the tab is currently in
+
+    The default value is 0, indicating the front row.  Currently this
+    property can only be 0.
+*/
+
+/*!
+    \variable QStyleOptionTab::position
+    \brief the position of the tab in the tab bar
+
+    The default value is \l Beginning, i.e. the tab is the first tab
+    in the tab bar.
+*/
+/*!
+    \variable QStyleOptionTab::iconSize
+    \brief the size for the icons
+
+    The default value is QSize(-1, -1), i.e. an invalid size; use
+    QStyle::pixelMetric() to find the default icon size for tab bars.
+
+    \sa QTabBar::iconSize()
+*/
+
+/*!
+    \variable QStyleOptionTab::documentMode
+    \brief whether the tabbar is in document mode.
+
+    The default value is false;
+*/
+
+/*!
+    \enum QStyleOptionTab::TabFeature
+
+    Describes the various features that a tab button can have.
+
+    \value None A normal tab button.
+    \value HasFrame The tab button is positioned on a tab frame
+
+    \sa features
+*/
+
+/*!
+    \variable QStyleOptionTab::leftButtonSize
+    \brief the size for the left widget on the tab.
+
+    The default value is QSize(-1, -1), i.e. an invalid size;
+*/
+
+/*!
+    \variable QStyleOptionTab::rightButtonSize
+    \brief the size for the right widget on the tab.
+
+    The default value is QSize(-1, -1), i.e. an invalid size;
+*/
+
+#endif // QT_NO_TABBAR
+
+/*!
+    \class QStyleOptionProgressBar
+    \brief The QStyleOptionProgressBar class is used to describe the
+    parameters necessary for drawing a progress bar.
+
+    \inmodule QtWidgets
+
+    An instance of the QStyleOptionProgressBar class has type
+    SO_ProgressBar and version 2.
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.  The
+    version is used by QStyleOption subclasses to implement extensions
+    without breaking compatibility. If you use qstyleoption_cast(),
+    you normally do not need to check it.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption
+*/
+
+/*!
+    \typedef QStyleOptionProgressBarV2
+    \relates QStyleOptionProgressBar
+
+    Synonym for QStyleOptionProgressBar.
+*/
+
+/*!
+    Constructs a QStyleOptionProgressBar, initializing the members
+    variables to their default values.
+*/
+
+QStyleOptionProgressBar::QStyleOptionProgressBar()
+    : QStyleOption(QStyleOptionProgressBar::Version, SO_ProgressBar),
+      minimum(0), maximum(0), progress(0), textAlignment(Qt::AlignLeft), textVisible(false),
+      orientation(Qt::Horizontal), invertedAppearance(false), bottomToTop(false)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionProgressBar::QStyleOptionProgressBar(int version)
+    : QStyleOption(version, SO_ProgressBar),
+      minimum(0), maximum(0), progress(0), textAlignment(Qt::AlignLeft), textVisible(false),
+      orientation(Qt::Horizontal), invertedAppearance(false), bottomToTop(false)
+{
+}
+
+/*!
+    \fn QStyleOptionProgressBar::QStyleOptionProgressBar(const QStyleOptionProgressBar &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionProgressBar::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_ProgressBar} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionProgressBar::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 2
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionProgressBar::minimum
+    \brief the minimum value for the progress bar
+
+    This is the minimum value in the progress bar. The default value
+    is 0.
+
+    \sa QProgressBar::minimum
+*/
+
+/*!
+    \variable QStyleOptionProgressBar::maximum
+    \brief the maximum value for the progress bar
+
+    This is the maximum value in the progress bar. The default value
+    is 0.
+
+    \sa QProgressBar::maximum
+*/
+
+/*!
+    \variable QStyleOptionProgressBar::text
+    \brief the text for the progress bar
+
+    The progress bar text is usually just the progress expressed as a
+    string.  An empty string indicates that the progress bar has not
+    started yet. The default value is an empty string.
+
+    \sa QProgressBar::text
+*/
+
+/*!
+    \variable QStyleOptionProgressBar::textVisible
+    \brief a flag indicating whether or not text is visible
+
+    If this flag is true then the text is visible. Otherwise, the text
+    is not visible. The default value is false.
+
+    \sa QProgressBar::textVisible
+*/
+
+
+/*!
+    \variable QStyleOptionProgressBar::textAlignment
+    \brief the text alignment for the text in the QProgressBar
+
+    This can be used as a guide on where the text should be in the
+    progress bar. The default value is Qt::AlignLeft.
+*/
+
+/*!
+    \variable QStyleOptionProgressBar::progress
+    \brief the current progress for the progress bar
+
+    The current progress. A value of QStyleOptionProgressBar::minimum
+    - 1 indicates that the progress hasn't started yet. The default
+    value is 0.
+
+    \sa QProgressBar::value
+*/
+
+/*!
+    \variable QStyleOptionProgressBar::orientation
+    \brief the progress bar's orientation (horizontal or vertical);
+    the default orentation is Qt::Horizontal
+
+    \sa QProgressBar::orientation
+*/
+
+/*!
+    \variable QStyleOptionProgressBar::invertedAppearance
+    \brief whether the progress bar's appearance is inverted
+
+    The default value is false.
+
+    \sa QProgressBar::invertedAppearance
+*/
+
+/*!
+    \variable QStyleOptionProgressBar::bottomToTop
+    \brief whether the text reads from bottom to top when the progress
+    bar is vertical
+
+    The default value is false.
+
+    \sa QProgressBar::textDirection
+*/
+
+/*!
+    \class QStyleOptionMenuItem
+    \brief The QStyleOptionMenuItem class is used to describe the
+    parameter necessary for drawing a menu item.
+
+    \inmodule QtWidgets
+
+    QStyleOptionMenuItem contains all the information that QStyle
+    functions need to draw the menu items from \l QMenu. It is also
+    used for drawing other menu-related widgets.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption
+*/
+
+/*!
+    Constructs a QStyleOptionMenuItem, initializing the members
+    variables to their default values.
+*/
+
+QStyleOptionMenuItem::QStyleOptionMenuItem()
+    : QStyleOption(QStyleOptionMenuItem::Version, SO_MenuItem), menuItemType(Normal),
+      checkType(NotCheckable), checked(false), menuHasCheckableItems(true), maxIconWidth(0), tabWidth(0)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionMenuItem::QStyleOptionMenuItem(int version)
+    : QStyleOption(version, SO_MenuItem), menuItemType(Normal),
+      checkType(NotCheckable), checked(false), menuHasCheckableItems(true), maxIconWidth(0), tabWidth(0)
+{
+}
+
+/*!
+    \fn QStyleOptionMenuItem::QStyleOptionMenuItem(const QStyleOptionMenuItem &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionMenuItem::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_MenuItem} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionMenuItem::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \enum QStyleOptionMenuItem::MenuItemType
+
+    This enum indicates the type of menu item that the structure describes.
+
+    \value Normal A normal menu item.
+    \value DefaultItem A menu item that is the default action as specified with \l QMenu::defaultAction().
+    \value Separator A menu separator.
+    \value SubMenu Indicates the menu item points to a sub-menu.
+    \value Scroller A popup menu scroller (currently only used on Mac OS X).
+    \value TearOff A tear-off handle for the menu.
+    \value Margin The margin of the menu.
+    \value EmptyArea The empty area of the menu.
+
+    \sa menuItemType
+*/
+
+/*!
+    \enum QStyleOptionMenuItem::CheckType
+
+    This enum is used to indicate whether or not a check mark should be
+    drawn for the item, or even if it should be drawn at all.
+
+    \value NotCheckable The item is not checkable.
+    \value Exclusive The item is an exclusive check item (like a radio button).
+    \value NonExclusive The item is a non-exclusive check item (like a check box).
+
+    \sa checkType, QAction::checkable, QAction::checked, QActionGroup::exclusive
+*/
+
+/*!
+    \variable QStyleOptionMenuItem::menuItemType
+    \brief the type of menu item
+
+    The default value is \l Normal.
+
+    \sa MenuItemType
+*/
+
+/*!
+    \variable QStyleOptionMenuItem::checkType
+    \brief the type of checkmark of the menu item
+
+    The default value is \l NotCheckable.
+
+    \sa CheckType
+*/
+
+/*!
+    \variable QStyleOptionMenuItem::checked
+    \brief whether the menu item is checked or not
+
+    The default value is false.
+*/
+
+/*!
+    \variable QStyleOptionMenuItem::menuHasCheckableItems
+    \brief whether the menu as a whole has checkable items or not
+
+    The default value is true.
+
+    If this option is set to false, then the menu has no checkable
+    items. This makes it possible for GUI styles to save some
+    horizontal space that would normally be used for the check column.
+*/
+
+/*!
+    \variable QStyleOptionMenuItem::menuRect
+    \brief the rectangle for the entire menu
+
+    The default value is a null rectangle, i.e. a rectangle with both
+    the width and the height set to 0.
+*/
+
+/*!
+    \variable QStyleOptionMenuItem::text
+    \brief the text for the menu item
+
+    Note that the text format is something like this "Menu
+    text\b{\\t}Shortcut".
+
+    If the menu item doesn't have a shortcut, it will just contain the
+    menu item's text. The default value is an empty string.
+*/
+
+/*!
+    \variable QStyleOptionMenuItem::icon
+    \brief the icon for the menu item
+
+    The default value is an empty icon, i.e. an icon with neither a
+    pixmap nor a filename.
+*/
+
+/*!
+    \variable QStyleOptionMenuItem::maxIconWidth
+    \brief the maximum icon width for the icon in the menu item
+
+    This can be used for drawing the icon into the correct place or
+    properly aligning items. The variable must be set regardless of
+    whether or not the menu item has an icon. The default value is 0.
+*/
+
+/*!
+    \variable QStyleOptionMenuItem::tabWidth
+    \brief the tab width for the menu item
+
+    The tab width is the distance between the text of the menu item
+    and the shortcut. The default value is 0.
+*/
+
+
+/*!
+    \variable QStyleOptionMenuItem::font
+    \brief the font used for the menu item text
+
+    This is the font that should be used for drawing the menu text
+    minus the shortcut. The shortcut is usually drawn using the
+    painter's font. By default, the application's default font is
+    used.
+*/
+
+/*!
+    \class QStyleOptionComplex
+    \brief The QStyleOptionComplex class is used to hold parameters that are
+    common to all complex controls.
+
+    \inmodule QtWidgets
+
+    This class is not used on its own. Instead it is used to derive
+    other complex control options, for example QStyleOptionSlider and
+    QStyleOptionSpinBox.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator).
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption
+*/
+
+/*!
+    Constructs a QStyleOptionComplex of the specified \a type and \a
+    version, initializing the member variables to their default
+    values. This constructor is usually called by subclasses.
+*/
+
+QStyleOptionComplex::QStyleOptionComplex(int version, int type)
+    : QStyleOption(version, type), subControls(QStyle::SC_All), activeSubControls(QStyle::SC_None)
+{
+}
+
+/*!
+    \fn QStyleOptionComplex::QStyleOptionComplex(const QStyleOptionComplex &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionComplex::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_Complex} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionComplex::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionComplex::subControls
+
+    This variable holds a bitwise OR of the \l{QStyle::SubControl}
+    {sub-controls} to be drawn for the complex control.
+
+    The default value is QStyle::SC_All.
+
+    \sa QStyle::SubControl
+*/
+
+/*!
+    \variable QStyleOptionComplex::activeSubControls
+
+    This variable holds a bitwise OR of the \l{QStyle::SubControl}
+    {sub-controls} that are active for the complex control.
+
+    The default value is QStyle::SC_None.
+
+    \sa QStyle::SubControl
+*/
+
+#ifndef QT_NO_SLIDER
+/*!
+    \class QStyleOptionSlider
+    \brief The QStyleOptionSlider class is used to describe the
+    parameters needed for drawing a slider.
+
+    \inmodule QtWidgets
+
+    QStyleOptionSlider contains all the information that QStyle
+    functions need to draw QSlider and QScrollBar.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOptionComplex, QSlider, QScrollBar
+*/
+
+/*!
+    Constructs a QStyleOptionSlider, initializing the members
+    variables to their default values.
+*/
+
+QStyleOptionSlider::QStyleOptionSlider()
+    : QStyleOptionComplex(Version, SO_Slider), orientation(Qt::Horizontal), minimum(0), maximum(0),
+      tickPosition(QSlider::NoTicks), tickInterval(0), upsideDown(false),
+      sliderPosition(0), sliderValue(0), singleStep(0), pageStep(0), notchTarget(0.0),
+      dialWrapping(false)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionSlider::QStyleOptionSlider(int version)
+    : QStyleOptionComplex(version, SO_Slider), orientation(Qt::Horizontal), minimum(0), maximum(0),
+      tickPosition(QSlider::NoTicks), tickInterval(0), upsideDown(false),
+      sliderPosition(0), sliderValue(0), singleStep(0), pageStep(0), notchTarget(0.0),
+      dialWrapping(false)
+{
+}
+
+/*!
+    \fn QStyleOptionSlider::QStyleOptionSlider(const QStyleOptionSlider &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionSlider::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_Slider} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionSlider::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionSlider::orientation
+    \brief the slider's orientation (horizontal or vertical)
+
+    The default orientation is Qt::Horizontal.
+
+    \sa Qt::Orientation
+*/
+
+/*!
+    \variable QStyleOptionSlider::minimum
+    \brief the minimum value for the slider
+
+    The default value is 0.
+*/
+
+/*!
+    \variable QStyleOptionSlider::maximum
+    \brief the maximum value for the slider
+
+    The default value is 0.
+*/
+
+/*!
+    \variable QStyleOptionSlider::tickPosition
+    \brief the position of the slider's tick marks, if any
+
+    The default value is QSlider::NoTicks.
+
+    \sa QSlider::TickPosition
+*/
+
+/*!
+    \variable QStyleOptionSlider::tickInterval
+    \brief the interval that should be drawn between tick marks
+
+    The default value is 0.
+*/
+
+/*!
+    \variable QStyleOptionSlider::notchTarget
+    \brief the number of pixel between notches
+
+    The default value is 0.0.
+
+    \sa QDial::notchTarget()
+*/
+
+/*!
+    \variable QStyleOptionSlider::dialWrapping
+    \brief whether the dial should wrap or not
+
+    The default value is false, i.e. the dial is not wrapped.
+
+    \sa QDial::wrapping()
+*/
+
+/*!
+    \variable QStyleOptionSlider::upsideDown
+    \brief the slider control orientation
+
+    Normally a slider increases as it moves up or to the right;
+    upsideDown indicates that it should do the opposite (increase as
+    it moves down or to the left).  The default value is false,
+    i.e. the slider increases as it moves up or to the right.
+
+    \sa QStyle::sliderPositionFromValue(),
+    QStyle::sliderValueFromPosition(),
+    QAbstractSlider::invertedAppearance
+*/
+
+/*!
+    \variable QStyleOptionSlider::sliderPosition
+    \brief the position of the slider handle
+
+    If the slider has active feedback (i.e.,
+    QAbstractSlider::tracking is true), this value will be the same as
+    \l sliderValue. Otherwise, it will have the current position of
+    the handle. The default value is 0.
+
+    \sa QAbstractSlider::tracking, sliderValue
+*/
+
+/*!
+    \variable QStyleOptionSlider::sliderValue
+    \brief the value of the slider
+
+    If the slider has active feedback (i.e.,
+    QAbstractSlider::tracking is true), this value will be the same
+    as \l sliderPosition. Otherwise, it will have the value the
+    slider had before the mouse was pressed.
+
+    The default value is 0.
+
+    \sa QAbstractSlider::tracking, sliderPosition
+*/
+
+/*!
+    \variable QStyleOptionSlider::singleStep
+    \brief the size of the single step of the slider
+
+    The default value is 0.
+
+    \sa QAbstractSlider::singleStep
+*/
+
+/*!
+    \variable QStyleOptionSlider::pageStep
+    \brief the size of the page step of the slider
+
+    The default value is 0.
+
+    \sa QAbstractSlider::pageStep
+*/
+#endif // QT_NO_SLIDER
+
+#ifndef QT_NO_SPINBOX
+/*!
+    \class QStyleOptionSpinBox
+    \brief The QStyleOptionSpinBox class is used to describe the
+    parameters necessary for drawing a spin box.
+
+    \inmodule QtWidgets
+
+    QStyleOptionSpinBox contains all the information that QStyle
+    functions need to draw QSpinBox and QDateTimeEdit.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption, QStyleOptionComplex
+*/
+
+/*!
+    Constructs a QStyleOptionSpinBox, initializing the members
+    variables to their default values.
+*/
+
+QStyleOptionSpinBox::QStyleOptionSpinBox()
+    : QStyleOptionComplex(Version, SO_SpinBox), buttonSymbols(QAbstractSpinBox::UpDownArrows),
+      stepEnabled(QAbstractSpinBox::StepNone), frame(false)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionSpinBox::QStyleOptionSpinBox(int version)
+    : QStyleOptionComplex(version, SO_SpinBox), buttonSymbols(QAbstractSpinBox::UpDownArrows),
+      stepEnabled(QAbstractSpinBox::StepNone), frame(false)
+{
+}
+
+/*!
+    \fn QStyleOptionSpinBox::QStyleOptionSpinBox(const QStyleOptionSpinBox &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionSpinBox::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_SpinBox} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionSpinBox::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionSpinBox::buttonSymbols
+    \brief the type of button symbols to draw for the spin box
+
+    The default value is QAbstractSpinBox::UpDownArrows specufying
+    little arrows in the classic style.
+
+    \sa QAbstractSpinBox::ButtonSymbols
+*/
+
+/*!
+    \variable QStyleOptionSpinBox::stepEnabled
+    \brief which buttons of the spin box that are enabled
+
+    The default value is QAbstractSpinBox::StepNone.
+
+    \sa QAbstractSpinBox::StepEnabled
+*/
+
+/*!
+    \variable QStyleOptionSpinBox::frame
+    \brief whether the spin box has a frame
+
+    The default value is false, i.e. the spin box has no frame.
+*/
+#endif // QT_NO_SPINBOX
+
+/*!
+    \class QStyleOptionDockWidget
+    \brief The QStyleOptionDockWidget class is used to describe the
+    parameters for drawing a dock widget.
+
+    \inmodule QtWidgets
+
+    QStyleOptionDockWidget contains all the information that QStyle
+    functions need to draw graphical elements like QDockWidget.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption
+*/
+
+/*!
+    \typedef QStyleOptionDockWidgetV2
+    \relates QStyleOptionDockWidget
+
+    Synonym for QStyleOptionDockWidget.
+*/
+
+/*!
+    Constructs a QStyleOptionDockWidget, initializing the member
+    variables to their default values.
+*/
+
+QStyleOptionDockWidget::QStyleOptionDockWidget()
+    : QStyleOption(Version, SO_DockWidget), closable(false),
+      movable(false), floatable(false), verticalTitleBar(false)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionDockWidget::QStyleOptionDockWidget(int version)
+    : QStyleOption(version, SO_DockWidget), closable(false),
+      movable(false), floatable(false), verticalTitleBar(false)
+{
+}
+
+/*!
+    \fn QStyleOptionDockWidget::QStyleOptionDockWidget(const QStyleOptionDockWidget &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionDockWidget::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_DockWidget} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionDockWidget::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 2
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionDockWidget::title
+    \brief the title of the dock window
+
+    The default value is an empty string.
+*/
+
+/*!
+    \variable QStyleOptionDockWidget::closable
+    \brief whether the dock window is closable
+
+    The default value is true.
+*/
+
+/*!
+    \variable QStyleOptionDockWidget::movable
+    \brief whether the dock window is movable
+
+    The default value is false.
+*/
+
+/*!
+    \variable QStyleOptionDockWidget::floatable
+    \brief whether the dock window is floatable
+
+    The default value is true.
+*/
+
+/*!
+    \class QStyleOptionToolButton
+    \brief The QStyleOptionToolButton class is used to describe the
+    parameters for drawing a tool button.
+
+    \inmodule QtWidgets
+
+    QStyleOptionToolButton contains all the information that QStyle
+    functions need to draw QToolButton.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption, QStyleOptionComplex, QStyleOptionButton
+*/
+
+/*!
+    \enum QStyleOptionToolButton::ToolButtonFeature
+    Describes the various features that a tool button can have.
+
+    \value None A normal tool button.
+    \value Arrow The tool button is an arrow.
+    \value Menu The tool button has a menu.
+    \value PopupDelay There is a delay to showing the menu.
+    \value HasMenu The button has a popup menu.
+    \value MenuButtonPopup The button should display an arrow to
+           indicate that a menu is present.
+
+    \sa features, QToolButton::toolButtonStyle(), QToolButton::popupMode()
+*/
+
+/*!
+    Constructs a QStyleOptionToolButton, initializing the members
+    variables to their default values.
+*/
+
+QStyleOptionToolButton::QStyleOptionToolButton()
+    : QStyleOptionComplex(Version, SO_ToolButton), features(None), arrowType(Qt::DownArrow)
+    , toolButtonStyle(Qt::ToolButtonIconOnly)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionToolButton::QStyleOptionToolButton(int version)
+    : QStyleOptionComplex(version, SO_ToolButton), features(None), arrowType(Qt::DownArrow)
+    , toolButtonStyle(Qt::ToolButtonIconOnly)
+
+{
+}
+
+/*!
+    \fn QStyleOptionToolButton::QStyleOptionToolButton(const QStyleOptionToolButton &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionToolButton::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_ToolButton} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionToolButton::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionToolButton::features
+    \brief an OR combination of the tool button's features
+
+    The default value is \l None.
+
+    \sa ToolButtonFeature
+*/
+
+/*!
+    \variable QStyleOptionToolButton::icon
+    \brief the icon for the tool button
+
+    The default value is an empty icon, i.e. an icon with neither a
+    pixmap nor a filename.
+
+    \sa iconSize
+*/
+
+/*!
+    \variable QStyleOptionToolButton::iconSize
+    \brief the size of the icon for the tool button
+
+    The default value is QSize(-1, -1), i.e. an invalid size.
+*/
+
+/*!
+    \variable QStyleOptionToolButton::text
+    \brief the text of the tool button
+
+    This value is only used if toolButtonStyle is
+    Qt::ToolButtonTextUnderIcon, Qt::ToolButtonTextBesideIcon, or
+    Qt::ToolButtonTextOnly. The default value is an empty string.
+*/
+
+/*!
+    \variable QStyleOptionToolButton::arrowType
+    \brief the direction of the arrow for the tool button
+
+    This value is only used if \l features includes \l Arrow. The
+    default value is Qt::DownArrow.
+*/
+
+/*!
+    \variable QStyleOptionToolButton::toolButtonStyle
+    \brief a Qt::ToolButtonStyle value describing the appearance of
+    the tool button
+
+    The default value is Qt::ToolButtonIconOnly.
+
+    \sa QToolButton::toolButtonStyle()
+*/
+
+/*!
+    \variable QStyleOptionToolButton::pos
+    \brief the position of the tool button
+
+    The default value is a null point, i.e. (0, 0)
+*/
+
+/*!
+    \variable QStyleOptionToolButton::font
+    \brief the font that is used for the text
+
+    This value is only used if toolButtonStyle is
+    Qt::ToolButtonTextUnderIcon, Qt::ToolButtonTextBesideIcon, or
+    Qt::ToolButtonTextOnly. By default, the application's default font
+    is used.
+*/
+
+/*!
+    \class QStyleOptionComboBox
+    \brief The QStyleOptionComboBox class is used to describe the
+    parameter for drawing a combobox.
+
+    \inmodule QtWidgets
+
+    QStyleOptionButton contains all the information that QStyle
+    functions need to draw QComboBox.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption, QStyleOptionComplex, QComboBox
+*/
+
+/*!
+    Creates a QStyleOptionComboBox, initializing the members variables
+    to their default values.
+*/
+
+QStyleOptionComboBox::QStyleOptionComboBox()
+    : QStyleOptionComplex(Version, SO_ComboBox), editable(false), frame(true)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionComboBox::QStyleOptionComboBox(int version)
+    : QStyleOptionComplex(version, SO_ComboBox), editable(false), frame(true)
+{
+}
+
+/*!
+    \fn QStyleOptionComboBox::QStyleOptionComboBox(const QStyleOptionComboBox &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionComboBox::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_ComboBox} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionComboBox::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionComboBox::editable
+    \brief whether or not the combobox is editable or not
+
+    the default
+    value is false
+
+    \sa QComboBox::isEditable()
+*/
+
+
+/*!
+    \variable QStyleOptionComboBox::frame
+    \brief whether the combo box has a frame
+
+    The default value is true.
+*/
+
+/*!
+    \variable QStyleOptionComboBox::currentText
+    \brief the text for the current item of the combo box
+
+    The default value is an empty string.
+*/
+
+/*!
+    \variable QStyleOptionComboBox::currentIcon
+    \brief the icon for the current item of the combo box
+
+    The default value is an empty icon, i.e. an icon with neither a
+    pixmap nor a filename.
+*/
+
+/*!
+    \variable QStyleOptionComboBox::iconSize
+    \brief the icon size for the current item of the combo box
+
+    The default value is QSize(-1, -1), i.e. an invalid size.
+*/
+
+/*!
+    \variable QStyleOptionComboBox::popupRect
+    \brief the popup rectangle for the combobox
+
+    The default value is a null rectangle, i.e. a rectangle with both
+    the width and the height set to 0.
+
+    This variable is currently unused. You can safely ignore it.
+
+    \sa QStyle::SC_ComboBoxListBoxPopup
+*/
+
+/*!
+    \class QStyleOptionToolBox
+    \brief The QStyleOptionToolBox class is used to describe the
+    parameters needed for drawing a tool box.
+
+    \inmodule QtWidgets
+
+    QStyleOptionToolBox contains all the information that QStyle
+    functions need to draw QToolBox.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption, QToolBox
+*/
+
+/*!
+    \typedef QStyleOptionToolBoxV2
+    \relates QStyleOptionToolBox
+
+    Synonym for QStyleOptionToolBox.
+*/
+
+/*!
+    Creates a QStyleOptionToolBox, initializing the members variables
+    to their default values.
+*/
+
+QStyleOptionToolBox::QStyleOptionToolBox()
+    : QStyleOption(Version, SO_ToolBox), position(Beginning), selectedPosition(NotAdjacent)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionToolBox::QStyleOptionToolBox(int version)
+    : QStyleOption(version, SO_ToolBox), position(Beginning), selectedPosition(NotAdjacent)
+{
+}
+
+/*!
+    \fn QStyleOptionToolBox::QStyleOptionToolBox(const QStyleOptionToolBox &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionToolBox::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_ToolBox} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionToolBox::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 2
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionToolBox::icon
+    \brief the icon for the tool box tab
+
+   The default value is an empty icon, i.e. an icon with neither a
+   pixmap nor a filename.
+*/
+
+/*!
+    \variable QStyleOptionToolBox::text
+    \brief the text for the tool box tab
+
+    The default value is an empty string.
+*/
+
+/*!
+    \enum QStyleOptionToolBox::SelectedPosition
+
+    This enum describes the position of the selected tab. Some styles
+    need to draw a tab differently depending on whether or not it is
+    adjacent to the selected tab.
+
+    \value NotAdjacent The tab is not adjacent to a selected tab (or is the selected tab).
+    \value NextIsSelected The next tab (typically the tab on the right) is selected.
+    \value PreviousIsSelected The previous tab (typically the tab on the left) is selected.
+
+    \sa selectedPosition
+*/
+
+/*!
+    \enum QStyleOptionToolBox::TabPosition
+
+    This enum describes tab positions relative to other tabs.
+
+    \value Beginning The tab is the first (i.e., top-most) tab in
+           the toolbox.
+    \value Middle The tab is placed in the middle of the toolbox.
+    \value End The tab is placed at the bottom of the toolbox.
+    \value OnlyOneTab There is only one tab in the toolbox.
+*/
+
+/*!
+    \variable QStyleOptionToolBox::selectedPosition
+    \brief the position of the selected tab in relation to this tab
+
+    The default value is NotAdjacent, i.e. the tab is not adjacent to
+    a selected tab nor is it the selected tab.
+*/
+
+#ifndef QT_NO_RUBBERBAND
+/*!
+    \class QStyleOptionRubberBand
+    \brief The QStyleOptionRubberBand class is used to describe the
+    parameters needed for drawing a rubber band.
+
+    \inmodule QtWidgets
+
+    QStyleOptionRubberBand contains all the information that
+    QStyle functions need to draw QRubberBand.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption, QRubberBand
+*/
+
+/*!
+    Creates a QStyleOptionRubberBand, initializing the members
+    variables to their default values.
+*/
+
+QStyleOptionRubberBand::QStyleOptionRubberBand()
+    : QStyleOption(Version, SO_RubberBand), shape(QRubberBand::Line), opaque(false)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionRubberBand::QStyleOptionRubberBand(int version)
+    : QStyleOption(version, SO_RubberBand), shape(QRubberBand::Line), opaque(false)
+{
+}
+
+/*!
+    \fn QStyleOptionRubberBand::QStyleOptionRubberBand(const QStyleOptionRubberBand &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionRubberBand::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_RubberBand} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionRubberBand::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionRubberBand::shape
+    \brief the shape of the rubber band
+
+    The default shape is QRubberBand::Line.
+*/
+
+/*!
+    \variable QStyleOptionRubberBand::opaque
+    \brief whether the rubber band is required to be drawn in an opaque style
+
+    The default value is true.
+*/
+#endif // QT_NO_RUBBERBAND
+
+/*!
+    \class QStyleOptionTitleBar
+    \brief The QStyleOptionTitleBar class is used to describe the
+    parameters for drawing a title bar.
+
+    \inmodule QtWidgets
+
+    QStyleOptionTitleBar contains all the information that QStyle
+    functions need to draw the title bar of a QMdiSubWindow.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption, QStyleOptionComplex, QMdiSubWindow
+*/
+
+/*!
+    Constructs a QStyleOptionTitleBar, initializing the members
+    variables to their default values.
+*/
+
+QStyleOptionTitleBar::QStyleOptionTitleBar()
+    : QStyleOptionComplex(Version, SO_TitleBar), titleBarState(0), titleBarFlags(0)
+{
+}
+
+/*!
+    \fn QStyleOptionTitleBar::QStyleOptionTitleBar(const QStyleOptionTitleBar &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionTitleBar::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_TitleBar} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionTitleBar::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \internal
+*/
+QStyleOptionTitleBar::QStyleOptionTitleBar(int version)
+    : QStyleOptionComplex(version, SO_TitleBar), titleBarState(0), titleBarFlags(0)
+{
+}
+
+
+/*!
+    \variable QStyleOptionTitleBar::text
+    \brief the text of the title bar
+
+    The default value is an empty string.
+*/
+
+/*!
+    \variable QStyleOptionTitleBar::icon
+    \brief the icon for the title bar
+
+    The default value is an empty icon, i.e. an icon with neither a
+    pixmap nor a filename.
+*/
+
+/*!
+    \variable QStyleOptionTitleBar::titleBarState
+    \brief the state of the title bar
+
+    This is basically the window state of the underlying widget. The
+    default value is 0.
+
+    \sa QWidget::windowState()
+*/
+
+/*!
+    \variable QStyleOptionTitleBar::titleBarFlags
+    \brief the widget flags for the title bar
+
+    The default value is Qt::Widget.
+
+    \sa Qt::WindowFlags
+*/
+
+#ifndef QT_NO_ITEMVIEWS
+/*!
+    \class QStyleOptionViewItem
+    \brief The QStyleOptionViewItem class is used to describe the
+    parameters used to draw an item in a view widget.
+
+    \inmodule QtWidgets
+
+    QStyleOptionViewItem contains all the information that QStyle
+    functions need to draw the items for Qt's model/view classes.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption, {model-view-programming.html}{Model/View
+    Programming}
+*/
+
+/*!
+    \typedef QStyleOptionViewItemV2
+    \relates QStyleOptionViewItem
+
+    Synonym for QStyleOptionViewItem.
+*/
+
+/*!
+    \typedef QStyleOptionViewItemV3
+    \relates QStyleOptionViewItem
+
+    Synonym for QStyleOptionViewItem.
+*/
+
+/*!
+    \typedef QStyleOptionViewItemV4
+    \relates QStyleOptionViewItem
+
+    Synonym for QStyleOptionViewItem.
+*/
+
+/*!
+    \enum QStyleOptionViewItem::Position
+
+    This enum describes the position of the item's decoration.
+
+    \value Left On the left of the text.
+    \value Right On the right of the text.
+    \value Top Above the text.
+    \value Bottom Below the text.
+
+    \sa decorationPosition
+*/
+
+/*!
+    \variable QStyleOptionViewItem::showDecorationSelected
+    \brief whether the decoration should be highlighted on selected
+    items
+
+    If this option is true, the branch and any decorations on selected items
+    should be highlighted, indicating that the item is selected; otherwise, no
+    highlighting is required. The default value is false.
+
+    \sa QStyle::SH_ItemView_ShowDecorationSelected, QAbstractItemView
+*/
+
+/*!
+    \variable QStyleOptionViewItem::textElideMode
+    \brief where ellipsis should be added for text that is too long to fit
+    into an item
+
+    The default value is Qt::ElideMiddle, i.e. the ellipsis appears in
+    the middle of the text.
+
+    \sa Qt::TextElideMode, QStyle::SH_ItemView_EllipsisLocation
+*/
+
+/*!
+    Constructs a QStyleOptionViewItem, initializing the members
+    variables to their default values.
+*/
+
+QStyleOptionViewItem::QStyleOptionViewItem()
+    : QStyleOption(Version, SO_ViewItem),
+      displayAlignment(Qt::AlignLeft), decorationAlignment(Qt::AlignLeft),
+      textElideMode(Qt::ElideMiddle), decorationPosition(Left),
+      showDecorationSelected(false), features(None), widget(0),
+      checkState(Qt::Unchecked), viewItemPosition(QStyleOptionViewItem::Invalid)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionViewItem::QStyleOptionViewItem(int version)
+    : QStyleOption(version, SO_ViewItem),
+      displayAlignment(Qt::AlignLeft), decorationAlignment(Qt::AlignLeft),
+      textElideMode(Qt::ElideMiddle), decorationPosition(Left),
+      showDecorationSelected(false), features(None), widget(0),
+      checkState(Qt::Unchecked), viewItemPosition(QStyleOptionViewItem::Invalid)
+{
+}
+
+/*!
+    \fn QStyleOptionViewItem::QStyleOptionViewItem(const QStyleOptionViewItem &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \enum QStyleOptionViewItem::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_ViewItem} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionViewItem::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 4
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionViewItem::displayAlignment
+    \brief the alignment of the display value for the item
+
+    The default value is Qt::AlignLeft.
+*/
+
+/*!
+    \variable QStyleOptionViewItem::decorationAlignment
+    \brief the alignment of the decoration for the item
+
+    The default value is Qt::AlignLeft.
+*/
+
+/*!
+    \variable QStyleOptionViewItem::decorationPosition
+    \brief the position of the decoration for the item
+
+    The default value is \l Left.
+
+    \sa Position
+*/
+
+/*!
+    \variable QStyleOptionViewItem::decorationSize
+    \brief the size of the decoration for the item
+
+    The default value is QSize(-1, -1), i.e. an invalid size.
+
+    \sa decorationAlignment, decorationPosition
+*/
+
+/*!
+    \variable QStyleOptionViewItem::font
+    \brief the font used for the item
+
+    By default, the application's default font is used.
+
+    \sa QFont
+*/
+
+/*!
+    \variable QStyleOptionViewItem::features
+    \brief a bitwise OR of the features that describe this view item
+
+    \sa ViewItemFeature
+*/
+
+/*!
+    \enum QStyleOptionViewItem::ViewItemFeature
+
+    This enum describes the different types of features an item can have.
+
+    \value None      Indicates a normal item.
+    \value WrapText  Indicates an item with wrapped text.
+    \value Alternate Indicates that the item's background is rendered using alternateBase.
+    \value HasCheckIndicator Indicates that the item has a check state indicator.
+    \value HasDisplay        Indicates that the item has a display role.
+    \value HasDecoration     Indicates that the item has a decoration role.
+*/
+
+/*!
+    \variable QStyleOptionViewItem::index
+
+    The model index that is to be drawn.
+*/
+
+/*!
+    \variable QStyleOptionViewItem::checkState
+
+    If this view item is checkable, i.e.,
+    ViewItemFeature::HasCheckIndicator is true, \c checkState is true
+    if the item is checked; otherwise, it is false.
+
+*/
+
+/*!
+    \variable QStyleOptionViewItem::icon
+
+    The icon (if any) to be drawn in the view item.
+*/
+
+
+/*!
+    \variable QStyleOptionViewItem::text
+
+    The text (if any) to be drawn in the view item.
+*/
+
+/*!
+    \variable QStyleOptionViewItem::backgroundBrush
+
+    The QBrush that should be used to paint the view items
+    background.
+*/
+
+/*!
+    \variable QStyleOptionViewItem::viewItemPosition
+
+    Gives the position of this view item relative to other items. See
+    the \l{QStyleOptionViewItem::}{ViewItemPosition} enum for the
+    details.
+*/
+
+/*!
+    \enum QStyleOptionViewItem::ViewItemPosition
+
+    This enum is used to represent the placement of the item on
+    a row. This can be used to draw items differently depending
+    on their placement, for example by putting rounded edges at
+    the beginning and end, and straight edges in between.
+
+    \value Invalid   The ViewItemPosition is unknown and should be
+                     disregarded.
+    \value Beginning The item appears at the beginning of the row.
+    \value Middle    The item appears in the middle of the row.
+    \value End       The item appears at the end of the row.
+    \value OnlyOne   The item is the only one on the row, and is
+                     therefore both at the beginning and the end.
+*/
+
+#endif // QT_NO_ITEMVIEWS
+/*!
+    \fn T qstyleoption_cast<T>(const QStyleOption *option)
+    \relates QStyleOption
+
+    Returns a T or 0 depending on the \l{QStyleOption::type}{type} and
+    \l{QStyleOption::version}{version} of the given \a option.
+
+    Example:
+
+    \snippet qstyleoption/main.cpp 4
+
+    \sa QStyleOption::type, QStyleOption::version
+*/
+
+/*!
+    \fn T qstyleoption_cast<T>(QStyleOption *option)
+    \overload
+    \relates QStyleOption
+
+    Returns a T or 0 depending on the type of the given \a option.
+*/
+
+#ifndef QT_NO_TABWIDGET
+/*!
+    \class QStyleOptionTabWidgetFrame
+    \brief The QStyleOptionTabWidgetFrame class is used to describe the
+    parameters for drawing the frame around a tab widget.
+
+    \inmodule QtWidgets
+
+    QStyleOptionTabWidgetFrame contains all the information that
+    QStyle functions need to draw the frame around QTabWidget.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption, QTabWidget
+*/
+
+/*!
+    \typedef QStyleOptionTabWidgetFrameV2
+    \relates QStyleOptionTabWidgetFrame
+
+    Synonym for QStyleOptionTabWidgetFrame.
+*/
+
+/*!
+    Constructs a QStyleOptionTabWidgetFrame, initializing the members
+    variables to their default values.
+*/
+QStyleOptionTabWidgetFrame::QStyleOptionTabWidgetFrame()
+    : QStyleOption(Version, SO_TabWidgetFrame), lineWidth(0), midLineWidth(0),
+      shape(QTabBar::RoundedNorth)
+{
+}
+
+/*!
+    \fn QStyleOptionTabWidgetFrame::QStyleOptionTabWidgetFrame(const QStyleOptionTabWidgetFrame &other)
+
+    Constructs a copy of \a other.
+*/
+
+/*! \internal */
+QStyleOptionTabWidgetFrame::QStyleOptionTabWidgetFrame(int version)
+    : QStyleOption(version, SO_TabWidgetFrame), lineWidth(0), midLineWidth(0),
+      shape(QTabBar::RoundedNorth)
+{
+}
+
+/*!
+    \enum QStyleOptionTabWidgetFrame::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_TabWidgetFrame} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionTabWidgetFrame::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 2
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionTabWidgetFrame::lineWidth
+    \brief the line width for drawing the panel
+
+    The default value is 0.
+*/
+
+/*!
+    \variable QStyleOptionTabWidgetFrame::midLineWidth
+    \brief the mid-line width for drawing the panel
+
+    The mid line width is usually used in drawing sunken or raised
+    frames. The default value is 0.
+*/
+
+/*!
+    \variable QStyleOptionTabWidgetFrame::shape
+    \brief the tab shape used to draw the tabs
+
+    The default value is QTabBar::RoundedNorth.
+*/
+
+/*!
+    \variable QStyleOptionTabWidgetFrame::tabBarSize
+    \brief the size of the tab bar
+
+    The default value is QSize(-1, -1), i.e. an invalid size.
+*/
+
+/*!
+    \variable QStyleOptionTabWidgetFrame::rightCornerWidgetSize
+    \brief the size of the right-corner widget
+
+    The default value is QSize(-1, -1), i.e. an invalid size.
+*/
+
+/*! \variable QStyleOptionTabWidgetFrame::leftCornerWidgetSize
+    \brief the size of the left-corner widget
+
+    The default value is QSize(-1, -1), i.e. an invalid size.
+*/
+
+
+/*!
+    \variable QStyleOptionTabWidgetFrame::tabBarRect
+    \brief the rectangle containing all the tabs
+
+    The default value is a null rectangle, i.e. a rectangle with both
+    the width and the height set to 0.
+*/
+
+/*!
+    \variable QStyleOptionTabWidgetFrame::selectedTabRect
+    \brief the rectangle containing the selected tab
+
+    This rectangle is contained within the tabBarRect. The default
+    value is a null rectangle, i.e. a rectangle with both the width
+    and the height set to 0.
+*/
+
+#endif // QT_NO_TABWIDGET
+
+#ifndef QT_NO_TABBAR
+
+/*!
+    \class QStyleOptionTabBarBase
+    \brief The QStyleOptionTabBarBase class is used to describe
+    the base of a tab bar, i.e. the part that the tab bar usually
+    overlaps with.
+
+    \inmodule QtWidgets
+
+    QStyleOptionTabBarBase  contains all the information that QStyle
+    functions need to draw the tab bar base. Note that this is only
+    drawn for a standalone QTabBar (one that isn't part of a
+    QTabWidget).
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption, QTabBar::drawBase()
+*/
+
+/*!
+    \typedef QStyleOptionTabBarBaseV2
+    \relates QStyleOptionTabBarBase
+
+    Synonym for QStyleOptionTabBarBase.
+*/
+
+/*!
+    Construct a QStyleOptionTabBarBase, initializing the members
+    vaiables to their default values.
+*/
+QStyleOptionTabBarBase::QStyleOptionTabBarBase()
+    : QStyleOption(Version, SO_TabBarBase), shape(QTabBar::RoundedNorth),
+      documentMode(false)
+{
+}
+
+/*! \internal */
+QStyleOptionTabBarBase::QStyleOptionTabBarBase(int version)
+    : QStyleOption(version, SO_TabBarBase), shape(QTabBar::RoundedNorth),
+      documentMode(false)
+{
+}
+
+/*!
+    \fn QStyleOptionTabBarBase::QStyleOptionTabBarBase(const QStyleOptionTabBarBase &other)
+
+    Constructs a copy of \a other.
+*/
+
+/*!
+    \enum QStyleOptionTabBarBase::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_TabBarBase} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionTabBarBase::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 2
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleOptionTabBarBase::shape
+    \brief the shape of the tab bar
+
+    The default value is QTabBar::RoundedNorth.
+*/
+
+/*!
+    \variable QStyleOptionTabBarBase::tabBarRect
+    \brief the rectangle containing all the tabs
+
+    The default value is a null rectangle, i.e. a rectangle with both
+    the width and the height set to 0.
+*/
+
+/*!
+    \variable QStyleOptionTabBarBase::selectedTabRect
+    \brief the rectangle containing the selected tab
+
+    This rectangle is contained within the tabBarRect. The default
+    value is a null rectangle, i.e. a rectangle with both the width
+    and the height set to 0.
+*/
+
+
+/*!
+    \variable QStyleOptionTabBarBase::documentMode
+    \brief whether the tabbar is in document mode.
+
+    The default value is false;
+*/
+
+#endif // QT_NO_TABBAR
+
+#ifndef QT_NO_SIZEGRIP
+/*!
+    \class QStyleOptionSizeGrip
+    \brief The QStyleOptionSizeGrip class is used to describe the
+    parameter for drawing a size grip.
+    \since 4.2
+    \inmodule QtWidgets
+
+    QStyleOptionButton contains all the information that QStyle
+    functions need to draw QSizeGrip.
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters used by the style functions.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption, QStyleOptionComplex, QSizeGrip
+*/
+
+/*!
+    Constructs a QStyleOptionSizeGrip.
+*/
+QStyleOptionSizeGrip::QStyleOptionSizeGrip()
+    : QStyleOptionComplex(Version, Type), corner(Qt::BottomRightCorner)
+{
+}
+
+/*!
+    \fn QStyleOptionSizeGrip::QStyleOptionSizeGrip(const QStyleOptionSizeGrip &other)
+
+    Constructs a copy of the \a other style option.
+*/
+
+/*!
+    \internal
+*/
+QStyleOptionSizeGrip::QStyleOptionSizeGrip(int version)
+    : QStyleOptionComplex(version, Type), corner(Qt::BottomRightCorner)
+{
+}
+
+/*!
+    \variable QStyleOptionSizeGrip::corner
+
+    The corner in which the size grip is located.
+*/
+
+/*!
+    \enum QStyleOptionSizeGrip::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l{SO_TabBarBase} for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionSizeGrip::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+#endif // QT_NO_SIZEGRIP
+
+/*!
+    \class QStyleOptionGraphicsItem
+    \brief The QStyleOptionGraphicsItem class is used to describe
+    the parameters needed to draw a QGraphicsItem.
+    \since 4.2
+    \ingroup graphicsview-api
+    \inmodule QtWidgets
+
+    For performance reasons, the access to the member variables is
+    direct (i.e., using the \c . or \c -> operator). This low-level feel
+    makes the structures straightforward to use and emphasizes that
+    these are simply parameters.
+
+    For an example demonstrating how style options can be used, see
+    the \l {widgets/styles}{Styles} example.
+
+    \sa QStyleOption, QGraphicsItem::paint()
+*/
+
+/*!
+    \enum QStyleOptionGraphicsItem::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Type The type of style option provided (\l SO_GraphicsItem for this class).
+
+    The type is used internally by QStyleOption, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleOption subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleOptionGraphicsItem::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleOption subclass.
+
+    \value Version 1
+
+    The version is used by QStyleOption subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    Constructs a QStyleOptionGraphicsItem.
+*/
+QStyleOptionGraphicsItem::QStyleOptionGraphicsItem()
+    : QStyleOption(Version, Type), levelOfDetail(1)
+{
+}
+
+/*!
+    \internal
+*/
+QStyleOptionGraphicsItem::QStyleOptionGraphicsItem(int version)
+    : QStyleOption(version, Type), levelOfDetail(1)
+{
+}
+
+/*!
+    \since 4.6
+
+    Returns the level of detail from the \a worldTransform.
+
+    Its value represents the maximum value of the height and
+    width of a unity rectangle, mapped using the \a worldTransform
+    of the painter used to draw the item. By default, if no
+    transformations are applied, its value is 1. If zoomed out 1:2, the level
+    of detail will be 0.5, and if zoomed in 2:1, its value is 2.
+*/
+qreal QStyleOptionGraphicsItem::levelOfDetailFromTransform(const QTransform &worldTransform)
+{
+    if (worldTransform.type() <= QTransform::TxTranslate)
+        return 1; // Translation only? The LOD is 1.
+
+    // Two unit vectors.
+    QLineF v1(0, 0, 1, 0);
+    QLineF v2(0, 0, 0, 1);
+    // LOD is the transformed area of a 1x1 rectangle.
+    return qSqrt(worldTransform.map(v1).length() * worldTransform.map(v2).length());
+}
+
+/*!
+    \fn QStyleOptionGraphicsItem::QStyleOptionGraphicsItem(const QStyleOptionGraphicsItem &other)
+
+    Constructs a copy of \a other.
+*/
+
+/*!
+    \variable QStyleOptionGraphicsItem::exposedRect
+    \brief the exposed rectangle, in item coordinates
+
+    Make use of this rectangle to speed up item drawing when only parts of the
+    item are exposed. If the whole item is exposed, this rectangle will be the
+    same as QGraphicsItem::boundingRect().
+
+    This member is only initialized for items that have the
+    QGraphicsItem::ItemUsesExtendedStyleOption flag set.
+*/
+
+/*!
+     \variable QStyleOptionGraphicsItem::matrix
+     \brief the complete transformation matrix for the item
+     \obsolete
+
+     The QMatrix provided through this member does include information about
+     any perspective transformations applied to the view or item. To get the
+     correct transformation matrix, use QPainter::transform() on the painter
+     passed into the QGraphicsItem::paint() implementation.
+
+     This matrix is the combination of the item's scene matrix and the matrix
+     of the painter used for drawing the item. It is provided for convenience,
+     allowing anvanced level-of-detail metrics that can be used to speed up
+     item drawing.
+
+     To find the dimensions of an item in screen coordinates (i.e., pixels),
+     you can use the mapping functions of QMatrix, such as QMatrix::map().
+
+     This member is only initialized for items that have the
+     QGraphicsItem::ItemUsesExtendedStyleOption flag set.
+
+     \sa QStyleOptionGraphicsItem::levelOfDetailFromTransform()
+*/
+
+/*!
+    \variable QStyleOptionGraphicsItem::levelOfDetail
+    \obsolete
+
+    Use QStyleOptionGraphicsItem::levelOfDetailFromTransform()
+    together with QPainter::worldTransform() instead.
+*/
+
+/*!
+    \class QStyleHintReturn
+    \brief The QStyleHintReturn class provides style hints that return more
+    than basic data types.
+
+    \ingroup appearance
+    \inmodule QtWidgets
+
+    QStyleHintReturn and its subclasses are used to pass information
+    from a style back to the querying widget. This is most useful
+    when the return value from QStyle::styleHint() does not provide enough
+    detail; for example, when a mask is to be returned.
+
+    \omit
+    ### --Sam
+    \endomit
+*/
+
+/*!
+    \enum QStyleHintReturn::HintReturnType
+
+    \value SH_Default QStyleHintReturn
+    \value SH_Mask \l QStyle::SH_RubberBand_Mask QStyle::SH_FocusFrame_Mask
+    \value SH_Variant \l QStyle::SH_TextControl_FocusIndicatorTextCharFormat
+*/
+
+/*!
+    \enum QStyleHintReturn::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleHintReturn subclass.
+
+    \value Type The type of style option provided (\l SH_Default for
+           this class).
+
+    The type is used internally by QStyleHintReturn, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleHintReturn subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleHintReturn::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleHintReturn subclass.
+
+    \value Version 1
+
+    The version is used by QStyleHintReturn subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \variable QStyleHintReturn::type
+    \brief the type of the style hint container
+
+    \sa HintReturnType
+*/
+
+/*!
+    \variable QStyleHintReturn::version
+    \brief the version of the style hint return container
+
+    This value can be used by subclasses to implement extensions
+    without breaking compatibility. If you use qstyleoption_cast<T>(), you
+    normally do not need to check it.
+*/
+
+/*!
+    Constructs a QStyleHintReturn with version \a version and type \a
+    type.
+
+    The version has no special meaning for QStyleHintReturn; it can be
+    used by subclasses to distinguish between different version of
+    the same hint type.
+
+    \sa QStyleOption::version, QStyleOption::type
+*/
+
+QStyleHintReturn::QStyleHintReturn(int version, int type)
+    : version(version), type(type)
+{
+}
+
+/*!
+    \internal
+*/
+
+QStyleHintReturn::~QStyleHintReturn()
+{
+
+}
+
+/*!
+    \class QStyleHintReturnMask
+    \brief The QStyleHintReturnMask class provides style hints that return a QRegion.
+
+    \ingroup appearance
+    \inmodule QtWidgets
+
+    \omit
+    ### --Sam
+    \endomit
+*/
+
+/*!
+    \variable QStyleHintReturnMask::region
+    \brief the region for style hints that return a QRegion
+*/
+
+/*!
+    Constructs a QStyleHintReturnMask. The member variables are
+    initialized to default values.
+*/
+QStyleHintReturnMask::QStyleHintReturnMask() : QStyleHintReturn(Version, Type)
+{
+}
+
+/*!
+    Destructor.
+*/
+QStyleHintReturnMask::~QStyleHintReturnMask()
+{
+}
+
+/*!
+    \enum QStyleHintReturnMask::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleHintReturn subclass.
+
+    \value Type The type of style option provided (\l{SH_Mask} for
+           this class).
+
+    The type is used internally by QStyleHintReturn, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleHintReturn subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleHintReturnMask::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleHintReturn subclass.
+
+    \value Version 1
+
+    The version is used by QStyleHintReturn subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \class QStyleHintReturnVariant
+    \brief The QStyleHintReturnVariant class provides style hints that return a QVariant.
+    \since 4.3
+    \ingroup appearance
+    \inmodule QtWidgets
+*/
+
+/*!
+    \variable QStyleHintReturnVariant::variant
+    \brief the variant for style hints that return a QVariant
+*/
+
+/*!
+    Constructs a QStyleHintReturnVariant. The member variables are
+    initialized to default values.
+*/
+QStyleHintReturnVariant::QStyleHintReturnVariant() : QStyleHintReturn(Version, Type)
+{
+}
+
+/*!
+    Destructor.
+*/
+QStyleHintReturnVariant::~QStyleHintReturnVariant()
+{
+}
+
+/*!
+    \enum QStyleHintReturnVariant::StyleOptionType
+
+    This enum is used to hold information about the type of the style option, and
+    is defined for each QStyleHintReturn subclass.
+
+    \value Type The type of style option provided (\l{SH_Variant} for
+           this class).
+
+    The type is used internally by QStyleHintReturn, its subclasses, and
+    qstyleoption_cast() to determine the type of style option. In
+    general you do not need to worry about this unless you want to
+    create your own QStyleHintReturn subclass and your own styles.
+
+    \sa StyleOptionVersion
+*/
+
+/*!
+    \enum QStyleHintReturnVariant::StyleOptionVersion
+
+    This enum is used to hold information about the version of the style option, and
+    is defined for each QStyleHintReturn subclass.
+
+    \value Version 1
+
+    The version is used by QStyleHintReturn subclasses to implement
+    extensions without breaking compatibility. If you use
+    qstyleoption_cast(), you normally do not need to check it.
+
+    \sa StyleOptionType
+*/
+
+/*!
+    \fn T qstyleoption_cast<T>(const QStyleHintReturn *hint)
+    \relates QStyleHintReturn
+
+    Returns a T or 0 depending on the \l{QStyleHintReturn::type}{type}
+    and \l{QStyleHintReturn::version}{version} of \a hint.
+
+    Example:
+
+    \snippet code/src_gui_styles_qstyleoption.cpp 0
+
+    \sa QStyleHintReturn::type, QStyleHintReturn::version
+*/
+
+/*!
+    \fn T qstyleoption_cast<T>(QStyleHintReturn *hint)
+    \overload
+    \relates QStyleHintReturn
+
+    Returns a T or 0 depending on the type of \a hint.
+*/
+
+#if !defined(QT_NO_DEBUG_STREAM)
+QDebug operator<<(QDebug debug, const QStyleOption::OptionType &optionType)
+{
+#if !defined(QT_NO_DEBUG)
+    switch (optionType) {
+    case QStyleOption::SO_Default:
+        debug << "SO_Default"; break;
+    case QStyleOption::SO_FocusRect:
+        debug << "SO_FocusRect"; break;
+    case QStyleOption::SO_Button:
+        debug << "SO_Button"; break;
+    case QStyleOption::SO_Tab:
+        debug << "SO_Tab"; break;
+    case QStyleOption::SO_MenuItem:
+        debug << "SO_MenuItem"; break;
+    case QStyleOption::SO_Frame:
+        debug << "SO_Frame"; break;
+    case QStyleOption::SO_ProgressBar:
+        debug << "SO_ProgressBar"; break;
+    case QStyleOption::SO_ToolBox:
+        debug << "SO_ToolBox"; break;
+    case QStyleOption::SO_Header:
+        debug << "SO_Header"; break;
+    case QStyleOption::SO_DockWidget:
+        debug << "SO_DockWidget"; break;
+    case QStyleOption::SO_ViewItem:
+        debug << "SO_ViewItem"; break;
+    case QStyleOption::SO_TabWidgetFrame:
+        debug << "SO_TabWidgetFrame"; break;
+    case QStyleOption::SO_TabBarBase:
+        debug << "SO_TabBarBase"; break;
+    case QStyleOption::SO_RubberBand:
+        debug << "SO_RubberBand"; break;
+    case QStyleOption::SO_Complex:
+        debug << "SO_Complex"; break;
+    case QStyleOption::SO_Slider:
+        debug << "SO_Slider"; break;
+    case QStyleOption::SO_SpinBox:
+        debug << "SO_SpinBox"; break;
+    case QStyleOption::SO_ToolButton:
+        debug << "SO_ToolButton"; break;
+    case QStyleOption::SO_ComboBox:
+        debug << "SO_ComboBox"; break;
+    case QStyleOption::SO_TitleBar:
+        debug << "SO_TitleBar"; break;
+    case QStyleOption::SO_CustomBase:
+        debug << "SO_CustomBase"; break;
+    case QStyleOption::SO_GroupBox:
+        debug << "SO_GroupBox"; break;
+    case QStyleOption::SO_ToolBar:
+        debug << "SO_ToolBar"; break;
+    case QStyleOption::SO_ComplexCustomBase:
+        debug << "SO_ComplexCustomBase"; break;
+    case QStyleOption::SO_SizeGrip:
+        debug << "SO_SizeGrip"; break;
+    case QStyleOption::SO_GraphicsItem:
+        debug << "SO_GraphicsItem"; break;
+    }
+#else
+    Q_UNUSED(optionType);
+#endif
+    return debug;
+}
+
+QDebug operator<<(QDebug debug, const QStyleOption &option)
+{
+#if !defined(QT_NO_DEBUG)
+    debug << "QStyleOption(";
+    debug << QStyleOption::OptionType(option.type);
+    debug << ',' << (option.direction == Qt::RightToLeft ? "RightToLeft" : "LeftToRight");
+    debug << ',' << option.state;
+    debug << ',' << option.rect;
+    debug << ',' << option.styleObject;
+    debug << ')';
+#else
+    Q_UNUSED(option);
+#endif
+    return debug;
+}
+#endif
+
+QT_END_NAMESPACE
diff --git a/.pc/inendi.patch/src/widgets/styles/qstyleoption.h b/.pc/inendi.patch/src/widgets/styles/qstyleoption.h
new file mode 100644
index 0000000..4f817a3
--- /dev/null
+++ b/.pc/inendi.patch/src/widgets/styles/qstyleoption.h
@@ -0,0 +1,752 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the QtWidgets module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QSTYLEOPTION_H
+#define QSTYLEOPTION_H
+
+#include <QtCore/qvariant.h>
+#include <QtWidgets/qabstractspinbox.h>
+#include <QtGui/qicon.h>
+#include <QtGui/qmatrix.h>
+#include <QtWidgets/qslider.h>
+#include <QtWidgets/qstyle.h>
+#include <QtWidgets/qtabbar.h>
+#include <QtWidgets/qtabwidget.h>
+#include <QtWidgets/qrubberband.h>
+#include <QtWidgets/qframe.h>
+#ifndef QT_NO_ITEMVIEWS
+#   include <QtCore/qabstractitemmodel.h>
+#endif
+
+QT_BEGIN_NAMESPACE
+
+
+class QDebug;
+
+class Q_WIDGETS_EXPORT QStyleOption
+{
+public:
+    enum OptionType {
+                      SO_Default, SO_FocusRect, SO_Button, SO_Tab, SO_MenuItem,
+                      SO_Frame, SO_ProgressBar, SO_ToolBox, SO_Header,
+                      SO_DockWidget, SO_ViewItem, SO_TabWidgetFrame,
+                      SO_TabBarBase, SO_RubberBand, SO_ToolBar, SO_GraphicsItem,
+
+                      SO_Complex = 0xf0000, SO_Slider, SO_SpinBox, SO_ToolButton, SO_ComboBox,
+                      SO_TitleBar, SO_GroupBox, SO_SizeGrip,
+
+                      SO_CustomBase = 0xf00,
+                      SO_ComplexCustomBase = 0xf000000
+                    };
+
+    enum StyleOptionType { Type = SO_Default };
+    enum StyleOptionVersion { Version = 1 };
+
+    int version;
+    int type;
+    QStyle::State state;
+    Qt::LayoutDirection direction;
+    QRect rect;
+    QFontMetrics fontMetrics;
+    QPalette palette;
+    QObject *styleObject;
+
+    QStyleOption(int version = QStyleOption::Version, int type = SO_Default);
+    QStyleOption(const QStyleOption &other);
+    ~QStyleOption();
+
+    void init(const QWidget *w);
+    inline void initFrom(const QWidget *w) { init(w); }
+    QStyleOption &operator=(const QStyleOption &other);
+};
+
+class Q_WIDGETS_EXPORT QStyleOptionFocusRect : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_FocusRect };
+    enum StyleOptionVersion { Version = 1 };
+
+    QColor backgroundColor;
+
+    QStyleOptionFocusRect();
+    QStyleOptionFocusRect(const QStyleOptionFocusRect &other) : QStyleOption(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionFocusRect(int version);
+};
+
+class Q_WIDGETS_EXPORT QStyleOptionFrame : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_Frame };
+    enum StyleOptionVersion { Version = 3 };
+
+    int lineWidth;
+    int midLineWidth;
+    enum FrameFeature {
+        None = 0x00,
+        Flat = 0x01,
+        Rounded = 0x02
+    };
+    Q_DECLARE_FLAGS(FrameFeatures, FrameFeature)
+    FrameFeatures features;
+    QFrame::Shape frameShape;
+
+    QStyleOptionFrame();
+    QStyleOptionFrame(const QStyleOptionFrame &other) : QStyleOption(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionFrame(int version);
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QStyleOptionFrame::FrameFeatures)
+
+typedef QStyleOptionFrame QStyleOptionFrameV2;
+typedef QStyleOptionFrame QStyleOptionFrameV3;
+
+#ifndef QT_NO_TABWIDGET
+class Q_WIDGETS_EXPORT QStyleOptionTabWidgetFrame : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_TabWidgetFrame };
+    enum StyleOptionVersion { Version = 2 };
+
+    int lineWidth;
+    int midLineWidth;
+    QTabBar::Shape shape;
+    QSize tabBarSize;
+    QSize rightCornerWidgetSize;
+    QSize leftCornerWidgetSize;
+    QRect tabBarRect;
+    QRect selectedTabRect;
+
+    QStyleOptionTabWidgetFrame();
+    inline QStyleOptionTabWidgetFrame(const QStyleOptionTabWidgetFrame &other)
+        : QStyleOption(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionTabWidgetFrame(int version);
+};
+
+typedef QStyleOptionTabWidgetFrame QStyleOptionTabWidgetFrameV2;
+#endif // QT_NO_TABWIDGET
+
+
+#ifndef QT_NO_TABBAR
+class Q_WIDGETS_EXPORT QStyleOptionTabBarBase : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_TabBarBase };
+    enum StyleOptionVersion { Version = 2 };
+
+    QTabBar::Shape shape;
+    QRect tabBarRect;
+    QRect selectedTabRect;
+    bool documentMode;
+
+    QStyleOptionTabBarBase();
+    QStyleOptionTabBarBase(const QStyleOptionTabBarBase &other) : QStyleOption(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionTabBarBase(int version);
+};
+
+typedef QStyleOptionTabBarBase QStyleOptionTabBarBaseV2;
+#endif // QT_NO_TABBAR
+
+class Q_WIDGETS_EXPORT QStyleOptionHeader : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_Header };
+    enum StyleOptionVersion { Version = 1 };
+
+    enum SectionPosition { Beginning, Middle, End, OnlyOneSection };
+    enum SelectedPosition { NotAdjacent, NextIsSelected, PreviousIsSelected,
+                            NextAndPreviousAreSelected };
+    enum SortIndicator { None, SortUp, SortDown };
+
+    int section;
+    QString text;
+    Qt::Alignment textAlignment;
+    QIcon icon;
+    Qt::Alignment iconAlignment;
+    SectionPosition position;
+    SelectedPosition selectedPosition;
+    SortIndicator sortIndicator;
+    Qt::Orientation orientation;
+
+    QStyleOptionHeader();
+    QStyleOptionHeader(const QStyleOptionHeader &other) : QStyleOption(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionHeader(int version);
+};
+
+class Q_WIDGETS_EXPORT QStyleOptionButton : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_Button };
+    enum StyleOptionVersion { Version = 1 };
+
+    enum ButtonFeature { None = 0x00, Flat = 0x01, HasMenu = 0x02, DefaultButton = 0x04,
+                         AutoDefaultButton = 0x08, CommandLinkButton = 0x10  };
+    Q_DECLARE_FLAGS(ButtonFeatures, ButtonFeature)
+
+    ButtonFeatures features;
+    QString text;
+    QIcon icon;
+    QSize iconSize;
+
+    QStyleOptionButton();
+    QStyleOptionButton(const QStyleOptionButton &other) : QStyleOption(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionButton(int version);
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QStyleOptionButton::ButtonFeatures)
+
+#ifndef QT_NO_TABBAR
+class Q_WIDGETS_EXPORT QStyleOptionTab : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_Tab };
+    enum StyleOptionVersion { Version = 3 };
+
+    enum TabPosition { Beginning, Middle, End, OnlyOneTab };
+    enum SelectedPosition { NotAdjacent, NextIsSelected, PreviousIsSelected };
+    enum CornerWidget { NoCornerWidgets = 0x00, LeftCornerWidget = 0x01,
+                        RightCornerWidget = 0x02 };
+    enum TabFeature { None = 0x00, HasFrame = 0x01 };
+    Q_DECLARE_FLAGS(CornerWidgets, CornerWidget)
+    Q_DECLARE_FLAGS(TabFeatures, TabFeature)
+
+    QTabBar::Shape shape;
+    QString text;
+    QIcon icon;
+    int row;
+    TabPosition position;
+    SelectedPosition selectedPosition;
+    CornerWidgets cornerWidgets;
+    QSize iconSize;
+    bool documentMode;
+    QSize leftButtonSize;
+    QSize rightButtonSize;
+    TabFeatures features;
+
+    QStyleOptionTab();
+    QStyleOptionTab(const QStyleOptionTab &other) : QStyleOption(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionTab(int version);
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QStyleOptionTab::CornerWidgets)
+
+typedef QStyleOptionTab QStyleOptionTabV2;
+typedef QStyleOptionTab QStyleOptionTabV3;
+#endif // QT_NO_TABBAR
+
+
+#ifndef QT_NO_TOOLBAR
+
+class Q_WIDGETS_EXPORT QStyleOptionToolBar : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_ToolBar };
+    enum StyleOptionVersion { Version = 1 };
+    enum ToolBarPosition { Beginning, Middle, End, OnlyOne };
+    enum ToolBarFeature { None = 0x0, Movable = 0x1 };
+    Q_DECLARE_FLAGS(ToolBarFeatures, ToolBarFeature)
+    ToolBarPosition positionOfLine; // The toolbar line position
+    ToolBarPosition positionWithinLine; // The position within a toolbar
+    Qt::ToolBarArea toolBarArea; // The toolbar docking area
+    ToolBarFeatures features;
+    int lineWidth;
+    int midLineWidth;
+    QStyleOptionToolBar();
+    QStyleOptionToolBar(const QStyleOptionToolBar &other) : QStyleOption(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionToolBar(int version);
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QStyleOptionToolBar::ToolBarFeatures)
+
+#endif // QT_NO_TOOLBAR
+
+class Q_WIDGETS_EXPORT QStyleOptionProgressBar : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_ProgressBar };
+    enum StyleOptionVersion { Version = 2 };
+
+    int minimum;
+    int maximum;
+    int progress;
+    QString text;
+    Qt::Alignment textAlignment;
+    bool textVisible;
+    Qt::Orientation orientation;
+    bool invertedAppearance;
+    bool bottomToTop;
+
+    QStyleOptionProgressBar();
+    QStyleOptionProgressBar(const QStyleOptionProgressBar &other) : QStyleOption(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionProgressBar(int version);
+};
+
+typedef QStyleOptionProgressBar QStyleOptionProgressBarV2;
+
+class Q_WIDGETS_EXPORT QStyleOptionMenuItem : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_MenuItem };
+    enum StyleOptionVersion { Version = 1 };
+
+    enum MenuItemType { Normal, DefaultItem, Separator, SubMenu, Scroller, TearOff, Margin,
+                        EmptyArea };
+    enum CheckType { NotCheckable, Exclusive, NonExclusive };
+
+    MenuItemType menuItemType;
+    CheckType checkType;
+    bool checked;
+    bool menuHasCheckableItems;
+    QRect menuRect;
+    QString text;
+    QIcon icon;
+    int maxIconWidth;
+    int tabWidth;
+    QFont font;
+
+    QStyleOptionMenuItem();
+    QStyleOptionMenuItem(const QStyleOptionMenuItem &other) : QStyleOption(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionMenuItem(int version);
+};
+
+class Q_WIDGETS_EXPORT QStyleOptionDockWidget : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_DockWidget };
+    enum StyleOptionVersion { Version = 2 };
+
+    QString title;
+    bool closable;
+    bool movable;
+    bool floatable;
+    bool verticalTitleBar;
+
+    QStyleOptionDockWidget();
+    QStyleOptionDockWidget(const QStyleOptionDockWidget &other) : QStyleOption(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionDockWidget(int version);
+};
+
+typedef QStyleOptionDockWidget QStyleOptionDockWidgetV2;
+
+#ifndef QT_NO_ITEMVIEWS
+
+class Q_WIDGETS_EXPORT QStyleOptionViewItem : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_ViewItem };
+    enum StyleOptionVersion { Version = 4 };
+
+    enum Position { Left, Right, Top, Bottom };
+
+    Qt::Alignment displayAlignment;
+    Qt::Alignment decorationAlignment;
+    Qt::TextElideMode textElideMode;
+    Position decorationPosition;
+    QSize decorationSize;
+    QFont font;
+    bool showDecorationSelected;
+
+    enum ViewItemFeature {
+        None = 0x00,
+        WrapText = 0x01,
+        Alternate = 0x02,
+        HasCheckIndicator = 0x04,
+        HasDisplay = 0x08,
+        HasDecoration = 0x10
+    };
+    Q_DECLARE_FLAGS(ViewItemFeatures, ViewItemFeature)
+
+    ViewItemFeatures features;
+
+    QLocale locale;
+    const QWidget *widget;
+
+    enum ViewItemPosition { Invalid, Beginning, Middle, End, OnlyOne };
+
+    QModelIndex index;
+    Qt::CheckState checkState;
+    QIcon icon;
+    QString text;
+    ViewItemPosition viewItemPosition;
+    QBrush backgroundBrush;
+
+    QStyleOptionViewItem();
+    QStyleOptionViewItem(const QStyleOptionViewItem &other) : QStyleOption(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionViewItem(int version);
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QStyleOptionViewItem::ViewItemFeatures)
+
+typedef QStyleOptionViewItem QStyleOptionViewItemV2;
+typedef QStyleOptionViewItem QStyleOptionViewItemV3;
+typedef QStyleOptionViewItem QStyleOptionViewItemV4;
+
+#endif // QT_NO_ITEMVIEWS
+
+class Q_WIDGETS_EXPORT QStyleOptionToolBox : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_ToolBox };
+    enum StyleOptionVersion { Version = 2 };
+
+    QString text;
+    QIcon icon;
+
+    enum TabPosition { Beginning, Middle, End, OnlyOneTab };
+    enum SelectedPosition { NotAdjacent, NextIsSelected, PreviousIsSelected };
+
+    TabPosition position;
+    SelectedPosition selectedPosition;
+
+    QStyleOptionToolBox();
+    QStyleOptionToolBox(const QStyleOptionToolBox &other) : QStyleOption(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionToolBox(int version);
+};
+
+typedef QStyleOptionToolBox QStyleOptionToolBoxV2;
+
+#ifndef QT_NO_RUBBERBAND
+class Q_WIDGETS_EXPORT QStyleOptionRubberBand : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_RubberBand };
+    enum StyleOptionVersion { Version = 1 };
+
+    QRubberBand::Shape shape;
+    bool opaque;
+
+    QStyleOptionRubberBand();
+    QStyleOptionRubberBand(const QStyleOptionRubberBand &other) : QStyleOption(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionRubberBand(int version);
+};
+#endif // QT_NO_RUBBERBAND
+
+// -------------------------- Complex style options -------------------------------
+class Q_WIDGETS_EXPORT QStyleOptionComplex : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_Complex };
+    enum StyleOptionVersion { Version = 1 };
+
+    QStyle::SubControls subControls;
+    QStyle::SubControls activeSubControls;
+
+    QStyleOptionComplex(int version = QStyleOptionComplex::Version, int type = SO_Complex);
+    QStyleOptionComplex(const QStyleOptionComplex &other) : QStyleOption(Version, Type) { *this = other; }
+};
+
+#ifndef QT_NO_SLIDER
+class Q_WIDGETS_EXPORT QStyleOptionSlider : public QStyleOptionComplex
+{
+public:
+    enum StyleOptionType { Type = SO_Slider };
+    enum StyleOptionVersion { Version = 1 };
+
+    Qt::Orientation orientation;
+    int minimum;
+    int maximum;
+    QSlider::TickPosition tickPosition;
+    int tickInterval;
+    bool upsideDown;
+    int sliderPosition;
+    int sliderValue;
+    int singleStep;
+    int pageStep;
+    qreal notchTarget;
+    bool dialWrapping;
+
+    QStyleOptionSlider();
+    QStyleOptionSlider(const QStyleOptionSlider &other) : QStyleOptionComplex(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionSlider(int version);
+};
+#endif // QT_NO_SLIDER
+
+#ifndef QT_NO_SPINBOX
+class Q_WIDGETS_EXPORT QStyleOptionSpinBox : public QStyleOptionComplex
+{
+public:
+    enum StyleOptionType { Type = SO_SpinBox };
+    enum StyleOptionVersion { Version = 1 };
+
+    QAbstractSpinBox::ButtonSymbols buttonSymbols;
+    QAbstractSpinBox::StepEnabled stepEnabled;
+    bool frame;
+
+    QStyleOptionSpinBox();
+    QStyleOptionSpinBox(const QStyleOptionSpinBox &other) : QStyleOptionComplex(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionSpinBox(int version);
+};
+#endif // QT_NO_SPINBOX
+
+class Q_WIDGETS_EXPORT QStyleOptionToolButton : public QStyleOptionComplex
+{
+public:
+    enum StyleOptionType { Type = SO_ToolButton };
+    enum StyleOptionVersion { Version = 1 };
+
+    enum ToolButtonFeature { None = 0x00, Arrow = 0x01, Menu = 0x04, MenuButtonPopup = Menu, PopupDelay = 0x08,
+                             HasMenu = 0x10 };
+    Q_DECLARE_FLAGS(ToolButtonFeatures, ToolButtonFeature)
+
+    ToolButtonFeatures features;
+    QIcon icon;
+    QSize iconSize;
+    QString text;
+    Qt::ArrowType arrowType;
+    Qt::ToolButtonStyle toolButtonStyle;
+    QPoint pos;
+    QFont font;
+
+    QStyleOptionToolButton();
+    QStyleOptionToolButton(const QStyleOptionToolButton &other) : QStyleOptionComplex(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionToolButton(int version);
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QStyleOptionToolButton::ToolButtonFeatures)
+
+class Q_WIDGETS_EXPORT QStyleOptionComboBox : public QStyleOptionComplex
+{
+public:
+    enum StyleOptionType { Type = SO_ComboBox };
+    enum StyleOptionVersion { Version = 1 };
+
+    bool editable;
+    QRect popupRect;
+    bool frame;
+    QString currentText;
+    QIcon currentIcon;
+    QSize iconSize;
+
+    QStyleOptionComboBox();
+    QStyleOptionComboBox(const QStyleOptionComboBox &other) : QStyleOptionComplex(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionComboBox(int version);
+};
+
+class Q_WIDGETS_EXPORT QStyleOptionTitleBar : public QStyleOptionComplex
+{
+public:
+    enum StyleOptionType { Type = SO_TitleBar };
+    enum StyleOptionVersion { Version = 1 };
+
+    QString text;
+    QIcon icon;
+    int titleBarState;
+    Qt::WindowFlags titleBarFlags;
+
+    QStyleOptionTitleBar();
+    QStyleOptionTitleBar(const QStyleOptionTitleBar &other) : QStyleOptionComplex(Version, Type) { *this = other; }
+
+protected:
+    QStyleOptionTitleBar(int version);
+};
+
+class Q_WIDGETS_EXPORT QStyleOptionGroupBox : public QStyleOptionComplex
+{
+public:
+    enum StyleOptionType { Type = SO_GroupBox };
+    enum StyleOptionVersion { Version = 1 };
+
+    QStyleOptionFrameV2::FrameFeatures features;
+    QString text;
+    Qt::Alignment textAlignment;
+    QColor textColor;
+    int lineWidth;
+    int midLineWidth;
+
+    QStyleOptionGroupBox();
+    QStyleOptionGroupBox(const QStyleOptionGroupBox &other) : QStyleOptionComplex(Version, Type) { *this = other; }
+protected:
+    QStyleOptionGroupBox(int version);
+};
+
+class Q_WIDGETS_EXPORT QStyleOptionSizeGrip : public QStyleOptionComplex
+{
+public:
+    enum StyleOptionType { Type = SO_SizeGrip };
+    enum StyleOptionVersion { Version = 1 };
+
+    Qt::Corner corner;
+
+    QStyleOptionSizeGrip();
+    QStyleOptionSizeGrip(const QStyleOptionSizeGrip &other) : QStyleOptionComplex(Version, Type) { *this = other; }
+protected:
+    QStyleOptionSizeGrip(int version);
+};
+
+class Q_WIDGETS_EXPORT QStyleOptionGraphicsItem : public QStyleOption
+{
+public:
+    enum StyleOptionType { Type = SO_GraphicsItem };
+    enum StyleOptionVersion { Version = 1 };
+
+    QRectF exposedRect;
+    QMatrix matrix;
+    qreal levelOfDetail;
+
+    QStyleOptionGraphicsItem();
+    QStyleOptionGraphicsItem(const QStyleOptionGraphicsItem &other) : QStyleOption(Version, Type) { *this = other; }
+    static qreal levelOfDetailFromTransform(const QTransform &worldTransform);
+protected:
+    QStyleOptionGraphicsItem(int version);
+};
+
+template <typename T>
+T qstyleoption_cast(const QStyleOption *opt)
+{
+    if (opt && opt->version >= static_cast<T>(0)->Version && (opt->type == static_cast<T>(0)->Type
+        || int(static_cast<T>(0)->Type) == QStyleOption::SO_Default
+        || (int(static_cast<T>(0)->Type) == QStyleOption::SO_Complex
+            && opt->type > QStyleOption::SO_Complex)))
+        return static_cast<T>(opt);
+    return 0;
+}
+
+template <typename T>
+T qstyleoption_cast(QStyleOption *opt)
+{
+    if (opt && opt->version >= static_cast<T>(0)->Version && (opt->type == static_cast<T>(0)->Type
+        || int(static_cast<T>(0)->Type) == QStyleOption::SO_Default
+        || (int(static_cast<T>(0)->Type) == QStyleOption::SO_Complex
+            && opt->type > QStyleOption::SO_Complex)))
+        return static_cast<T>(opt);
+    return 0;
+}
+
+// -------------------------- QStyleHintReturn -------------------------------
+class Q_WIDGETS_EXPORT QStyleHintReturn {
+public:
+    enum HintReturnType {
+        SH_Default=0xf000, SH_Mask, SH_Variant
+    };
+
+    enum StyleOptionType { Type = SH_Default };
+    enum StyleOptionVersion { Version = 1 };
+
+    QStyleHintReturn(int version = QStyleOption::Version, int type = SH_Default);
+    ~QStyleHintReturn();
+
+    int version;
+    int type;
+};
+
+class Q_WIDGETS_EXPORT QStyleHintReturnMask : public QStyleHintReturn {
+public:
+    enum StyleOptionType { Type = SH_Mask };
+    enum StyleOptionVersion { Version = 1 };
+
+    QStyleHintReturnMask();
+    ~QStyleHintReturnMask();
+
+    QRegion region;
+};
+
+class Q_WIDGETS_EXPORT QStyleHintReturnVariant : public QStyleHintReturn {
+public:
+    enum StyleOptionType { Type = SH_Variant };
+    enum StyleOptionVersion { Version = 1 };
+
+    QStyleHintReturnVariant();
+    ~QStyleHintReturnVariant();
+
+    QVariant variant;
+};
+
+template <typename T>
+T qstyleoption_cast(const QStyleHintReturn *hint)
+{
+    if (hint && hint->version <= static_cast<T>(0)->Version &&
+        (hint->type == static_cast<T>(0)->Type || int(static_cast<T>(0)->Type) == QStyleHintReturn::SH_Default))
+        return static_cast<T>(hint);
+    return 0;
+}
+
+template <typename T>
+T qstyleoption_cast(QStyleHintReturn *hint)
+{
+    if (hint && hint->version <= static_cast<T>(0)->Version &&
+        (hint->type == static_cast<T>(0)->Type || int(static_cast<T>(0)->Type) == QStyleHintReturn::SH_Default))
+        return static_cast<T>(hint);
+    return 0;
+}
+
+#if !defined(QT_NO_DEBUG_STREAM)
+Q_WIDGETS_EXPORT QDebug operator<<(QDebug debug, const QStyleOption::OptionType &optionType);
+Q_WIDGETS_EXPORT QDebug operator<<(QDebug debug, const QStyleOption &option);
+#endif
+
+QT_END_NAMESPACE
+
+#endif // QSTYLEOPTION_H
diff --git a/.pc/inendi.patch/src/widgets/widgets/qabstractslider64.cpp b/.pc/inendi.patch/src/widgets/widgets/qabstractslider64.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/.pc/inendi.patch/src/widgets/widgets/qabstractslider64.h b/.pc/inendi.patch/src/widgets/widgets/qabstractslider64.h
new file mode 100644
index 0000000..e69de29
diff --git a/.pc/inendi.patch/src/widgets/widgets/qabstractslider64_p.h b/.pc/inendi.patch/src/widgets/widgets/qabstractslider64_p.h
new file mode 100644
index 0000000..e69de29
diff --git a/.pc/inendi.patch/src/widgets/widgets/qscrollbar64.cpp b/.pc/inendi.patch/src/widgets/widgets/qscrollbar64.cpp
new file mode 100644
index 0000000..e69de29
diff --git a/.pc/inendi.patch/src/widgets/widgets/qscrollbar64.h b/.pc/inendi.patch/src/widgets/widgets/qscrollbar64.h
new file mode 100644
index 0000000..e69de29
diff --git a/.pc/inendi.patch/src/widgets/widgets/widgets.pri b/.pc/inendi.patch/src/widgets/widgets/widgets.pri
new file mode 100644
index 0000000..a924ba9
--- /dev/null
+++ b/.pc/inendi.patch/src/widgets/widgets/widgets.pri
@@ -0,0 +1,172 @@
+# Qt widgets module
+
+HEADERS += \
+        widgets/qbuttongroup.h \
+        widgets/qabstractbutton.h \
+        widgets/qabstractbutton_p.h \
+        widgets/qabstractslider.h \
+        widgets/qabstractslider_p.h \
+        widgets/qabstractspinbox.h \
+        widgets/qabstractspinbox_p.h \
+        widgets/qcalendartextnavigator_p.h \
+        widgets/qcalendarwidget.h \
+        widgets/qcheckbox.h \
+        widgets/qcombobox.h \
+        widgets/qcombobox_p.h \
+        widgets/qcommandlinkbutton.h \
+        widgets/qdatetimeedit.h \
+        widgets/qdatetimeedit_p.h \
+        widgets/qdial.h \
+        widgets/qdialogbuttonbox.h \
+        widgets/qdockwidget.h \
+        widgets/qdockwidget_p.h \
+        widgets/qdockarealayout_p.h \
+        widgets/qfontcombobox.h \
+        widgets/qframe.h \
+        widgets/qframe_p.h \
+        widgets/qgroupbox.h \
+        widgets/qkeysequenceedit.h \
+        widgets/qkeysequenceedit_p.h \
+        widgets/qlabel.h \
+        widgets/qlabel_p.h \
+        widgets/qlcdnumber.h \
+        widgets/qlineedit.h \
+        widgets/qlineedit_p.h \
+        widgets/qmainwindow.h \
+        widgets/qmainwindowlayout_p.h \
+        widgets/qmdiarea.h \
+        widgets/qmdiarea_p.h \
+        widgets/qmdisubwindow.h \
+        widgets/qmdisubwindow_p.h \
+        widgets/qmenu.h \
+        widgets/qmenu_p.h \
+        widgets/qmenubar.h \
+        widgets/qmenubar_p.h \
+        widgets/qprogressbar.h \
+        widgets/qpushbutton.h \
+        widgets/qpushbutton_p.h \
+        widgets/qradiobutton.h \
+        widgets/qrubberband.h \
+        widgets/qscrollbar.h \
+        widgets/qscrollbar_p.h \
+        widgets/qscrollarea_p.h \
+        widgets/qsizegrip.h \
+        widgets/qslider.h \
+        widgets/qspinbox.h \
+        widgets/qsplashscreen.h \
+        widgets/qsplitter.h \
+        widgets/qsplitter_p.h \
+        widgets/qstackedwidget.h \
+        widgets/qstatusbar.h \
+        widgets/qtabbar.h \
+        widgets/qtabbar_p.h \
+        widgets/qtabwidget.h \
+        widgets/qtextedit.h \
+        widgets/qtextedit_p.h \
+        widgets/qtextbrowser.h \
+        widgets/qtoolbar.h \
+        widgets/qtoolbar_p.h \
+        widgets/qtoolbarlayout_p.h \
+        widgets/qtoolbarextension_p.h \
+        widgets/qtoolbarseparator_p.h \
+        widgets/qtoolbox.h \
+        widgets/qtoolbutton.h \
+        widgets/qabstractscrollarea.h \
+        widgets/qabstractscrollarea_p.h \
+        widgets/qwidgetresizehandler_p.h \
+        widgets/qfocusframe.h \
+        widgets/qscrollarea.h \
+        widgets/qwidgetanimator_p.h \
+        widgets/qwidgettextcontrol_p.h \
+        widgets/qwidgettextcontrol_p_p.h \
+        widgets/qwidgetlinecontrol_p.h \
+        widgets/qtoolbararealayout_p.h \
+        widgets/qplaintextedit.h \
+        widgets/qplaintextedit_p.h
+
+SOURCES += \
+        widgets/qabstractbutton.cpp \
+        widgets/qabstractslider.cpp \
+        widgets/qabstractspinbox.cpp \
+        widgets/qcalendarwidget.cpp \
+        widgets/qcheckbox.cpp \
+        widgets/qcombobox.cpp \
+        widgets/qcommandlinkbutton.cpp \
+        widgets/qdatetimeedit.cpp \
+        widgets/qdial.cpp \
+        widgets/qdialogbuttonbox.cpp \
+        widgets/qdockwidget.cpp \
+        widgets/qdockarealayout.cpp \
+        widgets/qeffects.cpp \
+        widgets/qfontcombobox.cpp \
+        widgets/qframe.cpp \
+        widgets/qgroupbox.cpp \
+        widgets/qkeysequenceedit.cpp \
+        widgets/qlabel.cpp \
+        widgets/qlcdnumber.cpp \
+        widgets/qlineedit_p.cpp \
+        widgets/qlineedit.cpp \
+        widgets/qmainwindow.cpp \
+        widgets/qmainwindowlayout.cpp \
+        widgets/qmdiarea.cpp \
+        widgets/qmdisubwindow.cpp \
+        widgets/qmenu.cpp \
+        widgets/qmenubar.cpp \
+        widgets/qprogressbar.cpp \
+        widgets/qpushbutton.cpp \
+        widgets/qradiobutton.cpp \
+        widgets/qrubberband.cpp \
+        widgets/qscrollbar.cpp \
+        widgets/qsizegrip.cpp \
+        widgets/qslider.cpp \
+        widgets/qspinbox.cpp \
+        widgets/qsplashscreen.cpp \
+        widgets/qsplitter.cpp \
+        widgets/qstackedwidget.cpp \
+        widgets/qstatusbar.cpp \
+        widgets/qtabbar.cpp \
+        widgets/qtabwidget.cpp \
+        widgets/qtextedit.cpp \
+        widgets/qtextbrowser.cpp \
+        widgets/qtoolbar.cpp \
+        widgets/qtoolbarlayout.cpp \
+        widgets/qtoolbarextension.cpp \
+        widgets/qtoolbarseparator.cpp \
+        widgets/qtoolbox.cpp \
+        widgets/qtoolbutton.cpp \
+        widgets/qabstractscrollarea.cpp \
+        widgets/qwidgetresizehandler.cpp \
+        widgets/qfocusframe.cpp \
+        widgets/qscrollarea.cpp \
+        widgets/qwidgetanimator.cpp \
+        widgets/qwidgettextcontrol.cpp \
+        widgets/qwidgetlinecontrol.cpp \
+        widgets/qtoolbararealayout.cpp \
+        widgets/qplaintextedit.cpp
+
+macx {
+    HEADERS += \
+        widgets/qmacnativewidget_mac.h \
+        widgets/qmaccocoaviewcontainer_mac.h
+
+    OBJECTIVE_SOURCES += \
+        widgets/qmenu_mac.mm \
+        widgets/qmacnativewidget_mac.mm \
+        widgets/qmaccocoaviewcontainer_mac.mm
+}
+
+wince*: {
+    SOURCES += widgets/qmenu_wince.cpp
+    HEADERS += widgets/qmenu_wince_resource_p.h
+    RC_FILE = widgets/qmenu_wince.rc
+    !static: QMAKE_WRITE_DEFAULT_RC = 1
+    !isEmpty(QT_LIBINFIX) {
+       ORIG_RCFILE = $${TARGET}_resource.rc
+       copyrcc.commands = $$QMAKE_COPY ${QMAKE_FILE_IN} ${QMAKE_FILE_OUT}
+       copyrcc.input = ORIG_RCFILE
+       CONFIG(debug, debug|release):copyrcc.output = $${ORIG_TARGET}d_resource.rc
+       else:copyrcc.output = $${ORIG_TARGET}_resource.rc
+       copyrcc.CONFIG = target_predeps no_link
+       QMAKE_EXTRA_COMPILERS += copyrcc
+    }
+}
diff --git a/debian/patches/inendi.patch b/debian/patches/inendi.patch
new file mode 100644
index 0000000..a16fede
--- /dev/null
+++ b/debian/patches/inendi.patch
@@ -0,0 +1,6181 @@
+Description: INENDI patchset
+Author: Remi Herilier <remi.herilier@esi-group.com>
+
+---
+The information above should follow the Patch Tagging Guidelines, please
+checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
+are templates for supplementary fields that you might want to add:
+
+Origin: <vendor|upstream|other>, <url of original patch>
+Bug: <url in upstream bugtracker>
+Bug-Debian: https://bugs.debian.org/<bugnumber>
+Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
+Forwarded: <no|not-needed|url proving that it has been forwarded>
+Reviewed-By: <name and email of someone who approved the patch>
+Last-Update: <YYYY-MM-DD>
+
+--- qtbase-opensource-src-5.3.2+dfsg.orig/include/QtWidgets/QtWidgets
++++ qtbase-opensource-src-5.3.2+dfsg/include/QtWidgets/QtWidgets
+@@ -82,6 +82,7 @@
+ #include "qabstractbutton.h"
+ #include "qabstractscrollarea.h"
+ #include "qabstractslider.h"
++#include "qabstractslider64.h"
+ #include "qabstractspinbox.h"
+ #include "qbuttongroup.h"
+ #include "qcalendarwidget.h"
+@@ -112,6 +113,7 @@
+ #include "qrubberband.h"
+ #include "qscrollarea.h"
+ #include "qscrollbar.h"
++#include "qscrollbar64.h"
+ #include "qsizegrip.h"
+ #include "qslider.h"
+ #include "qspinbox.h"
+--- qtbase-opensource-src-5.3.2+dfsg.orig/include/QtWidgets/headers.pri
++++ qtbase-opensource-src-5.3.2+dfsg/include/QtWidgets/headers.pri
+@@ -1,5 +1,5 @@
+-SYNCQT.HEADER_FILES = accessible/qaccessiblewidget.h dialogs/qcolordialog.h dialogs/qdialog.h dialogs/qerrormessage.h dialogs/qfiledialog.h dialogs/qfilesystemmodel.h dialogs/qfontdialog.h dialogs/qinputdialog.h dialogs/qmessagebox.h dialogs/qprogressdialog.h dialogs/qwizard.h effects/qgraphicseffect.h graphicsview/qgraphicsanchorlayout.h graphicsview/qgraphicsgridlayout.h graphicsview/qgraphicsitem.h graphicsview/qgraphicsitemanimation.h graphicsview/qgraphicslayout.h graphicsview/qgraphicslayoutitem.h graphicsview/qgraphicslinearlayout.h graphicsview/qgraphicsproxywidget.h graphicsview/qgraphicsscene.h graphicsview/qgraphicssceneevent.h graphicsview/qgraphicstransform.h graphicsview/qgraphicsview.h graphicsview/qgraphicswidget.h itemviews/qabstractitemdelegate.h itemviews/qabstractitemview.h itemviews/qcolumnview.h itemviews/qdatawidgetmapper.h itemviews/qdirmodel.h itemviews/qfileiconprovider.h itemviews/qheaderview.h itemviews/qitemdelegate.h itemviews/qitemeditorfactory.h itemviews/qlistview.h itemviews/qlistwidget.h itemviews/qstyleditemdelegate.h itemviews/qtableview.h itemviews/qtablewidget.h itemviews/qtreeview.h itemviews/qtreewidget.h itemviews/qtreewidgetitemiterator.h kernel/qaction.h kernel/qactiongroup.h kernel/qapplication.h kernel/qboxlayout.h kernel/qdesktopwidget.h kernel/qformlayout.h kernel/qgesture.h kernel/qgesturerecognizer.h kernel/qgridlayout.h kernel/qlayout.h kernel/qlayoutitem.h kernel/qshortcut.h kernel/qsizepolicy.h kernel/qstackedlayout.h kernel/qtooltip.h kernel/qwhatsthis.h kernel/qwidget.h kernel/qwidgetaction.h kernel/qwidgetsfunctions_wince.h statemachine/qkeyeventtransition.h statemachine/qmouseeventtransition.h styles/qcommonstyle.h styles/qdrawutil.h styles/qproxystyle.h styles/qstyle.h styles/qstylefactory.h styles/qstyleoption.h styles/qstylepainter.h styles/qstyleplugin.h util/qcolormap.h util/qcompleter.h util/qscroller.h util/qscrollerproperties.h util/qsystemtrayicon.h util/qundogroup.h util/qundostack.h util/qundoview.h widgets/qabstractbutton.h widgets/qabstractscrollarea.h widgets/qabstractslider.h widgets/qabstractspinbox.h widgets/qbuttongroup.h widgets/qcalendarwidget.h widgets/qcheckbox.h widgets/qcombobox.h widgets/qcommandlinkbutton.h widgets/qdatetimeedit.h widgets/qdial.h widgets/qdialogbuttonbox.h widgets/qdockwidget.h widgets/qfocusframe.h widgets/qfontcombobox.h widgets/qframe.h widgets/qgroupbox.h widgets/qkeysequenceedit.h widgets/qlabel.h widgets/qlcdnumber.h widgets/qlineedit.h widgets/qmaccocoaviewcontainer_mac.h widgets/qmacnativewidget_mac.h widgets/qmainwindow.h widgets/qmdiarea.h widgets/qmdisubwindow.h widgets/qmenu.h widgets/qmenubar.h widgets/qplaintextedit.h widgets/qprogressbar.h widgets/qpushbutton.h widgets/qradiobutton.h widgets/qrubberband.h widgets/qscrollarea.h widgets/qscrollbar.h widgets/qsizegrip.h widgets/qslider.h widgets/qspinbox.h widgets/qsplashscreen.h widgets/qsplitter.h widgets/qstackedwidget.h widgets/qstatusbar.h widgets/qtabbar.h widgets/qtabwidget.h widgets/qtextbrowser.h widgets/qtextedit.h widgets/qtoolbar.h widgets/qtoolbox.h widgets/qtoolbutton.h ../../include/QtWidgets/qtwidgetsversion.h ../../include/QtWidgets/QtWidgets 
+-SYNCQT.HEADER_CLASSES = ../../include/QtWidgets/QAccessibleWidget ../../include/QtWidgets/QColorDialog ../../include/QtWidgets/QDialog ../../include/QtWidgets/QErrorMessage ../../include/QtWidgets/QFileDialog ../../include/QtWidgets/QFileSystemModel ../../include/QtWidgets/QFontDialog ../../include/QtWidgets/QInputDialog ../../include/QtWidgets/QMessageBox ../../include/QtWidgets/QProgressDialog ../../include/QtWidgets/QWizard ../../include/QtWidgets/QWizardPage ../../include/QtWidgets/QGraphicsEffect ../../include/QtWidgets/QGraphicsColorizeEffect ../../include/QtWidgets/QGraphicsBlurEffect ../../include/QtWidgets/QGraphicsDropShadowEffect ../../include/QtWidgets/QGraphicsOpacityEffect ../../include/QtWidgets/QGraphicsAnchor ../../include/QtWidgets/QGraphicsAnchorLayout ../../include/QtWidgets/QGraphicsGridLayout ../../include/QtWidgets/QGraphicsItem ../../include/QtWidgets/QGraphicsObject ../../include/QtWidgets/QAbstractGraphicsShapeItem ../../include/QtWidgets/QGraphicsPathItem ../../include/QtWidgets/QGraphicsRectItem ../../include/QtWidgets/QGraphicsEllipseItem ../../include/QtWidgets/QGraphicsPolygonItem ../../include/QtWidgets/QGraphicsLineItem ../../include/QtWidgets/QGraphicsPixmapItem ../../include/QtWidgets/QGraphicsTextItem ../../include/QtWidgets/QGraphicsSimpleTextItem ../../include/QtWidgets/QGraphicsItemGroup ../../include/QtWidgets/QGraphicsItemAnimation ../../include/QtWidgets/QGraphicsLayout ../../include/QtWidgets/QGraphicsLayoutItem ../../include/QtWidgets/QGraphicsLinearLayout ../../include/QtWidgets/QGraphicsProxyWidget ../../include/QtWidgets/QGraphicsScene ../../include/QtWidgets/QGraphicsSceneEvent ../../include/QtWidgets/QGraphicsSceneMouseEvent ../../include/QtWidgets/QGraphicsSceneWheelEvent ../../include/QtWidgets/QGraphicsSceneContextMenuEvent ../../include/QtWidgets/QGraphicsSceneHoverEvent ../../include/QtWidgets/QGraphicsSceneHelpEvent ../../include/QtWidgets/QGraphicsSceneDragDropEvent ../../include/QtWidgets/QGraphicsSceneResizeEvent ../../include/QtWidgets/QGraphicsSceneMoveEvent ../../include/QtWidgets/QGraphicsTransform ../../include/QtWidgets/QGraphicsScale ../../include/QtWidgets/QGraphicsRotation ../../include/QtWidgets/QGraphicsView ../../include/QtWidgets/QGraphicsWidget ../../include/QtWidgets/QAbstractItemDelegate ../../include/QtWidgets/QAbstractItemView ../../include/QtWidgets/QColumnView ../../include/QtWidgets/QDataWidgetMapper ../../include/QtWidgets/QDirModel ../../include/QtWidgets/QFileIconProvider ../../include/QtWidgets/QHeaderView ../../include/QtWidgets/QItemDelegate ../../include/QtWidgets/QItemEditorCreatorBase ../../include/QtWidgets/QItemEditorCreator ../../include/QtWidgets/QStandardItemEditorCreator ../../include/QtWidgets/QItemEditorFactory ../../include/QtWidgets/QListView ../../include/QtWidgets/QListWidgetItem ../../include/QtWidgets/QListWidget ../../include/QtWidgets/QStyledItemDelegate ../../include/QtWidgets/QTableView ../../include/QtWidgets/QTableWidgetSelectionRange ../../include/QtWidgets/QTableWidgetItem ../../include/QtWidgets/QTableWidget ../../include/QtWidgets/QTreeView ../../include/QtWidgets/QTreeWidgetItem ../../include/QtWidgets/QTreeWidget ../../include/QtWidgets/QTreeWidgetItemIterator ../../include/QtWidgets/QAction ../../include/QtWidgets/QActionGroup ../../include/QtWidgets/QApplication ../../include/QtWidgets/QBoxLayout ../../include/QtWidgets/QHBoxLayout ../../include/QtWidgets/QVBoxLayout ../../include/QtWidgets/QDesktopWidget ../../include/QtWidgets/QFormLayout ../../include/QtWidgets/QGesture ../../include/QtWidgets/QPanGesture ../../include/QtWidgets/QPinchGesture ../../include/QtWidgets/QSwipeGesture ../../include/QtWidgets/QTapGesture ../../include/QtWidgets/QTapAndHoldGesture ../../include/QtWidgets/QGestureEvent ../../include/QtWidgets/QGestureRecognizer ../../include/QtWidgets/QGridLayout ../../include/QtWidgets/QLayout ../../include/QtWidgets/QLayoutItem ../../include/QtWidgets/QSpacerItem ../../include/QtWidgets/QWidgetItem ../../include/QtWidgets/QWidgetItemV2 ../../include/QtWidgets/QShortcut ../../include/QtWidgets/QSizePolicy ../../include/QtWidgets/QStackedLayout ../../include/QtWidgets/QToolTip ../../include/QtWidgets/QWhatsThis ../../include/QtWidgets/QWidgetData ../../include/QtWidgets/QWidget ../../include/QtWidgets/QWidgetAction ../../include/QtWidgets/QKeyEventTransition ../../include/QtWidgets/QMouseEventTransition ../../include/QtWidgets/QCommonStyle ../../include/QtWidgets/QTileRules ../../include/QtWidgets/QProxyStyle ../../include/QtWidgets/QStyle ../../include/QtWidgets/QStyleFactory ../../include/QtWidgets/QStyleOption ../../include/QtWidgets/QStyleOptionFocusRect ../../include/QtWidgets/QStyleOptionFrame ../../include/QtWidgets/QStyleOptionFrameV2 ../../include/QtWidgets/QStyleOptionFrameV3 ../../include/QtWidgets/QStyleOptionTabWidgetFrame ../../include/QtWidgets/QStyleOptionTabWidgetFrameV2 ../../include/QtWidgets/QStyleOptionTabBarBase ../../include/QtWidgets/QStyleOptionTabBarBaseV2 ../../include/QtWidgets/QStyleOptionHeader ../../include/QtWidgets/QStyleOptionButton ../../include/QtWidgets/QStyleOptionTab ../../include/QtWidgets/QStyleOptionTabV2 ../../include/QtWidgets/QStyleOptionTabV3 ../../include/QtWidgets/QStyleOptionToolBar ../../include/QtWidgets/QStyleOptionProgressBar ../../include/QtWidgets/QStyleOptionProgressBarV2 ../../include/QtWidgets/QStyleOptionMenuItem ../../include/QtWidgets/QStyleOptionDockWidget ../../include/QtWidgets/QStyleOptionDockWidgetV2 ../../include/QtWidgets/QStyleOptionViewItem ../../include/QtWidgets/QStyleOptionViewItemV2 ../../include/QtWidgets/QStyleOptionViewItemV3 ../../include/QtWidgets/QStyleOptionViewItemV4 ../../include/QtWidgets/QStyleOptionToolBox ../../include/QtWidgets/QStyleOptionToolBoxV2 ../../include/QtWidgets/QStyleOptionRubberBand ../../include/QtWidgets/QStyleOptionComplex ../../include/QtWidgets/QStyleOptionSlider ../../include/QtWidgets/QStyleOptionSpinBox ../../include/QtWidgets/QStyleOptionToolButton ../../include/QtWidgets/QStyleOptionComboBox ../../include/QtWidgets/QStyleOptionTitleBar ../../include/QtWidgets/QStyleOptionGroupBox ../../include/QtWidgets/QStyleOptionSizeGrip ../../include/QtWidgets/QStyleOptionGraphicsItem ../../include/QtWidgets/QStyleHintReturn ../../include/QtWidgets/QStyleHintReturnMask ../../include/QtWidgets/QStyleHintReturnVariant ../../include/QtWidgets/QStylePainter ../../include/QtWidgets/QStylePlugin ../../include/QtWidgets/QColormap ../../include/QtWidgets/QCompleter ../../include/QtWidgets/QScroller ../../include/QtWidgets/QScrollerProperties ../../include/QtWidgets/QSystemTrayIcon ../../include/QtWidgets/QUndoGroup ../../include/QtWidgets/QUndoCommand ../../include/QtWidgets/QUndoStack ../../include/QtWidgets/QUndoView ../../include/QtWidgets/QAbstractButton ../../include/QtWidgets/QAbstractScrollArea ../../include/QtWidgets/QAbstractSlider ../../include/QtWidgets/QAbstractSpinBox ../../include/QtWidgets/QButtonGroup ../../include/QtWidgets/QCalendarWidget ../../include/QtWidgets/QCheckBox ../../include/QtWidgets/QComboBox ../../include/QtWidgets/QCommandLinkButton ../../include/QtWidgets/QDateTimeEdit ../../include/QtWidgets/QTimeEdit ../../include/QtWidgets/QDateEdit ../../include/QtWidgets/QDial ../../include/QtWidgets/QDialogButtonBox ../../include/QtWidgets/QDockWidget ../../include/QtWidgets/QFocusFrame ../../include/QtWidgets/QFontComboBox ../../include/QtWidgets/QFrame ../../include/QtWidgets/QGroupBox ../../include/QtWidgets/QKeySequenceEdit ../../include/QtWidgets/QLabel ../../include/QtWidgets/QLCDNumber ../../include/QtWidgets/QLineEdit ../../include/QtWidgets/QMacCocoaViewContainer ../../include/QtWidgets/QMacNativeWidget ../../include/QtWidgets/QMainWindow ../../include/QtWidgets/QMdiArea ../../include/QtWidgets/QMdiSubWindow ../../include/QtWidgets/QMenu ../../include/QtWidgets/QMenuBar ../../include/QtWidgets/QPlainTextEdit ../../include/QtWidgets/QPlainTextDocumentLayout ../../include/QtWidgets/QProgressBar ../../include/QtWidgets/QPushButton ../../include/QtWidgets/QRadioButton ../../include/QtWidgets/QRubberBand ../../include/QtWidgets/QScrollArea ../../include/QtWidgets/QScrollBar ../../include/QtWidgets/QSizeGrip ../../include/QtWidgets/QSlider ../../include/QtWidgets/QSpinBox ../../include/QtWidgets/QDoubleSpinBox ../../include/QtWidgets/QSplashScreen ../../include/QtWidgets/QSplitter ../../include/QtWidgets/QSplitterHandle ../../include/QtWidgets/QStackedWidget ../../include/QtWidgets/QStatusBar ../../include/QtWidgets/QTabBar ../../include/QtWidgets/QTabWidget ../../include/QtWidgets/QTextBrowser ../../include/QtWidgets/QTextEdit ../../include/QtWidgets/QToolBar ../../include/QtWidgets/QToolBox ../../include/QtWidgets/QToolButton ../../include/QtWidgets/QtWidgetsVersion 
+-SYNCQT.PRIVATE_HEADER_FILES = dialogs/qcolordialog_p.h dialogs/qdialog_p.h dialogs/qfiledialog_p.h dialogs/qfileinfogatherer_p.h dialogs/qfilesystemmodel_p.h dialogs/qfontdialog_p.h dialogs/qfscompleter_p.h dialogs/qsidebar_p.h dialogs/qwizard_win_p.h effects/qgraphicseffect_p.h effects/qpixmapfilter_p.h graphicsview/qgraph_p.h graphicsview/qgraphicsanchorlayout_p.h graphicsview/qgraphicsgridlayoutengine_p.h graphicsview/qgraphicsitem_p.h graphicsview/qgraphicslayout_p.h graphicsview/qgraphicslayoutitem_p.h graphicsview/qgraphicslayoutstyleinfo_p.h graphicsview/qgraphicsproxywidget_p.h graphicsview/qgraphicsscene_bsp_p.h graphicsview/qgraphicsscene_p.h graphicsview/qgraphicsscenebsptreeindex_p.h graphicsview/qgraphicssceneindex_p.h graphicsview/qgraphicsscenelinearindex_p.h graphicsview/qgraphicstransform_p.h graphicsview/qgraphicsview_p.h graphicsview/qgraphicswidget_p.h graphicsview/qsimplex_p.h itemviews/qabstractitemview_p.h itemviews/qbsptree_p.h itemviews/qcolumnview_p.h itemviews/qcolumnviewgrip_p.h itemviews/qfileiconprovider_p.h itemviews/qheaderview_p.h itemviews/qitemeditorfactory_p.h itemviews/qlistview_p.h itemviews/qlistwidget_p.h itemviews/qtableview_p.h itemviews/qtablewidget_p.h itemviews/qtreeview_p.h itemviews/qtreewidget_p.h itemviews/qtreewidgetitemiterator_p.h itemviews/qwidgetitemdata_p.h kernel/qaction_p.h kernel/qapplication_p.h kernel/qdesktopwidget_qpa_p.h kernel/qgesture_p.h kernel/qgesturemanager_p.h kernel/qlayout_p.h kernel/qlayoutengine_p.h kernel/qmacgesturerecognizer_p.h kernel/qopenglwidget_p.h kernel/qstandardgestures_p.h kernel/qt_widgets_pch.h kernel/qwidget_p.h kernel/qwidgetaction_p.h kernel/qwidgetbackingstore_p.h kernel/qwidgetwindow_qpa_p.h kernel/qwindowcontainer_p.h statemachine/qbasickeyeventtransition_p.h statemachine/qbasicmouseeventtransition_p.h styles/qandroidstyle_p.h styles/qcommonstyle_p.h styles/qcommonstylepixmaps_p.h styles/qfusionstyle_p.h styles/qfusionstyle_p_p.h styles/qgtk2painter_p.h styles/qgtkglobal_p.h styles/qgtkpainter_p.h styles/qgtkstyle_p.h styles/qgtkstyle_p_p.h styles/qmacstyle_mac_p.h styles/qmacstyle_mac_p_p.h styles/qproxystyle_p.h styles/qstyle_p.h styles/qstyleanimation_p.h styles/qstylehelper_p.h styles/qstylesheetstyle_p.h styles/qwindowscestyle_p.h styles/qwindowscestyle_p_p.h styles/qwindowsmobilestyle_p.h styles/qwindowsmobilestyle_p_p.h styles/qwindowsstyle_p.h styles/qwindowsstyle_p_p.h styles/qwindowsvistastyle_p.h styles/qwindowsvistastyle_p_p.h styles/qwindowsxpstyle_p.h styles/qwindowsxpstyle_p_p.h util/qcompleter_p.h util/qflickgesture_p.h util/qscroller_p.h util/qscrollerproperties_p.h util/qsystemtrayicon_p.h util/qundostack_p.h widgets/qabstractbutton_p.h widgets/qabstractscrollarea_p.h widgets/qabstractslider_p.h widgets/qabstractspinbox_p.h widgets/qcalendartextnavigator_p.h widgets/qcombobox_p.h widgets/qdatetimeedit_p.h widgets/qdockarealayout_p.h widgets/qdockwidget_p.h widgets/qeffects_p.h widgets/qframe_p.h widgets/qkeysequenceedit_p.h widgets/qlabel_p.h widgets/qlineedit_p.h widgets/qmainwindowlayout_p.h widgets/qmdiarea_p.h widgets/qmdisubwindow_p.h widgets/qmenu_p.h widgets/qmenu_wince_resource_p.h widgets/qmenubar_p.h widgets/qplaintextedit_p.h widgets/qpushbutton_p.h widgets/qscrollarea_p.h widgets/qscrollbar_p.h widgets/qsplitter_p.h widgets/qtabbar_p.h widgets/qtextedit_p.h widgets/qtoolbar_p.h widgets/qtoolbararealayout_p.h widgets/qtoolbarextension_p.h widgets/qtoolbarlayout_p.h widgets/qtoolbarseparator_p.h widgets/qwidgetanimator_p.h widgets/qwidgetlinecontrol_p.h widgets/qwidgetresizehandler_p.h widgets/qwidgettextcontrol_p.h widgets/qwidgettextcontrol_p_p.h 
++SYNCQT.HEADER_FILES = accessible/qaccessiblewidget.h dialogs/qcolordialog.h dialogs/qdialog.h dialogs/qerrormessage.h dialogs/qfiledialog.h dialogs/qfilesystemmodel.h dialogs/qfontdialog.h dialogs/qinputdialog.h dialogs/qmessagebox.h dialogs/qprogressdialog.h dialogs/qwizard.h effects/qgraphicseffect.h graphicsview/qgraphicsanchorlayout.h graphicsview/qgraphicsgridlayout.h graphicsview/qgraphicsitem.h graphicsview/qgraphicsitemanimation.h graphicsview/qgraphicslayout.h graphicsview/qgraphicslayoutitem.h graphicsview/qgraphicslinearlayout.h graphicsview/qgraphicsproxywidget.h graphicsview/qgraphicsscene.h graphicsview/qgraphicssceneevent.h graphicsview/qgraphicstransform.h graphicsview/qgraphicsview.h graphicsview/qgraphicswidget.h itemviews/qabstractitemdelegate.h itemviews/qabstractitemview.h itemviews/qcolumnview.h itemviews/qdatawidgetmapper.h itemviews/qdirmodel.h itemviews/qfileiconprovider.h itemviews/qheaderview.h itemviews/qitemdelegate.h itemviews/qitemeditorfactory.h itemviews/qlistview.h itemviews/qlistwidget.h itemviews/qstyleditemdelegate.h itemviews/qtableview.h itemviews/qtablewidget.h itemviews/qtreeview.h itemviews/qtreewidget.h itemviews/qtreewidgetitemiterator.h kernel/qaction.h kernel/qactiongroup.h kernel/qapplication.h kernel/qboxlayout.h kernel/qdesktopwidget.h kernel/qformlayout.h kernel/qgesture.h kernel/qgesturerecognizer.h kernel/qgridlayout.h kernel/qlayout.h kernel/qlayoutitem.h kernel/qshortcut.h kernel/qsizepolicy.h kernel/qstackedlayout.h kernel/qtooltip.h kernel/qwhatsthis.h kernel/qwidget.h kernel/qwidgetaction.h kernel/qwidgetsfunctions_wince.h statemachine/qkeyeventtransition.h statemachine/qmouseeventtransition.h styles/qcommonstyle.h styles/qdrawutil.h styles/qproxystyle.h styles/qstyle.h styles/qstylefactory.h styles/qstyleoption.h styles/qstylepainter.h styles/qstyleplugin.h util/qcolormap.h util/qcompleter.h util/qscroller.h util/qscrollerproperties.h util/qsystemtrayicon.h util/qundogroup.h util/qundostack.h util/qundoview.h widgets/qabstractbutton.h widgets/qabstractscrollarea.h widgets/qabstractslider.h widgets/qabstractslider64.h widgets/qabstractspinbox.h widgets/qbuttongroup.h widgets/qcalendarwidget.h widgets/qcheckbox.h widgets/qcombobox.h widgets/qcommandlinkbutton.h widgets/qdatetimeedit.h widgets/qdial.h widgets/qdialogbuttonbox.h widgets/qdockwidget.h widgets/qfocusframe.h widgets/qfontcombobox.h widgets/qframe.h widgets/qgroupbox.h widgets/qkeysequenceedit.h widgets/qlabel.h widgets/qlcdnumber.h widgets/qlineedit.h widgets/qmaccocoaviewcontainer_mac.h widgets/qmacnativewidget_mac.h widgets/qmainwindow.h widgets/qmdiarea.h widgets/qmdisubwindow.h widgets/qmenu.h widgets/qmenubar.h widgets/qplaintextedit.h widgets/qprogressbar.h widgets/qpushbutton.h widgets/qradiobutton.h widgets/qrubberband.h widgets/qscrollarea.h widgets/qscrollbar.h widgets/qscrollbar64.h widgets/qsizegrip.h widgets/qslider.h widgets/qspinbox.h widgets/qsplashscreen.h widgets/qsplitter.h widgets/qstackedwidget.h widgets/qstatusbar.h widgets/qtabbar.h widgets/qtabwidget.h widgets/qtextbrowser.h widgets/qtextedit.h widgets/qtoolbar.h widgets/qtoolbox.h widgets/qtoolbutton.h ../../include/QtWidgets/qtwidgetsversion.h ../../include/QtWidgets/QtWidgets 
++SYNCQT.HEADER_CLASSES = ../../include/QtWidgets/QAccessibleWidget ../../include/QtWidgets/QColorDialog ../../include/QtWidgets/QDialog ../../include/QtWidgets/QErrorMessage ../../include/QtWidgets/QFileDialog ../../include/QtWidgets/QFileSystemModel ../../include/QtWidgets/QFontDialog ../../include/QtWidgets/QInputDialog ../../include/QtWidgets/QMessageBox ../../include/QtWidgets/QProgressDialog ../../include/QtWidgets/QWizard ../../include/QtWidgets/QWizardPage ../../include/QtWidgets/QGraphicsEffect ../../include/QtWidgets/QGraphicsColorizeEffect ../../include/QtWidgets/QGraphicsBlurEffect ../../include/QtWidgets/QGraphicsDropShadowEffect ../../include/QtWidgets/QGraphicsOpacityEffect ../../include/QtWidgets/QGraphicsAnchor ../../include/QtWidgets/QGraphicsAnchorLayout ../../include/QtWidgets/QGraphicsGridLayout ../../include/QtWidgets/QGraphicsItem ../../include/QtWidgets/QGraphicsObject ../../include/QtWidgets/QAbstractGraphicsShapeItem ../../include/QtWidgets/QGraphicsPathItem ../../include/QtWidgets/QGraphicsRectItem ../../include/QtWidgets/QGraphicsEllipseItem ../../include/QtWidgets/QGraphicsPolygonItem ../../include/QtWidgets/QGraphicsLineItem ../../include/QtWidgets/QGraphicsPixmapItem ../../include/QtWidgets/QGraphicsTextItem ../../include/QtWidgets/QGraphicsSimpleTextItem ../../include/QtWidgets/QGraphicsItemGroup ../../include/QtWidgets/QGraphicsItemAnimation ../../include/QtWidgets/QGraphicsLayout ../../include/QtWidgets/QGraphicsLayoutItem ../../include/QtWidgets/QGraphicsLinearLayout ../../include/QtWidgets/QGraphicsProxyWidget ../../include/QtWidgets/QGraphicsScene ../../include/QtWidgets/QGraphicsSceneEvent ../../include/QtWidgets/QGraphicsSceneMouseEvent ../../include/QtWidgets/QGraphicsSceneWheelEvent ../../include/QtWidgets/QGraphicsSceneContextMenuEvent ../../include/QtWidgets/QGraphicsSceneHoverEvent ../../include/QtWidgets/QGraphicsSceneHelpEvent ../../include/QtWidgets/QGraphicsSceneDragDropEvent ../../include/QtWidgets/QGraphicsSceneResizeEvent ../../include/QtWidgets/QGraphicsSceneMoveEvent ../../include/QtWidgets/QGraphicsTransform ../../include/QtWidgets/QGraphicsScale ../../include/QtWidgets/QGraphicsRotation ../../include/QtWidgets/QGraphicsView ../../include/QtWidgets/QGraphicsWidget ../../include/QtWidgets/QAbstractItemDelegate ../../include/QtWidgets/QAbstractItemView ../../include/QtWidgets/QColumnView ../../include/QtWidgets/QDataWidgetMapper ../../include/QtWidgets/QDirModel ../../include/QtWidgets/QFileIconProvider ../../include/QtWidgets/QHeaderView ../../include/QtWidgets/QItemDelegate ../../include/QtWidgets/QItemEditorCreatorBase ../../include/QtWidgets/QItemEditorCreator ../../include/QtWidgets/QStandardItemEditorCreator ../../include/QtWidgets/QItemEditorFactory ../../include/QtWidgets/QListView ../../include/QtWidgets/QListWidgetItem ../../include/QtWidgets/QListWidget ../../include/QtWidgets/QStyledItemDelegate ../../include/QtWidgets/QTableView ../../include/QtWidgets/QTableWidgetSelectionRange ../../include/QtWidgets/QTableWidgetItem ../../include/QtWidgets/QTableWidget ../../include/QtWidgets/QTreeView ../../include/QtWidgets/QTreeWidgetItem ../../include/QtWidgets/QTreeWidget ../../include/QtWidgets/QTreeWidgetItemIterator ../../include/QtWidgets/QAction ../../include/QtWidgets/QActionGroup ../../include/QtWidgets/QApplication ../../include/QtWidgets/QBoxLayout ../../include/QtWidgets/QHBoxLayout ../../include/QtWidgets/QVBoxLayout ../../include/QtWidgets/QDesktopWidget ../../include/QtWidgets/QFormLayout ../../include/QtWidgets/QGesture ../../include/QtWidgets/QPanGesture ../../include/QtWidgets/QPinchGesture ../../include/QtWidgets/QSwipeGesture ../../include/QtWidgets/QTapGesture ../../include/QtWidgets/QTapAndHoldGesture ../../include/QtWidgets/QGestureEvent ../../include/QtWidgets/QGestureRecognizer ../../include/QtWidgets/QGridLayout ../../include/QtWidgets/QLayout ../../include/QtWidgets/QLayoutItem ../../include/QtWidgets/QSpacerItem ../../include/QtWidgets/QWidgetItem ../../include/QtWidgets/QWidgetItemV2 ../../include/QtWidgets/QShortcut ../../include/QtWidgets/QSizePolicy ../../include/QtWidgets/QStackedLayout ../../include/QtWidgets/QToolTip ../../include/QtWidgets/QWhatsThis ../../include/QtWidgets/QWidgetData ../../include/QtWidgets/QWidget ../../include/QtWidgets/QWidgetAction ../../include/QtWidgets/QKeyEventTransition ../../include/QtWidgets/QMouseEventTransition ../../include/QtWidgets/QCommonStyle ../../include/QtWidgets/QTileRules ../../include/QtWidgets/QProxyStyle ../../include/QtWidgets/QStyle ../../include/QtWidgets/QStyleFactory ../../include/QtWidgets/QStyleOption ../../include/QtWidgets/QStyleOptionFocusRect ../../include/QtWidgets/QStyleOptionFrame ../../include/QtWidgets/QStyleOptionFrameV2 ../../include/QtWidgets/QStyleOptionFrameV3 ../../include/QtWidgets/QStyleOptionTabWidgetFrame ../../include/QtWidgets/QStyleOptionTabWidgetFrameV2 ../../include/QtWidgets/QStyleOptionTabBarBase ../../include/QtWidgets/QStyleOptionTabBarBaseV2 ../../include/QtWidgets/QStyleOptionHeader ../../include/QtWidgets/QStyleOptionButton ../../include/QtWidgets/QStyleOptionTab ../../include/QtWidgets/QStyleOptionTabV2 ../../include/QtWidgets/QStyleOptionTabV3 ../../include/QtWidgets/QStyleOptionToolBar ../../include/QtWidgets/QStyleOptionProgressBar ../../include/QtWidgets/QStyleOptionProgressBarV2 ../../include/QtWidgets/QStyleOptionMenuItem ../../include/QtWidgets/QStyleOptionDockWidget ../../include/QtWidgets/QStyleOptionDockWidgetV2 ../../include/QtWidgets/QStyleOptionViewItem ../../include/QtWidgets/QStyleOptionViewItemV2 ../../include/QtWidgets/QStyleOptionViewItemV3 ../../include/QtWidgets/QStyleOptionViewItemV4 ../../include/QtWidgets/QStyleOptionToolBox ../../include/QtWidgets/QStyleOptionToolBoxV2 ../../include/QtWidgets/QStyleOptionRubberBand ../../include/QtWidgets/QStyleOptionComplex ../../include/QtWidgets/QStyleOptionSlider ../../include/QtWidgets/QStyleOptionSlider64 ../../include/QtWidgets/QStyleOptionSpinBox ../../include/QtWidgets/QStyleOptionToolButton ../../include/QtWidgets/QStyleOptionComboBox ../../include/QtWidgets/QStyleOptionTitleBar ../../include/QtWidgets/QStyleOptionGroupBox ../../include/QtWidgets/QStyleOptionSizeGrip ../../include/QtWidgets/QStyleOptionGraphicsItem ../../include/QtWidgets/QStyleHintReturn ../../include/QtWidgets/QStyleHintReturnMask ../../include/QtWidgets/QStyleHintReturnVariant ../../include/QtWidgets/QStylePainter ../../include/QtWidgets/QStylePlugin ../../include/QtWidgets/QColormap ../../include/QtWidgets/QCompleter ../../include/QtWidgets/QScroller ../../include/QtWidgets/QScrollerProperties ../../include/QtWidgets/QSystemTrayIcon ../../include/QtWidgets/QUndoGroup ../../include/QtWidgets/QUndoCommand ../../include/QtWidgets/QUndoStack ../../include/QtWidgets/QUndoView ../../include/QtWidgets/QAbstractButton ../../include/QtWidgets/QAbstractScrollArea ../../include/QtWidgets/QAbstractSlider ../../include/QtWidgets/QAbstractSlider64 ../../include/QtWidgets/QAbstractSpinBox ../../include/QtWidgets/QButtonGroup ../../include/QtWidgets/QCalendarWidget ../../include/QtWidgets/QCheckBox ../../include/QtWidgets/QComboBox ../../include/QtWidgets/QCommandLinkButton ../../include/QtWidgets/QDateTimeEdit ../../include/QtWidgets/QTimeEdit ../../include/QtWidgets/QDateEdit ../../include/QtWidgets/QDial ../../include/QtWidgets/QDialogButtonBox ../../include/QtWidgets/QDockWidget ../../include/QtWidgets/QFocusFrame ../../include/QtWidgets/QFontComboBox ../../include/QtWidgets/QFrame ../../include/QtWidgets/QGroupBox ../../include/QtWidgets/QKeySequenceEdit ../../include/QtWidgets/QLabel ../../include/QtWidgets/QLCDNumber ../../include/QtWidgets/QLineEdit ../../include/QtWidgets/QMacCocoaViewContainer ../../include/QtWidgets/QMacNativeWidget ../../include/QtWidgets/QMainWindow ../../include/QtWidgets/QMdiArea ../../include/QtWidgets/QMdiSubWindow ../../include/QtWidgets/QMenu ../../include/QtWidgets/QMenuBar ../../include/QtWidgets/QPlainTextEdit ../../include/QtWidgets/QPlainTextDocumentLayout ../../include/QtWidgets/QProgressBar ../../include/QtWidgets/QPushButton ../../include/QtWidgets/QRadioButton ../../include/QtWidgets/QRubberBand ../../include/QtWidgets/QScrollArea ../../include/QtWidgets/QScrollBar ../../include/QtWidgets/QScrollBar64 ../../include/QtWidgets/QSizeGrip ../../include/QtWidgets/QSlider ../../include/QtWidgets/QSpinBox ../../include/QtWidgets/QDoubleSpinBox ../../include/QtWidgets/QSplashScreen ../../include/QtWidgets/QSplitter ../../include/QtWidgets/QSplitterHandle ../../include/QtWidgets/QStackedWidget ../../include/QtWidgets/QStatusBar ../../include/QtWidgets/QTabBar ../../include/QtWidgets/QTabWidget ../../include/QtWidgets/QTextBrowser ../../include/QtWidgets/QTextEdit ../../include/QtWidgets/QToolBar ../../include/QtWidgets/QToolBox ../../include/QtWidgets/QToolButton ../../include/QtWidgets/QtWidgetsVersion 
++SYNCQT.PRIVATE_HEADER_FILES = dialogs/qcolordialog_p.h dialogs/qdialog_p.h dialogs/qfiledialog_p.h dialogs/qfileinfogatherer_p.h dialogs/qfilesystemmodel_p.h dialogs/qfontdialog_p.h dialogs/qfscompleter_p.h dialogs/qsidebar_p.h dialogs/qwizard_win_p.h effects/qgraphicseffect_p.h effects/qpixmapfilter_p.h graphicsview/qgraph_p.h graphicsview/qgraphicsanchorlayout_p.h graphicsview/qgraphicsgridlayoutengine_p.h graphicsview/qgraphicsitem_p.h graphicsview/qgraphicslayout_p.h graphicsview/qgraphicslayoutitem_p.h graphicsview/qgraphicslayoutstyleinfo_p.h graphicsview/qgraphicsproxywidget_p.h graphicsview/qgraphicsscene_bsp_p.h graphicsview/qgraphicsscene_p.h graphicsview/qgraphicsscenebsptreeindex_p.h graphicsview/qgraphicssceneindex_p.h graphicsview/qgraphicsscenelinearindex_p.h graphicsview/qgraphicstransform_p.h graphicsview/qgraphicsview_p.h graphicsview/qgraphicswidget_p.h graphicsview/qsimplex_p.h itemviews/qabstractitemview_p.h itemviews/qbsptree_p.h itemviews/qcolumnview_p.h itemviews/qcolumnviewgrip_p.h itemviews/qfileiconprovider_p.h itemviews/qheaderview_p.h itemviews/qitemeditorfactory_p.h itemviews/qlistview_p.h itemviews/qlistwidget_p.h itemviews/qtableview_p.h itemviews/qtablewidget_p.h itemviews/qtreeview_p.h itemviews/qtreewidget_p.h itemviews/qtreewidgetitemiterator_p.h itemviews/qwidgetitemdata_p.h kernel/qaction_p.h kernel/qapplication_p.h kernel/qdesktopwidget_qpa_p.h kernel/qgesture_p.h kernel/qgesturemanager_p.h kernel/qlayout_p.h kernel/qlayoutengine_p.h kernel/qmacgesturerecognizer_p.h kernel/qopenglwidget_p.h kernel/qstandardgestures_p.h kernel/qt_widgets_pch.h kernel/qwidget_p.h kernel/qwidgetaction_p.h kernel/qwidgetbackingstore_p.h kernel/qwidgetwindow_qpa_p.h kernel/qwindowcontainer_p.h statemachine/qbasickeyeventtransition_p.h statemachine/qbasicmouseeventtransition_p.h styles/qandroidstyle_p.h styles/qcommonstyle_p.h styles/qcommonstylepixmaps_p.h styles/qfusionstyle_p.h styles/qfusionstyle_p_p.h styles/qgtk2painter_p.h styles/qgtkglobal_p.h styles/qgtkpainter_p.h styles/qgtkstyle_p.h styles/qgtkstyle_p_p.h styles/qmacstyle_mac_p.h styles/qmacstyle_mac_p_p.h styles/qproxystyle_p.h styles/qstyle_p.h styles/qstyleanimation_p.h styles/qstylehelper_p.h styles/qstylesheetstyle_p.h styles/qwindowscestyle_p.h styles/qwindowscestyle_p_p.h styles/qwindowsmobilestyle_p.h styles/qwindowsmobilestyle_p_p.h styles/qwindowsstyle_p.h styles/qwindowsstyle_p_p.h styles/qwindowsvistastyle_p.h styles/qwindowsvistastyle_p_p.h styles/qwindowsxpstyle_p.h styles/qwindowsxpstyle_p_p.h util/qcompleter_p.h util/qflickgesture_p.h util/qscroller_p.h util/qscrollerproperties_p.h util/qsystemtrayicon_p.h util/qundostack_p.h widgets/qabstractbutton_p.h widgets/qabstractscrollarea_p.h widgets/qabstractslider_p.h widgets/qabstractslider64_p.h widgets/qabstractspinbox_p.h widgets/qcalendartextnavigator_p.h widgets/qcombobox_p.h widgets/qdatetimeedit_p.h widgets/qdockarealayout_p.h widgets/qdockwidget_p.h widgets/qeffects_p.h widgets/qframe_p.h widgets/qkeysequenceedit_p.h widgets/qlabel_p.h widgets/qlineedit_p.h widgets/qmainwindowlayout_p.h widgets/qmdiarea_p.h widgets/qmdisubwindow_p.h widgets/qmenu_p.h widgets/qmenu_wince_resource_p.h widgets/qmenubar_p.h widgets/qplaintextedit_p.h widgets/qpushbutton_p.h widgets/qscrollarea_p.h widgets/qscrollbar_p.h widgets/qsplitter_p.h widgets/qtabbar_p.h widgets/qtextedit_p.h widgets/qtoolbar_p.h widgets/qtoolbararealayout_p.h widgets/qtoolbarextension_p.h widgets/qtoolbarlayout_p.h widgets/qtoolbarseparator_p.h widgets/qwidgetanimator_p.h widgets/qwidgetlinecontrol_p.h widgets/qwidgetresizehandler_p.h widgets/qwidgettextcontrol_p.h widgets/qwidgettextcontrol_p_p.h 
+ SYNCQT.QPA_HEADER_FILES = 
+ SYNCQT.INJECTIONS = 
+--- qtbase-opensource-src-5.3.2+dfsg.orig/src/corelib/tools/qrect.cpp
++++ qtbase-opensource-src-5.3.2+dfsg/src/corelib/tools/qrect.cpp
+@@ -2281,14 +2281,18 @@ QRectF QRectF::operator&(const QRectF &r
+ 
+ bool QRectF::intersects(const QRectF &r) const
+ {
++    if (w == 0   ||
++        r.w == 0 ||
++        h == 0   ||
++        r.h == 0) // null rect
++        return false;
++
+     qreal l1 = xp;
+     qreal r1 = xp;
+     if (w < 0)
+         l1 += w;
+     else
+         r1 += w;
+-    if (l1 == r1) // null rect
+-        return false;
+ 
+     qreal l2 = r.xp;
+     qreal r2 = r.xp;
+@@ -2296,8 +2300,6 @@ bool QRectF::intersects(const QRectF &r)
+         l2 += r.w;
+     else
+         r2 += r.w;
+-    if (l2 == r2) // null rect
+-        return false;
+ 
+     if (l1 >= r2 || l2 >= r1)
+         return false;
+@@ -2308,8 +2310,6 @@ bool QRectF::intersects(const QRectF &r)
+         t1 += h;
+     else
+         b1 += h;
+-    if (t1 == b1) // null rect
+-        return false;
+ 
+     qreal t2 = r.yp;
+     qreal b2 = r.yp;
+@@ -2317,8 +2317,6 @@ bool QRectF::intersects(const QRectF &r)
+         t2 += r.h;
+     else
+         b2 += r.h;
+-    if (t2 == b2) // null rect
+-        return false;
+ 
+     if (t1 >= b2 || t2 >= b1)
+         return false;
+--- qtbase-opensource-src-5.3.2+dfsg.orig/src/widgets/graphicsview/qgraphicsscene.cpp
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/graphicsview/qgraphicsscene.cpp
+@@ -1117,7 +1117,7 @@ QList<QGraphicsItem *> QGraphicsScenePri
+     Q_Q(const QGraphicsScene);
+     QGraphicsView *view = widget ? qobject_cast<QGraphicsView *>(widget->parentWidget()) : 0;
+     if (!view)
+-        return q->items(scenePos, Qt::IntersectsItemShape, Qt::DescendingOrder, QTransform());
++        return q->items(scenePos, Qt::IntersectsItemShape, Qt::DescendingOrder, defaultViewTransform);
+ 
+     const QRectF pointRect(QPointF(widget->mapFromGlobal(screenPos)), QSizeF(1, 1));
+     if (!view->isTransformed())
+@@ -5601,6 +5601,29 @@ void QGraphicsScene::setPalette(const QP
+     d->setPalette_helper(resolvedPalette);
+ }
+ 
++/*! \since 4.8.4 (Picviz)
++ *
++ * Set the default scene-to-view transformation used if none can be found.
++ * By default, an identity matrix is used.
++ */
++void QGraphicsScene::setDefaultViewTransform(QTransform const& viewTransform)
++{
++	Q_D(QGraphicsScene);
++	d->defaultViewTransform = viewTransform;
++}
++
++/*! \since 4.8.4 (Picviz)
++ *
++ * Get the default scene-to-view transformation used if none can be found.
++ *
++ * \sa setDefaultTransform
++ */
++QTransform const& QGraphicsScene::defaultViewTransform() const
++{
++	Q_D(const QGraphicsScene);
++	return d->defaultViewTransform;
++}
++
+ /*!
+     \since 4.6
+ 
+--- qtbase-opensource-src-5.3.2+dfsg.orig/src/widgets/graphicsview/qgraphicsscene.h
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/graphicsview/qgraphicsscene.h
+@@ -249,6 +249,9 @@ public:
+ 
+     bool sendEvent(QGraphicsItem *item, QEvent *event);
+ 
++	void setDefaultViewTransform(QTransform const& viewTransform);
++	QTransform const& defaultViewTransform() const;
++
+ public Q_SLOTS:
+     void update(const QRectF &rect = QRectF());
+     void invalidate(const QRectF &rect = QRectF(), SceneLayers layers = AllLayers);
+--- qtbase-opensource-src-5.3.2+dfsg.orig/src/widgets/graphicsview/qgraphicsscene_p.h
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/graphicsview/qgraphicsscene_p.h
+@@ -69,6 +69,7 @@
+ #include <QtCore/qset.h>
+ #include <QtGui/qfont.h>
+ #include <QtGui/qpalette.h>
++#include <QtGui/qtransform.h>
+ #include <QtWidgets/qstyle.h>
+ #include <QtWidgets/qstyleoption.h>
+ 
+@@ -181,6 +182,8 @@ public:
+     QList<QGraphicsItem *> cachedItemsUnderMouse;
+     QList<QGraphicsItem *> hoverItems;
+     QPointF lastSceneMousePos;
++
++	QTransform defaultViewTransform;
+     void enableMouseTrackingOnViews();
+     QMap<Qt::MouseButton, QPointF> mouseGrabberButtonDownPos;
+     QMap<Qt::MouseButton, QPointF> mouseGrabberButtonDownScenePos;
+--- qtbase-opensource-src-5.3.2+dfsg.orig/src/widgets/styles/qcommonstyle.cpp
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/styles/qcommonstyle.cpp
+@@ -3075,6 +3075,153 @@ static QPolygonF calcArrow(const QStyleO
+ 
+ #endif // QT_NO_DIAL
+ 
++template <class OptionSlider>
++static void drawSlider(const QStyleOptionComplex* opt, const QWidget* widget, QPainter* p, const QStyle* proxy)
++{
++	if (const OptionSlider *slider = qstyleoption_cast<const OptionSlider*>(opt)) {
++		if (slider->subControls == QCommonStyle::SC_SliderTickmarks) {
++			int tickOffset = proxy->pixelMetric(QCommonStyle::PM_SliderTickmarkOffset, slider, widget);
++			int ticks = slider->tickPosition;
++			int thickness = proxy->pixelMetric(QCommonStyle::PM_SliderControlThickness, slider, widget);
++			int len = proxy->pixelMetric(QCommonStyle::PM_SliderLength, slider, widget);
++			qint64 available = proxy->pixelMetric(QCommonStyle::PM_SliderSpaceAvailable, slider, widget);
++			qint64 interval = slider->tickInterval;
++			if (interval <= 0) {
++				interval = slider->singleStep;
++				if (QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum, interval,
++													available)
++					- QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum,
++													  (qint64) 0, available) < 3)
++					interval = slider->pageStep;
++			}
++			if (!interval)
++				interval = 1;
++			int fudge = len / 2;
++			qint64 pos;
++			// Since there is no subrect for tickmarks do a translation here.
++			p->save();
++			p->translate(slider->rect.x(), slider->rect.y());
++			p->setPen(slider->palette.foreground().color());
++			qint64 v = slider->minimum;
++			while (v <= slider->maximum + 1) {
++				if (v == slider->maximum + 1 && interval == 1)
++					break;
++				const qint64 v_ = qMin(v, (qint64) slider->maximum);
++				pos = QStyle::sliderPositionFromValue((qint64) slider->minimum, (qint64) slider->maximum,
++													  v_, available) + fudge;
++				if (slider->orientation == Qt::Horizontal) {
++					if (ticks & QSlider::TicksAbove)
++						p->drawLine(pos, 0, pos, tickOffset - 2);
++					if (ticks & QSlider::TicksBelow)
++						p->drawLine(pos, tickOffset + thickness + 1, pos,
++									slider->rect.height()-1);
++				} else {
++					if (ticks & QSlider::TicksAbove)
++						p->drawLine(0, pos, tickOffset - 2, pos);
++					if (ticks & QSlider::TicksBelow)
++						p->drawLine(tickOffset + thickness + 1, pos,
++									slider->rect.width()-1, pos);
++				}
++				// in the case where maximum is max int
++				qint64 nextInterval = v + interval;
++				if (nextInterval < v)
++					break;
++				v = nextInterval;
++			}
++			p->restore();
++		}
++	}
++}
++
++template <class OptionStyle>
++static void drawScrollBar(const QStyleOptionComplex* opt, QCommonStyle::ComplexControl cc, const QWidget* widget, QPainter* p, QStyle const* proxy)
++{
++	if (const OptionStyle *scrollbar = qstyleoption_cast<const OptionStyle *>(opt)) {
++		// Make a copy here and reset it for each primitive.
++		OptionStyle newScrollbar = *scrollbar;
++		QCommonStyle::State saveFlags = scrollbar->state;
++
++		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarSubLine) {
++			newScrollbar.state = saveFlags;
++			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarSubLine, widget);
++			if (newScrollbar.rect.isValid()) {
++				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarSubLine))
++					newScrollbar.state &= ~(QCommonStyle::QCommonStyle::State_Sunken | QCommonStyle::QCommonStyle::State_MouseOver);
++				proxy->drawControl(QCommonStyle::QCommonStyle::CE_ScrollBarSubLine, &newScrollbar, p, widget);
++			}
++		}
++		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarAddLine) {
++			newScrollbar.rect = scrollbar->rect;
++			newScrollbar.state = saveFlags;
++			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarAddLine, widget);
++			if (newScrollbar.rect.isValid()) {
++				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarAddLine))
++					newScrollbar.state &= ~(QCommonStyle::QCommonStyle::State_Sunken | QCommonStyle::QCommonStyle::State_MouseOver);
++				proxy->drawControl(QCommonStyle::QCommonStyle::CE_ScrollBarAddLine, &newScrollbar, p, widget);
++			}
++		}
++		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarSubPage) {
++			newScrollbar.rect = scrollbar->rect;
++			newScrollbar.state = saveFlags;
++			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarSubPage, widget);
++			if (newScrollbar.rect.isValid()) {
++				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarSubPage))
++					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
++				proxy->drawControl(QCommonStyle::CE_ScrollBarSubPage, &newScrollbar, p, widget);
++			}
++		}
++		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarAddPage) {
++			newScrollbar.rect = scrollbar->rect;
++			newScrollbar.state = saveFlags;
++			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarAddPage, widget);
++			if (newScrollbar.rect.isValid()) {
++				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarAddPage))
++					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
++				proxy->drawControl(QCommonStyle::CE_ScrollBarAddPage, &newScrollbar, p, widget);
++			}
++		}
++		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarFirst) {
++			newScrollbar.rect = scrollbar->rect;
++			newScrollbar.state = saveFlags;
++			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarFirst, widget);
++			if (newScrollbar.rect.isValid()) {
++				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarFirst))
++					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
++				proxy->drawControl(QCommonStyle::CE_ScrollBarFirst, &newScrollbar, p, widget);
++			}
++		}
++		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarLast) {
++			newScrollbar.rect = scrollbar->rect;
++			newScrollbar.state = saveFlags;
++			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarLast, widget);
++			if (newScrollbar.rect.isValid()) {
++				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarLast))
++					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
++				proxy->drawControl(QCommonStyle::CE_ScrollBarLast, &newScrollbar, p, widget);
++			}
++		}
++		if (scrollbar->subControls & QCommonStyle::SC_ScrollBarSlider) {
++			newScrollbar.rect = scrollbar->rect;
++			newScrollbar.state = saveFlags;
++			newScrollbar.rect = proxy->subControlRect(cc, &newScrollbar, QCommonStyle::SC_ScrollBarSlider, widget);
++			if (newScrollbar.rect.isValid()) {
++				if (!(scrollbar->activeSubControls & QCommonStyle::SC_ScrollBarSlider))
++					newScrollbar.state &= ~(QCommonStyle::State_Sunken | QCommonStyle::State_MouseOver);
++				proxy->drawControl(QCommonStyle::CE_ScrollBarSlider, &newScrollbar, p, widget);
++
++				if (scrollbar->state & QCommonStyle::State_HasFocus) {
++					QStyleOptionFocusRect fropt;
++					fropt.QStyleOption::operator=(newScrollbar);
++					fropt.rect.setRect(newScrollbar.rect.x() + 2, newScrollbar.rect.y() + 2,
++									   newScrollbar.rect.width() - 5,
++									   newScrollbar.rect.height() - 5);
++					proxy->drawPrimitive(QCommonStyle::PE_FrameFocusRect, &fropt, p, widget);
++				}
++			}
++		}
++	}
++}
++
+ /*!
+   \reimp
+ */
+@@ -3084,147 +3231,18 @@ void QCommonStyle::drawComplexControl(Co
+     switch (cc) {
+ #ifndef QT_NO_SLIDER
+     case CC_Slider:
+-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+-            if (slider->subControls == SC_SliderTickmarks) {
+-                int tickOffset = proxy()->pixelMetric(PM_SliderTickmarkOffset, slider, widget);
+-                int ticks = slider->tickPosition;
+-                int thickness = proxy()->pixelMetric(PM_SliderControlThickness, slider, widget);
+-                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
+-                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
+-                int interval = slider->tickInterval;
+-                if (interval <= 0) {
+-                    interval = slider->singleStep;
+-                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
+-                                                        available)
+-                        - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
+-                                                          0, available) < 3)
+-                        interval = slider->pageStep;
+-                }
+-                if (!interval)
+-                    interval = 1;
+-                int fudge = len / 2;
+-                int pos;
+-                // Since there is no subrect for tickmarks do a translation here.
+-                p->save();
+-                p->translate(slider->rect.x(), slider->rect.y());
+-                p->setPen(slider->palette.foreground().color());
+-                int v = slider->minimum;
+-                while (v <= slider->maximum + 1) {
+-                    if (v == slider->maximum + 1 && interval == 1)
+-                        break;
+-                    const int v_ = qMin(v, slider->maximum);
+-                    pos = QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
+-                                                          v_, available) + fudge;
+-                    if (slider->orientation == Qt::Horizontal) {
+-                        if (ticks & QSlider::TicksAbove)
+-                            p->drawLine(pos, 0, pos, tickOffset - 2);
+-                        if (ticks & QSlider::TicksBelow)
+-                            p->drawLine(pos, tickOffset + thickness + 1, pos,
+-                                        slider->rect.height()-1);
+-                    } else {
+-                        if (ticks & QSlider::TicksAbove)
+-                            p->drawLine(0, pos, tickOffset - 2, pos);
+-                        if (ticks & QSlider::TicksBelow)
+-                            p->drawLine(tickOffset + thickness + 1, pos,
+-                                        slider->rect.width()-1, pos);
+-                    }
+-                    // in the case where maximum is max int
+-                    int nextInterval = v + interval;
+-                    if (nextInterval < v)
+-                        break;
+-                    v = nextInterval;
+-                }
+-                p->restore();
+-            }
+-        }
++		drawSlider<QStyleOptionSlider>(opt, widget, p, proxy());
++        break;
++    case CC_Slider64:
++		drawSlider<QStyleOptionSlider64>(opt, widget, p, proxy());
+         break;
+ #endif // QT_NO_SLIDER
+ #ifndef QT_NO_SCROLLBAR
+     case CC_ScrollBar:
+-        if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+-            // Make a copy here and reset it for each primitive.
+-            QStyleOptionSlider newScrollbar = *scrollbar;
+-            State saveFlags = scrollbar->state;
+-
+-            if (scrollbar->subControls & SC_ScrollBarSubLine) {
+-                newScrollbar.state = saveFlags;
+-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarSubLine, widget);
+-                if (newScrollbar.rect.isValid()) {
+-                    if (!(scrollbar->activeSubControls & SC_ScrollBarSubLine))
+-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
+-                    proxy()->drawControl(CE_ScrollBarSubLine, &newScrollbar, p, widget);
+-                }
+-            }
+-            if (scrollbar->subControls & SC_ScrollBarAddLine) {
+-                newScrollbar.rect = scrollbar->rect;
+-                newScrollbar.state = saveFlags;
+-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarAddLine, widget);
+-                if (newScrollbar.rect.isValid()) {
+-                    if (!(scrollbar->activeSubControls & SC_ScrollBarAddLine))
+-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
+-                    proxy()->drawControl(CE_ScrollBarAddLine, &newScrollbar, p, widget);
+-                }
+-            }
+-            if (scrollbar->subControls & SC_ScrollBarSubPage) {
+-                newScrollbar.rect = scrollbar->rect;
+-                newScrollbar.state = saveFlags;
+-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarSubPage, widget);
+-                if (newScrollbar.rect.isValid()) {
+-                    if (!(scrollbar->activeSubControls & SC_ScrollBarSubPage))
+-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
+-                    proxy()->drawControl(CE_ScrollBarSubPage, &newScrollbar, p, widget);
+-                }
+-            }
+-            if (scrollbar->subControls & SC_ScrollBarAddPage) {
+-                newScrollbar.rect = scrollbar->rect;
+-                newScrollbar.state = saveFlags;
+-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarAddPage, widget);
+-                if (newScrollbar.rect.isValid()) {
+-                    if (!(scrollbar->activeSubControls & SC_ScrollBarAddPage))
+-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
+-                    proxy()->drawControl(CE_ScrollBarAddPage, &newScrollbar, p, widget);
+-                }
+-            }
+-            if (scrollbar->subControls & SC_ScrollBarFirst) {
+-                newScrollbar.rect = scrollbar->rect;
+-                newScrollbar.state = saveFlags;
+-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarFirst, widget);
+-                if (newScrollbar.rect.isValid()) {
+-                    if (!(scrollbar->activeSubControls & SC_ScrollBarFirst))
+-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
+-                    proxy()->drawControl(CE_ScrollBarFirst, &newScrollbar, p, widget);
+-                }
+-            }
+-            if (scrollbar->subControls & SC_ScrollBarLast) {
+-                newScrollbar.rect = scrollbar->rect;
+-                newScrollbar.state = saveFlags;
+-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarLast, widget);
+-                if (newScrollbar.rect.isValid()) {
+-                    if (!(scrollbar->activeSubControls & SC_ScrollBarLast))
+-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
+-                    proxy()->drawControl(CE_ScrollBarLast, &newScrollbar, p, widget);
+-                }
+-            }
+-            if (scrollbar->subControls & SC_ScrollBarSlider) {
+-                newScrollbar.rect = scrollbar->rect;
+-                newScrollbar.state = saveFlags;
+-                newScrollbar.rect = proxy()->subControlRect(cc, &newScrollbar, SC_ScrollBarSlider, widget);
+-                if (newScrollbar.rect.isValid()) {
+-                    if (!(scrollbar->activeSubControls & SC_ScrollBarSlider))
+-                        newScrollbar.state &= ~(State_Sunken | State_MouseOver);
+-                    proxy()->drawControl(CE_ScrollBarSlider, &newScrollbar, p, widget);
+-
+-                    if (scrollbar->state & State_HasFocus) {
+-                        QStyleOptionFocusRect fropt;
+-                        fropt.QStyleOption::operator=(newScrollbar);
+-                        fropt.rect.setRect(newScrollbar.rect.x() + 2, newScrollbar.rect.y() + 2,
+-                                           newScrollbar.rect.width() - 5,
+-                                           newScrollbar.rect.height() - 5);
+-                        proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, p, widget);
+-                    }
+-                }
+-            }
+-        }
++		drawScrollBar<QStyleOptionSlider>(opt, cc, widget, p, proxy());
++        break;
++    case CC_ScrollBar64:
++		drawScrollBar<QStyleOptionSlider64>(opt, cc, widget, p, proxy());
+         break;
+ #endif // QT_NO_SCROLLBAR
+ #ifndef QT_NO_SPINBOX
+@@ -3756,6 +3774,92 @@ void QCommonStyle::drawComplexControl(Co
+     }
+ }
+ 
++template <class OptionStyle, class Class>
++void hitTestComplexControlScrollbar(const QStyleOptionComplex* opt, const QWidget* widget, QCommonStyle::SubControl sc, QRect& ret, QStyle const* proxy, Class* c)
++{
++        if (const OptionStyle *scrollbar = qstyleoption_cast<const OptionStyle*>(opt)) {
++            const QRect scrollBarRect = scrollbar->rect;
++            int sbextent = 0;
++            if (!proxy->styleHint(QStyle::SH_ScrollBar_Transient, scrollbar, widget))
++                sbextent = proxy->pixelMetric(QStyle::PM_ScrollBarExtent, scrollbar, widget);
++            int maxlen = ((scrollbar->orientation == Qt::Horizontal) ?
++                          scrollBarRect.width() : scrollBarRect.height()) - (sbextent * 2);
++            int sliderlen;
++
++            // calculate slider length
++            if (scrollbar->maximum != scrollbar->minimum) {
++                uint range = scrollbar->maximum - scrollbar->minimum;
++                sliderlen = (qint64(scrollbar->pageStep) * maxlen) / (range + scrollbar->pageStep);
++
++                int slidermin = proxy->pixelMetric(QCommonStyle::PM_ScrollBarSliderMin, scrollbar, widget);
++                if (sliderlen < slidermin || range > INT_MAX / 2)
++                    sliderlen = slidermin;
++                if (sliderlen > maxlen)
++                    sliderlen = maxlen;
++            } else {
++                sliderlen = maxlen;
++            }
++
++            int sliderstart = sbextent + QStyle::sliderPositionFromValue((qint64)scrollbar->minimum,
++                                                                         (qint64) scrollbar->maximum,
++                                                                         (qint64)scrollbar->sliderPosition,
++                                                                         (qint64)maxlen - sliderlen,
++                                                                         scrollbar->upsideDown);
++
++            switch (sc) {
++            case QStyle::SC_ScrollBarSubLine:            // top/left button
++                if (scrollbar->orientation == Qt::Horizontal) {
++                    int buttonWidth = qMin(scrollBarRect.width() / 2, sbextent);
++                    ret.setRect(0, 0, buttonWidth, scrollBarRect.height());
++                } else {
++                    int buttonHeight = qMin(scrollBarRect.height() / 2, sbextent);
++                    ret.setRect(0, 0, scrollBarRect.width(), buttonHeight);
++                }
++                break;
++            case QStyle::SC_ScrollBarAddLine:            // bottom/right button
++                if (scrollbar->orientation == Qt::Horizontal) {
++                    int buttonWidth = qMin(scrollBarRect.width()/2, sbextent);
++                    ret.setRect(scrollBarRect.width() - buttonWidth, 0, buttonWidth, scrollBarRect.height());
++                } else {
++                    int buttonHeight = qMin(scrollBarRect.height()/2, sbextent);
++                    ret.setRect(0, scrollBarRect.height() - buttonHeight, scrollBarRect.width(), buttonHeight);
++                }
++                break;
++            case QStyle::SC_ScrollBarSubPage:            // between top/left button and slider
++                if (scrollbar->orientation == Qt::Horizontal)
++                    ret.setRect(sbextent, 0, sliderstart - sbextent, scrollBarRect.height());
++                else
++                    ret.setRect(0, sbextent, scrollBarRect.width(), sliderstart - sbextent);
++                break;
++            case QStyle::SC_ScrollBarAddPage:            // between bottom/right button and slider
++                if (scrollbar->orientation == Qt::Horizontal)
++                    ret.setRect(sliderstart + sliderlen, 0,
++                                maxlen - sliderstart - sliderlen + sbextent, scrollBarRect.height());
++                else
++                    ret.setRect(0, sliderstart + sliderlen, scrollBarRect.width(),
++                                maxlen - sliderstart - sliderlen + sbextent);
++                break;
++            case QStyle::SC_ScrollBarGroove:
++                if (scrollbar->orientation == Qt::Horizontal)
++                    ret.setRect(sbextent, 0, scrollBarRect.width() - sbextent * 2,
++                                scrollBarRect.height());
++                else
++                    ret.setRect(0, sbextent, scrollBarRect.width(),
++                                scrollBarRect.height() - sbextent * 2);
++                break;
++            case QStyle::SC_ScrollBarSlider:
++                if (scrollbar->orientation == Qt::Horizontal)
++                    ret.setRect(sliderstart, 0, sliderlen, scrollBarRect.height());
++                else
++                    ret.setRect(0, sliderstart, scrollBarRect.width(), sliderlen);
++                break;
++            default:
++                break;
++            }
++            ret = c->visualRect(scrollbar->direction, scrollBarRect, ret);
++        }
++}
++
+ /*!
+     \reimp
+ */
+@@ -3780,11 +3884,12 @@ QStyle::SubControl QCommonStyle::hitTest
+ #endif // QT_NO_SLIDER
+ #ifndef QT_NO_SCROLLBAR
+     case CC_ScrollBar:
+-        if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
++    case CC_ScrollBar64:
++        if (qstyleoption_cast<const QStyleOptionSlider *>(opt) || qstyleoption_cast<const QStyleOptionSlider64 *>(opt)) {
+             QRect r;
+             uint ctrl = SC_ScrollBarAddLine;
+             while (ctrl <= SC_ScrollBarGroove) {
+-                r = proxy()->subControlRect(cc, scrollbar, QStyle::SubControl(ctrl), widget);
++                r = proxy()->subControlRect(cc, opt, QStyle::SubControl(ctrl), widget);
+                 if (r.isValid() && r.contains(pt)) {
+                     sc = QStyle::SubControl(ctrl);
+                     break;
+@@ -3939,87 +4044,10 @@ QRect QCommonStyle::subControlRect(Compl
+ #endif // QT_NO_SLIDER
+ #ifndef QT_NO_SCROLLBAR
+     case CC_ScrollBar:
+-        if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
+-            const QRect scrollBarRect = scrollbar->rect;
+-            int sbextent = 0;
+-            if (!proxy()->styleHint(SH_ScrollBar_Transient, scrollbar, widget))
+-                sbextent = proxy()->pixelMetric(PM_ScrollBarExtent, scrollbar, widget);
+-            int maxlen = ((scrollbar->orientation == Qt::Horizontal) ?
+-                          scrollBarRect.width() : scrollBarRect.height()) - (sbextent * 2);
+-            int sliderlen;
+-
+-            // calculate slider length
+-            if (scrollbar->maximum != scrollbar->minimum) {
+-                uint range = scrollbar->maximum - scrollbar->minimum;
+-                sliderlen = (qint64(scrollbar->pageStep) * maxlen) / (range + scrollbar->pageStep);
+-
+-                int slidermin = proxy()->pixelMetric(PM_ScrollBarSliderMin, scrollbar, widget);
+-                if (sliderlen < slidermin || range > INT_MAX / 2)
+-                    sliderlen = slidermin;
+-                if (sliderlen > maxlen)
+-                    sliderlen = maxlen;
+-            } else {
+-                sliderlen = maxlen;
+-            }
+-
+-            int sliderstart = sbextent + sliderPositionFromValue(scrollbar->minimum,
+-                                                                 scrollbar->maximum,
+-                                                                 scrollbar->sliderPosition,
+-                                                                 maxlen - sliderlen,
+-                                                                 scrollbar->upsideDown);
+-
+-            switch (sc) {
+-            case SC_ScrollBarSubLine:            // top/left button
+-                if (scrollbar->orientation == Qt::Horizontal) {
+-                    int buttonWidth = qMin(scrollBarRect.width() / 2, sbextent);
+-                    ret.setRect(0, 0, buttonWidth, scrollBarRect.height());
+-                } else {
+-                    int buttonHeight = qMin(scrollBarRect.height() / 2, sbextent);
+-                    ret.setRect(0, 0, scrollBarRect.width(), buttonHeight);
+-                }
+-                break;
+-            case SC_ScrollBarAddLine:            // bottom/right button
+-                if (scrollbar->orientation == Qt::Horizontal) {
+-                    int buttonWidth = qMin(scrollBarRect.width()/2, sbextent);
+-                    ret.setRect(scrollBarRect.width() - buttonWidth, 0, buttonWidth, scrollBarRect.height());
+-                } else {
+-                    int buttonHeight = qMin(scrollBarRect.height()/2, sbextent);
+-                    ret.setRect(0, scrollBarRect.height() - buttonHeight, scrollBarRect.width(), buttonHeight);
+-                }
+-                break;
+-            case SC_ScrollBarSubPage:            // between top/left button and slider
+-                if (scrollbar->orientation == Qt::Horizontal)
+-                    ret.setRect(sbextent, 0, sliderstart - sbextent, scrollBarRect.height());
+-                else
+-                    ret.setRect(0, sbextent, scrollBarRect.width(), sliderstart - sbextent);
+-                break;
+-            case SC_ScrollBarAddPage:            // between bottom/right button and slider
+-                if (scrollbar->orientation == Qt::Horizontal)
+-                    ret.setRect(sliderstart + sliderlen, 0,
+-                                maxlen - sliderstart - sliderlen + sbextent, scrollBarRect.height());
+-                else
+-                    ret.setRect(0, sliderstart + sliderlen, scrollBarRect.width(),
+-                                maxlen - sliderstart - sliderlen + sbextent);
+-                break;
+-            case SC_ScrollBarGroove:
+-                if (scrollbar->orientation == Qt::Horizontal)
+-                    ret.setRect(sbextent, 0, scrollBarRect.width() - sbextent * 2,
+-                                scrollBarRect.height());
+-                else
+-                    ret.setRect(0, sbextent, scrollBarRect.width(),
+-                                scrollBarRect.height() - sbextent * 2);
+-                break;
+-            case SC_ScrollBarSlider:
+-                if (scrollbar->orientation == Qt::Horizontal)
+-                    ret.setRect(sliderstart, 0, sliderlen, scrollBarRect.height());
+-                else
+-                    ret.setRect(0, sliderstart, scrollBarRect.width(), sliderlen);
+-                break;
+-            default:
+-                break;
+-            }
+-            ret = visualRect(scrollbar->direction, scrollBarRect, ret);
+-        }
++	    hitTestComplexControlScrollbar<QStyleOptionSlider>(opt, widget, sc, ret, proxy(), this);
++        break;
++    case CC_ScrollBar64:
++	    hitTestComplexControlScrollbar<QStyleOptionSlider64>(opt, widget, sc, ret, proxy(), this);
+         break;
+ #endif // QT_NO_SCROLLBAR
+ #ifndef QT_NO_SPINBOX
+--- qtbase-opensource-src-5.3.2+dfsg.orig/src/widgets/styles/qfusionstyle.cpp
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/styles/qfusionstyle.cpp
+@@ -333,150 +333,744 @@ static void qt_fusion_draw_mdibutton(QPa
+     painter->drawPoint(tmp.right() , tmp.bottom() - 1);
+ }
+ 
+-/*
+-    \internal
+-*/
+-QFusionStylePrivate::QFusionStylePrivate()
++template <class OptionStyle, class PrivClass>
++static void drawComplexControlScrollBar(QStyle::ComplexControl control,
++                                        const QStyleOptionComplex *option,
++                                        QPainter *painter, const QWidget *widget,
++                                        QStyle const* proxy,
++                                        PrivClass *d)
+ {
+-    animationFps = 60;
+-}
++        painter->save();
++        QColor outline = d->outline(option->palette);
++        QColor buttonColor = d->buttonColor(option->palette);
++        QColor gradientStartColor = buttonColor.lighter(104);
++        QColor gradientStopColor = buttonColor.darker(102);
+ 
+-/*!
+-    \class QFusionStyle
+-    \brief The QFusionStyle class provides a custom widget style
++        if (const OptionStyle *scrollBar = qstyleoption_cast<const OptionStyle *>(option)) {
++            bool wasActive = false;
++            qreal expandScale = 1.0;
++            qreal expandOffset = -1.0;
++            QObject *styleObject = option->styleObject;
++            if (styleObject && proxy->styleHint(QStyle::SH_ScrollBar_Transient, option, widget)) {
++                qreal opacity = 0.0;
++                bool shouldExpand = false;
++                const qreal maxExpandScale = 13.0 / 9.0;
+ 
+-    \inmodule QtWidgets
+-    \internal
++                int oldPos = styleObject->property("_q_stylepos").toInt();
++                int oldMin = styleObject->property("_q_stylemin").toInt();
++                int oldMax = styleObject->property("_q_stylemax").toInt();
++                QRect oldRect = styleObject->property("_q_stylerect").toRect();
++                int oldState = styleObject->property("_q_stylestate").toInt();
++                uint oldActiveControls = styleObject->property("_q_stylecontrols").toUInt();
+ 
+-    The Fusion style provides a custom look and feel that is not
+-    tied to a particular platform.
+-    //{Fusion Style Widget Gallery}
+-    \sa QWindowsStyle, QWindowsVistaStyle, QMacStyle, QCommonStyle
+-*/
++                // a scrollbar is transient when the the scrollbar itself and
++                // its sibling are both inactive (ie. not pressed/hovered/moved)
++                bool transient = !option->activeSubControls && !(option->state & QStyle::State_On);
+ 
+-/*!
+-    Constructs a QFusionStyle object.
+-*/
+-QFusionStyle::QFusionStyle() : QCommonStyle(*new QFusionStylePrivate)
+-{
+-    setObjectName(QLatin1String("Fusion"));
+-}
++                if (!transient ||
++                        oldPos != scrollBar->sliderPosition ||
++                        oldMin != scrollBar->minimum ||
++                        oldMax != scrollBar->maximum ||
++                        oldRect != scrollBar->rect ||
++                        oldState != scrollBar->state ||
++                        oldActiveControls != scrollBar->activeSubControls) {
+ 
+-/*!
+-    \internal
++                    // if the scrollbar is transient or its attributes, geometry or
++                    // state has changed, the opacity is reset back to 100% opaque
++                    opacity = 1.0;
+ 
+-    Constructs a QFusionStyle object.
+-*/
+-QFusionStyle::QFusionStyle(QFusionStylePrivate &dd) : QCommonStyle(dd)
+-{
+-}
++                    styleObject->setProperty("_q_stylepos", scrollBar->sliderPosition);
++                    styleObject->setProperty("_q_stylemin", scrollBar->minimum);
++                    styleObject->setProperty("_q_stylemax", scrollBar->maximum);
++                    styleObject->setProperty("_q_stylerect", scrollBar->rect);
++                    styleObject->setProperty("_q_stylestate", static_cast<int>(scrollBar->state));
++                    styleObject->setProperty("_q_stylecontrols", static_cast<uint>(scrollBar->activeSubControls));
+ 
+-/*!
+-    Destroys the QFusionStyle object.
+-*/
+-QFusionStyle::~QFusionStyle()
+-{
+-}
++                    QScrollbarStyleAnimation *anim  = qobject_cast<QScrollbarStyleAnimation *>(d->animation(styleObject));
++                    if (transient) {
++                        if (!anim) {
++                            anim = new QScrollbarStyleAnimation(QScrollbarStyleAnimation::Deactivating, styleObject);
++                            d->startAnimation(anim);
++                        } else if (anim->mode() == QScrollbarStyleAnimation::Deactivating) {
++                            // the scrollbar was already fading out while the
++                            // state changed -> restart the fade out animation
++                            anim->setCurrentTime(0);
++                        }
++                    } else if (anim && anim->mode() == QScrollbarStyleAnimation::Deactivating) {
++                        d->stopAnimation(styleObject);
++                    }
++                }
+ 
+-/*!
+-    \fn void QFusionStyle::drawItemText(QPainter *painter, const QRect &rectangle, int alignment, const QPalette &palette,
+-                                    bool enabled, const QString& text, QPalette::ColorRole textRole) const
++                QScrollbarStyleAnimation *anim = qobject_cast<QScrollbarStyleAnimation *>(d->animation(styleObject));
++                if (anim && anim->mode() == QScrollbarStyleAnimation::Deactivating) {
++                    // once a scrollbar was active (hovered/pressed), it retains
++                    // the active look even if it's no longer active while fading out
++                    if (oldActiveControls)
++                        anim->setActive(true);
+ 
+-    Draws the given \a text in the specified \a rectangle using the
+-    provided \a painter and \a palette.
++                    wasActive = anim->wasActive();
++                    opacity = anim->currentValue();
++                }
+ 
+-    Text is drawn using the painter's pen. If an explicit \a textRole
+-    is specified, then the text is drawn using the \a palette's color
+-    for the specified role.  The \a enabled value indicates whether or
+-    not the item is enabled; when reimplementing, this value should
+-    influence how the item is drawn.
++                shouldExpand = (option->activeSubControls || wasActive);
++                if (shouldExpand) {
++                    if (!anim && !oldActiveControls) {
++                        // Start expand animation only once and when entering
++                        anim = new QScrollbarStyleAnimation(QScrollbarStyleAnimation::Activating, styleObject);
++                        d->startAnimation(anim);
++                    }
++                    if (anim && anim->mode() == QScrollbarStyleAnimation::Activating) {
++                        expandScale = 1.0 + (maxExpandScale - 1.0) * anim->currentValue();
++                        expandOffset = 5.5 * anim->currentValue() - 1;
++                    } else {
++                        // Keep expanded state after the animation ends, and when fading out
++                        expandScale = maxExpandScale;
++                        expandOffset = 4.5;
++                    }
++                }
++                painter->setOpacity(opacity);
++            }
+ 
+-    The text is aligned and wrapped according to the specified \a
+-    alignment.
++            bool transient = proxy->styleHint(QStyle::SH_ScrollBar_Transient, option, widget);
++            bool horizontal = scrollBar->orientation == Qt::Horizontal;
++            bool sunken = scrollBar->state & QStyle::State_Sunken;
+ 
+-    \sa Qt::Alignment
+-*/
+-void QFusionStyle::drawItemText(QPainter *painter, const QRect &rect, int alignment, const QPalette &pal,
+-                                bool enabled, const QString& text, QPalette::ColorRole textRole) const
+-{
+-    if (text.isEmpty())
+-        return;
++            QRect scrollBarSubLine = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarSubLine, widget);
++            QRect scrollBarAddLine = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarAddLine, widget);
++            QRect scrollBarSlider = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarSlider, widget);
++            QRect scrollBarGroove = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarGroove, widget);
+ 
+-    QPen savedPen = painter->pen();
+-    if (textRole != QPalette::NoRole) {
+-        painter->setPen(QPen(pal.brush(textRole), savedPen.widthF()));
+-    }
+-    if (!enabled) {
+-        QPen pen = painter->pen();
+-        painter->setPen(pen);
+-    }
+-    painter->drawText(rect, alignment, text);
+-    painter->setPen(savedPen);
+-}
++            QRect rect = option->rect;
++            QColor alphaOutline = outline;
++            alphaOutline.setAlpha(180);
+ 
++            QColor arrowColor = option->palette.foreground().color();
++            arrowColor.setAlpha(220);
+ 
+-/*!
+-    \reimp
+-*/
+-void QFusionStyle::drawPrimitive(PrimitiveElement elem,
+-                                 const QStyleOption *option,
+-                                 QPainter *painter, const QWidget *widget) const
+-{
+-    Q_ASSERT(option);
+-    Q_D (const QFusionStyle);
++            const QColor bgColor = QStyleHelper::backgroundColor(option->palette, widget);
++            const bool isDarkBg = bgColor.red() < 128 && bgColor.green() < 128 && bgColor.blue() < 128;
+ 
+-    QRect rect = option->rect;
+-    int state = option->state;
++            if (transient) {
++                if (horizontal) {
++                    rect.setY(rect.y() + 4.5 - expandOffset);
++                    scrollBarSlider.setY(scrollBarSlider.y() + 4.5 - expandOffset);
++                    scrollBarGroove.setY(scrollBarGroove.y() + 4.5 - expandOffset);
+ 
+-    QColor outline = d->outline(option->palette);
+-    QColor highlightedOutline = d->highlightedOutline(option->palette);
++                    rect.setHeight(rect.height() * expandScale);
++                    scrollBarGroove.setHeight(scrollBarGroove.height() * expandScale);
++                } else {
++                    rect.setX(rect.x() + 4.5 - expandOffset);
++                    scrollBarSlider.setX(scrollBarSlider.x() + 4.5 - expandOffset);
++                    scrollBarGroove.setX(scrollBarGroove.x() + 4.5 - expandOffset);
+ 
+-    QColor tabFrameColor = d->tabFrameColor(option->palette);
++                    rect.setWidth(rect.width() * expandScale);
++                    scrollBarGroove.setWidth(scrollBarGroove.width() * expandScale);
++                }
++            }
+ 
+-    switch (elem) {
++            // Paint groove
++            if ((!transient || scrollBar->activeSubControls || wasActive) && scrollBar->subControls & QStyle::SC_ScrollBarGroove) {
++                QLinearGradient gradient(rect.center().x(), rect.top(),
++                                         rect.center().x(), rect.bottom());
++                if (!horizontal)
++                    gradient = QLinearGradient(rect.left(), rect.center().y(),
++                                               rect.right(), rect.center().y());
++                if (!transient || !isDarkBg) {
++                    gradient.setColorAt(0, buttonColor.darker(107));
++                    gradient.setColorAt(0.1, buttonColor.darker(105));
++                    gradient.setColorAt(0.9, buttonColor.darker(105));
++                    gradient.setColorAt(1, buttonColor.darker(107));
++                } else {
++                    gradient.setColorAt(0, bgColor.lighter(157));
++                    gradient.setColorAt(0.1, bgColor.lighter(155));
++                    gradient.setColorAt(0.9, bgColor.lighter(155));
++                    gradient.setColorAt(1, bgColor.lighter(157));
++                }
+ 
+-    // No frame drawn
+-    case PE_FrameGroupBox:
+-    {
+-        QPixmap pixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_groupbox.png"));
+-        int topMargin = qMax(pixelMetric(PM_ExclusiveIndicatorHeight), option->fontMetrics.height()) + groupBoxTopMargin;
+-        QRect frame = option->rect.adjusted(0, topMargin, 0, 0);
+-        qDrawBorderPixmap(painter, frame, QMargins(6, 6, 6, 6), pixmap);
+-        break;
+-    }
+-    case PE_IndicatorBranch: {
+-        if (!(option->state & State_Children))
+-            break;
+-        if (option->state & State_Open)
+-            drawPrimitive(PE_IndicatorArrowDown, option, painter, widget);
+-        else
+-            drawPrimitive(PE_IndicatorArrowRight, option, painter, widget);
+-        break;
+-    }
+-    case PE_FrameTabBarBase:
+-        if (const QStyleOptionTabBarBase *tbb
+-                = qstyleoption_cast<const QStyleOptionTabBarBase *>(option)) {
+-            painter->save();
+-            painter->setPen(QPen(outline.lighter(110)));
+-            switch (tbb->shape) {
+-            case QTabBar::RoundedNorth: {
+-                QRegion region(tbb->rect);
+-                region -= tbb->selectedTabRect;
+-                painter->drawLine(tbb->rect.topLeft(), tbb->rect.topRight());
+-                painter->setClipRegion(region);
+-                painter->setPen(option->palette.light().color());
+-                painter->drawLine(tbb->rect.topLeft() + QPoint(0, 1), tbb->rect.topRight() + QPoint(0, 1));
++                painter->save();
++                if (transient)
++                    painter->setOpacity(0.8);
++                painter->fillRect(rect, gradient);
++                painter->setPen(Qt::NoPen);
++                if (transient)
++                    painter->setOpacity(0.4);
++                painter->setPen(alphaOutline);
++                if (horizontal)
++                    painter->drawLine(rect.topLeft(), rect.topRight());
++                else
++                    painter->drawLine(rect.topLeft(), rect.bottomLeft());
++
++                QColor subtleEdge = alphaOutline;
++                subtleEdge.setAlpha(40);
++                painter->setPen(Qt::NoPen);
++                painter->setBrush(Qt::NoBrush);
++                painter->setClipRect(scrollBarGroove.adjusted(1, 0, -1, -3));
++                painter->drawRect(scrollBarGroove.adjusted(1, 0, -1, -1));
++                painter->restore();
+             }
+-                break;
+-            case QTabBar::RoundedWest:
+-                painter->drawLine(tbb->rect.left(), tbb->rect.top(), tbb->rect.left(), tbb->rect.bottom());
+-                break;
+-            case QTabBar::RoundedSouth:
+-                painter->drawLine(tbb->rect.left(), tbb->rect.bottom(),
+-                                  tbb->rect.right(), tbb->rect.bottom());
+-                break;
+-            case QTabBar::RoundedEast:
+-                painter->drawLine(tbb->rect.topRight(), tbb->rect.bottomRight());
++
++            QRect pixmapRect = scrollBarSlider;
++            QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
++                                     pixmapRect.center().x(), pixmapRect.bottom());
++            if (!horizontal)
++                gradient = QLinearGradient(pixmapRect.left(), pixmapRect.center().y(),
++                                           pixmapRect.right(), pixmapRect.center().y());
++
++            QLinearGradient highlightedGradient = gradient;
++
++            QColor midColor2 = mergedColors(gradientStartColor, gradientStopColor, 40);
++            gradient.setColorAt(0, d->buttonColor(option->palette).lighter(108));
++            gradient.setColorAt(1, d->buttonColor(option->palette));
++
++            highlightedGradient.setColorAt(0, gradientStartColor.darker(102));
++            highlightedGradient.setColorAt(1, gradientStopColor.lighter(102));
++
++            // Paint slider
++            if (scrollBar->subControls & QStyle::SC_ScrollBarSlider) {
++                if (transient) {
++                    QRect rect = scrollBarSlider.adjusted(horizontal ? 1 : 2, horizontal ? 2 : 1, -1, -1);
++                    painter->setPen(Qt::NoPen);
++                    painter->setBrush(isDarkBg ? d->lightShade() : d->darkShade());
++                    int r = qMin(rect.width(), rect.height()) / 2;
++
++                    painter->save();
++                    painter->setRenderHint(QPainter::Antialiasing, true);
++                    painter->drawRoundedRect(rect, r, r);
++                    painter->restore();
++                } else {
++                    QRect pixmapRect = scrollBarSlider;
++                    painter->setPen(QPen(alphaOutline));
++                    if (option->state & QStyle::State_Sunken && scrollBar->activeSubControls & QStyle::SC_ScrollBarSlider)
++                        painter->setBrush(midColor2);
++                    else if (option->state & QStyle::State_MouseOver && scrollBar->activeSubControls & QStyle::SC_ScrollBarSlider)
++                        painter->setBrush(highlightedGradient);
++                    else
++                        painter->setBrush(gradient);
++
++                    painter->drawRect(pixmapRect.adjusted(horizontal ? -1 : 0, horizontal ? 0 : -1, horizontal ? 0 : 1, horizontal ? 1 : 0));
++
++                    painter->setPen(d->innerContrastLine());
++                    painter->drawRect(scrollBarSlider.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, -1, -1));
++
++                    // Outer shadow
++                    //                  painter->setPen(subtleEdge);
++                    //                  if (horizontal) {
++                    ////                    painter->drawLine(scrollBarSlider.topLeft() + QPoint(-2, 0), scrollBarSlider.bottomLeft() + QPoint(2, 0));
++                    ////                    painter->drawLine(scrollBarSlider.topRight() + QPoint(-2, 0), scrollBarSlider.bottomRight() + QPoint(2, 0));
++                    //                  } else {
++                    ////                    painter->drawLine(pixmapRect.topLeft() + QPoint(0, -2), pixmapRect.bottomLeft() + QPoint(0, -2));
++                    ////                    painter->drawLine(pixmapRect.topRight() + QPoint(0, 2), pixmapRect.bottomRight() + QPoint(0, 2));
++                    //                  }
++                }
++            }
++
++            // The SubLine (up/left) buttons
++            if (!transient && scrollBar->subControls & QStyle::SC_ScrollBarSubLine) {
++                if ((scrollBar->activeSubControls & QStyle::SC_ScrollBarSubLine) && sunken)
++                    painter->setBrush(gradientStopColor);
++                else if ((scrollBar->activeSubControls & QStyle::SC_ScrollBarSubLine))
++                    painter->setBrush(highlightedGradient);
++                else
++                    painter->setBrush(gradient);
++
++                painter->setPen(Qt::NoPen);
++                painter->drawRect(scrollBarSubLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, 0, 0));
++                painter->setPen(QPen(alphaOutline));
++                if (option->state & QStyle::State_Horizontal) {
++                    if (option->direction == Qt::RightToLeft) {
++                        pixmapRect.setLeft(scrollBarSubLine.left());
++                        painter->drawLine(pixmapRect.topLeft(), pixmapRect.bottomLeft());
++                    } else {
++                        pixmapRect.setRight(scrollBarSubLine.right());
++                        painter->drawLine(pixmapRect.topRight(), pixmapRect.bottomRight());
++                    }
++                } else {
++                    pixmapRect.setBottom(scrollBarSubLine.bottom());
++                    painter->drawLine(pixmapRect.bottomLeft(), pixmapRect.bottomRight());
++                }
++
++                painter->setBrush(Qt::NoBrush);
++                painter->setPen(d->innerContrastLine());
++                painter->drawRect(scrollBarSubLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0 ,  horizontal ? -2 : -1, horizontal ? -1 : -2));
++
++                // Arrows
++                int rotation = 0;
++                if (option->state & QStyle::State_Horizontal)
++                    rotation = option->direction == Qt::LeftToRight ? -90 : 90;
++                QRect upRect = scrollBarSubLine.translated(horizontal ? -2 : -1, 0);
++                QPixmap arrowPixmap = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), arrowColor, rotation);
++                painter->drawPixmap(QRectF(upRect.center().x() - arrowPixmap.width() / 4.0  + 2.0,
++                                          upRect.center().y() - arrowPixmap.height() / 4.0 + 1.0,
++                                          arrowPixmap.width() / 2.0, arrowPixmap.height() / 2.0),
++                                          arrowPixmap, QRectF(QPoint(0.0, 0.0), arrowPixmap.size()));
++            }
++
++            // The AddLine (down/right) button
++            if (!transient && scrollBar->subControls & QStyle::SC_ScrollBarAddLine) {
++                if ((scrollBar->activeSubControls & QStyle::SC_ScrollBarAddLine) && sunken)
++                    painter->setBrush(gradientStopColor);
++                else if ((scrollBar->activeSubControls & QStyle::SC_ScrollBarAddLine))
++                    painter->setBrush(midColor2);
++                else
++                    painter->setBrush(gradient);
++
++                painter->setPen(Qt::NoPen);
++                painter->drawRect(scrollBarAddLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, 0, 0));
++                painter->setPen(QPen(alphaOutline, 1));
++                if (option->state & QStyle::State_Horizontal) {
++                    if (option->direction == Qt::LeftToRight) {
++                        pixmapRect.setLeft(scrollBarAddLine.left());
++                        painter->drawLine(pixmapRect.topLeft(), pixmapRect.bottomLeft());
++                    } else {
++                        pixmapRect.setRight(scrollBarAddLine.right());
++                        painter->drawLine(pixmapRect.topRight(), pixmapRect.bottomRight());
++                    }
++                } else {
++                    pixmapRect.setTop(scrollBarAddLine.top());
++                    painter->drawLine(pixmapRect.topLeft(), pixmapRect.topRight());
++                }
++
++                painter->setPen(d->innerContrastLine());
++                painter->setBrush(Qt::NoBrush);
++                painter->drawRect(scrollBarAddLine.adjusted(1, 1, -1, -1));
++
++                int rotation = 180;
++                if (option->state & QStyle::State_Horizontal)
++                    rotation = option->direction == Qt::LeftToRight ? 90 : -90;
++                QRect downRect = scrollBarAddLine.translated(-1, 1);
++                QPixmap arrowPixmap = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), arrowColor, rotation);
++                painter->drawPixmap(QRectF(downRect.center().x() - arrowPixmap.width() / 4.0 + 2.0,
++                                           downRect.center().y() - arrowPixmap.height() / 4.0,
++                                           arrowPixmap.width() / 2.0, arrowPixmap.height() / 2.0),
++                                           arrowPixmap, QRectF(QPoint(0.0, 0.0), arrowPixmap.size()));
++            }
++        }
++        painter->restore();
++}
++
++template <class OptionStyle, class PrivClass>
++static void drawComplexControlSlider(QStyle::ComplexControl control,
++                                     const QStyleOptionComplex *option,
++                                     QPainter *painter,
++                                     const QWidget *widget,
++                                     const QStyle* proxy,
++                                     PrivClass *d)
++{
++        if (const OptionStyle *slider = qstyleoption_cast<const OptionStyle *>(option)) {
++            QRect groove = proxy->subControlRect(control, option, QStyle::SC_SliderGroove, widget);
++            QRect handle = proxy->subControlRect(control, option, QStyle::SC_SliderHandle, widget);
++
++            bool horizontal = slider->orientation == Qt::Horizontal;
++            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
++            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
++            QColor activeHighlight = d->highlight(option->palette);
++            QPixmap cache;
++            QBrush oldBrush = painter->brush();
++            QPen oldPen = painter->pen();
++            QColor shadowAlpha(Qt::black);
++            QColor outline = d->outline(option->palette);
++            QColor buttonColor = d->buttonColor(option->palette);
++
++            shadowAlpha.setAlpha(10);
++            if (option->state & QStyle::State_HasFocus && option->state & QStyle::State_KeyboardFocusChange)
++                outline = d->highlightedOutline(option->palette);
++
++
++            if ((option->subControls & QStyle::SC_SliderGroove) && groove.isValid()) {
++                QColor grooveColor;
++                grooveColor.setHsv(buttonColor.hue(),
++                                   qMin(255, (int)(buttonColor.saturation())),
++                                   qMin(255, (int)(buttonColor.value()*0.9)));
++                QString groovePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_groove"), option, groove.size());
++                QRect pixmapRect(0, 0, groove.width(), groove.height());
++                QColor outline = d->outline(option->palette);
++
++                // draw background groove
++                if (!QPixmapCache::find(groovePixmapName, cache)) {
++                    cache = styleCachePixmap(pixmapRect.size());
++                    cache.fill(Qt::transparent);
++                    QPainter groovePainter(&cache);
++                    groovePainter.setRenderHint(QPainter::Antialiasing, true);
++                    groovePainter.translate(0.5, 0.5);
++                    QLinearGradient gradient;
++                    if (horizontal) {
++                        gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
++                        gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
++                    }
++                    else {
++                        gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
++                        gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
++                    }
++                    groovePainter.setPen(QPen(outline));
++                    gradient.setColorAt(0, grooveColor.darker(110));
++                    gradient.setColorAt(1, grooveColor.lighter(110));//palette.button().color().darker(115));
++                    groovePainter.setBrush(gradient);
++                    groovePainter.drawRoundedRect(pixmapRect.adjusted(1, 1, -2, -2), 1, 1);
++                    groovePainter.end();
++                    QPixmapCache::insert(groovePixmapName, cache);
++                }
++                painter->drawPixmap(groove.topLeft(), cache);
++
++                // draw blue groove highlight
++                QRect clipRect;
++                groovePixmapName += QLatin1String("_blue");
++                if (!QPixmapCache::find(groovePixmapName, cache)) {
++                    cache = styleCachePixmap(pixmapRect.size());
++                    cache.fill(Qt::transparent);
++                    QPainter groovePainter(&cache);
++                    QLinearGradient gradient;
++                    if (horizontal) {
++                        gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
++                        gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
++                    }
++                    else {
++                        gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
++                        gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
++                    }
++                    QColor highlight = d->highlight(option->palette);
++                    QColor highlightedoutline = highlight.darker(140);
++                    if (qGray(outline.rgb()) > qGray(highlightedoutline.rgb()))
++                        outline = highlightedoutline;
++
++
++                    groovePainter.setRenderHint(QPainter::Antialiasing, true);
++                    groovePainter.translate(0.5, 0.5);
++                    groovePainter.setPen(QPen(outline));
++                    gradient.setColorAt(0, activeHighlight);
++                    gradient.setColorAt(1, activeHighlight.lighter(130));
++                    groovePainter.setBrush(gradient);
++                    groovePainter.drawRoundedRect(pixmapRect.adjusted(1, 1, -2, -2), 1, 1);
++                    groovePainter.setPen(d->innerContrastLine());
++                    groovePainter.setBrush(Qt::NoBrush);
++                    groovePainter.drawRoundedRect(pixmapRect.adjusted(2, 2, -3, -3), 1, 1);
++                    groovePainter.end();
++                    QPixmapCache::insert(groovePixmapName, cache);
++                }
++                if (horizontal) {
++                    if (slider->upsideDown)
++                        clipRect = QRect(handle.right(), groove.top(), groove.right() - handle.right(), groove.height());
++                    else
++                        clipRect = QRect(groove.left(), groove.top(), handle.left(), groove.height());
++                } else {
++                    if (slider->upsideDown)
++                        clipRect = QRect(groove.left(), handle.bottom(), groove.width(), groove.height() - handle.bottom());
++                    else
++                        clipRect = QRect(groove.left(), groove.top(), groove.width(), handle.top() - groove.top());
++                }
++                painter->save();
++                painter->setClipRect(clipRect.adjusted(0, 0, 1, 1), Qt::IntersectClip);
++                painter->drawPixmap(groove.topLeft(), cache);
++                painter->restore();
++            }
++
++            if (option->subControls & QStyle::SC_SliderTickmarks) {
++                painter->setPen(outline);
++                int tickSize = proxy->pixelMetric(QStyle::PM_SliderTickmarkOffset, option, widget);
++                int available = proxy->pixelMetric(QStyle::PM_SliderSpaceAvailable, slider, widget);
++                int interval = slider->tickInterval;
++                if (interval <= 0) {
++                    interval = slider->singleStep;
++                    if (QStyle::sliderPositionFromValue((qint64)slider->minimum, (qint64)slider->maximum, (qint64)interval,
++                                                        (qint64)available)
++                        - QStyle::sliderPositionFromValue((qint64)slider->minimum, (qint64)slider->maximum,
++                                                              (qint64)0, (qint64)available) < 3)
++                        interval = slider->pageStep;
++                }
++                if (interval <= 0)
++                    interval = 1;
++
++                int v = slider->minimum;
++                int len = proxy->pixelMetric(QStyle::PM_SliderLength, slider, widget);
++                while (v <= slider->maximum + 1) {
++                    if (v == slider->maximum + 1 && interval == 1)
++                        break;
++                    const int v_ = qMin((qint64)v, (qint64)slider->maximum);
++                    int pos = QStyle::sliderPositionFromValue((qint64)slider->minimum, (qint64)slider->maximum,
++                                                              (qint64)v_, (horizontal
++                                                                   ? slider->rect.width()
++                                                                   : slider->rect.height()) - (qint64)len,
++                                                              slider->upsideDown) + len / 2;
++                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
++
++                    if (horizontal) {
++                        if (ticksAbove) {
++                            painter->drawLine(pos, slider->rect.top() + extra,
++                                              pos, slider->rect.top() + tickSize);
++                        }
++                        if (ticksBelow) {
++                            painter->drawLine(pos, slider->rect.bottom() - extra,
++                                              pos, slider->rect.bottom() - tickSize);
++                        }
++                    } else {
++                        if (ticksAbove) {
++                            painter->drawLine(slider->rect.left() + extra, pos,
++                                              slider->rect.left() + tickSize, pos);
++                        }
++                        if (ticksBelow) {
++                            painter->drawLine(slider->rect.right() - extra, pos,
++                                              slider->rect.right() - tickSize, pos);
++                        }
++                    }
++                    // in the case where maximum is max int
++                    int nextInterval = v + interval;
++                    if (nextInterval < v)
++                        break;
++                    v = nextInterval;
++                }
++            }
++            // draw handle
++            if ((option->subControls & QStyle::SC_SliderHandle) ) {
++                QString handlePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_handle"), option, handle.size());
++                if (!QPixmapCache::find(handlePixmapName, cache)) {
++                    cache = styleCachePixmap(handle.size());
++                    cache.fill(Qt::transparent);
++                    QRect pixmapRect(0, 0, handle.width(), handle.height());
++                    QPainter handlePainter(&cache);
++                    QRect gradRect = pixmapRect.adjusted(2, 2, -2, -2);
++
++                    // gradient fill
++                    QRect r = pixmapRect.adjusted(1, 1, -2, -2);
++                    QLinearGradient gradient = qt_fusion_gradient(gradRect, d->buttonColor(option->palette),horizontal ? TopDown : FromLeft);
++
++                    handlePainter.setRenderHint(QPainter::Antialiasing, true);
++                    handlePainter.translate(0.5, 0.5);
++
++                    handlePainter.setPen(Qt::NoPen);
++                    handlePainter.setBrush(QColor(0, 0, 0, 40));
++                    handlePainter.drawRect(r.adjusted(-1, 2, 1, -2));
++
++                    handlePainter.setPen(QPen(d->outline(option->palette)));
++                    if (option->state & QStyle::State_HasFocus && option->state & QStyle::State_KeyboardFocusChange)
++                        handlePainter.setPen(QPen(d->highlightedOutline(option->palette)));
++
++                    handlePainter.setBrush(gradient);
++                    handlePainter.drawRoundedRect(r, 2, 2);
++                    handlePainter.setBrush(Qt::NoBrush);
++                    handlePainter.setPen(d->innerContrastLine());
++                    handlePainter.drawRoundedRect(r.adjusted(1, 1, -1, -1), 2, 2);
++
++                    QColor cornerAlpha = outline.darker(120);
++                    cornerAlpha.setAlpha(80);
++
++                    //handle shadow
++                    handlePainter.setPen(shadowAlpha);
++                    handlePainter.drawLine(QPoint(r.left() + 2, r.bottom() + 1), QPoint(r.right() - 2, r.bottom() + 1));
++                    handlePainter.drawLine(QPoint(r.right() + 1, r.bottom() - 3), QPoint(r.right() + 1, r.top() + 4));
++                    handlePainter.drawLine(QPoint(r.right() - 1, r.bottom()), QPoint(r.right() + 1, r.bottom() - 2));
++
++                    handlePainter.end();
++                    QPixmapCache::insert(handlePixmapName, cache);
++                }
++
++                painter->drawPixmap(handle.topLeft(), cache);
++
++            }
++            painter->setBrush(oldBrush);
++            painter->setPen(oldPen);
++        }
++}
++
++template <class OptionStyle>
++static void subControlRectSlider(QStyle::ComplexControl control,
++                                 const QStyleOptionComplex *option,
++                                 QStyle::SubControl subControl,
++                                 const QWidget *widget,
++                                 QRect &rect,
++                                 const QStyle* proxy)
++{
++        if (const OptionStyle *slider = qstyleoption_cast<const OptionStyle *>(option)) {
++            int tickSize = proxy->pixelMetric(QStyle::PM_SliderTickmarkOffset, option, widget);
++            switch (subControl) {
++            case QStyle::SC_SliderHandle: {
++                if (slider->orientation == Qt::Horizontal) {
++                    rect.setHeight(proxy->pixelMetric(QStyle::PM_SliderThickness));
++                    rect.setWidth(proxy->pixelMetric(QStyle::PM_SliderLength));
++                    int centerY = slider->rect.center().y() - rect.height() / 2;
++                    if (slider->tickPosition & QSlider::TicksAbove)
++                        centerY += tickSize;
++                    if (slider->tickPosition & QSlider::TicksBelow)
++                        centerY -= tickSize;
++                    rect.moveTop(centerY);
++                } else {
++                    rect.setWidth(proxy->pixelMetric(QStyle::PM_SliderThickness));
++                    rect.setHeight(proxy->pixelMetric(QStyle::PM_SliderLength));
++                    int centerX = slider->rect.center().x() - rect.width() / 2;
++                    if (slider->tickPosition & QSlider::TicksAbove)
++                        centerX += tickSize;
++                    if (slider->tickPosition & QSlider::TicksBelow)
++                        centerX -= tickSize;
++                    rect.moveLeft(centerX);
++                }
++            }
++                break;
++            case QStyle::SC_SliderGroove: {
++                QPoint grooveCenter = slider->rect.center();
++                if (slider->orientation == Qt::Horizontal) {
++                    rect.setHeight(7);
++                    if (slider->tickPosition & QSlider::TicksAbove)
++                        grooveCenter.ry() += tickSize;
++                    if (slider->tickPosition & QSlider::TicksBelow)
++                        grooveCenter.ry() -= tickSize;
++                } else {
++                    rect.setWidth(7);
++                    if (slider->tickPosition & QSlider::TicksAbove)
++                        grooveCenter.rx() += tickSize;
++                    if (slider->tickPosition & QSlider::TicksBelow)
++                        grooveCenter.rx() -= tickSize;
++                }
++                rect.moveCenter(grooveCenter);
++                break;
++            }
++            default:
++                break;
++            }
++        }
++}
++
++/*
++    \internal
++*/
++QFusionStylePrivate::QFusionStylePrivate()
++{
++    animationFps = 60;
++}
++
++/*!
++    \class QFusionStyle
++    \brief The QFusionStyle class provides a custom widget style
++
++    \inmodule QtWidgets
++    \internal
++
++    The Fusion style provides a custom look and feel that is not
++    tied to a particular platform.
++    //{Fusion Style Widget Gallery}
++    \sa QWindowsStyle, QWindowsVistaStyle, QMacStyle, QCommonStyle
++*/
++
++/*!
++    Constructs a QFusionStyle object.
++*/
++QFusionStyle::QFusionStyle() : QCommonStyle(*new QFusionStylePrivate)
++{
++    setObjectName(QLatin1String("Fusion"));
++}
++
++/*!
++    \internal
++
++    Constructs a QFusionStyle object.
++*/
++QFusionStyle::QFusionStyle(QFusionStylePrivate &dd) : QCommonStyle(dd)
++{
++}
++
++/*!
++    Destroys the QFusionStyle object.
++*/
++QFusionStyle::~QFusionStyle()
++{
++}
++
++/*!
++    \fn void QFusionStyle::drawItemText(QPainter *painter, const QRect &rectangle, int alignment, const QPalette &palette,
++                                    bool enabled, const QString& text, QPalette::ColorRole textRole) const
++
++    Draws the given \a text in the specified \a rectangle using the
++    provided \a painter and \a palette.
++
++    Text is drawn using the painter's pen. If an explicit \a textRole
++    is specified, then the text is drawn using the \a palette's color
++    for the specified role.  The \a enabled value indicates whether or
++    not the item is enabled; when reimplementing, this value should
++    influence how the item is drawn.
++
++    The text is aligned and wrapped according to the specified \a
++    alignment.
++
++    \sa Qt::Alignment
++*/
++void QFusionStyle::drawItemText(QPainter *painter, const QRect &rect, int alignment, const QPalette &pal,
++                                bool enabled, const QString& text, QPalette::ColorRole textRole) const
++{
++    if (text.isEmpty())
++        return;
++
++    QPen savedPen = painter->pen();
++    if (textRole != QPalette::NoRole) {
++        painter->setPen(QPen(pal.brush(textRole), savedPen.widthF()));
++    }
++    if (!enabled) {
++        QPen pen = painter->pen();
++        painter->setPen(pen);
++    }
++    painter->drawText(rect, alignment, text);
++    painter->setPen(savedPen);
++}
++
++
++/*!
++    \reimp
++*/
++void QFusionStyle::drawPrimitive(PrimitiveElement elem,
++                                 const QStyleOption *option,
++                                 QPainter *painter, const QWidget *widget) const
++{
++    Q_ASSERT(option);
++    Q_D (const QFusionStyle);
++
++    QRect rect = option->rect;
++    int state = option->state;
++
++    QColor outline = d->outline(option->palette);
++    QColor highlightedOutline = d->highlightedOutline(option->palette);
++
++    QColor tabFrameColor = d->tabFrameColor(option->palette);
++
++    switch (elem) {
++
++    // No frame drawn
++    case PE_FrameGroupBox:
++    {
++        QPixmap pixmap(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_groupbox.png"));
++        int topMargin = qMax(pixelMetric(PM_ExclusiveIndicatorHeight), option->fontMetrics.height()) + groupBoxTopMargin;
++        QRect frame = option->rect.adjusted(0, topMargin, 0, 0);
++        qDrawBorderPixmap(painter, frame, QMargins(6, 6, 6, 6), pixmap);
++        break;
++    }
++    case PE_IndicatorBranch: {
++        if (!(option->state & State_Children))
++            break;
++        if (option->state & State_Open)
++            drawPrimitive(PE_IndicatorArrowDown, option, painter, widget);
++        else
++            drawPrimitive(PE_IndicatorArrowRight, option, painter, widget);
++        break;
++    }
++    case PE_FrameTabBarBase:
++        if (const QStyleOptionTabBarBase *tbb
++                = qstyleoption_cast<const QStyleOptionTabBarBase *>(option)) {
++            painter->save();
++            painter->setPen(QPen(outline.lighter(110)));
++            switch (tbb->shape) {
++            case QTabBar::RoundedNorth: {
++                QRegion region(tbb->rect);
++                region -= tbb->selectedTabRect;
++                painter->drawLine(tbb->rect.topLeft(), tbb->rect.topRight());
++                painter->setClipRegion(region);
++                painter->setPen(option->palette.light().color());
++                painter->drawLine(tbb->rect.topLeft() + QPoint(0, 1), tbb->rect.topRight() + QPoint(0, 1));
++            }
++                break;
++            case QTabBar::RoundedWest:
++                painter->drawLine(tbb->rect.left(), tbb->rect.top(), tbb->rect.left(), tbb->rect.bottom());
++                break;
++            case QTabBar::RoundedSouth:
++                painter->drawLine(tbb->rect.left(), tbb->rect.bottom(),
++                                  tbb->rect.right(), tbb->rect.bottom());
++                break;
++            case QTabBar::RoundedEast:
++                painter->drawLine(tbb->rect.topRight(), tbb->rect.bottomRight());
+                 break;
+             case QTabBar::TriangularNorth:
+             case QTabBar::TriangularEast:
+@@ -1920,7 +2514,6 @@ void QFusionStyle::drawComplexControl(Co
+     Q_D (const QFusionStyle);
+ 
+     QColor buttonColor = d->buttonColor(option->palette);
+-    QColor gradientStartColor = buttonColor.lighter(118);
+     QColor gradientStopColor = buttonColor;
+     QColor outline = d->outline(option->palette);
+ 
+@@ -1956,743 +2549,445 @@ void QFusionStyle::drawComplexControl(Co
+                 painter->setPen(QPen(option->palette.windowText(), 1));
+                 int alignment = int(groupBox->textAlignment);
+                 if (!proxy()->styleHint(QStyle::SH_UnderlineShortcut, option, widget))
+-                    alignment |= Qt::TextHideMnemonic;
+-
+-                proxy()->drawItemText(painter, textRect,  Qt::TextShowMnemonic | Qt::AlignLeft | alignment,
+-                                      groupBox->palette, groupBox->state & State_Enabled, groupBox->text, QPalette::NoRole);
+-
+-                if (groupBox->state & State_HasFocus) {
+-                    QStyleOptionFocusRect fropt;
+-                    fropt.QStyleOption::operator=(*groupBox);
+-                    fropt.rect = textRect.adjusted(-2, -1, 2, 1);
+-                    proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
+-                }
+-            }
+-
+-            // Draw checkbox
+-            if (groupBox->subControls & SC_GroupBoxCheckBox) {
+-                QStyleOptionButton box;
+-                box.QStyleOption::operator=(*groupBox);
+-                box.rect = checkBoxRect;
+-                proxy()->drawPrimitive(PE_IndicatorCheckBox, &box, painter, widget);
+-            }
+-        }
+-        painter->restore();
+-        break;
+-    case CC_SpinBox:
+-        if (const QStyleOptionSpinBox *spinBox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
+-            QPixmap cache;
+-            QString pixmapName = QStyleHelper::uniqueName(QLatin1String("spinbox"), spinBox, spinBox->rect.size());
+-            if (!QPixmapCache::find(pixmapName, cache)) {
+-
+-                cache = styleCachePixmap(spinBox->rect.size());
+-                cache.fill(Qt::transparent);
+-
+-                QRect pixmapRect(0, 0, spinBox->rect.width(), spinBox->rect.height());
+-                QRect rect = pixmapRect;
+-                QRect r = rect.adjusted(0, 1, 0, -1);
+-                QPainter cachePainter(&cache);
+-                QColor arrowColor = spinBox->palette.foreground().color();
+-                arrowColor.setAlpha(220);
+-
+-                bool isEnabled = (spinBox->state & State_Enabled);
+-                bool hover = isEnabled && (spinBox->state & State_MouseOver);
+-                bool sunken = (spinBox->state & State_Sunken);
+-                bool upIsActive = (spinBox->activeSubControls == SC_SpinBoxUp);
+-                bool downIsActive = (spinBox->activeSubControls == SC_SpinBoxDown);
+-                bool hasFocus = (option->state & State_HasFocus);
+-
+-                QStyleOptionSpinBox spinBoxCopy = *spinBox;
+-                spinBoxCopy.rect = pixmapRect;
+-                QRect upRect = proxy()->subControlRect(CC_SpinBox, &spinBoxCopy, SC_SpinBoxUp, widget);
+-                QRect downRect = proxy()->subControlRect(CC_SpinBox, &spinBoxCopy, SC_SpinBoxDown, widget);
+-
+-                if (spinBox->frame) {
+-                    cachePainter.save();
+-                    cachePainter.setRenderHint(QPainter::Antialiasing, true);
+-                    cachePainter.translate(0.5, 0.5);
+-
+-                    // Fill background
+-                    cachePainter.setPen(Qt::NoPen);
+-                    cachePainter.setBrush(option->palette.base());
+-                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
+-
+-                    // Draw inner shadow
+-                    cachePainter.setPen(d->topShadow());
+-                    cachePainter.drawLine(QPoint(r.left() + 2, r.top() + 1), QPoint(r.right() - 2, r.top() + 1));
+-
+-                    // Draw button gradient
+-                    QColor buttonColor = d->buttonColor(option->palette);
+-                    QRect updownRect = upRect.adjusted(0, -2, 0, downRect.height() + 2);
+-                    QLinearGradient gradient = qt_fusion_gradient(updownRect, (isEnabled && option->state & State_MouseOver ) ? buttonColor : buttonColor.darker(104));
+-
+-                    // Draw button gradient
+-                    cachePainter.setPen(Qt::NoPen);
+-                    cachePainter.setBrush(gradient);
+-
+-                    cachePainter.save();
+-                    cachePainter.setClipRect(updownRect);
+-                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
+-                    cachePainter.setPen(QPen(d->innerContrastLine()));
+-                    cachePainter.setBrush(Qt::NoBrush);
+-                    cachePainter.drawRoundedRect(r.adjusted(1, 1, -2, -2), 2, 2);
+-                    cachePainter.restore();
+-
+-                    if ((spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) && upIsActive) {
+-                        if (sunken)
+-                            cachePainter.fillRect(upRect.adjusted(0, -1, 0, 0), gradientStopColor.darker(110));
+-                        else if (hover)
+-                            cachePainter.fillRect(upRect.adjusted(0, -1, 0, 0), d->innerContrastLine());
+-                    }
+-
+-                    if ((spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) && downIsActive) {
+-                        if (sunken)
+-                            cachePainter.fillRect(downRect.adjusted(0, 0, 0, 1), gradientStopColor.darker(110));
+-                        else if (hover)
+-                            cachePainter.fillRect(downRect.adjusted(0, 0, 0, 1), d->innerContrastLine());
+-                    }
+-
+-                    cachePainter.setPen(hasFocus ? d->highlightedOutline(option->palette) : outline);
+-                    cachePainter.setBrush(Qt::NoBrush);
+-                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
+-                    if (hasFocus) {
+-                        QColor softHighlight = option->palette.highlight().color();
+-                        softHighlight.setAlpha(40);
+-                        cachePainter.setPen(softHighlight);
+-                        cachePainter.drawRoundedRect(r.adjusted(1, 1, -2, -2), 1.7, 1.7);
+-                    }
+-                    cachePainter.restore();
+-                }
+-
+-                // outline the up/down buttons
+-                cachePainter.setPen(outline);
+-                if (spinBox->direction == Qt::RightToLeft) {
+-                    cachePainter.drawLine(upRect.right(), upRect.top() - 1, upRect.right(), downRect.bottom() + 1);
+-                } else {
+-                    cachePainter.drawLine(upRect.left(), upRect.top() - 1, upRect.left(), downRect.bottom() + 1);
+-                }
+-
+-                if (upIsActive && sunken) {
+-                    cachePainter.setPen(gradientStopColor.darker(130));
+-                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.right(), downRect.top());
+-                    cachePainter.drawLine(upRect.left() + 1, upRect.top(), upRect.left() + 1, upRect.bottom());
+-                    cachePainter.drawLine(upRect.left() + 1, upRect.top() - 1, upRect.right(), upRect.top() - 1);
+-                }
+-
+-                if (downIsActive && sunken) {
+-                    cachePainter.setPen(gradientStopColor.darker(130));
+-                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.left() + 1, downRect.bottom() + 1);
+-                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.right(), downRect.top());
+-                    cachePainter.setPen(gradientStopColor.darker(110));
+-                    cachePainter.drawLine(downRect.left() + 1, downRect.bottom() + 1, downRect.right(), downRect.bottom() + 1);
+-                }
+-
+-                QColor disabledColor = mergedColors(arrowColor, option->palette.button().color());
+-                if (spinBox->buttonSymbols == QAbstractSpinBox::PlusMinus) {
+-                    int centerX = upRect.center().x();
+-                    int centerY = upRect.center().y();
+-
+-                    // plus/minus
+-                    cachePainter.setPen((spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) ? arrowColor : disabledColor);
+-                    cachePainter.drawLine(centerX - 1, centerY, centerX + 3, centerY);
+-                    cachePainter.drawLine(centerX + 1, centerY - 2, centerX + 1, centerY + 2);
+-
+-                    centerX = downRect.center().x();
+-                    centerY = downRect.center().y();
+-                    cachePainter.setPen((spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) ? arrowColor : disabledColor);
+-                    cachePainter.drawLine(centerX - 1, centerY, centerX + 3, centerY);
+-
+-                } else if (spinBox->buttonSymbols == QAbstractSpinBox::UpDownArrows){
+-                    // arrows
+-                    painter->setRenderHint(QPainter::SmoothPixmapTransform);
+-
+-                    QPixmap upArrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"),
+-                                                     (spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) ? arrowColor : disabledColor);
+-
+-                    QRectF upArrowRect = QRectF(upRect.center().x() - upArrow.width() / 4.0 + 1.0,
+-                                                upRect.center().y() - upArrow.height() / 4.0 + 1.0,
+-                                                upArrow.width() / 2.0, upArrow.height() / 2.0);
+-
+-                    cachePainter.drawPixmap(upArrowRect, upArrow, QRectF(QPointF(0.0, 0.0), upArrow.size()));
+-
+-                    QPixmap downArrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"),
+-                                                       (spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) ? arrowColor : disabledColor, 180);
+-                    QRectF downArrowRect = QRectF(downRect.center().x() - downArrow.width() / 4.0 + 1.0,
+-                                                  downRect.center().y() - downArrow.height() / 4.0 + 1.0,
+-                                                  downArrow.width() / 2.0, downArrow.height() / 2.0);
+-                    cachePainter.drawPixmap(downArrowRect, downArrow, QRectF(QPointF(0.0, 0.0), downArrow.size()));
+-                }
+-
+-                cachePainter.end();
+-                QPixmapCache::insert(pixmapName, cache);
+-            }
+-            painter->drawPixmap(spinBox->rect.topLeft(), cache);
+-        }
+-        break;
+-    case CC_TitleBar:
+-        painter->save();
+-        if (const QStyleOptionTitleBar *titleBar = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {
+-            const int buttonMargin = 5;
+-            bool active = (titleBar->titleBarState & State_Active);
+-            QRect fullRect = titleBar->rect;
+-            QPalette palette = option->palette;
+-            QColor highlight = option->palette.highlight().color();
+-
+-            QColor titleBarFrameBorder(active ? highlight.darker(180): outline.darker(110));
+-            QColor titleBarHighlight(active ? highlight.lighter(120): palette.background().color().lighter(120));
+-            QColor textColor(active ? 0xffffff : 0xff000000);
+-            QColor textAlphaColor(active ? 0xffffff : 0xff000000 );
+-
+-            {
+-                // Fill title bar gradient
+-                QColor titlebarColor = QColor(active ? highlight: palette.background().color());
+-                QLinearGradient gradient(option->rect.center().x(), option->rect.top(),
+-                                         option->rect.center().x(), option->rect.bottom());
+-
+-                gradient.setColorAt(0, titlebarColor.lighter(114));
+-                gradient.setColorAt(0.5, titlebarColor.lighter(102));
+-                gradient.setColorAt(0.51, titlebarColor.darker(104));
+-                gradient.setColorAt(1, titlebarColor);
+-                painter->fillRect(option->rect.adjusted(1, 1, -1, 0), gradient);
+-
+-                // Frame and rounded corners
+-                painter->setPen(titleBarFrameBorder);
+-
+-                // top outline
+-                painter->drawLine(fullRect.left() + 5, fullRect.top(), fullRect.right() - 5, fullRect.top());
+-                painter->drawLine(fullRect.left(), fullRect.top() + 4, fullRect.left(), fullRect.bottom());
+-                const QPoint points[5] = {
+-                    QPoint(fullRect.left() + 4, fullRect.top() + 1),
+-                    QPoint(fullRect.left() + 3, fullRect.top() + 1),
+-                    QPoint(fullRect.left() + 2, fullRect.top() + 2),
+-                    QPoint(fullRect.left() + 1, fullRect.top() + 3),
+-                    QPoint(fullRect.left() + 1, fullRect.top() + 4)
+-                };
+-                painter->drawPoints(points, 5);
+-
+-                painter->drawLine(fullRect.right(), fullRect.top() + 4, fullRect.right(), fullRect.bottom());
+-                const QPoint points2[5] = {
+-                    QPoint(fullRect.right() - 3, fullRect.top() + 1),
+-                    QPoint(fullRect.right() - 4, fullRect.top() + 1),
+-                    QPoint(fullRect.right() - 2, fullRect.top() + 2),
+-                    QPoint(fullRect.right() - 1, fullRect.top() + 3),
+-                    QPoint(fullRect.right() - 1, fullRect.top() + 4)
+-                };
+-                painter->drawPoints(points2, 5);
++                    alignment |= Qt::TextHideMnemonic;
+ 
+-                // draw bottomline
+-                painter->drawLine(fullRect.right(), fullRect.bottom(), fullRect.left(), fullRect.bottom());
++                proxy()->drawItemText(painter, textRect,  Qt::TextShowMnemonic | Qt::AlignLeft | alignment,
++                                      groupBox->palette, groupBox->state & State_Enabled, groupBox->text, QPalette::NoRole);
+ 
+-                // top highlight
+-                painter->setPen(titleBarHighlight);
+-                painter->drawLine(fullRect.left() + 6, fullRect.top() + 1, fullRect.right() - 6, fullRect.top() + 1);
+-            }
+-            // draw title
+-            QRect textRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarLabel, widget);
+-            painter->setPen(active? (titleBar->palette.text().color().lighter(120)) :
+-                                    titleBar->palette.text().color() );
+-            // Note workspace also does elliding but it does not use the correct font
+-            QString title = painter->fontMetrics().elidedText(titleBar->text, Qt::ElideRight, textRect.width() - 14);
+-            painter->drawText(textRect.adjusted(1, 1, 1, 1), title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
+-            painter->setPen(Qt::white);
+-            if (active)
+-                painter->drawText(textRect, title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
+-            // min button
+-            if ((titleBar->subControls & SC_TitleBarMinButton) && (titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
+-                    !(titleBar->titleBarState& Qt::WindowMinimized)) {
+-                QRect minButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMinButton, widget);
+-                if (minButtonRect.isValid()) {
+-                    bool hover = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_MouseOver);
+-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_Sunken);
+-                    qt_fusion_draw_mdibutton(painter, titleBar, minButtonRect, hover, sunken);
+-                    QRect minButtonIconRect = minButtonRect.adjusted(buttonMargin ,buttonMargin , -buttonMargin, -buttonMargin);
+-                    painter->setPen(textColor);
+-                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 3,
+-                                      minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 3);
+-                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 4,
+-                                      minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 4);
+-                    painter->setPen(textAlphaColor);
+-                    painter->drawLine(minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 3,
+-                                      minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 4);
+-                    painter->drawLine(minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 3,
+-                                      minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 4);
++                if (groupBox->state & State_HasFocus) {
++                    QStyleOptionFocusRect fropt;
++                    fropt.QStyleOption::operator=(*groupBox);
++                    fropt.rect = textRect.adjusted(-2, -1, 2, 1);
++                    proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
+                 }
+             }
+-            // max button
+-            if ((titleBar->subControls & SC_TitleBarMaxButton) && (titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
+-                    !(titleBar->titleBarState & Qt::WindowMaximized)) {
+-                QRect maxButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMaxButton, widget);
+-                if (maxButtonRect.isValid()) {
+-                    bool hover = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_MouseOver);
+-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_Sunken);
+-                    qt_fusion_draw_mdibutton(painter, titleBar, maxButtonRect, hover, sunken);
+-
+-                    QRect maxButtonIconRect = maxButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+ 
+-                    painter->setPen(textColor);
+-                    painter->drawRect(maxButtonIconRect.adjusted(0, 0, -1, -1));
+-                    painter->drawLine(maxButtonIconRect.left() + 1, maxButtonIconRect.top() + 1,
+-                                      maxButtonIconRect.right() - 1, maxButtonIconRect.top() + 1);
+-                    painter->setPen(textAlphaColor);
+-                    const QPoint points[4] = {
+-                        maxButtonIconRect.topLeft(),
+-                        maxButtonIconRect.topRight(),
+-                        maxButtonIconRect.bottomLeft(),
+-                        maxButtonIconRect.bottomRight()
+-                    };
+-                    painter->drawPoints(points, 4);
+-                }
++            // Draw checkbox
++            if (groupBox->subControls & SC_GroupBoxCheckBox) {
++                QStyleOptionButton box;
++                box.QStyleOption::operator=(*groupBox);
++                box.rect = checkBoxRect;
++                proxy()->drawPrimitive(PE_IndicatorCheckBox, &box, painter, widget);
+             }
++        }
++        painter->restore();
++        break;
++    case CC_SpinBox:
++        if (const QStyleOptionSpinBox *spinBox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
++            QPixmap cache;
++            QString pixmapName = QStyleHelper::uniqueName(QLatin1String("spinbox"), spinBox, spinBox->rect.size());
++            if (!QPixmapCache::find(pixmapName, cache)) {
+ 
+-            // close button
+-            if ((titleBar->subControls & SC_TitleBarCloseButton) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
+-                QRect closeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarCloseButton, widget);
+-                if (closeButtonRect.isValid()) {
+-                    bool hover = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_MouseOver);
+-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_Sunken);
+-                    qt_fusion_draw_mdibutton(painter, titleBar, closeButtonRect, hover, sunken);
+-                    QRect closeIconRect = closeButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+-                    painter->setPen(textAlphaColor);
+-                    const QLine lines[4] = {
+-                        QLine(closeIconRect.left() + 1, closeIconRect.top(),
+-                        closeIconRect.right(), closeIconRect.bottom() - 1),
+-                        QLine(closeIconRect.left(), closeIconRect.top() + 1,
+-                        closeIconRect.right() - 1, closeIconRect.bottom()),
+-                        QLine(closeIconRect.right() - 1, closeIconRect.top(),
+-                        closeIconRect.left(), closeIconRect.bottom() - 1),
+-                        QLine(closeIconRect.right(), closeIconRect.top() + 1,
+-                        closeIconRect.left() + 1, closeIconRect.bottom())
+-                    };
+-                    painter->drawLines(lines, 4);
+-                    const QPoint points[4] = {
+-                        closeIconRect.topLeft(),
+-                        closeIconRect.topRight(),
+-                        closeIconRect.bottomLeft(),
+-                        closeIconRect.bottomRight()
+-                    };
+-                    painter->drawPoints(points, 4);
++                cache = styleCachePixmap(spinBox->rect.size());
++                cache.fill(Qt::transparent);
+ 
+-                    painter->setPen(textColor);
+-                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.top() + 1,
+-                                      closeIconRect.right() - 1, closeIconRect.bottom() - 1);
+-                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.bottom() - 1,
+-                                      closeIconRect.right() - 1, closeIconRect.top() + 1);
+-                }
+-            }
++                QRect pixmapRect(0, 0, spinBox->rect.width(), spinBox->rect.height());
++                QRect rect = pixmapRect;
++                QRect r = rect.adjusted(0, 1, 0, -1);
++                QPainter cachePainter(&cache);
++                QColor arrowColor = spinBox->palette.foreground().color();
++                arrowColor.setAlpha(220);
+ 
+-            // normalize button
+-            if ((titleBar->subControls & SC_TitleBarNormalButton) &&
+-                    (((titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
+-                      (titleBar->titleBarState & Qt::WindowMinimized)) ||
+-                     ((titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
+-                      (titleBar->titleBarState & Qt::WindowMaximized)))) {
+-                QRect normalButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarNormalButton, widget);
+-                if (normalButtonRect.isValid()) {
++                bool isEnabled = (spinBox->state & State_Enabled);
++                bool hover = isEnabled && (spinBox->state & State_MouseOver);
++                bool sunken = (spinBox->state & State_Sunken);
++                bool upIsActive = (spinBox->activeSubControls == SC_SpinBoxUp);
++                bool downIsActive = (spinBox->activeSubControls == SC_SpinBoxDown);
++                bool hasFocus = (option->state & State_HasFocus);
+ 
+-                    bool hover = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_MouseOver);
+-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_Sunken);
+-                    QRect normalButtonIconRect = normalButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+-                    qt_fusion_draw_mdibutton(painter, titleBar, normalButtonRect, hover, sunken);
++                QStyleOptionSpinBox spinBoxCopy = *spinBox;
++                spinBoxCopy.rect = pixmapRect;
++                QRect upRect = proxy()->subControlRect(CC_SpinBox, &spinBoxCopy, SC_SpinBoxUp, widget);
++                QRect downRect = proxy()->subControlRect(CC_SpinBox, &spinBoxCopy, SC_SpinBoxDown, widget);
+ 
+-                    QRect frontWindowRect = normalButtonIconRect.adjusted(0, 3, -3, 0);
+-                    painter->setPen(textColor);
+-                    painter->drawRect(frontWindowRect.adjusted(0, 0, -1, -1));
+-                    painter->drawLine(frontWindowRect.left() + 1, frontWindowRect.top() + 1,
+-                                      frontWindowRect.right() - 1, frontWindowRect.top() + 1);
+-                    painter->setPen(textAlphaColor);
+-                    const QPoint points[4] = {
+-                        frontWindowRect.topLeft(),
+-                        frontWindowRect.topRight(),
+-                        frontWindowRect.bottomLeft(),
+-                        frontWindowRect.bottomRight()
+-                    };
+-                    painter->drawPoints(points, 4);
++                if (spinBox->frame) {
++                    cachePainter.save();
++                    cachePainter.setRenderHint(QPainter::Antialiasing, true);
++                    cachePainter.translate(0.5, 0.5);
+ 
+-                    QRect backWindowRect = normalButtonIconRect.adjusted(3, 0, 0, -3);
+-                    QRegion clipRegion = backWindowRect;
+-                    clipRegion -= frontWindowRect;
+-                    painter->save();
+-                    painter->setClipRegion(clipRegion);
+-                    painter->setPen(textColor);
+-                    painter->drawRect(backWindowRect.adjusted(0, 0, -1, -1));
+-                    painter->drawLine(backWindowRect.left() + 1, backWindowRect.top() + 1,
+-                                      backWindowRect.right() - 1, backWindowRect.top() + 1);
+-                    painter->setPen(textAlphaColor);
+-                    const QPoint points2[4] = {
+-                        backWindowRect.topLeft(),
+-                        backWindowRect.topRight(),
+-                        backWindowRect.bottomLeft(),
+-                        backWindowRect.bottomRight()
+-                    };
+-                    painter->drawPoints(points2, 4);
+-                    painter->restore();
+-                }
+-            }
++                    // Fill background
++                    cachePainter.setPen(Qt::NoPen);
++                    cachePainter.setBrush(option->palette.base());
++                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
+ 
+-            // context help button
+-            if (titleBar->subControls & SC_TitleBarContextHelpButton
+-                    && (titleBar->titleBarFlags & Qt::WindowContextHelpButtonHint)) {
+-                QRect contextHelpButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarContextHelpButton, widget);
+-                if (contextHelpButtonRect.isValid()) {
+-                    bool hover = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_MouseOver);
+-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_Sunken);
+-                    qt_fusion_draw_mdibutton(painter, titleBar, contextHelpButtonRect, hover, sunken);
+-                    QImage image(qt_titlebar_context_help);
+-                    QColor alpha = textColor;
+-                    alpha.setAlpha(128);
+-                    image.setColor(1, textColor.rgba());
+-                    image.setColor(2, alpha.rgba());
+-                    painter->setRenderHint(QPainter::SmoothPixmapTransform);
+-                    painter->drawImage(contextHelpButtonRect.adjusted(4, 4, -4, -4), image);
++                    // Draw inner shadow
++                    cachePainter.setPen(d->topShadow());
++                    cachePainter.drawLine(QPoint(r.left() + 2, r.top() + 1), QPoint(r.right() - 2, r.top() + 1));
++
++                    // Draw button gradient
++                    QColor buttonColor = d->buttonColor(option->palette);
++                    QRect updownRect = upRect.adjusted(0, -2, 0, downRect.height() + 2);
++                    QLinearGradient gradient = qt_fusion_gradient(updownRect, (isEnabled && option->state & State_MouseOver ) ? buttonColor : buttonColor.darker(104));
++
++                    // Draw button gradient
++                    cachePainter.setPen(Qt::NoPen);
++                    cachePainter.setBrush(gradient);
++
++                    cachePainter.save();
++                    cachePainter.setClipRect(updownRect);
++                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
++                    cachePainter.setPen(QPen(d->innerContrastLine()));
++                    cachePainter.setBrush(Qt::NoBrush);
++                    cachePainter.drawRoundedRect(r.adjusted(1, 1, -2, -2), 2, 2);
++                    cachePainter.restore();
++
++                    if ((spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) && upIsActive) {
++                        if (sunken)
++                            cachePainter.fillRect(upRect.adjusted(0, -1, 0, 0), gradientStopColor.darker(110));
++                        else if (hover)
++                            cachePainter.fillRect(upRect.adjusted(0, -1, 0, 0), d->innerContrastLine());
++                    }
++
++                    if ((spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) && downIsActive) {
++                        if (sunken)
++                            cachePainter.fillRect(downRect.adjusted(0, 0, 0, 1), gradientStopColor.darker(110));
++                        else if (hover)
++                            cachePainter.fillRect(downRect.adjusted(0, 0, 0, 1), d->innerContrastLine());
++                    }
++
++                    cachePainter.setPen(hasFocus ? d->highlightedOutline(option->palette) : outline);
++                    cachePainter.setBrush(Qt::NoBrush);
++                    cachePainter.drawRoundedRect(r.adjusted(0, 0, -1, -1), 2, 2);
++                    if (hasFocus) {
++                        QColor softHighlight = option->palette.highlight().color();
++                        softHighlight.setAlpha(40);
++                        cachePainter.setPen(softHighlight);
++                        cachePainter.drawRoundedRect(r.adjusted(1, 1, -2, -2), 1.7, 1.7);
++                    }
++                    cachePainter.restore();
+                 }
+-            }
+ 
+-            // shade button
+-            if (titleBar->subControls & SC_TitleBarShadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
+-                QRect shadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarShadeButton, widget);
+-                if (shadeButtonRect.isValid()) {
+-                    bool hover = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_MouseOver);
+-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_Sunken);
+-                    qt_fusion_draw_mdibutton(painter, titleBar, shadeButtonRect, hover, sunken);
+-                    QPixmap arrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), textColor);
+-                    painter->drawPixmap(shadeButtonRect.adjusted(5, 7, -5, -7), arrow);
++                // outline the up/down buttons
++                cachePainter.setPen(outline);
++                if (spinBox->direction == Qt::RightToLeft) {
++                    cachePainter.drawLine(upRect.right(), upRect.top() - 1, upRect.right(), downRect.bottom() + 1);
++                } else {
++                    cachePainter.drawLine(upRect.left(), upRect.top() - 1, upRect.left(), downRect.bottom() + 1);
+                 }
+-            }
+ 
+-            // unshade button
+-            if (titleBar->subControls & SC_TitleBarUnshadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
+-                QRect unshadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarUnshadeButton, widget);
+-                if (unshadeButtonRect.isValid()) {
+-                    bool hover = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_MouseOver);
+-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_Sunken);
+-                    qt_fusion_draw_mdibutton(painter, titleBar, unshadeButtonRect, hover, sunken);
+-                    QPixmap arrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), textColor, 180);
+-                    painter->drawPixmap(unshadeButtonRect.adjusted(5, 7, -5, -7), arrow);
++                if (upIsActive && sunken) {
++                    cachePainter.setPen(gradientStopColor.darker(130));
++                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.right(), downRect.top());
++                    cachePainter.drawLine(upRect.left() + 1, upRect.top(), upRect.left() + 1, upRect.bottom());
++                    cachePainter.drawLine(upRect.left() + 1, upRect.top() - 1, upRect.right(), upRect.top() - 1);
+                 }
+-            }
+ 
+-            if ((titleBar->subControls & SC_TitleBarSysMenu) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
+-                QRect iconRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarSysMenu, widget);
+-                if (iconRect.isValid()) {
+-                    if (!titleBar->icon.isNull()) {
+-                        titleBar->icon.paint(painter, iconRect);
+-                    } else {
+-                        QStyleOption tool(0);
+-                        tool.palette = titleBar->palette;
+-                        QPixmap pm = standardIcon(SP_TitleBarMenuButton, &tool, widget).pixmap(16, 16);
+-                        tool.rect = iconRect;
+-                        painter->save();
+-                        proxy()->drawItemPixmap(painter, iconRect, Qt::AlignCenter, pm);
+-                        painter->restore();
+-                    }
++                if (downIsActive && sunken) {
++                    cachePainter.setPen(gradientStopColor.darker(130));
++                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.left() + 1, downRect.bottom() + 1);
++                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.right(), downRect.top());
++                    cachePainter.setPen(gradientStopColor.darker(110));
++                    cachePainter.drawLine(downRect.left() + 1, downRect.bottom() + 1, downRect.right(), downRect.bottom() + 1);
+                 }
+-            }
+-        }
+-        painter->restore();
+-        break;
+-    case CC_ScrollBar:
+-        painter->save();
+-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+-            bool wasActive = false;
+-            qreal expandScale = 1.0;
+-            qreal expandOffset = -1.0;
+-            QObject *styleObject = option->styleObject;
+-            if (styleObject && proxy()->styleHint(SH_ScrollBar_Transient, option, widget)) {
+-                qreal opacity = 0.0;
+-                bool shouldExpand = false;
+-                const qreal maxExpandScale = 13.0 / 9.0;
+ 
+-                int oldPos = styleObject->property("_q_stylepos").toInt();
+-                int oldMin = styleObject->property("_q_stylemin").toInt();
+-                int oldMax = styleObject->property("_q_stylemax").toInt();
+-                QRect oldRect = styleObject->property("_q_stylerect").toRect();
+-                int oldState = styleObject->property("_q_stylestate").toInt();
+-                uint oldActiveControls = styleObject->property("_q_stylecontrols").toUInt();
++                QColor disabledColor = mergedColors(arrowColor, option->palette.button().color());
++                if (spinBox->buttonSymbols == QAbstractSpinBox::PlusMinus) {
++                    int centerX = upRect.center().x();
++                    int centerY = upRect.center().y();
+ 
+-                // a scrollbar is transient when the the scrollbar itself and
+-                // its sibling are both inactive (ie. not pressed/hovered/moved)
+-                bool transient = !option->activeSubControls && !(option->state & State_On);
++                    // plus/minus
++                    cachePainter.setPen((spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) ? arrowColor : disabledColor);
++                    cachePainter.drawLine(centerX - 1, centerY, centerX + 3, centerY);
++                    cachePainter.drawLine(centerX + 1, centerY - 2, centerX + 1, centerY + 2);
+ 
+-                if (!transient ||
+-                        oldPos != scrollBar->sliderPosition ||
+-                        oldMin != scrollBar->minimum ||
+-                        oldMax != scrollBar->maximum ||
+-                        oldRect != scrollBar->rect ||
+-                        oldState != scrollBar->state ||
+-                        oldActiveControls != scrollBar->activeSubControls) {
++                    centerX = downRect.center().x();
++                    centerY = downRect.center().y();
++                    cachePainter.setPen((spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) ? arrowColor : disabledColor);
++                    cachePainter.drawLine(centerX - 1, centerY, centerX + 3, centerY);
+ 
+-                    // if the scrollbar is transient or its attributes, geometry or
+-                    // state has changed, the opacity is reset back to 100% opaque
+-                    opacity = 1.0;
++                } else if (spinBox->buttonSymbols == QAbstractSpinBox::UpDownArrows){
++                    // arrows
++                    painter->setRenderHint(QPainter::SmoothPixmapTransform);
+ 
+-                    styleObject->setProperty("_q_stylepos", scrollBar->sliderPosition);
+-                    styleObject->setProperty("_q_stylemin", scrollBar->minimum);
+-                    styleObject->setProperty("_q_stylemax", scrollBar->maximum);
+-                    styleObject->setProperty("_q_stylerect", scrollBar->rect);
+-                    styleObject->setProperty("_q_stylestate", static_cast<int>(scrollBar->state));
+-                    styleObject->setProperty("_q_stylecontrols", static_cast<uint>(scrollBar->activeSubControls));
++                    QPixmap upArrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"),
++                                                     (spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled) ? arrowColor : disabledColor);
+ 
+-                    QScrollbarStyleAnimation *anim  = qobject_cast<QScrollbarStyleAnimation *>(d->animation(styleObject));
+-                    if (transient) {
+-                        if (!anim) {
+-                            anim = new QScrollbarStyleAnimation(QScrollbarStyleAnimation::Deactivating, styleObject);
+-                            d->startAnimation(anim);
+-                        } else if (anim->mode() == QScrollbarStyleAnimation::Deactivating) {
+-                            // the scrollbar was already fading out while the
+-                            // state changed -> restart the fade out animation
+-                            anim->setCurrentTime(0);
+-                        }
+-                    } else if (anim && anim->mode() == QScrollbarStyleAnimation::Deactivating) {
+-                        d->stopAnimation(styleObject);
+-                    }
+-                }
++                    QRectF upArrowRect = QRectF(upRect.center().x() - upArrow.width() / 4.0 + 1.0,
++                                                upRect.center().y() - upArrow.height() / 4.0 + 1.0,
++                                                upArrow.width() / 2.0, upArrow.height() / 2.0);
+ 
+-                QScrollbarStyleAnimation *anim = qobject_cast<QScrollbarStyleAnimation *>(d->animation(styleObject));
+-                if (anim && anim->mode() == QScrollbarStyleAnimation::Deactivating) {
+-                    // once a scrollbar was active (hovered/pressed), it retains
+-                    // the active look even if it's no longer active while fading out
+-                    if (oldActiveControls)
+-                        anim->setActive(true);
++                    cachePainter.drawPixmap(upArrowRect, upArrow, QRectF(QPointF(0.0, 0.0), upArrow.size()));
+ 
+-                    wasActive = anim->wasActive();
+-                    opacity = anim->currentValue();
++                    QPixmap downArrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"),
++                                                       (spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled) ? arrowColor : disabledColor, 180);
++                    QRectF downArrowRect = QRectF(downRect.center().x() - downArrow.width() / 4.0 + 1.0,
++                                                  downRect.center().y() - downArrow.height() / 4.0 + 1.0,
++                                                  downArrow.width() / 2.0, downArrow.height() / 2.0);
++                    cachePainter.drawPixmap(downArrowRect, downArrow, QRectF(QPointF(0.0, 0.0), downArrow.size()));
+                 }
+ 
+-                shouldExpand = (option->activeSubControls || wasActive);
+-                if (shouldExpand) {
+-                    if (!anim && !oldActiveControls) {
+-                        // Start expand animation only once and when entering
+-                        anim = new QScrollbarStyleAnimation(QScrollbarStyleAnimation::Activating, styleObject);
+-                        d->startAnimation(anim);
+-                    }
+-                    if (anim && anim->mode() == QScrollbarStyleAnimation::Activating) {
+-                        expandScale = 1.0 + (maxExpandScale - 1.0) * anim->currentValue();
+-                        expandOffset = 5.5 * anim->currentValue() - 1;
+-                    } else {
+-                        // Keep expanded state after the animation ends, and when fading out
+-                        expandScale = maxExpandScale;
+-                        expandOffset = 4.5;
+-                    }
+-                }
+-                painter->setOpacity(opacity);
++                cachePainter.end();
++                QPixmapCache::insert(pixmapName, cache);
+             }
++            painter->drawPixmap(spinBox->rect.topLeft(), cache);
++        }
++        break;
++    case CC_TitleBar:
++        painter->save();
++        if (const QStyleOptionTitleBar *titleBar = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {
++            const int buttonMargin = 5;
++            bool active = (titleBar->titleBarState & State_Active);
++            QRect fullRect = titleBar->rect;
++            QPalette palette = option->palette;
++            QColor highlight = option->palette.highlight().color();
+ 
+-            bool transient = proxy()->styleHint(SH_ScrollBar_Transient, option, widget);
+-            bool horizontal = scrollBar->orientation == Qt::Horizontal;
+-            bool sunken = scrollBar->state & State_Sunken;
++            QColor titleBarFrameBorder(active ? highlight.darker(180): outline.darker(110));
++            QColor titleBarHighlight(active ? highlight.lighter(120): palette.background().color().lighter(120));
++            QColor textColor(active ? 0xffffff : 0xff000000);
++            QColor textAlphaColor(active ? 0xffffff : 0xff000000 );
+ 
+-            QRect scrollBarSubLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSubLine, widget);
+-            QRect scrollBarAddLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarAddLine, widget);
+-            QRect scrollBarSlider = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSlider, widget);
+-            QRect scrollBarGroove = proxy()->subControlRect(control, scrollBar, SC_ScrollBarGroove, widget);
++            {
++                // Fill title bar gradient
++                QColor titlebarColor = QColor(active ? highlight: palette.background().color());
++                QLinearGradient gradient(option->rect.center().x(), option->rect.top(),
++                                         option->rect.center().x(), option->rect.bottom());
+ 
+-            QRect rect = option->rect;
+-            QColor alphaOutline = outline;
+-            alphaOutline.setAlpha(180);
++                gradient.setColorAt(0, titlebarColor.lighter(114));
++                gradient.setColorAt(0.5, titlebarColor.lighter(102));
++                gradient.setColorAt(0.51, titlebarColor.darker(104));
++                gradient.setColorAt(1, titlebarColor);
++                painter->fillRect(option->rect.adjusted(1, 1, -1, 0), gradient);
+ 
+-            QColor arrowColor = option->palette.foreground().color();
+-            arrowColor.setAlpha(220);
++                // Frame and rounded corners
++                painter->setPen(titleBarFrameBorder);
+ 
+-            const QColor bgColor = QStyleHelper::backgroundColor(option->palette, widget);
+-            const bool isDarkBg = bgColor.red() < 128 && bgColor.green() < 128 && bgColor.blue() < 128;
++                // top outline
++                painter->drawLine(fullRect.left() + 5, fullRect.top(), fullRect.right() - 5, fullRect.top());
++                painter->drawLine(fullRect.left(), fullRect.top() + 4, fullRect.left(), fullRect.bottom());
++                const QPoint points[5] = {
++                    QPoint(fullRect.left() + 4, fullRect.top() + 1),
++                    QPoint(fullRect.left() + 3, fullRect.top() + 1),
++                    QPoint(fullRect.left() + 2, fullRect.top() + 2),
++                    QPoint(fullRect.left() + 1, fullRect.top() + 3),
++                    QPoint(fullRect.left() + 1, fullRect.top() + 4)
++                };
++                painter->drawPoints(points, 5);
+ 
+-            if (transient) {
+-                if (horizontal) {
+-                    rect.setY(rect.y() + 4.5 - expandOffset);
+-                    scrollBarSlider.setY(scrollBarSlider.y() + 4.5 - expandOffset);
+-                    scrollBarGroove.setY(scrollBarGroove.y() + 4.5 - expandOffset);
++                painter->drawLine(fullRect.right(), fullRect.top() + 4, fullRect.right(), fullRect.bottom());
++                const QPoint points2[5] = {
++                    QPoint(fullRect.right() - 3, fullRect.top() + 1),
++                    QPoint(fullRect.right() - 4, fullRect.top() + 1),
++                    QPoint(fullRect.right() - 2, fullRect.top() + 2),
++                    QPoint(fullRect.right() - 1, fullRect.top() + 3),
++                    QPoint(fullRect.right() - 1, fullRect.top() + 4)
++                };
++                painter->drawPoints(points2, 5);
+ 
+-                    rect.setHeight(rect.height() * expandScale);
+-                    scrollBarGroove.setHeight(scrollBarGroove.height() * expandScale);
+-                } else {
+-                    rect.setX(rect.x() + 4.5 - expandOffset);
+-                    scrollBarSlider.setX(scrollBarSlider.x() + 4.5 - expandOffset);
+-                    scrollBarGroove.setX(scrollBarGroove.x() + 4.5 - expandOffset);
++                // draw bottomline
++                painter->drawLine(fullRect.right(), fullRect.bottom(), fullRect.left(), fullRect.bottom());
+ 
+-                    rect.setWidth(rect.width() * expandScale);
+-                    scrollBarGroove.setWidth(scrollBarGroove.width() * expandScale);
+-                }
++                // top highlight
++                painter->setPen(titleBarHighlight);
++                painter->drawLine(fullRect.left() + 6, fullRect.top() + 1, fullRect.right() - 6, fullRect.top() + 1);
+             }
+-
+-            // Paint groove
+-            if ((!transient || scrollBar->activeSubControls || wasActive) && scrollBar->subControls & SC_ScrollBarGroove) {
+-                QLinearGradient gradient(rect.center().x(), rect.top(),
+-                                         rect.center().x(), rect.bottom());
+-                if (!horizontal)
+-                    gradient = QLinearGradient(rect.left(), rect.center().y(),
+-                                               rect.right(), rect.center().y());
+-                if (!transient || !isDarkBg) {
+-                    gradient.setColorAt(0, buttonColor.darker(107));
+-                    gradient.setColorAt(0.1, buttonColor.darker(105));
+-                    gradient.setColorAt(0.9, buttonColor.darker(105));
+-                    gradient.setColorAt(1, buttonColor.darker(107));
+-                } else {
+-                    gradient.setColorAt(0, bgColor.lighter(157));
+-                    gradient.setColorAt(0.1, bgColor.lighter(155));
+-                    gradient.setColorAt(0.9, bgColor.lighter(155));
+-                    gradient.setColorAt(1, bgColor.lighter(157));
++            // draw title
++            QRect textRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarLabel, widget);
++            painter->setPen(active? (titleBar->palette.text().color().lighter(120)) :
++                                    titleBar->palette.text().color() );
++            // Note workspace also does elliding but it does not use the correct font
++            QString title = painter->fontMetrics().elidedText(titleBar->text, Qt::ElideRight, textRect.width() - 14);
++            painter->drawText(textRect.adjusted(1, 1, 1, 1), title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
++            painter->setPen(Qt::white);
++            if (active)
++                painter->drawText(textRect, title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
++            // min button
++            if ((titleBar->subControls & SC_TitleBarMinButton) && (titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
++                    !(titleBar->titleBarState& Qt::WindowMinimized)) {
++                QRect minButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMinButton, widget);
++                if (minButtonRect.isValid()) {
++                    bool hover = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_MouseOver);
++                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_Sunken);
++                    qt_fusion_draw_mdibutton(painter, titleBar, minButtonRect, hover, sunken);
++                    QRect minButtonIconRect = minButtonRect.adjusted(buttonMargin ,buttonMargin , -buttonMargin, -buttonMargin);
++                    painter->setPen(textColor);
++                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 3,
++                                      minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 3);
++                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 4,
++                                      minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 4);
++                    painter->setPen(textAlphaColor);
++                    painter->drawLine(minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 3,
++                                      minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 4);
++                    painter->drawLine(minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 3,
++                                      minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 4);
+                 }
++            }
++            // max button
++            if ((titleBar->subControls & SC_TitleBarMaxButton) && (titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
++                    !(titleBar->titleBarState & Qt::WindowMaximized)) {
++                QRect maxButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMaxButton, widget);
++                if (maxButtonRect.isValid()) {
++                    bool hover = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_MouseOver);
++                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_Sunken);
++                    qt_fusion_draw_mdibutton(painter, titleBar, maxButtonRect, hover, sunken);
+ 
+-                painter->save();
+-                if (transient)
+-                    painter->setOpacity(0.8);
+-                painter->fillRect(rect, gradient);
+-                painter->setPen(Qt::NoPen);
+-                if (transient)
+-                    painter->setOpacity(0.4);
+-                painter->setPen(alphaOutline);
+-                if (horizontal)
+-                    painter->drawLine(rect.topLeft(), rect.topRight());
+-                else
+-                    painter->drawLine(rect.topLeft(), rect.bottomLeft());
++                    QRect maxButtonIconRect = maxButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
+ 
+-                QColor subtleEdge = alphaOutline;
+-                subtleEdge.setAlpha(40);
+-                painter->setPen(Qt::NoPen);
+-                painter->setBrush(Qt::NoBrush);
+-                painter->setClipRect(scrollBarGroove.adjusted(1, 0, -1, -3));
+-                painter->drawRect(scrollBarGroove.adjusted(1, 0, -1, -1));
+-                painter->restore();
++                    painter->setPen(textColor);
++                    painter->drawRect(maxButtonIconRect.adjusted(0, 0, -1, -1));
++                    painter->drawLine(maxButtonIconRect.left() + 1, maxButtonIconRect.top() + 1,
++                                      maxButtonIconRect.right() - 1, maxButtonIconRect.top() + 1);
++                    painter->setPen(textAlphaColor);
++                    const QPoint points[4] = {
++                        maxButtonIconRect.topLeft(),
++                        maxButtonIconRect.topRight(),
++                        maxButtonIconRect.bottomLeft(),
++                        maxButtonIconRect.bottomRight()
++                    };
++                    painter->drawPoints(points, 4);
++                }
+             }
+ 
+-            QRect pixmapRect = scrollBarSlider;
+-            QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
+-                                     pixmapRect.center().x(), pixmapRect.bottom());
+-            if (!horizontal)
+-                gradient = QLinearGradient(pixmapRect.left(), pixmapRect.center().y(),
+-                                           pixmapRect.right(), pixmapRect.center().y());
++            // close button
++            if ((titleBar->subControls & SC_TitleBarCloseButton) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
++                QRect closeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarCloseButton, widget);
++                if (closeButtonRect.isValid()) {
++                    bool hover = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_MouseOver);
++                    bool sunken = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_Sunken);
++                    qt_fusion_draw_mdibutton(painter, titleBar, closeButtonRect, hover, sunken);
++                    QRect closeIconRect = closeButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
++                    painter->setPen(textAlphaColor);
++                    const QLine lines[4] = {
++                        QLine(closeIconRect.left() + 1, closeIconRect.top(),
++                        closeIconRect.right(), closeIconRect.bottom() - 1),
++                        QLine(closeIconRect.left(), closeIconRect.top() + 1,
++                        closeIconRect.right() - 1, closeIconRect.bottom()),
++                        QLine(closeIconRect.right() - 1, closeIconRect.top(),
++                        closeIconRect.left(), closeIconRect.bottom() - 1),
++                        QLine(closeIconRect.right(), closeIconRect.top() + 1,
++                        closeIconRect.left() + 1, closeIconRect.bottom())
++                    };
++                    painter->drawLines(lines, 4);
++                    const QPoint points[4] = {
++                        closeIconRect.topLeft(),
++                        closeIconRect.topRight(),
++                        closeIconRect.bottomLeft(),
++                        closeIconRect.bottomRight()
++                    };
++                    painter->drawPoints(points, 4);
+ 
+-            QLinearGradient highlightedGradient = gradient;
++                    painter->setPen(textColor);
++                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.top() + 1,
++                                      closeIconRect.right() - 1, closeIconRect.bottom() - 1);
++                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.bottom() - 1,
++                                      closeIconRect.right() - 1, closeIconRect.top() + 1);
++                }
++            }
+ 
+-            QColor midColor2 = mergedColors(gradientStartColor, gradientStopColor, 40);
+-            gradient.setColorAt(0, d->buttonColor(option->palette).lighter(108));
+-            gradient.setColorAt(1, d->buttonColor(option->palette));
++            // normalize button
++            if ((titleBar->subControls & SC_TitleBarNormalButton) &&
++                    (((titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
++                      (titleBar->titleBarState & Qt::WindowMinimized)) ||
++                     ((titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
++                      (titleBar->titleBarState & Qt::WindowMaximized)))) {
++                QRect normalButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarNormalButton, widget);
++                if (normalButtonRect.isValid()) {
+ 
+-            highlightedGradient.setColorAt(0, gradientStartColor.darker(102));
+-            highlightedGradient.setColorAt(1, gradientStopColor.lighter(102));
++                    bool hover = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_MouseOver);
++                    bool sunken = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_Sunken);
++                    QRect normalButtonIconRect = normalButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
++                    qt_fusion_draw_mdibutton(painter, titleBar, normalButtonRect, hover, sunken);
+ 
+-            // Paint slider
+-            if (scrollBar->subControls & SC_ScrollBarSlider) {
+-                if (transient) {
+-                    QRect rect = scrollBarSlider.adjusted(horizontal ? 1 : 2, horizontal ? 2 : 1, -1, -1);
+-                    painter->setPen(Qt::NoPen);
+-                    painter->setBrush(isDarkBg ? d->lightShade() : d->darkShade());
+-                    int r = qMin(rect.width(), rect.height()) / 2;
++                    QRect frontWindowRect = normalButtonIconRect.adjusted(0, 3, -3, 0);
++                    painter->setPen(textColor);
++                    painter->drawRect(frontWindowRect.adjusted(0, 0, -1, -1));
++                    painter->drawLine(frontWindowRect.left() + 1, frontWindowRect.top() + 1,
++                                      frontWindowRect.right() - 1, frontWindowRect.top() + 1);
++                    painter->setPen(textAlphaColor);
++                    const QPoint points[4] = {
++                        frontWindowRect.topLeft(),
++                        frontWindowRect.topRight(),
++                        frontWindowRect.bottomLeft(),
++                        frontWindowRect.bottomRight()
++                    };
++                    painter->drawPoints(points, 4);
+ 
++                    QRect backWindowRect = normalButtonIconRect.adjusted(3, 0, 0, -3);
++                    QRegion clipRegion = backWindowRect;
++                    clipRegion -= frontWindowRect;
+                     painter->save();
+-                    painter->setRenderHint(QPainter::Antialiasing, true);
+-                    painter->drawRoundedRect(rect, r, r);
++                    painter->setClipRegion(clipRegion);
++                    painter->setPen(textColor);
++                    painter->drawRect(backWindowRect.adjusted(0, 0, -1, -1));
++                    painter->drawLine(backWindowRect.left() + 1, backWindowRect.top() + 1,
++                                      backWindowRect.right() - 1, backWindowRect.top() + 1);
++                    painter->setPen(textAlphaColor);
++                    const QPoint points2[4] = {
++                        backWindowRect.topLeft(),
++                        backWindowRect.topRight(),
++                        backWindowRect.bottomLeft(),
++                        backWindowRect.bottomRight()
++                    };
++                    painter->drawPoints(points2, 4);
+                     painter->restore();
+-                } else {
+-                    QRect pixmapRect = scrollBarSlider;
+-                    painter->setPen(QPen(alphaOutline));
+-                    if (option->state & State_Sunken && scrollBar->activeSubControls & SC_ScrollBarSlider)
+-                        painter->setBrush(midColor2);
+-                    else if (option->state & State_MouseOver && scrollBar->activeSubControls & SC_ScrollBarSlider)
+-                        painter->setBrush(highlightedGradient);
+-                    else
+-                        painter->setBrush(gradient);
+-
+-                    painter->drawRect(pixmapRect.adjusted(horizontal ? -1 : 0, horizontal ? 0 : -1, horizontal ? 0 : 1, horizontal ? 1 : 0));
+-
+-                    painter->setPen(d->innerContrastLine());
+-                    painter->drawRect(scrollBarSlider.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, -1, -1));
+-
+-                    // Outer shadow
+-                    //                  painter->setPen(subtleEdge);
+-                    //                  if (horizontal) {
+-                    ////                    painter->drawLine(scrollBarSlider.topLeft() + QPoint(-2, 0), scrollBarSlider.bottomLeft() + QPoint(2, 0));
+-                    ////                    painter->drawLine(scrollBarSlider.topRight() + QPoint(-2, 0), scrollBarSlider.bottomRight() + QPoint(2, 0));
+-                    //                  } else {
+-                    ////                    painter->drawLine(pixmapRect.topLeft() + QPoint(0, -2), pixmapRect.bottomLeft() + QPoint(0, -2));
+-                    ////                    painter->drawLine(pixmapRect.topRight() + QPoint(0, 2), pixmapRect.bottomRight() + QPoint(0, 2));
+-                    //                  }
+                 }
+             }
+ 
+-            // The SubLine (up/left) buttons
+-            if (!transient && scrollBar->subControls & SC_ScrollBarSubLine) {
+-                if ((scrollBar->activeSubControls & SC_ScrollBarSubLine) && sunken)
+-                    painter->setBrush(gradientStopColor);
+-                else if ((scrollBar->activeSubControls & SC_ScrollBarSubLine))
+-                    painter->setBrush(highlightedGradient);
+-                else
+-                    painter->setBrush(gradient);
+-
+-                painter->setPen(Qt::NoPen);
+-                painter->drawRect(scrollBarSubLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, 0, 0));
+-                painter->setPen(QPen(alphaOutline));
+-                if (option->state & State_Horizontal) {
+-                    if (option->direction == Qt::RightToLeft) {
+-                        pixmapRect.setLeft(scrollBarSubLine.left());
+-                        painter->drawLine(pixmapRect.topLeft(), pixmapRect.bottomLeft());
+-                    } else {
+-                        pixmapRect.setRight(scrollBarSubLine.right());
+-                        painter->drawLine(pixmapRect.topRight(), pixmapRect.bottomRight());
+-                    }
+-                } else {
+-                    pixmapRect.setBottom(scrollBarSubLine.bottom());
+-                    painter->drawLine(pixmapRect.bottomLeft(), pixmapRect.bottomRight());
++            // context help button
++            if (titleBar->subControls & SC_TitleBarContextHelpButton
++                    && (titleBar->titleBarFlags & Qt::WindowContextHelpButtonHint)) {
++                QRect contextHelpButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarContextHelpButton, widget);
++                if (contextHelpButtonRect.isValid()) {
++                    bool hover = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_MouseOver);
++                    bool sunken = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_Sunken);
++                    qt_fusion_draw_mdibutton(painter, titleBar, contextHelpButtonRect, hover, sunken);
++                    QImage image(qt_titlebar_context_help);
++                    QColor alpha = textColor;
++                    alpha.setAlpha(128);
++                    image.setColor(1, textColor.rgba());
++                    image.setColor(2, alpha.rgba());
++                    painter->setRenderHint(QPainter::SmoothPixmapTransform);
++                    painter->drawImage(contextHelpButtonRect.adjusted(4, 4, -4, -4), image);
+                 }
++            }
+ 
+-                painter->setBrush(Qt::NoBrush);
+-                painter->setPen(d->innerContrastLine());
+-                painter->drawRect(scrollBarSubLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0 ,  horizontal ? -2 : -1, horizontal ? -1 : -2));
+-
+-                // Arrows
+-                int rotation = 0;
+-                if (option->state & State_Horizontal)
+-                    rotation = option->direction == Qt::LeftToRight ? -90 : 90;
+-                QRect upRect = scrollBarSubLine.translated(horizontal ? -2 : -1, 0);
+-                QPixmap arrowPixmap = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), arrowColor, rotation);
+-                painter->drawPixmap(QRectF(upRect.center().x() - arrowPixmap.width() / 4.0  + 2.0,
+-                                          upRect.center().y() - arrowPixmap.height() / 4.0 + 1.0,
+-                                          arrowPixmap.width() / 2.0, arrowPixmap.height() / 2.0),
+-                                          arrowPixmap, QRectF(QPoint(0.0, 0.0), arrowPixmap.size()));
++            // shade button
++            if (titleBar->subControls & SC_TitleBarShadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
++                QRect shadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarShadeButton, widget);
++                if (shadeButtonRect.isValid()) {
++                    bool hover = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_MouseOver);
++                    bool sunken = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_Sunken);
++                    qt_fusion_draw_mdibutton(painter, titleBar, shadeButtonRect, hover, sunken);
++                    QPixmap arrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), textColor);
++                    painter->drawPixmap(shadeButtonRect.adjusted(5, 7, -5, -7), arrow);
++                }
+             }
+ 
+-            // The AddLine (down/right) button
+-            if (!transient && scrollBar->subControls & SC_ScrollBarAddLine) {
+-                if ((scrollBar->activeSubControls & SC_ScrollBarAddLine) && sunken)
+-                    painter->setBrush(gradientStopColor);
+-                else if ((scrollBar->activeSubControls & SC_ScrollBarAddLine))
+-                    painter->setBrush(midColor2);
+-                else
+-                    painter->setBrush(gradient);
++            // unshade button
++            if (titleBar->subControls & SC_TitleBarUnshadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
++                QRect unshadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarUnshadeButton, widget);
++                if (unshadeButtonRect.isValid()) {
++                    bool hover = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_MouseOver);
++                    bool sunken = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_Sunken);
++                    qt_fusion_draw_mdibutton(painter, titleBar, unshadeButtonRect, hover, sunken);
++                    QPixmap arrow = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), textColor, 180);
++                    painter->drawPixmap(unshadeButtonRect.adjusted(5, 7, -5, -7), arrow);
++                }
++            }
+ 
+-                painter->setPen(Qt::NoPen);
+-                painter->drawRect(scrollBarAddLine.adjusted(horizontal ? 0 : 1, horizontal ? 1 : 0, 0, 0));
+-                painter->setPen(QPen(alphaOutline, 1));
+-                if (option->state & State_Horizontal) {
+-                    if (option->direction == Qt::LeftToRight) {
+-                        pixmapRect.setLeft(scrollBarAddLine.left());
+-                        painter->drawLine(pixmapRect.topLeft(), pixmapRect.bottomLeft());
++            if ((titleBar->subControls & SC_TitleBarSysMenu) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
++                QRect iconRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarSysMenu, widget);
++                if (iconRect.isValid()) {
++                    if (!titleBar->icon.isNull()) {
++                        titleBar->icon.paint(painter, iconRect);
+                     } else {
+-                        pixmapRect.setRight(scrollBarAddLine.right());
+-                        painter->drawLine(pixmapRect.topRight(), pixmapRect.bottomRight());
++                        QStyleOption tool(0);
++                        tool.palette = titleBar->palette;
++                        QPixmap pm = standardIcon(SP_TitleBarMenuButton, &tool, widget).pixmap(16, 16);
++                        tool.rect = iconRect;
++                        painter->save();
++                        proxy()->drawItemPixmap(painter, iconRect, Qt::AlignCenter, pm);
++                        painter->restore();
+                     }
+-                } else {
+-                    pixmapRect.setTop(scrollBarAddLine.top());
+-                    painter->drawLine(pixmapRect.topLeft(), pixmapRect.topRight());
+                 }
+-
+-                painter->setPen(d->innerContrastLine());
+-                painter->setBrush(Qt::NoBrush);
+-                painter->drawRect(scrollBarAddLine.adjusted(1, 1, -1, -1));
+-
+-                int rotation = 180;
+-                if (option->state & State_Horizontal)
+-                    rotation = option->direction == Qt::LeftToRight ? 90 : -90;
+-                QRect downRect = scrollBarAddLine.translated(-1, 1);
+-                QPixmap arrowPixmap = colorizedImage(QLatin1String(":/qt-project.org/styles/commonstyle/images/fusion_arrow.png"), arrowColor, rotation);
+-                painter->drawPixmap(QRectF(downRect.center().x() - arrowPixmap.width() / 4.0 + 2.0,
+-                                           downRect.center().y() - arrowPixmap.height() / 4.0,
+-                                           arrowPixmap.width() / 2.0, arrowPixmap.height() / 2.0),
+-                                           arrowPixmap, QRectF(QPoint(0.0, 0.0), arrowPixmap.size()));
+             }
+-
+         }
+         painter->restore();
++        break;
++    case CC_ScrollBar:
++        drawComplexControlScrollBar<QStyleOptionSlider>(control, option, painter, widget, proxy(), d);
++        break;;
++    case CC_ScrollBar64:
++        drawComplexControlScrollBar<QStyleOptionSlider64>(control, option, painter, widget, proxy(), d);
+         break;;
+     case CC_ComboBox:
+         painter->save();
+@@ -2792,214 +3087,10 @@ void QFusionStyle::drawComplexControl(Co
+         painter->restore();
+         break;
+     case CC_Slider:
+-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+-            QRect groove = proxy()->subControlRect(CC_Slider, option, SC_SliderGroove, widget);
+-            QRect handle = proxy()->subControlRect(CC_Slider, option, SC_SliderHandle, widget);
+-
+-            bool horizontal = slider->orientation == Qt::Horizontal;
+-            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
+-            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
+-            QColor activeHighlight = d->highlight(option->palette);
+-            QPixmap cache;
+-            QBrush oldBrush = painter->brush();
+-            QPen oldPen = painter->pen();
+-            QColor shadowAlpha(Qt::black);
+-            shadowAlpha.setAlpha(10);
+-            if (option->state & State_HasFocus && option->state & State_KeyboardFocusChange)
+-                outline = d->highlightedOutline(option->palette);
+-
+-
+-            if ((option->subControls & SC_SliderGroove) && groove.isValid()) {
+-                QColor grooveColor;
+-                grooveColor.setHsv(buttonColor.hue(),
+-                                   qMin(255, (int)(buttonColor.saturation())),
+-                                   qMin(255, (int)(buttonColor.value()*0.9)));
+-                QString groovePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_groove"), option, groove.size());
+-                QRect pixmapRect(0, 0, groove.width(), groove.height());
+-
+-                // draw background groove
+-                if (!QPixmapCache::find(groovePixmapName, cache)) {
+-                    cache = styleCachePixmap(pixmapRect.size());
+-                    cache.fill(Qt::transparent);
+-                    QPainter groovePainter(&cache);
+-                    groovePainter.setRenderHint(QPainter::Antialiasing, true);
+-                    groovePainter.translate(0.5, 0.5);
+-                    QLinearGradient gradient;
+-                    if (horizontal) {
+-                        gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
+-                        gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
+-                    }
+-                    else {
+-                        gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
+-                        gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
+-                    }
+-                    groovePainter.setPen(QPen(outline));
+-                    gradient.setColorAt(0, grooveColor.darker(110));
+-                    gradient.setColorAt(1, grooveColor.lighter(110));//palette.button().color().darker(115));
+-                    groovePainter.setBrush(gradient);
+-                    groovePainter.drawRoundedRect(pixmapRect.adjusted(1, 1, -2, -2), 1, 1);
+-                    groovePainter.end();
+-                    QPixmapCache::insert(groovePixmapName, cache);
+-                }
+-                painter->drawPixmap(groove.topLeft(), cache);
+-
+-                // draw blue groove highlight
+-                QRect clipRect;
+-                groovePixmapName += QLatin1String("_blue");
+-                if (!QPixmapCache::find(groovePixmapName, cache)) {
+-                    cache = styleCachePixmap(pixmapRect.size());
+-                    cache.fill(Qt::transparent);
+-                    QPainter groovePainter(&cache);
+-                    QLinearGradient gradient;
+-                    if (horizontal) {
+-                        gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
+-                        gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
+-                    }
+-                    else {
+-                        gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
+-                        gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
+-                    }
+-                    QColor highlight = d->highlight(option->palette);
+-                    QColor highlightedoutline = highlight.darker(140);
+-                    if (qGray(outline.rgb()) > qGray(highlightedoutline.rgb()))
+-                        outline = highlightedoutline;
+-
+-
+-                    groovePainter.setRenderHint(QPainter::Antialiasing, true);
+-                    groovePainter.translate(0.5, 0.5);
+-                    groovePainter.setPen(QPen(outline));
+-                    gradient.setColorAt(0, activeHighlight);
+-                    gradient.setColorAt(1, activeHighlight.lighter(130));
+-                    groovePainter.setBrush(gradient);
+-                    groovePainter.drawRoundedRect(pixmapRect.adjusted(1, 1, -2, -2), 1, 1);
+-                    groovePainter.setPen(d->innerContrastLine());
+-                    groovePainter.setBrush(Qt::NoBrush);
+-                    groovePainter.drawRoundedRect(pixmapRect.adjusted(2, 2, -3, -3), 1, 1);
+-                    groovePainter.end();
+-                    QPixmapCache::insert(groovePixmapName, cache);
+-                }
+-                if (horizontal) {
+-                    if (slider->upsideDown)
+-                        clipRect = QRect(handle.right(), groove.top(), groove.right() - handle.right(), groove.height());
+-                    else
+-                        clipRect = QRect(groove.left(), groove.top(), handle.left(), groove.height());
+-                } else {
+-                    if (slider->upsideDown)
+-                        clipRect = QRect(groove.left(), handle.bottom(), groove.width(), groove.height() - handle.bottom());
+-                    else
+-                        clipRect = QRect(groove.left(), groove.top(), groove.width(), handle.top() - groove.top());
+-                }
+-                painter->save();
+-                painter->setClipRect(clipRect.adjusted(0, 0, 1, 1), Qt::IntersectClip);
+-                painter->drawPixmap(groove.topLeft(), cache);
+-                painter->restore();
+-            }
+-
+-            if (option->subControls & SC_SliderTickmarks) {
+-                painter->setPen(outline);
+-                int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
+-                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
+-                int interval = slider->tickInterval;
+-                if (interval <= 0) {
+-                    interval = slider->singleStep;
+-                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
+-                                                        available)
+-                            - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
+-                                                              0, available) < 3)
+-                        interval = slider->pageStep;
+-                }
+-                if (interval <= 0)
+-                    interval = 1;
+-
+-                int v = slider->minimum;
+-                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
+-                while (v <= slider->maximum + 1) {
+-                    if (v == slider->maximum + 1 && interval == 1)
+-                        break;
+-                    const int v_ = qMin(v, slider->maximum);
+-                    int pos = sliderPositionFromValue(slider->minimum, slider->maximum,
+-                                                      v_, (horizontal
+-                                                           ? slider->rect.width()
+-                                                           : slider->rect.height()) - len,
+-                                                      slider->upsideDown) + len / 2;
+-                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
+-
+-                    if (horizontal) {
+-                        if (ticksAbove) {
+-                            painter->drawLine(pos, slider->rect.top() + extra,
+-                                              pos, slider->rect.top() + tickSize);
+-                        }
+-                        if (ticksBelow) {
+-                            painter->drawLine(pos, slider->rect.bottom() - extra,
+-                                              pos, slider->rect.bottom() - tickSize);
+-                        }
+-                    } else {
+-                        if (ticksAbove) {
+-                            painter->drawLine(slider->rect.left() + extra, pos,
+-                                              slider->rect.left() + tickSize, pos);
+-                        }
+-                        if (ticksBelow) {
+-                            painter->drawLine(slider->rect.right() - extra, pos,
+-                                              slider->rect.right() - tickSize, pos);
+-                        }
+-                    }
+-                    // in the case where maximum is max int
+-                    int nextInterval = v + interval;
+-                    if (nextInterval < v)
+-                        break;
+-                    v = nextInterval;
+-                }
+-            }
+-            // draw handle
+-            if ((option->subControls & SC_SliderHandle) ) {
+-                QString handlePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_handle"), option, handle.size());
+-                if (!QPixmapCache::find(handlePixmapName, cache)) {
+-                    cache = styleCachePixmap(handle.size());
+-                    cache.fill(Qt::transparent);
+-                    QRect pixmapRect(0, 0, handle.width(), handle.height());
+-                    QPainter handlePainter(&cache);
+-                    QRect gradRect = pixmapRect.adjusted(2, 2, -2, -2);
+-
+-                    // gradient fill
+-                    QRect r = pixmapRect.adjusted(1, 1, -2, -2);
+-                    QLinearGradient gradient = qt_fusion_gradient(gradRect, d->buttonColor(option->palette),horizontal ? TopDown : FromLeft);
+-
+-                    handlePainter.setRenderHint(QPainter::Antialiasing, true);
+-                    handlePainter.translate(0.5, 0.5);
+-
+-                    handlePainter.setPen(Qt::NoPen);
+-                    handlePainter.setBrush(QColor(0, 0, 0, 40));
+-                    handlePainter.drawRect(r.adjusted(-1, 2, 1, -2));
+-
+-                    handlePainter.setPen(QPen(d->outline(option->palette)));
+-                    if (option->state & State_HasFocus && option->state & State_KeyboardFocusChange)
+-                        handlePainter.setPen(QPen(d->highlightedOutline(option->palette)));
+-
+-                    handlePainter.setBrush(gradient);
+-                    handlePainter.drawRoundedRect(r, 2, 2);
+-                    handlePainter.setBrush(Qt::NoBrush);
+-                    handlePainter.setPen(d->innerContrastLine());
+-                    handlePainter.drawRoundedRect(r.adjusted(1, 1, -1, -1), 2, 2);
+-
+-                    QColor cornerAlpha = outline.darker(120);
+-                    cornerAlpha.setAlpha(80);
+-
+-                    //handle shadow
+-                    handlePainter.setPen(shadowAlpha);
+-                    handlePainter.drawLine(QPoint(r.left() + 2, r.bottom() + 1), QPoint(r.right() - 2, r.bottom() + 1));
+-                    handlePainter.drawLine(QPoint(r.right() + 1, r.bottom() - 3), QPoint(r.right() + 1, r.top() + 4));
+-                    handlePainter.drawLine(QPoint(r.right() - 1, r.bottom()), QPoint(r.right() + 1, r.bottom() - 2));
+-
+-                    handlePainter.end();
+-                    QPixmapCache::insert(handlePixmapName, cache);
+-                }
+-
+-                painter->drawPixmap(handle.topLeft(), cache);
+-
+-            }
+-            painter->setBrush(oldBrush);
+-            painter->setPen(oldPen);
+-        }
++        drawComplexControlSlider<QStyleOptionSlider>(control, option, painter, widget, proxy(), d);
++        break;
++    case CC_Slider64:
++        drawComplexControlSlider<QStyleOptionSlider64>(control, option, painter, widget, proxy(), d);
+         break;
+     case CC_Dial:
+         if (const QStyleOptionSlider *dial = qstyleoption_cast<const QStyleOptionSlider *>(option))
+@@ -3282,53 +3373,10 @@ QRect QFusionStyle::subControlRect(Compl
+ 
+     switch (control) {
+     case CC_Slider:
+-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+-            int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
+-            switch (subControl) {
+-            case SC_SliderHandle: {
+-                if (slider->orientation == Qt::Horizontal) {
+-                    rect.setHeight(proxy()->pixelMetric(PM_SliderThickness));
+-                    rect.setWidth(proxy()->pixelMetric(PM_SliderLength));
+-                    int centerY = slider->rect.center().y() - rect.height() / 2;
+-                    if (slider->tickPosition & QSlider::TicksAbove)
+-                        centerY += tickSize;
+-                    if (slider->tickPosition & QSlider::TicksBelow)
+-                        centerY -= tickSize;
+-                    rect.moveTop(centerY);
+-                } else {
+-                    rect.setWidth(proxy()->pixelMetric(PM_SliderThickness));
+-                    rect.setHeight(proxy()->pixelMetric(PM_SliderLength));
+-                    int centerX = slider->rect.center().x() - rect.width() / 2;
+-                    if (slider->tickPosition & QSlider::TicksAbove)
+-                        centerX += tickSize;
+-                    if (slider->tickPosition & QSlider::TicksBelow)
+-                        centerX -= tickSize;
+-                    rect.moveLeft(centerX);
+-                }
+-            }
+-                break;
+-            case SC_SliderGroove: {
+-                QPoint grooveCenter = slider->rect.center();
+-                if (slider->orientation == Qt::Horizontal) {
+-                    rect.setHeight(7);
+-                    if (slider->tickPosition & QSlider::TicksAbove)
+-                        grooveCenter.ry() += tickSize;
+-                    if (slider->tickPosition & QSlider::TicksBelow)
+-                        grooveCenter.ry() -= tickSize;
+-                } else {
+-                    rect.setWidth(7);
+-                    if (slider->tickPosition & QSlider::TicksAbove)
+-                        grooveCenter.rx() += tickSize;
+-                    if (slider->tickPosition & QSlider::TicksBelow)
+-                        grooveCenter.rx() -= tickSize;
+-                }
+-                rect.moveCenter(grooveCenter);
+-                break;
+-            }
+-            default:
+-                break;
+-            }
+-        }
++        subControlRectSlider<QStyleOptionSlider>(control, option, subControl, widget, rect, proxy());
++        break;
++    case CC_Slider64:
++        subControlRectSlider<QStyleOptionSlider64>(control, option, subControl, widget, rect, proxy());
+         break;
+     case CC_SpinBox:
+         if (const QStyleOptionSpinBox *spinbox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
+--- qtbase-opensource-src-5.3.2+dfsg.orig/src/widgets/styles/qgtkstyle.cpp
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/styles/qgtkstyle.cpp
+@@ -1472,6 +1472,367 @@ void QGtkStyle::drawPrimitive(PrimitiveE
+     }
+ }
+ 
++template <class OptionStyle>
++static void drawSlider(QGtkStyle::ComplexControl control, const QStyleOptionComplex* option,
++                       const QGtkStylePrivate* const d, const QWidget* widget,
++                       QGtkPainter* gtkPainter, QPainter* painter, GtkStyle* style,
++                       QStyle const* proxy)
++{
++        if (const OptionStyle *slider = qstyleoption_cast<const OptionStyle *>(option)) {
++            GtkWidget *hScaleWidget = d->gtkWidget("GtkHScale");
++            GtkWidget *vScaleWidget = d->gtkWidget("GtkVScale");
++
++            QRect groove = proxy->subControlRect(QStyle::CC_Slider, option, QStyle::SC_SliderGroove, widget);
++            QRect handle = proxy->subControlRect(QStyle::CC_Slider, option, QStyle::SC_SliderHandle, widget);
++
++            bool horizontal = slider->orientation == Qt::Horizontal;
++            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
++            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
++            QColor button = option->palette.button().color();
++            QColor darkOutline;
++            darkOutline.setHsv(button.hue(),
++                               qMin(255, (int)(button.saturation()*3.0)),
++                               qMin(255, (int)(button.value()*0.6)));
++
++            QBrush oldBrush = painter->brush();
++            QPen oldPen = painter->pen();
++
++            QColor shadowAlpha(Qt::black);
++            shadowAlpha.setAlpha(10);
++            QColor highlightAlpha(Qt::white);
++            highlightAlpha.setAlpha(80);
++
++            QGtkStylePrivate::gtk_widget_set_direction(hScaleWidget, slider->upsideDown ?
++                                                       GTK_TEXT_DIR_RTL : GTK_TEXT_DIR_LTR);
++            GtkWidget *scaleWidget = horizontal ? hScaleWidget : vScaleWidget;
++            style = d->gtk_widget_get_style(scaleWidget);
++
++            if ((option->subControls & QStyle::SC_SliderGroove) && groove.isValid()) {
++
++                GtkRange *range = (GtkRange*)scaleWidget;
++                GtkAdjustment *adjustment = 0;
++                if (d->gtk_adjustment_configure)
++                    adjustment = d->gtk_range_get_adjustment(range);
++                if (adjustment) {
++                    d->gtk_adjustment_configure(adjustment,
++                                                slider->sliderPosition,
++                                                slider->minimum,
++                                                slider->maximum,
++                                                slider->singleStep,
++                                                slider->singleStep,
++                                                slider->pageStep);
++                } else {
++                    adjustment = (GtkAdjustment*)d->gtk_adjustment_new(slider->sliderPosition,
++                                                                       slider->minimum,
++                                                                       slider->maximum,
++                                                                       slider->singleStep,
++                                                                       slider->singleStep,
++                                                                       slider->pageStep);
++                    d->gtk_range_set_adjustment(range, adjustment);
++                }
++
++                int outerSize;
++                d->gtk_range_set_inverted(range, !horizontal);
++                d->gtk_widget_style_get(scaleWidget, "trough-border", &outerSize, NULL);
++                outerSize++;
++
++                GtkStateType state = qt_gtk_state(option);
++                int focusFrameMargin = 2;
++                QRect grooveRect = option->rect.adjusted(focusFrameMargin, outerSize + focusFrameMargin,
++                                   -focusFrameMargin, -outerSize - focusFrameMargin);
++
++                gboolean trough_side_details = false; // Indicates if the upper or lower scale background differs
++                if (!d->gtk_check_version(2, 10, 0))
++                    d->gtk_widget_style_get((GtkWidget*)(scaleWidget), "trough-side-details", &trough_side_details, NULL);
++
++                if (!trough_side_details) {
++                    gtkPainter->paintBox(scaleWidget, "trough", grooveRect, state,
++                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
++                } else {
++                    QRect upperGroove = grooveRect;
++                    QRect lowerGroove = grooveRect;
++
++                    if (horizontal) {
++                        if (slider->upsideDown) {
++                            lowerGroove.setLeft(handle.center().x());
++                            upperGroove.setRight(handle.center().x());
++                        } else {
++                            upperGroove.setLeft(handle.center().x());
++                            lowerGroove.setRight(handle.center().x());
++                        }
++                    } else {
++                        if (!slider->upsideDown) {
++                            lowerGroove.setBottom(handle.center().y());
++                            upperGroove.setTop(handle.center().y());
++                        } else {
++                            upperGroove.setBottom(handle.center().y());
++                            lowerGroove.setTop(handle.center().y());
++                        }
++                    }
++
++                    gtkPainter->paintBox(scaleWidget, "trough-upper", upperGroove, state,
++                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
++                    gtkPainter->paintBox(scaleWidget, "trough-lower", lowerGroove, state,
++                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
++                }
++            }
++
++            if (option->subControls & QStyle::SC_SliderTickmarks) {
++                painter->setPen(darkOutline);
++                int tickSize = proxy->pixelMetric(QStyle::PM_SliderTickmarkOffset, option, widget);
++                int available = proxy->pixelMetric(QStyle::PM_SliderSpaceAvailable, slider, widget);
++                int interval = slider->tickInterval;
++
++                if (interval <= 0) {
++                    interval = slider->singleStep;
++
++                    if (QStyle::sliderPositionFromValue((qint64)slider->minimum, (qint64)slider->maximum, (qint64)interval,
++                                                        (qint64)available)
++                            - QStyle::sliderPositionFromValue((qint64)slider->minimum, (qint64)slider->maximum,
++                                                              (qint64)0, (qint64)available) < 3)
++                        interval = slider->pageStep;
++                }
++
++                if (interval <= 0)
++                    interval = 1;
++
++                int v = slider->minimum;
++                int len = proxy->pixelMetric(QStyle::PM_SliderLength, slider, widget);
++                while (v <= slider->maximum + 1) {
++                    if (v == slider->maximum + 1 && interval == 1)
++                        break;
++                    const int v_ = qMin((qint64)v, (qint64)slider->maximum);
++                    int pos = QStyle::sliderPositionFromValue((qint64)slider->minimum, (qint64)slider->maximum,
++                                                      (qint64)v_, (qint64)(horizontal
++                                                           ? slider->rect.width()
++                                                           : slider->rect.height()) - len,
++                                                      slider->upsideDown) + len / 2;
++                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
++                    if (horizontal) {
++                        if (ticksAbove)
++                            painter->drawLine(pos, slider->rect.top() + extra,
++                                              pos, slider->rect.top() + tickSize);
++                        if (ticksBelow)
++                            painter->drawLine(pos, slider->rect.bottom() - extra,
++                                              pos, slider->rect.bottom() - tickSize);
++
++                    } else {
++                        if (ticksAbove)
++                            painter->drawLine(slider->rect.left() + extra, pos,
++                                              slider->rect.left() + tickSize, pos);
++                        if (ticksBelow)
++                            painter->drawLine(slider->rect.right() - extra, pos,
++                                              slider->rect.right() - tickSize, pos);
++                    }
++
++                    // In the case where maximum is max int
++                    int nextInterval = v + interval;
++                    if (nextInterval < v)
++                        break;
++                    v = nextInterval;
++                }
++            }
++
++            // Draw slider handle
++            if (option->subControls & QStyle::SC_SliderHandle) {
++                GtkShadowType shadow =  GTK_SHADOW_OUT;
++                GtkStateType state = GTK_STATE_NORMAL;
++
++                if (!(option->state & QStyle::State_Enabled))
++                    state = GTK_STATE_INSENSITIVE;
++                else if (option->state & QStyle::State_MouseOver && option->activeSubControls & QStyle::SC_SliderHandle)
++                    state = GTK_STATE_PRELIGHT;
++
++                bool horizontal = option->state & QStyle::State_Horizontal;
++
++                if (slider->state & QStyle::State_HasFocus) {
++                    QStyleOptionFocusRect fropt;
++                    fropt.QStyleOption::operator=(*slider);
++                    fropt.rect = slider->rect.adjusted(-1, -1 ,1, 1);
++
++                    if (horizontal) {
++                        fropt.rect.setTop(handle.top() - 3);
++                        fropt.rect.setBottom(handle.bottom() + 4);
++
++                    } else {
++                        fropt.rect.setLeft(handle.left() - 3);
++                        fropt.rect.setRight(handle.right() + 3);
++                    }
++                    proxy->drawPrimitive(QStyle::PE_FrameFocusRect, &fropt, painter, widget);
++                }
++                gtkPainter->paintSlider(scaleWidget, horizontal ? "hscale" : "vscale", handle, state, shadow, style,
++                                        horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL);
++            }
++            painter->setBrush(oldBrush);
++            painter->setPen(oldPen);
++        }
++}
++
++template <class OptionStyle>
++void drawScrollBar(const QStyleOptionComplex* option, QGtkStyle::ComplexControl control, const QGtkStylePrivate* const d, const QWidget* widget, QGtkPainter* gtkPainter, QPainter* painter, GtkStyle* style, QStyle const* proxy)
++{
++        if (const OptionStyle *scrollBar = qstyleoption_cast<const OptionStyle *>(option)) {
++            GtkWidget *gtkHScrollBar = d->gtkWidget("GtkHScrollbar");
++            GtkWidget *gtkVScrollBar = d->gtkWidget("GtkVScrollbar");
++
++            // Fill background in case the scrollbar is partially transparent
++            painter->fillRect(option->rect, option->palette.background());
++
++            QRect rect = scrollBar->rect;
++            QRect scrollBarSubLine = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarSubLine, widget);
++            QRect scrollBarAddLine = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarAddLine, widget);
++            QRect scrollBarSlider = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarSlider, widget);
++            QRect grooveRect = proxy->subControlRect(control, scrollBar, QStyle::SC_ScrollBarGroove, widget);
++            bool horizontal = scrollBar->orientation == Qt::Horizontal;
++            GtkWidget * scrollbarWidget = horizontal ? gtkHScrollBar : gtkVScrollBar;
++            style = d->gtk_widget_get_style(scrollbarWidget);
++            gboolean trough_under_steppers = true;
++            gboolean trough_side_details = false;
++            gboolean activate_slider = false;
++            gboolean stepper_size = 14;
++            gint trough_border = 1;
++            if (!d->gtk_check_version(2, 10, 0)) {
++                d->gtk_widget_style_get((GtkWidget*)(scrollbarWidget),
++                                           "trough-border",         &trough_border,
++                                           "trough-side-details",   &trough_side_details,
++                                           "trough-under-steppers", &trough_under_steppers,
++                                           "activate-slider",       &activate_slider,
++                                           "stepper-size",          &stepper_size, NULL);
++            }
++            if (trough_under_steppers) {
++                scrollBarAddLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
++                scrollBarSubLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
++                scrollBarSlider.adjust(horizontal ? -trough_border : 0, horizontal ? 0 : -trough_border,
++                                       horizontal ? trough_border : 0, horizontal ? 0 : trough_border);
++            }
++
++            // Some styles check the position of scrollbars in order to determine
++            // if lines should be painted when the scrollbar is in max or min positions.
++            int maximum = 2;
++            int fakePos = 0;
++            bool reverse = (option->direction == Qt::RightToLeft);
++            if (scrollBar->minimum == scrollBar->maximum)
++                maximum = 0;
++            if (scrollBar->sliderPosition == scrollBar->maximum)
++                fakePos = maximum;
++            else if (scrollBar->sliderPosition > scrollBar->minimum)
++                fakePos = maximum - 1;
++
++
++            GtkRange *range = (GtkRange*)(horizontal ? gtkHScrollBar : gtkVScrollBar);
++            GtkAdjustment *adjustment = 0;
++
++            if (d->gtk_adjustment_configure)
++                adjustment = d->gtk_range_get_adjustment(range);
++            if (adjustment) {
++                d->gtk_adjustment_configure(adjustment, fakePos, 0, maximum, 0, 0, 0);
++            } else {
++                adjustment = (GtkAdjustment*)d->gtk_adjustment_new(fakePos, 0, maximum, 0, 0, 0);
++                d->gtk_range_set_adjustment(range, adjustment);
++            }
++
++            if (scrollBar->subControls & QStyle::SC_ScrollBarGroove) {
++                GtkStateType state = GTK_STATE_ACTIVE;
++
++                if (!(option->state & QStyle::State_Enabled))
++                    state = GTK_STATE_INSENSITIVE;
++
++                if (trough_under_steppers)
++                    grooveRect = option->rect;
++
++                gtkPainter->paintBox(scrollbarWidget, "trough", grooveRect, state, GTK_SHADOW_IN, style);
++            }
++
++            //paint slider
++            if (scrollBar->subControls & QStyle::SC_ScrollBarSlider) {
++                GtkStateType state = GTK_STATE_NORMAL;
++
++                if (!(option->state & QStyle::State_Enabled))
++                    state = GTK_STATE_INSENSITIVE;
++                else if (activate_slider &&
++                         option->state & QStyle::State_Sunken && (scrollBar->activeSubControls & QStyle::SC_ScrollBarSlider))
++                    state = GTK_STATE_ACTIVE;
++                else if (option->state & QStyle::State_MouseOver && (scrollBar->activeSubControls & QStyle::SC_ScrollBarSlider))
++                    state = GTK_STATE_PRELIGHT;
++
++                GtkShadowType shadow = GTK_SHADOW_OUT;
++
++                if (trough_under_steppers) {
++                    if (!horizontal)
++                        scrollBarSlider.adjust(trough_border, 0, -trough_border, 0);
++                    else
++                        scrollBarSlider.adjust(0, trough_border, 0, -trough_border);
++                }
++
++                gtkPainter->paintSlider(scrollbarWidget, "slider", scrollBarSlider, state, shadow, style,
++                                        horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL, QString(QLS("%0%1")).arg(fakePos).arg(maximum));
++            }
++
++            if (scrollBar->subControls & QStyle::SC_ScrollBarAddLine) {
++                GtkAllocation vAllocation;
++                vAllocation.y = scrollBarAddLine.top();
++                vAllocation.height = scrollBarAddLine.height() - rect.height() + 6;
++                d->gtk_widget_set_allocation(gtkVScrollBar, &vAllocation);
++
++                GtkAllocation hAllocation;
++                hAllocation.x = scrollBarAddLine.right();
++                hAllocation.width = scrollBarAddLine.width() - rect.width();
++                d->gtk_widget_set_allocation(gtkHScrollBar, &hAllocation);
++
++                GtkShadowType shadow = GTK_SHADOW_OUT;
++                GtkStateType state = GTK_STATE_NORMAL;
++
++                if (!(option->state & QStyle::State_Enabled) || (fakePos == maximum))
++                    state = GTK_STATE_INSENSITIVE;
++                else if (option->state & QStyle::State_Sunken && (scrollBar->activeSubControls & QStyle::SC_ScrollBarAddLine)) {
++                    state = GTK_STATE_ACTIVE;
++                    shadow = GTK_SHADOW_IN;
++
++                } else if (option->state & QStyle::State_MouseOver && (scrollBar->activeSubControls & QStyle::SC_ScrollBarAddLine))
++                    state = GTK_STATE_PRELIGHT;
++
++                gtkPainter->paintBox(scrollbarWidget,
++                                     horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine,
++                                     state, shadow, style, QLS("add"));
++
++                gtkPainter->paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine.adjusted(4, 4, -4, -4),
++                                       horizontal ? (reverse ? GTK_ARROW_LEFT : GTK_ARROW_RIGHT) :
++                                       GTK_ARROW_DOWN, state, GTK_SHADOW_NONE, false, style);
++            }
++
++            if (scrollBar->subControls & QStyle::SC_ScrollBarSubLine) {
++                GtkAllocation vAllocation;
++                vAllocation.y = 0;
++                vAllocation.height = scrollBarSubLine.height();
++                d->gtk_widget_set_allocation(gtkVScrollBar, &vAllocation);
++
++                GtkAllocation hAllocation;
++                hAllocation.x = 0;
++                hAllocation.width = scrollBarSubLine.width();
++                d->gtk_widget_set_allocation(gtkHScrollBar, &hAllocation);
++
++                GtkShadowType shadow = GTK_SHADOW_OUT;
++                GtkStateType state = GTK_STATE_NORMAL;
++
++                if (!(option->state & QStyle::State_Enabled) || (fakePos == 0))
++                    state = GTK_STATE_INSENSITIVE;
++                else if (option->state & QStyle::State_Sunken && (scrollBar->activeSubControls & QStyle::SC_ScrollBarSubLine)) {
++                    shadow = GTK_SHADOW_IN;
++                    state = GTK_STATE_ACTIVE;
++
++                } else if (option->state & QStyle::State_MouseOver && (scrollBar->activeSubControls & QStyle::SC_ScrollBarSubLine))
++                    state = GTK_STATE_PRELIGHT;
++
++                gtkPainter->paintBox(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine,
++                                     state, shadow, style, QLS("sub"));
++
++                gtkPainter->paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine.adjusted(4, 4, -4, -4),
++                                       horizontal ? (reverse ? GTK_ARROW_RIGHT : GTK_ARROW_LEFT) :
++                                       GTK_ARROW_UP, state, GTK_SHADOW_NONE, false, style);
++            }
++        }
++}
++
+ /*!
+     \reimp
+ */
+@@ -2096,208 +2457,53 @@ void QGtkStyle::drawComplexControl(Compl
+ 
+             if (toolbutton->state & State_HasFocus) {
+                 QStyleOptionFocusRect fr;
+-                fr.QStyleOption::operator=(*toolbutton);
+-                fr.rect = proxy()->subControlRect(CC_ToolButton, toolbutton, SC_ToolButton, widget);
+-                fr.rect.adjust(1, 1, -1, -1);
+-                proxy()->drawPrimitive(PE_FrameFocusRect, &fr, painter, widget);
+-            }
+-
+-            QStyleOptionToolButton label = *toolbutton;
+-            label.state = bflags;
+-            GtkWidget *gtkButton = d->gtkWidget("GtkToolButton.GtkButton");
+-            QPalette pal = toolbutton->palette;
+-            if (option->state & State_Enabled &&
+-                option->state & State_MouseOver && !(widget && widget->testAttribute(Qt::WA_SetPalette))) {
+-                GdkColor gdkText = d->gtk_widget_get_style(gtkButton)->fg[GTK_STATE_PRELIGHT];
+-                QColor textColor = QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
+-                pal.setBrush(QPalette::All, QPalette::ButtonText, textColor);
+-                label.palette = pal;
+-            }
+-            label.rect = button.adjusted(style->xthickness, style->ythickness,
+-                                        -style->xthickness - popupArrowSize, -style->ythickness);
+-            proxy()->drawControl(CE_ToolButtonLabel, &label, painter, widget);
+-
+-            if (toolbutton->subControls & SC_ToolButtonMenu) {
+-                tool.rect = menuarea;
+-                tool.state = mflags;
+-                if ((mflags & State_Enabled && (mflags & (State_Sunken | State_Raised | State_MouseOver))) || !(mflags & State_AutoRaise))
+-                    proxy()->drawPrimitive(PE_IndicatorButtonDropDown, &tool, painter, widget);
+-
+-                proxy()->drawPrimitive(PE_IndicatorArrowDown, &tool, painter, widget);
+-
+-            } else if (drawMenuArrow) {
+-                QRect ir = toolbutton->rect;
+-                QStyleOptionToolButton newBtn = *toolbutton;
+-                newBtn.rect = QRect(ir.right() - popupArrowSize - style->xthickness - 3, ir.height()/2 - 1, popupArrowSize, popupArrowSize);
+-                proxy()->drawPrimitive(PE_IndicatorArrowDown, &newBtn, painter, widget);
+-            }
+-        }
+-        break;
+-
+-#endif // QT_NO_TOOLBUTTON
+-#ifndef QT_NO_SCROLLBAR
+-
+-    case CC_ScrollBar:
+-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+-            GtkWidget *gtkHScrollBar = d->gtkWidget("GtkHScrollbar");
+-            GtkWidget *gtkVScrollBar = d->gtkWidget("GtkVScrollbar");
+-
+-            // Fill background in case the scrollbar is partially transparent
+-            painter->fillRect(option->rect, option->palette.background());
+-
+-            QRect rect = scrollBar->rect;
+-            QRect scrollBarSubLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSubLine, widget);
+-            QRect scrollBarAddLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarAddLine, widget);
+-            QRect scrollBarSlider = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSlider, widget);
+-            QRect grooveRect = proxy()->subControlRect(control, scrollBar, SC_ScrollBarGroove, widget);
+-            bool horizontal = scrollBar->orientation == Qt::Horizontal;
+-            GtkWidget * scrollbarWidget = horizontal ? gtkHScrollBar : gtkVScrollBar;
+-            style = d->gtk_widget_get_style(scrollbarWidget);
+-            gboolean trough_under_steppers = true;
+-            gboolean trough_side_details = false;
+-            gboolean activate_slider = false;
+-            gboolean stepper_size = 14;
+-            gint trough_border = 1;
+-            if (!d->gtk_check_version(2, 10, 0)) {
+-                d->gtk_widget_style_get((GtkWidget*)(scrollbarWidget),
+-                                           "trough-border",         &trough_border,
+-                                           "trough-side-details",   &trough_side_details,
+-                                           "trough-under-steppers", &trough_under_steppers,
+-                                           "activate-slider",       &activate_slider,
+-                                           "stepper-size",          &stepper_size, NULL);
+-            }
+-            if (trough_under_steppers) {
+-                scrollBarAddLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
+-                scrollBarSubLine.adjust(trough_border, trough_border, -trough_border, -trough_border);
+-                scrollBarSlider.adjust(horizontal ? -trough_border : 0, horizontal ? 0 : -trough_border,
+-                                       horizontal ? trough_border : 0, horizontal ? 0 : trough_border);
+-            }
+-
+-            // Some styles check the position of scrollbars in order to determine
+-            // if lines should be painted when the scrollbar is in max or min positions.
+-            int maximum = 2;
+-            int fakePos = 0;
+-            bool reverse = (option->direction == Qt::RightToLeft);
+-            if (scrollBar->minimum == scrollBar->maximum)
+-                maximum = 0;
+-            if (scrollBar->sliderPosition == scrollBar->maximum)
+-                fakePos = maximum;
+-            else if (scrollBar->sliderPosition > scrollBar->minimum)
+-                fakePos = maximum - 1;
+-
+-
+-            GtkRange *range = (GtkRange*)(horizontal ? gtkHScrollBar : gtkVScrollBar);
+-            GtkAdjustment *adjustment = 0;
+-
+-            if (d->gtk_adjustment_configure)
+-                adjustment = d->gtk_range_get_adjustment(range);
+-            if (adjustment) {
+-                d->gtk_adjustment_configure(adjustment, fakePos, 0, maximum, 0, 0, 0);
+-            } else {
+-                adjustment = (GtkAdjustment*)d->gtk_adjustment_new(fakePos, 0, maximum, 0, 0, 0);
+-                d->gtk_range_set_adjustment(range, adjustment);
+-            }
+-
+-            if (scrollBar->subControls & SC_ScrollBarGroove) {
+-                GtkStateType state = GTK_STATE_ACTIVE;
+-
+-                if (!(option->state & State_Enabled))
+-                    state = GTK_STATE_INSENSITIVE;
+-
+-                if (trough_under_steppers)
+-                    grooveRect = option->rect;
+-
+-                gtkPainter->paintBox(scrollbarWidget, "trough", grooveRect, state, GTK_SHADOW_IN, style);
+-            }
+-
+-            //paint slider
+-            if (scrollBar->subControls & SC_ScrollBarSlider) {
+-                GtkStateType state = GTK_STATE_NORMAL;
+-
+-                if (!(option->state & State_Enabled))
+-                    state = GTK_STATE_INSENSITIVE;
+-                else if (activate_slider &&
+-                         option->state & State_Sunken && (scrollBar->activeSubControls & SC_ScrollBarSlider))
+-                    state = GTK_STATE_ACTIVE;
+-                else if (option->state & State_MouseOver && (scrollBar->activeSubControls & SC_ScrollBarSlider))
+-                    state = GTK_STATE_PRELIGHT;
+-
+-                GtkShadowType shadow = GTK_SHADOW_OUT;
+-
+-                if (trough_under_steppers) {
+-                    if (!horizontal)
+-                        scrollBarSlider.adjust(trough_border, 0, -trough_border, 0);
+-                    else
+-                        scrollBarSlider.adjust(0, trough_border, 0, -trough_border);
+-                }
+-
+-                gtkPainter->paintSlider(scrollbarWidget, "slider", scrollBarSlider, state, shadow, style,
+-                                        horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL, QString(QLS("%0%1")).arg(fakePos).arg(maximum));
+-            }
+-
+-            if (scrollBar->subControls & SC_ScrollBarAddLine) {
+-                GtkAllocation vAllocation;
+-                vAllocation.y = scrollBarAddLine.top();
+-                vAllocation.height = scrollBarAddLine.height() - rect.height() + 6;
+-                d->gtk_widget_set_allocation(gtkVScrollBar, &vAllocation);
+-
+-                GtkAllocation hAllocation;
+-                hAllocation.x = scrollBarAddLine.right();
+-                hAllocation.width = scrollBarAddLine.width() - rect.width();
+-                d->gtk_widget_set_allocation(gtkHScrollBar, &hAllocation);
+-
+-                GtkShadowType shadow = GTK_SHADOW_OUT;
+-                GtkStateType state = GTK_STATE_NORMAL;
+-
+-                if (!(option->state & State_Enabled) || (fakePos == maximum))
+-                    state = GTK_STATE_INSENSITIVE;
+-                else if (option->state & State_Sunken && (scrollBar->activeSubControls & SC_ScrollBarAddLine)) {
+-                    state = GTK_STATE_ACTIVE;
+-                    shadow = GTK_SHADOW_IN;
+-
+-                } else if (option->state & State_MouseOver && (scrollBar->activeSubControls & SC_ScrollBarAddLine))
+-                    state = GTK_STATE_PRELIGHT;
+-
+-                gtkPainter->paintBox(scrollbarWidget,
+-                                     horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine,
+-                                     state, shadow, style, QLS("add"));
+-
+-                gtkPainter->paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarAddLine.adjusted(4, 4, -4, -4),
+-                                       horizontal ? (reverse ? GTK_ARROW_LEFT : GTK_ARROW_RIGHT) :
+-                                       GTK_ARROW_DOWN, state, GTK_SHADOW_NONE, false, style);
++                fr.QStyleOption::operator=(*toolbutton);
++                fr.rect = proxy()->subControlRect(CC_ToolButton, toolbutton, SC_ToolButton, widget);
++                fr.rect.adjust(1, 1, -1, -1);
++                proxy()->drawPrimitive(PE_FrameFocusRect, &fr, painter, widget);
+             }
+ 
+-            if (scrollBar->subControls & SC_ScrollBarSubLine) {
+-                GtkAllocation vAllocation;
+-                vAllocation.y = 0;
+-                vAllocation.height = scrollBarSubLine.height();
+-                d->gtk_widget_set_allocation(gtkVScrollBar, &vAllocation);
++            QStyleOptionToolButton label = *toolbutton;
++            label.state = bflags;
++            GtkWidget *gtkButton = d->gtkWidget("GtkToolButton.GtkButton");
++            QPalette pal = toolbutton->palette;
++            if (option->state & State_Enabled &&
++                option->state & State_MouseOver && !(widget && widget->testAttribute(Qt::WA_SetPalette))) {
++                GdkColor gdkText = d->gtk_widget_get_style(gtkButton)->fg[GTK_STATE_PRELIGHT];
++                QColor textColor = QColor(gdkText.red>>8, gdkText.green>>8, gdkText.blue>>8);
++                pal.setBrush(QPalette::All, QPalette::ButtonText, textColor);
++                label.palette = pal;
++            }
++            label.rect = button.adjusted(style->xthickness, style->ythickness,
++                                        -style->xthickness - popupArrowSize, -style->ythickness);
++            proxy()->drawControl(CE_ToolButtonLabel, &label, painter, widget);
+ 
+-                GtkAllocation hAllocation;
+-                hAllocation.x = 0;
+-                hAllocation.width = scrollBarSubLine.width();
+-                d->gtk_widget_set_allocation(gtkHScrollBar, &hAllocation);
++            if (toolbutton->subControls & SC_ToolButtonMenu) {
++                tool.rect = menuarea;
++                tool.state = mflags;
++                if ((mflags & State_Enabled && (mflags & (State_Sunken | State_Raised | State_MouseOver))) || !(mflags & State_AutoRaise))
++                    proxy()->drawPrimitive(PE_IndicatorButtonDropDown, &tool, painter, widget);
+ 
+-                GtkShadowType shadow = GTK_SHADOW_OUT;
+-                GtkStateType state = GTK_STATE_NORMAL;
++                proxy()->drawPrimitive(PE_IndicatorArrowDown, &tool, painter, widget);
+ 
+-                if (!(option->state & State_Enabled) || (fakePos == 0))
+-                    state = GTK_STATE_INSENSITIVE;
+-                else if (option->state & State_Sunken && (scrollBar->activeSubControls & SC_ScrollBarSubLine)) {
+-                    shadow = GTK_SHADOW_IN;
+-                    state = GTK_STATE_ACTIVE;
++            } else if (drawMenuArrow) {
++                QRect ir = toolbutton->rect;
++                QStyleOptionToolButton newBtn = *toolbutton;
++                newBtn.rect = QRect(ir.right() - popupArrowSize - style->xthickness - 3, ir.height()/2 - 1, popupArrowSize, popupArrowSize);
++                proxy()->drawPrimitive(PE_IndicatorArrowDown, &newBtn, painter, widget);
++            }
++        }
++        break;
+ 
+-                } else if (option->state & State_MouseOver && (scrollBar->activeSubControls & SC_ScrollBarSubLine))
+-                    state = GTK_STATE_PRELIGHT;
++#endif // QT_NO_TOOLBUTTON
++#ifndef QT_NO_SCROLLBAR
+ 
+-                gtkPainter->paintBox(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine,
+-                                     state, shadow, style, QLS("sub"));
++    case CC_ScrollBar:
++        drawScrollBar<QStyleOptionSlider>(option, control, d, widget, gtkPainter, painter, style, proxy());
++        break;
+ 
+-                gtkPainter->paintArrow(scrollbarWidget, horizontal ? "hscrollbar" : "vscrollbar", scrollBarSubLine.adjusted(4, 4, -4, -4),
+-                                       horizontal ? (reverse ? GTK_ARROW_RIGHT : GTK_ARROW_LEFT) :
+-                                       GTK_ARROW_UP, state, GTK_SHADOW_NONE, false, style);
+-            }
+-        }
++    case CC_ScrollBar64:
++        drawScrollBar<QStyleOptionSlider64>(option, control, d, widget, gtkPainter, painter, style, proxy());
+         break;
+ 
+ #endif //QT_NO_SCROLLBAR
+@@ -2457,189 +2663,10 @@ void QGtkStyle::drawComplexControl(Compl
+ #ifndef QT_NO_SLIDER
+ 
+     case CC_Slider:
+-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+-            GtkWidget *hScaleWidget = d->gtkWidget("GtkHScale");
+-            GtkWidget *vScaleWidget = d->gtkWidget("GtkVScale");
+-
+-            QRect groove = proxy()->subControlRect(CC_Slider, option, SC_SliderGroove, widget);
+-            QRect handle = proxy()->subControlRect(CC_Slider, option, SC_SliderHandle, widget);
+-
+-            bool horizontal = slider->orientation == Qt::Horizontal;
+-            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
+-            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
+-
+-            QBrush oldBrush = painter->brush();
+-            QPen oldPen = painter->pen();
+-
+-            QColor shadowAlpha(Qt::black);
+-            shadowAlpha.setAlpha(10);
+-            QColor highlightAlpha(Qt::white);
+-            highlightAlpha.setAlpha(80);
+-
+-            QGtkStylePrivate::gtk_widget_set_direction(hScaleWidget, slider->upsideDown ?
+-                                                       GTK_TEXT_DIR_RTL : GTK_TEXT_DIR_LTR);
+-            GtkWidget *scaleWidget = horizontal ? hScaleWidget : vScaleWidget;
+-            style = d->gtk_widget_get_style(scaleWidget);
+-
+-            if ((option->subControls & SC_SliderGroove) && groove.isValid()) {
+-
+-                GtkRange *range = (GtkRange*)scaleWidget;
+-                GtkAdjustment *adjustment = 0;
+-                if (d->gtk_adjustment_configure)
+-                    adjustment = d->gtk_range_get_adjustment(range);
+-                if (adjustment) {
+-                    d->gtk_adjustment_configure(adjustment,
+-                                                slider->sliderPosition,
+-                                                slider->minimum,
+-                                                slider->maximum,
+-                                                slider->singleStep,
+-                                                slider->singleStep,
+-                                                slider->pageStep);
+-                } else {
+-                    adjustment = (GtkAdjustment*)d->gtk_adjustment_new(slider->sliderPosition,
+-                                                                       slider->minimum,
+-                                                                       slider->maximum,
+-                                                                       slider->singleStep,
+-                                                                       slider->singleStep,
+-                                                                       slider->pageStep);
+-                    d->gtk_range_set_adjustment(range, adjustment);
+-                }
+-
+-                int outerSize;
+-                d->gtk_range_set_inverted(range, !horizontal);
+-                d->gtk_widget_style_get(scaleWidget, "trough-border", &outerSize, NULL);
+-                outerSize++;
+-
+-                GtkStateType state = qt_gtk_state(option);
+-                int focusFrameMargin = 2;
+-                QRect grooveRect = option->rect.adjusted(focusFrameMargin, outerSize + focusFrameMargin,
+-                                   -focusFrameMargin, -outerSize - focusFrameMargin);
+-
+-                gboolean trough_side_details = false; // Indicates if the upper or lower scale background differs
+-                if (!d->gtk_check_version(2, 10, 0))
+-                    d->gtk_widget_style_get((GtkWidget*)(scaleWidget), "trough-side-details", &trough_side_details, NULL);
+-
+-                if (!trough_side_details) {
+-                    gtkPainter->paintBox(scaleWidget, "trough", grooveRect, state,
+-                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
+-                } else {
+-                    QRect upperGroove = grooveRect;
+-                    QRect lowerGroove = grooveRect;
+-
+-                    if (horizontal) {
+-                        if (slider->upsideDown) {
+-                            lowerGroove.setLeft(handle.center().x());
+-                            upperGroove.setRight(handle.center().x());
+-                        } else {
+-                            upperGroove.setLeft(handle.center().x());
+-                            lowerGroove.setRight(handle.center().x());
+-                        }
+-                    } else {
+-                        if (!slider->upsideDown) {
+-                            lowerGroove.setBottom(handle.center().y());
+-                            upperGroove.setTop(handle.center().y());
+-                        } else {
+-                            upperGroove.setBottom(handle.center().y());
+-                            lowerGroove.setTop(handle.center().y());
+-                        }
+-                    }
+-
+-                    gtkPainter->paintBox(scaleWidget, "trough-upper", upperGroove, state,
+-                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
+-                    gtkPainter->paintBox(scaleWidget, "trough-lower", lowerGroove, state,
+-                                         GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
+-                }
+-            }
+-
+-            if (option->subControls & SC_SliderTickmarks) {
+-                painter->setPen(darkOutline);
+-                int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
+-                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
+-                int interval = slider->tickInterval;
+-
+-                if (interval <= 0) {
+-                    interval = slider->singleStep;
+-
+-                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
+-                                                        available)
+-                            - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
+-                                                              0, available) < 3)
+-                        interval = slider->pageStep;
+-                }
+-
+-                if (interval <= 0)
+-                    interval = 1;
+-
+-                int v = slider->minimum;
+-                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
+-                while (v <= slider->maximum + 1) {
+-                    if (v == slider->maximum + 1 && interval == 1)
+-                        break;
+-                    const int v_ = qMin(v, slider->maximum);
+-                    int pos = sliderPositionFromValue(slider->minimum, slider->maximum,
+-                                                      v_, (horizontal
+-                                                           ? slider->rect.width()
+-                                                           : slider->rect.height()) - len,
+-                                                      slider->upsideDown) + len / 2;
+-                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
+-                    if (horizontal) {
+-                        if (ticksAbove)
+-                            painter->drawLine(pos, slider->rect.top() + extra,
+-                                              pos, slider->rect.top() + tickSize);
+-                        if (ticksBelow)
+-                            painter->drawLine(pos, slider->rect.bottom() - extra,
+-                                              pos, slider->rect.bottom() - tickSize);
+-
+-                    } else {
+-                        if (ticksAbove)
+-                            painter->drawLine(slider->rect.left() + extra, pos,
+-                                              slider->rect.left() + tickSize, pos);
+-                        if (ticksBelow)
+-                            painter->drawLine(slider->rect.right() - extra, pos,
+-                                              slider->rect.right() - tickSize, pos);
+-                    }
+-
+-                    // In the case where maximum is max int
+-                    int nextInterval = v + interval;
+-                    if (nextInterval < v)
+-                        break;
+-                    v = nextInterval;
+-                }
+-            }
+-
+-            // Draw slider handle
+-            if (option->subControls & SC_SliderHandle) {
+-                GtkShadowType shadow =  GTK_SHADOW_OUT;
+-                GtkStateType state = GTK_STATE_NORMAL;
+-
+-                if (!(option->state & State_Enabled))
+-                    state = GTK_STATE_INSENSITIVE;
+-                else if (option->state & State_MouseOver && option->activeSubControls & SC_SliderHandle)
+-                    state = GTK_STATE_PRELIGHT;
+-
+-                bool horizontal = option->state & State_Horizontal;
+-
+-                if (slider->state & State_HasFocus) {
+-                    QStyleOptionFocusRect fropt;
+-                    fropt.QStyleOption::operator=(*slider);
+-                    fropt.rect = slider->rect.adjusted(-1, -1 ,1, 1);
+-
+-                    if (horizontal) {
+-                        fropt.rect.setTop(handle.top() - 3);
+-                        fropt.rect.setBottom(handle.bottom() + 4);
+-
+-                    } else {
+-                        fropt.rect.setLeft(handle.left() - 3);
+-                        fropt.rect.setRight(handle.right() + 3);
+-                    }
+-                    proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
+-                }
+-                gtkPainter->paintSlider(scaleWidget, horizontal ? "hscale" : "vscale", handle, state, shadow, style,
+-                                        horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL);
+-            }
+-            painter->setBrush(oldBrush);
+-            painter->setPen(oldPen);
+-        }
++        drawSlider<QStyleOptionSlider>(control, option, d, widget, gtkPainter, painter, style, proxy());
++        break;
++    case CC_Slider64:
++        drawSlider<QStyleOptionSlider64>(control, option, d, widget, gtkPainter, painter, style, proxy());
+         break;
+     case CC_Dial:
+         if (const QStyleOptionSlider *dial = qstyleoption_cast<const QStyleOptionSlider *>(option))
+@@ -3548,29 +3575,19 @@ void QGtkStyle::drawControl(ControlEleme
+     }
+ }
+ 
+-/*!
+-  \reimp
+-*/
+-QRect QGtkStyle::subControlRect(ComplexControl control, const QStyleOptionComplex *option,
+-                                SubControl subControl, const QWidget *widget) const
++template <class OptionStyle>
++static void subControlRectSlider(QStyle::ComplexControl control, const QStyleOptionComplex *option,
++                                 QStyle::SubControl subControl, const QWidget *widget,
++                                 QStyle const* proxy,
++                                 QRect& rect)
+ {
+-    Q_D(const QGtkStyle);
+-
+-    QRect rect = QCommonStyle::subControlRect(control, option, subControl, widget);
+-    if (!d->isThemeAvailable())
+-        return QCommonStyle::subControlRect(control, option, subControl, widget);
+-
+-    switch (control) {
+-    case CC_ScrollBar:
+-        break;
+-    case CC_Slider:
+-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
+-            int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
++        if (const OptionStyle *slider = qstyleoption_cast<const OptionStyle *>(option)) {
++            int tickSize = proxy->pixelMetric(QStyle::PM_SliderTickmarkOffset, option, widget);
+             switch (subControl) {
+-            case SC_SliderHandle: {
++            case QStyle::SC_SliderHandle: {
+                 if (slider->orientation == Qt::Horizontal) {
+-                    rect.setHeight(proxy()->pixelMetric(PM_SliderThickness));
+-                    rect.setWidth(proxy()->pixelMetric(PM_SliderLength));
++                    rect.setHeight(proxy->pixelMetric(QStyle::PM_SliderThickness));
++                    rect.setWidth(proxy->pixelMetric(QStyle::PM_SliderLength));
+                     int centerY = slider->rect.center().y() - rect.height() / 2;
+                     if (slider->tickPosition & QSlider::TicksAbove)
+                         centerY += tickSize;
+@@ -3578,8 +3595,8 @@ QRect QGtkStyle::subControlRect(ComplexC
+                         centerY -= tickSize;
+                     rect.moveTop(centerY);
+                 } else {
+-                    rect.setWidth(proxy()->pixelMetric(PM_SliderThickness));
+-                    rect.setHeight(proxy()->pixelMetric(PM_SliderLength));
++                    rect.setWidth(proxy->pixelMetric(QStyle::PM_SliderThickness));
++                    rect.setHeight(proxy->pixelMetric(QStyle::PM_SliderLength));
+                     int centerX = slider->rect.center().x() - rect.width() / 2;
+                     if (slider->tickPosition & QSlider::TicksAbove)
+                         centerX += tickSize;
+@@ -3589,7 +3606,7 @@ QRect QGtkStyle::subControlRect(ComplexC
+                 }
+             }
+                 break;
+-            case SC_SliderGroove: {
++            case QStyle::SC_SliderGroove: {
+                 QPoint grooveCenter = slider->rect.center();
+                 if (slider->orientation == Qt::Horizontal) {
+                     rect.setHeight(7);
+@@ -3611,6 +3628,29 @@ QRect QGtkStyle::subControlRect(ComplexC
+                 break;
+             }
+         }
++}
++
++/*!
++  \reimp
++*/
++QRect QGtkStyle::subControlRect(ComplexControl control, const QStyleOptionComplex *option,
++                                SubControl subControl, const QWidget *widget) const
++{
++    Q_D(const QGtkStyle);
++
++    QRect rect = QCommonStyle::subControlRect(control, option, subControl, widget);
++    if (!d->isThemeAvailable())
++        return QCommonStyle::subControlRect(control, option, subControl, widget);
++
++    switch (control) {
++    case CC_ScrollBar:
++        break;
++    case CC_Slider:
++        subControlRectSlider<QStyleOptionSlider>(control, option, subControl, widget, proxy(), rect);
++        break;
++
++    case CC_Slider64:
++        subControlRectSlider<QStyleOptionSlider64>(control, option, subControl, widget, proxy(), rect);
+         break;
+ 
+ #ifndef QT_NO_GROUPBOX
+--- qtbase-opensource-src-5.3.2+dfsg.orig/src/widgets/styles/qstyle.cpp
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/styles/qstyle.cpp
+@@ -2142,6 +2142,16 @@ Qt::Alignment QStyle::visualAlignment(Qt
+ }
+ 
+ /*!
++    Implemented for ABI compatibility.
++*/
++
++int QStyle::sliderPositionFromValue(int min, int max, int logicalValue, int span, bool upsideDown)
++{
++	return sliderPositionFromValue((qint64) min, (qint64) max, (qint64) logicalValue, (qint64) span, upsideDown);
++}
++
++
++/*!
+     Converts the given \a logicalValue to a pixel position. The \a min
+     parameter maps to 0, \a max maps to \a span and other values are
+     distributed evenly in-between.
+@@ -2156,24 +2166,24 @@ Qt::Alignment QStyle::visualAlignment(Qt
+     \sa sliderValueFromPosition()
+ */
+ 
+-int QStyle::sliderPositionFromValue(int min, int max, int logicalValue, int span, bool upsideDown)
++int QStyle::sliderPositionFromValue(qint64 min, qint64 max, qint64 logicalValue, qint64 span, bool upsideDown)
+ {
+     if (span <= 0 || logicalValue < min || max <= min)
+         return 0;
+     if (logicalValue > max)
+         return upsideDown ? span : min;
+ 
+-    uint range = max - min;
+-    uint p = upsideDown ? max - logicalValue : logicalValue - min;
++    quint64 range = max - min;
++    quint64 p = upsideDown ? max - logicalValue : logicalValue - min;
+ 
+     if (range > (uint)INT_MAX/4096) {
+         double dpos = (double(p))/(double(range)/span);
+-        return int(dpos);
++        return qint64(dpos);
+     } else if (range > (uint)span) {
+         return (2 * p * span + range) / (2*range);
+     } else {
+-        uint div = span / range;
+-        uint mod = span % range;
++        quint64 div = span / range;
++        quint64 mod = span % range;
+         return p * div + (2 * p * mod + range) / (2 * range);
+     }
+     // equiv. to (p * span) / range + 0.5
+@@ -2182,6 +2192,14 @@ int QStyle::sliderPositionFromValue(int
+ }
+ 
+ /*!
++    Implemented for ABI compatibility.
++*/
++int QStyle::sliderValueFromPosition(int min, int max, int pos, int span, bool upsideDown)
++{
++	return sliderValueFromPosition((qint64) min, (qint64) max, pos, (qint64) span, upsideDown);
++}
++
++/*!
+     \fn int QStyle::sliderValueFromPosition(int min, int max, int position, int span, bool upsideDown)
+ 
+     Converts the given pixel \a position to a logical value. 0 maps to
+@@ -2199,22 +2217,22 @@ int QStyle::sliderPositionFromValue(int
+     \sa sliderPositionFromValue()
+ */
+ 
+-int QStyle::sliderValueFromPosition(int min, int max, int pos, int span, bool upsideDown)
++qint64 QStyle::sliderValueFromPosition(qint64 min, qint64 max, int pos, qint64 span, bool upsideDown)
+ {
+     if (span <= 0 || pos <= 0)
+         return upsideDown ? max : min;
+     if (pos >= span)
+         return upsideDown ? min : max;
+ 
+-    uint range = max - min;
++    quint64 range = max - min;
+ 
+     if ((uint)span > range) {
+-        int tmp = (2 * pos * range + span) / (2 * span);
++        qint64 tmp = (2 * pos * range + span) / (2 * span);
+         return upsideDown ? max - tmp : tmp + min;
+     } else {
+-        uint div = range / span;
+-        uint mod = range % span;
+-        int tmp = pos * div + (2 * pos * mod + span) / (2 * span);
++        quint64 div = range / span;
++        quint64 mod = range % span;
++        qint64 tmp = pos * div + (2 * pos * mod + span) / (2 * span);
+         return upsideDown ? max - tmp : tmp + min;
+     }
+     // equiv. to min + (pos*range)/span + 0.5
+--- qtbase-opensource-src-5.3.2+dfsg.orig/src/widgets/styles/qstyle.h
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/styles/qstyle.h
+@@ -364,6 +364,8 @@ public:
+         CC_Dial,
+         CC_GroupBox,
+         CC_MdiControls,
++        CC_ScrollBar64,
++        CC_Slider64,
+ 
+         // do not add any values below/greater than this
+         CC_CustomBase = 0xf0000000
+@@ -804,6 +806,10 @@ public:
+                                        bool upsideDown = false);
+     static int sliderValueFromPosition(int min, int max, int pos, int space,
+                                        bool upsideDown = false);
++	static int sliderPositionFromValue(qint64 min, qint64 max, qint64 val, qint64 space,
++                                       bool upsideDown = false);
++	static qint64 sliderValueFromPosition(qint64 min, qint64 max, int pos, qint64 space,
++                                       bool upsideDown = false);
+     static Qt::Alignment visualAlignment(Qt::LayoutDirection direction, Qt::Alignment alignment);
+     static QRect alignedRect(Qt::LayoutDirection direction, Qt::Alignment alignment,
+                              const QSize &size, const QRect &rectangle);
+--- qtbase-opensource-src-5.3.2+dfsg.orig/src/widgets/styles/qstyleoption.cpp
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/styles/qstyleoption.cpp
+@@ -2143,6 +2143,25 @@ QStyleOptionSlider::QStyleOptionSlider(i
+ 
+     \sa QAbstractSlider::pageStep
+ */
++
++QStyleOptionSlider64::QStyleOptionSlider64()
++    : QStyleOptionComplex(Version, SO_Slider64), orientation(Qt::Horizontal), minimum(0), maximum(0),
++      tickPosition(QSlider::NoTicks), tickInterval(0), upsideDown(false),
++      sliderPosition(0), sliderValue(0), singleStep(0), pageStep(0), notchTarget(0.0),
++      dialWrapping(false)
++{
++}
++
++/*!
++    \internal
++*/
++QStyleOptionSlider64::QStyleOptionSlider64(int version)
++    : QStyleOptionComplex(version, SO_Slider64), orientation(Qt::Horizontal), minimum(0), maximum(0),
++      tickPosition(QSlider::NoTicks), tickInterval(0), upsideDown(false),
++      sliderPosition(0), sliderValue(0), singleStep(0), pageStep(0), notchTarget(0.0),
++      dialWrapping(false)
++{
++}
+ #endif // QT_NO_SLIDER
+ 
+ #ifndef QT_NO_SPINBOX
+--- qtbase-opensource-src-5.3.2+dfsg.orig/src/widgets/styles/qstyleoption.h
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/styles/qstyleoption.h
+@@ -71,7 +71,7 @@ public:
+                       SO_TabBarBase, SO_RubberBand, SO_ToolBar, SO_GraphicsItem,
+ 
+                       SO_Complex = 0xf0000, SO_Slider, SO_SpinBox, SO_ToolButton, SO_ComboBox,
+-                      SO_TitleBar, SO_GroupBox, SO_SizeGrip,
++                      SO_TitleBar, SO_GroupBox, SO_SizeGrip, SO_Slider64,
+ 
+                       SO_CustomBase = 0xf00,
+                       SO_ComplexCustomBase = 0xf000000
+@@ -526,6 +526,33 @@ public:
+ protected:
+     QStyleOptionSlider(int version);
+ };
++
++class Q_GUI_EXPORT QStyleOptionSlider64: public QStyleOptionComplex
++{
++public:
++    enum StyleOptionType { Type = SO_Slider64 };
++    enum StyleOptionVersion { Version = 1 };
++
++    Qt::Orientation orientation;
++    qint64 minimum;
++    qint64 maximum;
++    QSlider::TickPosition tickPosition;
++    int tickInterval;
++    bool upsideDown;
++    qint64 sliderPosition;
++    qint64 sliderValue;
++    qint64 singleStep;
++    qint64 pageStep;
++    qreal notchTarget;
++    bool dialWrapping;
++
++    QStyleOptionSlider64();
++    QStyleOptionSlider64(const QStyleOptionSlider64 &other) : QStyleOptionComplex(Version, Type) { *this = other; }
++
++protected:
++    QStyleOptionSlider64(int version);
++};
++
+ #endif // QT_NO_SLIDER
+ 
+ #ifndef QT_NO_SPINBOX
+--- /dev/null
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/widgets/qabstractslider64.cpp
+@@ -0,0 +1,1014 @@
++/****************************************************************************
++**
++** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
++** All rights reserved.
++** Contact: Nokia Corporation (qt-info@nokia.com)
++**
++** This file is part of the QtGui module of the Qt Toolkit.
++**
++** $QT_BEGIN_LICENSE:LGPL$
++** GNU Lesser General Public License Usage
++** This file may be used under the terms of the GNU Lesser General Public
++** License version 2.1 as published by the Free Software Foundation and
++** appearing in the file LICENSE.LGPL included in the packaging of this
++** file. Please review the following information to ensure the GNU Lesser
++** General Public License version 2.1 requirements will be met:
++** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
++**
++** In addition, as a special exception, Nokia gives you certain additional
++** rights. These rights are described in the Nokia Qt LGPL Exception
++** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
++**
++** GNU General Public License Usage
++** Alternatively, this file may be used under the terms of the GNU General
++** Public License version 3.0 as published by the Free Software Foundation
++** and appearing in the file LICENSE.GPL included in the packaging of this
++** file. Please review the following information to ensure the GNU General
++** Public License version 3.0 requirements will be met:
++** http://www.gnu.org/copyleft/gpl.html.
++**
++** Other Usage
++** Alternatively, this file may be used in accordance with the terms and
++** conditions contained in a signed written agreement between you and Nokia.
++**
++**
++**
++**
++**
++** $QT_END_LICENSE$
++**
++****************************************************************************/
++
++#include <qapplication.h>
++#include "qabstractslider64.h"
++#include "qevent.h"
++#include "qabstractslider64_p.h"
++#include "qdebug.h"
++#ifndef QT_NO_ACCESSIBILITY
++#include "qaccessible.h"
++#endif
++#include <limits.h>
++#define __STDC_LIMIT_MACROS
++#include <stdint.h>
++
++QT_BEGIN_NAMESPACE
++
++/*!
++    \class QAbstractSlider64
++    \brief The QAbstractSlider64 class provides an integer value within a range.
++
++    \ingroup abstractwidgets
++
++    The class is designed as a common super class for widgets like
++    QScrollBar, QSlider and QDial.
++
++    Here are the main properties of the class:
++
++    \list 1
++
++    \i \l value: The bounded integer that QAbstractSlider64 maintains.
++
++    \i \l minimum: The lowest possible value.
++
++    \i \l maximum: The highest possible value.
++
++    \i \l singleStep: The smaller of two natural steps that an
++    abstract sliders provides and typically corresponds to the user
++    pressing an arrow key.
++
++    \i \l pageStep: The larger of two natural steps that an abstract
++    slider provides and typically corresponds to the user pressing
++    PageUp or PageDown.
++
++    \i \l tracking: Whether slider tracking is enabled.
++
++    \i \l sliderPosition: The current position of the slider. If \l
++    tracking is enabled (the default), this is identical to \l value.
++
++    \endlist
++
++    Unity (1) may be viewed as a third step size. setValue() lets you
++    set the current value to any integer in the allowed range, not
++    just minimum() + \e n * singleStep() for integer values of \e n.
++    Some widgets may allow the user to set any value at all; others
++    may just provide multiples of singleStep() or pageStep().
++
++    QAbstractSlider64 emits a comprehensive set of signals:
++
++    \table
++    \header \i Signal \i Emitted when
++    \row \i \l valueChanged()
++         \i the value has changed. The \l tracking
++            determines whether this signal is emitted during user
++            interaction.
++    \row \i \l sliderPressed()
++         \i the user starts to drag the slider.
++    \row \i \l sliderMoved()
++         \i the user drags the slider.
++    \row \i \l sliderReleased()
++         \i the user releases the slider.
++    \row \i \l actionTriggered()
++         \i a slider action was triggerd.
++    \row \i \l rangeChanged()
++         \i a the range has changed.
++    \endtable
++
++    QAbstractSlider64 provides a virtual sliderChange() function that is
++    well suited for updating the on-screen representation of
++    sliders. By calling triggerAction(), subclasses trigger slider
++    actions. Two helper functions QStyle::sliderPositionFromValue() and
++    QStyle::sliderValueFromPosition() help subclasses and styles to map
++    screen coordinates to logical range values.
++
++    \sa QAbstractSpinBox, QSlider, QDial, QScrollBar, {Sliders Example}
++*/
++
++/*!
++    \enum QAbstractSlider64::SliderAction
++
++    \value SliderNoAction
++    \value SliderSingleStepAdd
++    \value SliderSingleStepSub
++    \value SliderPageStepAdd
++    \value SliderPageStepSub
++    \value SliderToMinimum
++    \value SliderToMaximum
++    \value SliderMove
++
++*/
++
++/*!
++    \fn void QAbstractSlider64::valueChanged(int value)
++
++    This signal is emitted when the slider value has changed, with the
++    new slider \a value as argument.
++*/
++
++/*!
++    \fn void QAbstractSlider64::sliderPressed()
++
++    This signal is emitted when the user presses the slider with the
++    mouse, or programmatically when setSliderDown(true) is called.
++
++    \sa sliderReleased(), sliderMoved(), isSliderDown()
++*/
++
++/*!
++    \fn void QAbstractSlider64::sliderMoved(int value)
++
++    This signal is emitted when sliderDown is true and the slider moves. This
++    usually happens when the user is dragging the slider. The \a value
++    is the new slider position.
++
++    This signal is emitted even when tracking is turned off.
++
++    \sa setTracking(), valueChanged(), isSliderDown(),
++    sliderPressed(), sliderReleased()
++*/
++
++/*!
++    \fn void QAbstractSlider64::sliderReleased()
++
++    This signal is emitted when the user releases the slider with the
++    mouse, or programmatically when setSliderDown(false) is called.
++
++    \sa sliderPressed() sliderMoved() sliderDown
++*/
++
++/*!
++    \fn void QAbstractSlider64::rangeChanged(int min, int max)
++
++    This signal is emitted when the slider range has changed, with \a
++    min being the new minimum, and \a max being the new maximum.
++
++    \sa minimum, maximum
++*/
++
++/*!
++    \fn void QAbstractSlider64::actionTriggered(int action)
++
++    This signal is emitted when the slider action \a action is
++    triggered. Actions are \l SliderSingleStepAdd, \l
++    SliderSingleStepSub, \l SliderPageStepAdd, \l SliderPageStepSub,
++    \l SliderToMinimum, \l SliderToMaximum, and \l SliderMove.
++
++    When the signal is emitted, the \l sliderPosition has been
++    adjusted according to the action, but the \l value has not yet
++    been propagated (meaning the valueChanged() signal was not yet
++    emitted), and the visual display has not been updated. In slots
++    connected to this signal you can thus safely adjust any action by
++    calling setSliderPosition() yourself, based on both the action and
++    the slider's value.
++
++    \sa triggerAction()
++*/
++
++/*!
++    \enum QAbstractSlider64::SliderChange
++
++    \value SliderRangeChange
++    \value SliderOrientationChange
++    \value SliderStepsChange
++    \value SliderValueChange
++*/
++
++QAbstractSlider64Private::QAbstractSlider64Private()
++    : minimum(0), maximum(99), pageStep(10), value(0), position(0), pressValue(-1),
++      singleStep(1), offset_accumulated(0), tracking(true),
++      blocktracking(false), pressed(false),
++      invertedAppearance(false), invertedControls(false),
++      orientation(Qt::Horizontal), repeatAction(QAbstractSlider64::SliderNoAction)
++#ifdef QT_KEYPAD_NAVIGATION
++      , isAutoRepeating(false)
++      , repeatMultiplier(1)
++{
++    firstRepeat.invalidate();
++#else
++{
++#endif
++
++}
++
++QAbstractSlider64Private::~QAbstractSlider64Private()
++{
++}
++
++/*!
++    Sets the slider's minimum to \a min and its maximum to \a max.
++
++    If \a max is smaller than \a min, \a min becomes the only legal
++    value.
++
++    \sa minimum maximum
++*/
++void QAbstractSlider64::setRange(qint64 min, qint64 max)
++{
++    Q_D(QAbstractSlider64);
++    qint64 oldMin = d->minimum;
++    qint64 oldMax = d->maximum;
++    d->minimum = min;
++    d->maximum = qMax(min, max);
++    if (oldMin != d->minimum || oldMax != d->maximum) {
++        sliderChange(SliderRangeChange);
++        emit rangeChanged(d->minimum, d->maximum);
++        setValue(d->value); // re-bound
++    }
++}
++
++
++void QAbstractSlider64Private::setSteps(qint64 single, qint64 page)
++{
++    Q_Q(QAbstractSlider64);
++    singleStep = qAbs(single);
++    pageStep = qAbs(page);
++    q->sliderChange(QAbstractSlider64::SliderStepsChange);
++}
++
++/*!
++    Constructs an abstract slider.
++
++    The \a parent argument is sent to the QWidget constructor.
++
++    The \l minimum defaults to 0, the \l maximum to 99, with a \l
++    singleStep size of 1 and a \l pageStep size of 10, and an initial
++    \l value of 0.
++*/
++QAbstractSlider64::QAbstractSlider64(QWidget *parent)
++    :QWidget(*new QAbstractSlider64Private, parent, 0)
++{
++}
++
++/*! \internal */
++QAbstractSlider64::QAbstractSlider64(QAbstractSlider64Private &dd, QWidget *parent)
++    :QWidget(dd, parent, 0)
++{
++}
++
++/*!
++    Destroys the slider.
++*/
++QAbstractSlider64::~QAbstractSlider64()
++{
++}
++
++/*!
++    \property QAbstractSlider64::orientation
++    \brief the orientation of the slider
++
++    The orientation must be \l Qt::Vertical (the default) or \l
++    Qt::Horizontal.
++*/
++void QAbstractSlider64::setOrientation(Qt::Orientation orientation)
++{
++    Q_D(QAbstractSlider64);
++    if (d->orientation == orientation)
++        return;
++
++    d->orientation = orientation;
++    if (!testAttribute(Qt::WA_WState_OwnSizePolicy)) {
++        QSizePolicy sp = sizePolicy();
++        sp.transpose();
++        setSizePolicy(sp);
++        setAttribute(Qt::WA_WState_OwnSizePolicy, false);
++    }
++    update();
++    updateGeometry();
++}
++
++Qt::Orientation QAbstractSlider64::orientation() const
++{
++    Q_D(const QAbstractSlider64);
++    return d->orientation;
++}
++
++
++/*!
++    \property QAbstractSlider64::minimum
++    \brief the sliders's minimum value
++
++    When setting this property, the \l maximum is adjusted if
++    necessary to ensure that the range remains valid. Also the
++    slider's current value is adjusted to be within the new range.
++
++*/
++
++void QAbstractSlider64::setMinimum(qint64 min)
++{
++    Q_D(QAbstractSlider64);
++    setRange(min, qMax(d->maximum, min));
++}
++
++qint64 QAbstractSlider64::minimum() const
++{
++    Q_D(const QAbstractSlider64);
++    return d->minimum;
++}
++
++
++/*!
++    \property QAbstractSlider64::maximum
++    \brief the slider's maximum value
++
++    When setting this property, the \l minimum is adjusted if
++    necessary to ensure that the range remains valid.  Also the
++    slider's current value is adjusted to be within the new range.
++
++
++*/
++
++void QAbstractSlider64::setMaximum(qint64 max)
++{
++    Q_D(QAbstractSlider64);
++    setRange(qMin(d->minimum, max), max);
++}
++
++qint64 QAbstractSlider64::maximum() const
++{
++    Q_D(const QAbstractSlider64);
++    return d->maximum;
++}
++
++
++
++/*!
++    \property QAbstractSlider64::singleStep
++    \brief the single step.
++
++    The smaller of two natural steps that an
++    abstract sliders provides and typically corresponds to the user
++    pressing an arrow key.
++
++    If the property is modified during an auto repeating key event, behavior
++    is undefined.
++
++    \sa pageStep
++*/
++
++void QAbstractSlider64::setSingleStep(qint64 step)
++{
++    Q_D(QAbstractSlider64);
++    if (step != d->singleStep)
++        d->setSteps(step, d->pageStep);
++}
++
++qint64 QAbstractSlider64::singleStep() const
++{
++    Q_D(const QAbstractSlider64);
++    return d->singleStep;
++}
++
++
++/*!
++    \property QAbstractSlider64::pageStep
++    \brief the page step.
++
++    The larger of two natural steps that an abstract slider provides
++    and typically corresponds to the user pressing PageUp or PageDown.
++
++    \sa singleStep
++*/
++
++void QAbstractSlider64::setPageStep(qint64 step)
++{
++    Q_D(QAbstractSlider64);
++    if (step != d->pageStep)
++        d->setSteps(d->singleStep, step);
++}
++
++qint64 QAbstractSlider64::pageStep() const
++{
++    Q_D(const QAbstractSlider64);
++    return d->pageStep;
++}
++
++/*!
++    \property QAbstractSlider64::tracking
++    \brief whether slider tracking is enabled
++
++    If tracking is enabled (the default), the slider emits the
++    valueChanged() signal while the slider is being dragged. If
++    tracking is disabled, the slider emits the valueChanged() signal
++    only when the user releases the slider.
++
++    \sa sliderDown
++*/
++void QAbstractSlider64::setTracking(bool enable)
++{
++    Q_D(QAbstractSlider64);
++    d->tracking = enable;
++}
++
++bool QAbstractSlider64::hasTracking() const
++{
++    Q_D(const QAbstractSlider64);
++    return d->tracking;
++}
++
++
++/*!
++    \property QAbstractSlider64::sliderDown
++    \brief whether the slider is pressed down.
++
++    The property is set by subclasses in order to let the abstract
++    slider know whether or not \l tracking has any effect.
++
++    Changing the slider down property emits the sliderPressed() and
++    sliderReleased() signals.
++
++*/
++void QAbstractSlider64::setSliderDown(bool down)
++{
++    Q_D(QAbstractSlider64);
++    bool doEmit = d->pressed != down;
++
++    d->pressed = down;
++
++    if (doEmit) {
++        if (down)
++            emit sliderPressed();
++        else
++            emit sliderReleased();
++    }
++
++    if (!down && d->position != d->value)
++        triggerAction(SliderMove);
++}
++
++bool QAbstractSlider64::isSliderDown() const
++{
++    Q_D(const QAbstractSlider64);
++    return d->pressed;
++}
++
++
++/*!
++    \property QAbstractSlider64::sliderPosition
++    \brief the current slider position
++
++    If \l tracking is enabled (the default), this is identical to \l value.
++*/
++void QAbstractSlider64::setSliderPosition(qint64 position)
++{
++    Q_D(QAbstractSlider64);
++    position = d->bound(position);
++    if (position == d->position)
++        return;
++    d->position = position;
++    if (!d->tracking)
++        update();
++    if (d->pressed)
++        emit sliderMoved(position);
++    if (d->tracking && !d->blocktracking)
++        triggerAction(SliderMove);
++}
++
++qint64 QAbstractSlider64::sliderPosition() const
++{
++    Q_D(const QAbstractSlider64);
++    return d->position;
++}
++
++
++/*!
++    \property QAbstractSlider64::value
++    \brief the slider's current value
++
++    The slider forces the value to be within the legal range: \l
++    minimum <= \c value <= \l maximum.
++
++    Changing the value also changes the \l sliderPosition.
++*/
++
++
++qint64 QAbstractSlider64::value() const
++{
++    Q_D(const QAbstractSlider64);
++    return d->value;
++}
++
++void QAbstractSlider64::setValue(qint64 value)
++{
++    Q_D(QAbstractSlider64);
++    value = d->bound(value);
++    if (d->value == value && d->position == value)
++        return;
++    d->value = value;
++    if (d->position != value) {
++        d->position = value;
++        if (d->pressed)
++            emit sliderMoved((d->position = value));
++    }
++#ifndef QT_NO_ACCESSIBILITY
++    QAccessibleValueChangeEvent event(this, d->value);
++    QAccessible::updateAccessibility(&event);
++#endif
++    sliderChange(SliderValueChange);
++    emit valueChanged(value);
++}
++
++/*!
++    \property QAbstractSlider64::invertedAppearance
++    \brief whether or not a slider shows its values inverted.
++
++    If this property is false (the default), the minimum and maximum will
++    be shown in its classic position for the inherited widget. If the
++    value is true, the minimum and maximum appear at their opposite location.
++
++    Note: This property makes most sense for sliders and dials. For
++    scroll bars, the visual effect of the scroll bar subcontrols depends on
++    whether or not the styles understand inverted appearance; most styles
++    ignore this property for scroll bars.
++*/
++
++bool QAbstractSlider64::invertedAppearance() const
++{
++    Q_D(const QAbstractSlider64);
++    return d->invertedAppearance;
++}
++
++void QAbstractSlider64::setInvertedAppearance(bool invert)
++{
++    Q_D(QAbstractSlider64);
++    d->invertedAppearance = invert;
++    update();
++}
++
++
++/*!
++    \property QAbstractSlider64::invertedControls
++    \brief whether or not the slider inverts its wheel and key events.
++
++    If this property is false, scrolling the mouse wheel "up" and using keys
++    like page up will increase the slider's value towards its maximum. Otherwise
++    pressing page up will move value towards the slider's minimum.
++*/
++
++
++bool QAbstractSlider64::invertedControls() const
++{
++    Q_D(const QAbstractSlider64);
++    return d->invertedControls;
++}
++
++void QAbstractSlider64::setInvertedControls(bool invert)
++{
++    Q_D(QAbstractSlider64);
++    d->invertedControls = invert;
++}
++
++/*!  Triggers a slider \a action.  Possible actions are \l
++  SliderSingleStepAdd, \l SliderSingleStepSub, \l SliderPageStepAdd,
++  \l SliderPageStepSub, \l SliderToMinimum, \l SliderToMaximum, and \l
++  SliderMove.
++
++  \sa actionTriggered()
++ */
++void QAbstractSlider64::triggerAction(SliderAction action)
++{
++    Q_D(QAbstractSlider64);
++    d->blocktracking = true;
++    switch (action) {
++    case SliderSingleStepAdd:
++        setSliderPosition(d->overflowSafeAdd(d->effectiveSingleStep()));
++        break;
++    case SliderSingleStepSub:
++        setSliderPosition(d->overflowSafeAdd(-d->effectiveSingleStep()));
++        break;
++    case SliderPageStepAdd:
++        setSliderPosition(d->overflowSafeAdd(d->pageStep));
++        break;
++    case SliderPageStepSub:
++        setSliderPosition(d->overflowSafeAdd(-d->pageStep));
++        break;
++    case SliderToMinimum:
++        setSliderPosition(d->minimum);
++        break;
++    case SliderToMaximum:
++        setSliderPosition(d->maximum);
++        break;
++    case SliderMove:
++    case SliderNoAction:
++        break;
++    };
++    emit actionTriggered(action);
++    d->blocktracking = false;
++    setValue(d->position);
++}
++
++/*!  Sets action \a action to be triggered repetitively in intervals
++of \a repeatTime, after an initial delay of \a thresholdTime.
++
++\sa triggerAction() repeatAction()
++ */
++void QAbstractSlider64::setRepeatAction(SliderAction action, int thresholdTime, int repeatTime)
++{
++    Q_D(QAbstractSlider64);
++    if ((d->repeatAction = action) == SliderNoAction) {
++        d->repeatActionTimer.stop();
++    } else {
++        d->repeatActionTime = repeatTime;
++        d->repeatActionTimer.start(thresholdTime, this);
++    }
++}
++
++/*!
++  Returns the current repeat action.
++  \sa setRepeatAction()
++ */
++QAbstractSlider64::SliderAction QAbstractSlider64::repeatAction() const
++{
++    Q_D(const QAbstractSlider64);
++    return d->repeatAction;
++}
++
++/*!\reimp
++ */
++void QAbstractSlider64::timerEvent(QTimerEvent *e)
++{
++    Q_D(QAbstractSlider64);
++    if (e->timerId() == d->repeatActionTimer.timerId()) {
++        if (d->repeatActionTime) { // was threshold time, use repeat time next time
++            d->repeatActionTimer.start(d->repeatActionTime, this);
++            d->repeatActionTime = 0;
++        }
++        if (d->repeatAction == SliderPageStepAdd)
++            d->setAdjustedSliderPosition(d->overflowSafeAdd(d->pageStep));
++        else if (d->repeatAction == SliderPageStepSub)
++            d->setAdjustedSliderPosition(d->overflowSafeAdd(-d->pageStep));
++        else
++            triggerAction(d->repeatAction);
++    }
++}
++
++/*!
++    Reimplement this virtual function to track slider changes such as
++    \l SliderRangeChange, \l SliderOrientationChange, \l
++    SliderStepsChange, or \l SliderValueChange. The default
++    implementation only updates the display and ignores the \a change
++    parameter.
++ */
++void QAbstractSlider64::sliderChange(SliderChange)
++{
++    update();
++}
++
++/*!
++    \internal
++
++    Truncate qreal to int without flipping on overflow.
++*/
++static inline qint64 clampScrollStep(qreal x)
++{
++    return qint64(qBound(qreal(INT64_MIN), x, qreal(INT64_MAX)));
++}
++
++bool QAbstractSlider64Private::scrollByDelta(Qt::Orientation orientation, Qt::KeyboardModifiers modifiers, qint64 delta)
++{
++    Q_Q(QAbstractSlider64);
++    qint64 stepsToScroll = 0;
++    // in Qt scrolling to the right gives negative values.
++    if (orientation == Qt::Horizontal)
++        delta = -delta;
++    qreal offset = qreal(delta) / 120;
++
++    if ((modifiers & Qt::ControlModifier) || (modifiers & Qt::ShiftModifier)) {
++        // Scroll one page regardless of delta:
++        stepsToScroll = qBound(-pageStep, clampScrollStep(offset * pageStep), pageStep);
++        offset_accumulated = 0;
++    } else {
++        // Calculate how many lines to scroll. Depending on what delta is (and
++        // offset), we might end up with a fraction (e.g. scroll 1.3 lines). We can
++        // only scroll whole lines, so we keep the reminder until next event.
++        qreal stepsToScrollF =
++#ifndef QT_NO_WHEELEVENT
++                QApplication::wheelScrollLines() *
++#endif
++                offset * effectiveSingleStep();
++        // Check if wheel changed direction since last event:
++        if (offset_accumulated != 0 && (offset / offset_accumulated) < 0)
++            offset_accumulated = 0;
++
++        offset_accumulated += stepsToScrollF;
++#ifndef Q_WS_MAC
++        // Don't scroll more than one page in any case:
++        stepsToScroll = qBound(-pageStep, clampScrollStep(offset_accumulated), pageStep);
++#else
++        // Native UI-elements on Mac can scroll hundreds of lines at a time as
++        // a result of acceleration. So keep the same behaviour in Qt, and
++        // don't restrict stepsToScroll to certain maximum (pageStep):
++        stepsToScroll = clampScrollStep(offset_accumulated);
++#endif
++        offset_accumulated -= clampScrollStep(offset_accumulated);
++        if (stepsToScroll == 0)
++            return false;
++    }
++
++    if (invertedControls)
++        stepsToScroll = -stepsToScroll;
++
++    qint64 prevValue = value;
++    position = overflowSafeAdd(stepsToScroll); // value will be updated by triggerAction()
++    q->triggerAction(QAbstractSlider64::SliderMove);
++
++    if (prevValue == value) {
++        offset_accumulated = 0;
++        return false;
++    }
++    return true;
++}
++
++/*!
++    \reimp
++*/
++#ifndef QT_NO_WHEELEVENT
++void QAbstractSlider64::wheelEvent(QWheelEvent * e)
++{
++    Q_D(QAbstractSlider64);
++    e->ignore();
++    int delta = e->delta();
++    if (d->scrollByDelta(e->orientation(), e->modifiers(), delta))
++        e->accept();
++}
++
++#endif
++
++/*!
++    \reimp
++*/
++void QAbstractSlider64::keyPressEvent(QKeyEvent *ev)
++{
++    Q_D(QAbstractSlider64);
++    SliderAction action = SliderNoAction;
++#ifdef QT_KEYPAD_NAVIGATION
++    if (ev->isAutoRepeat()) {
++        if (!d->firstRepeat.isValid())
++            d->firstRepeat.start();
++        else if (1 == d->repeatMultiplier) {
++            // This is the interval in milli seconds which one key repetition
++            // takes.
++            const int repeatMSecs = d->firstRepeat.elapsed();
++
++            /**
++             * The time it takes to currently navigate the whole slider.
++             */
++            const qreal currentTimeElapse = (qreal(maximum()) / singleStep()) * repeatMSecs;
++
++            /**
++             * This is an arbitrarily determined constant in msecs that
++             * specifies how long time it should take to navigate from the
++             * start to the end(excluding starting key auto repeat).
++             */
++            const int SliderRepeatElapse = 2500;
++
++            d->repeatMultiplier = currentTimeElapse / SliderRepeatElapse;
++        }
++
++    }
++    else if (d->firstRepeat.isValid()) {
++        d->firstRepeat.invalidate();
++        d->repeatMultiplier = 1;
++    }
++
++#endif
++
++    switch (ev->key()) {
++#ifdef QT_KEYPAD_NAVIGATION
++        case Qt::Key_Select:
++            if (QApplication::keypadNavigationEnabled())
++                setEditFocus(!hasEditFocus());
++            else
++                ev->ignore();
++            break;
++        case Qt::Key_Back:
++            if (QApplication::keypadNavigationEnabled() && hasEditFocus()) {
++                setValue(d->origValue);
++                setEditFocus(false);
++            } else
++                ev->ignore();
++            break;
++#endif
++
++        // It seems we need to use invertedAppearance for Left and right, otherwise, things look weird.
++        case Qt::Key_Left:
++#ifdef QT_KEYPAD_NAVIGATION
++            // In QApplication::KeypadNavigationDirectional, we want to change the slider
++            // value if there is no left/right navigation possible and if this slider is not
++            // inside a tab widget.
++            if (QApplication::keypadNavigationEnabled()
++                    && (!hasEditFocus() && QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
++                    || d->orientation == Qt::Vertical
++                    || !hasEditFocus()
++                    && (QWidgetPrivate::canKeypadNavigate(Qt::Horizontal) || QWidgetPrivate::inTabWidget(this)))) {
++                ev->ignore();
++                return;
++            }
++            if (QApplication::keypadNavigationEnabled() && d->orientation == Qt::Vertical)
++                action = d->invertedControls ? SliderSingleStepSub : SliderSingleStepAdd;
++            else
++#endif
++            if (isRightToLeft())
++                action = d->invertedAppearance ? SliderSingleStepSub : SliderSingleStepAdd;
++            else
++                action = !d->invertedAppearance ? SliderSingleStepSub : SliderSingleStepAdd;
++            break;
++        case Qt::Key_Right:
++#ifdef QT_KEYPAD_NAVIGATION
++            // Same logic as in Qt::Key_Left
++            if (QApplication::keypadNavigationEnabled()
++                    && (!hasEditFocus() && QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
++                    || d->orientation == Qt::Vertical
++                    || !hasEditFocus()
++                    && (QWidgetPrivate::canKeypadNavigate(Qt::Horizontal) || QWidgetPrivate::inTabWidget(this)))) {
++                ev->ignore();
++                return;
++            }
++            if (QApplication::keypadNavigationEnabled() && d->orientation == Qt::Vertical)
++                action = d->invertedControls ? SliderSingleStepAdd : SliderSingleStepSub;
++            else
++#endif
++            if (isRightToLeft())
++                action = d->invertedAppearance ? SliderSingleStepAdd : SliderSingleStepSub;
++            else
++                action = !d->invertedAppearance ? SliderSingleStepAdd : SliderSingleStepSub;
++            break;
++        case Qt::Key_Up:
++#ifdef QT_KEYPAD_NAVIGATION
++            // In QApplication::KeypadNavigationDirectional, we want to change the slider
++            // value if there is no up/down navigation possible.
++            if (QApplication::keypadNavigationEnabled()
++                    && (QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
++                    || d->orientation == Qt::Horizontal
++                    || !hasEditFocus() && QWidgetPrivate::canKeypadNavigate(Qt::Vertical))) {
++                ev->ignore();
++                break;
++            }
++#endif
++            action = d->invertedControls ? SliderSingleStepSub : SliderSingleStepAdd;
++            break;
++        case Qt::Key_Down:
++#ifdef QT_KEYPAD_NAVIGATION
++            // Same logic as in Qt::Key_Up
++            if (QApplication::keypadNavigationEnabled()
++                    && (QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder
++                    || d->orientation == Qt::Horizontal
++                    || !hasEditFocus() && QWidgetPrivate::canKeypadNavigate(Qt::Vertical))) {
++                ev->ignore();
++                break;
++            }
++#endif
++            action = d->invertedControls ? SliderSingleStepAdd : SliderSingleStepSub;
++            break;
++        case Qt::Key_PageUp:
++            action = d->invertedControls ? SliderPageStepSub : SliderPageStepAdd;
++            break;
++        case Qt::Key_PageDown:
++            action = d->invertedControls ? SliderPageStepAdd : SliderPageStepSub;
++            break;
++        case Qt::Key_Home:
++            action = SliderToMinimum;
++            break;
++        case Qt::Key_End:
++            action = SliderToMaximum;
++            break;
++        default:
++            ev->ignore();
++            break;
++    }
++    if (action)
++        triggerAction(action);
++}
++
++/*!
++    \reimp
++*/
++void QAbstractSlider64::changeEvent(QEvent *ev)
++{
++    Q_D(QAbstractSlider64);
++    switch (ev->type()) {
++    case QEvent::EnabledChange:
++        if (!isEnabled()) {
++            d->repeatActionTimer.stop();
++            setSliderDown(false);
++        }
++        // fall through...
++    default:
++        QWidget::changeEvent(ev);
++    }
++}
++
++/*!
++    \reimp
++*/
++bool QAbstractSlider64::event(QEvent *e)
++{
++#ifdef QT_KEYPAD_NAVIGATION
++    Q_D(QAbstractSlider64);
++    switch (e->type()) {
++    case QEvent::FocusIn:
++        d->origValue = d->value;
++        break;
++    default:
++        break;
++    }
++#endif
++
++    return QWidget::event(e);
++}
++
++/*! \fn int QAbstractSlider64::minValue() const
++
++    Use minimum() instead.
++*/
++
++/*! \fn int QAbstractSlider64::maxValue() const
++
++    Use maximum() instead.
++*/
++
++/*! \fn int QAbstractSlider64::lineStep() const
++
++    Use singleStep() instead.
++*/
++
++/*! \fn void QAbstractSlider64::setMinValue(int v)
++
++    Use setMinimum() instead.
++*/
++
++/*! \fn void QAbstractSlider64::setMaxValue(int v)
++
++    Use setMaximum() instead.
++*/
++
++/*! \fn void QAbstractSlider64::setLineStep(int v)
++
++    Use setSingleStep() instead.
++*/
++
++/*! \fn void QAbstractSlider64::addPage()
++
++    Use triggerAction(QAbstractSlider64::SliderPageStepAdd) instead.
++*/
++
++/*! \fn void QAbstractSlider64::subtractPage()
++
++    Use triggerAction(QAbstractSlider64::SliderPageStepSub) instead.
++*/
++
++/*! \fn void QAbstractSlider64::addLine()
++
++    Use triggerAction(QAbstractSlider64::SliderSingleStepAdd) instead.
++*/
++
++/*! \fn void QAbstractSlider64::subtractLine()
++
++    Use triggerAction(QAbstractSlider64::SliderSingleStepSub) instead.
++*/
++
++/*! \fn void QAbstractSlider64::setSteps(int single, int page)
++
++    Use setSingleStep(\a single) followed by setPageStep(\a page)
++    instead.
++*/
++
++QT_END_NAMESPACE
+--- /dev/null
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/widgets/qabstractslider64.h
+@@ -0,0 +1,143 @@
++#ifndef QABSTRACTSLIDER64_H
++#define QABSTRACTSLIDER64_H
++
++#include <QtWidgets/qwidget.h>
++
++QT_BEGIN_HEADER
++
++QT_BEGIN_NAMESPACE
++
++QT_MODULE(Gui)
++
++class QAbstractSlider64Private;
++
++class Q_GUI_EXPORT QAbstractSlider64 : public QWidget
++{
++    Q_OBJECT
++
++    Q_PROPERTY(qint64 minimum READ minimum WRITE setMinimum)
++    Q_PROPERTY(qint64 maximum READ maximum WRITE setMaximum)
++    Q_PROPERTY(qint64 singleStep READ singleStep WRITE setSingleStep)
++    Q_PROPERTY(qint64 pageStep READ pageStep WRITE setPageStep)
++    Q_PROPERTY(qint64 value READ value WRITE setValue NOTIFY valueChanged USER true)
++    Q_PROPERTY(qint64 sliderPosition READ sliderPosition WRITE setSliderPosition NOTIFY sliderMoved)
++    Q_PROPERTY(bool tracking READ hasTracking WRITE setTracking)
++    Q_PROPERTY(Qt::Orientation orientation READ orientation WRITE setOrientation)
++    Q_PROPERTY(bool invertedAppearance READ invertedAppearance WRITE setInvertedAppearance)
++    Q_PROPERTY(bool invertedControls READ invertedControls WRITE setInvertedControls)
++    Q_PROPERTY(bool sliderDown READ isSliderDown WRITE setSliderDown DESIGNABLE false)
++
++public:
++    explicit QAbstractSlider64(QWidget *parent=0);
++    ~QAbstractSlider64();
++
++    Qt::Orientation orientation() const;
++
++    void setMinimum(qint64);
++    qint64 minimum() const;
++
++    void setMaximum(qint64);
++    qint64 maximum() const;
++
++    void setRange(qint64 min, qint64 max);
++
++    void setSingleStep(qint64);
++    qint64 singleStep() const;
++
++    void setPageStep(qint64);
++    qint64 pageStep() const;
++
++    void setTracking(bool enable);
++    bool hasTracking() const;
++
++    void setSliderDown(bool);
++    bool isSliderDown() const;
++
++    void setSliderPosition(qint64);
++    qint64 sliderPosition() const;
++
++    void setInvertedAppearance(bool);
++    bool invertedAppearance() const;
++
++    void setInvertedControls(bool);
++    bool invertedControls() const;
++
++    enum SliderAction {
++        SliderNoAction,
++        SliderSingleStepAdd,
++        SliderSingleStepSub,
++        SliderPageStepAdd,
++        SliderPageStepSub,
++        SliderToMinimum,
++        SliderToMaximum,
++        SliderMove
++    };
++
++    qint64 value() const;
++
++    void triggerAction(SliderAction action);
++
++public Q_SLOTS:
++    void setValue(qint64);
++    void setOrientation(Qt::Orientation);
++
++Q_SIGNALS:
++    void valueChanged(qint64 value);
++
++    void sliderPressed();
++    void sliderMoved(qint64 position);
++    void sliderReleased();
++
++    void rangeChanged(qint64 min, qint64 max);
++
++    void actionTriggered(int action);
++
++protected:
++    bool event(QEvent *e);
++
++    void setRepeatAction(SliderAction action, int thresholdTime = 500, int repeatTime = 50);
++    SliderAction repeatAction() const;
++
++    enum SliderChange {
++        SliderRangeChange,
++        SliderOrientationChange,
++        SliderStepsChange,
++        SliderValueChange
++    };
++    virtual void sliderChange(SliderChange change);
++
++    void keyPressEvent(QKeyEvent *ev);
++    void timerEvent(QTimerEvent *);
++#ifndef QT_NO_WHEELEVENT
++    void wheelEvent(QWheelEvent *e);
++#endif
++    void changeEvent(QEvent *e);
++
++#ifdef QT3_SUPPORT
++public:
++    inline QT3_SUPPORT qint64 minValue() const { return minimum(); }
++    inline QT3_SUPPORT qint64 maxValue() const { return maximum(); }
++    inline QT3_SUPPORT qint64 lineStep() const { return singleStep(); }
++    inline QT3_SUPPORT void setMinValue(qint64 v) { setMinimum(v); }
++    inline QT3_SUPPORT void setMaxValue(qint64 v) { setMaximum(v); }
++    inline QT3_SUPPORT void setLineStep(qint64 v) { setSingleStep(v); }
++    inline QT3_SUPPORT void setSteps(qint64 single, qint64 page) { setSingleStep(single); setPageStep(page); }
++    inline QT3_SUPPORT void addPage() { triggerAction(SliderPageStepAdd); }
++    inline QT3_SUPPORT void subtractPage() { triggerAction(SliderPageStepSub); }
++    inline QT3_SUPPORT void addLine() { triggerAction(SliderSingleStepAdd); }
++    inline QT3_SUPPORT void subtractLine() { triggerAction(SliderSingleStepSub); }
++#endif
++
++protected:
++    QAbstractSlider64(QAbstractSlider64Private &dd, QWidget *parent=0);
++
++private:
++    Q_DISABLE_COPY(QAbstractSlider64)
++    Q_DECLARE_PRIVATE(QAbstractSlider64)
++};
++
++QT_END_NAMESPACE
++
++QT_END_HEADER
++
++#endif // QABSTRACTSLIDER64_H
+--- /dev/null
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/widgets/qabstractslider64_p.h
+@@ -0,0 +1,106 @@
++#ifndef QABSTRACTSLIDER64_P_H
++#define QABSTRACTSLIDER64_P_H
++
++//
++//  W A R N I N G
++//  -------------
++//
++// This file is not part of the Qt API.  It exists purely as an
++// implementation detail.  This header file may change from version to
++// version without notice, or even be removed.
++//
++// We mean it.
++//
++
++#include "QtCore/qbasictimer.h"
++#include "QtCore/qelapsedtimer.h"
++#include "private/qwidget_p.h"
++#include "qstyle.h"
++
++QT_BEGIN_NAMESPACE
++
++class QAbstractSlider64Private : public QWidgetPrivate
++{
++    Q_DECLARE_PUBLIC(QAbstractSlider64)
++public:
++    QAbstractSlider64Private();
++    ~QAbstractSlider64Private();
++
++    void setSteps(qint64 single, qint64 page);
++
++    qint64 minimum, maximum, pageStep, value, position, pressValue;
++
++    /**
++     * Call effectiveSingleStep() when changing the slider value.
++     */
++    qint64 singleStep;
++
++    float offset_accumulated;
++    uint tracking : 1;
++    uint blocktracking :1;
++    uint pressed : 1;
++    uint invertedAppearance : 1;
++    uint invertedControls : 1;
++    Qt::Orientation orientation;
++
++    QBasicTimer repeatActionTimer;
++    int repeatActionTime;
++    QAbstractSlider64::SliderAction repeatAction;
++
++#ifdef QT_KEYPAD_NAVIGATION
++    qint64 origValue;
++
++    /**
++     */
++    bool isAutoRepeating;
++
++    /**
++     * When we're auto repeating, we multiply singleStep with this value to
++     * get our effective step.
++     */
++    qreal repeatMultiplier;
++
++    /**
++     * The time of when the first auto repeating key press event occurs.
++     */
++    QElapsedTimer firstRepeat;
++
++#endif
++
++    inline qint64 effectiveSingleStep() const
++    {
++        return singleStep
++#ifdef QT_KEYPAD_NAVIGATION
++        * repeatMultiplier
++#endif
++        ;
++    }
++
++    virtual qint64 bound(qint64 val) const { return qMax(minimum, qMin(maximum, val)); }
++    inline qint64 overflowSafeAdd(qint64 add) const
++    {
++        qint64 newValue = value + add;
++        if (add > 0 && newValue < value)
++            newValue = maximum;
++        else if (add < 0 && newValue > value)
++            newValue = minimum;
++        return newValue;
++    }
++    inline void setAdjustedSliderPosition(qint64 position)
++    {
++        Q_Q(QAbstractSlider64);
++        if (q->style()->styleHint(QStyle::SH_Slider_StopMouseOverSlider, 0, q)) {
++            if ((position > pressValue - 2 * pageStep) && (position < pressValue + 2 * pageStep)) {
++                repeatAction = QAbstractSlider64::SliderNoAction;
++                q->setSliderPosition(pressValue);
++                return;
++            }
++        }
++        q->triggerAction(repeatAction);
++    }
++    bool scrollByDelta(Qt::Orientation orientation, Qt::KeyboardModifiers modifiers, qint64 delta);
++};
++
++QT_END_NAMESPACE
++
++#endif // QABSTRACTSLIDER64_P_H
+--- /dev/null
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/widgets/qscrollbar64.cpp
+@@ -0,0 +1,764 @@
++/****************************************************************************
++**
++** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
++** All rights reserved.
++** Contact: Nokia Corporation (qt-info@nokia.com)
++**
++** This file is part of the QtGui module of the Qt Toolkit.
++**
++** $QT_BEGIN_LICENSE:LGPL$
++** GNU Lesser General Public License Usage
++** This file may be used under the terms of the GNU Lesser General Public
++** License version 2.1 as published by the Free Software Foundation and
++** appearing in the file LICENSE.LGPL included in the packaging of this
++** file. Please review the following information to ensure the GNU Lesser
++** General Public License version 2.1 requirements will be met:
++** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
++**
++** In addition, as a special exception, Nokia gives you certain additional
++** rights. These rights are described in the Nokia Qt LGPL Exception
++** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
++**
++** GNU General Public License Usage
++** Alternatively, this file may be used under the terms of the GNU General
++** Public License version 3.0 as published by the Free Software Foundation
++** and appearing in the file LICENSE.GPL included in the packaging of this
++** file. Please review the following information to ensure the GNU General
++** Public License version 3.0 requirements will be met:
++** http://www.gnu.org/copyleft/gpl.html.
++**
++** Other Usage
++** Alternatively, this file may be used in accordance with the terms and
++** conditions contained in a signed written agreement between you and Nokia.
++**
++**
++**
++**
++**
++** $QT_END_LICENSE$
++**
++****************************************************************************/
++
++#include "qapplication.h"
++#include "qcursor.h"
++#include "qevent.h"
++#include "qpainter.h"
++#include "qscrollbar64.h"
++#include "qstyle.h"
++#include "qstyleoption.h"
++#include "qmenu.h"
++#include <QtCore/qelapsedtimer.h>
++
++#ifndef QT_NO_SCROLLBAR
++
++#ifndef QT_NO_ACCESSIBILITY
++#include "qaccessible.h"
++#endif
++#include <limits.h>
++#include "qabstractslider64_p.h"
++
++QT_BEGIN_NAMESPACE
++
++/*!
++    \class QScrollBar64
++    \brief The QScrollBar64 widget provides a vertical or horizontal scroll bar.
++
++    \ingroup basicwidgets
++
++    A scroll bar is a control that enables the user to access parts of a
++    document that is larger than the widget used to display it. It provides
++    a visual indication of the user's current position within the document
++    and the amount of the document that is visible. Scroll bars are usually
++    equipped with other controls that enable more accurate navigation.
++    Qt displays scroll bars in a way that is appropriate for each platform.
++
++    If you need to provide a scrolling view onto another widget, it may be
++    more convenient to use the QScrollArea class because this provides a
++    viewport widget and scroll bars. QScrollBar64 is useful if you need to
++    implement similar functionality for specialized widgets using QAbstractScrollArea;
++    for example, if you decide to subclass QAbstractItemView.
++    For most other situations where a slider control is used to obtain a value
++    within a given range, the QSlider class may be more appropriate for your
++    needs.
++
++    \table
++    \row \o \image qscrollbar-picture.png
++    \o Scroll bars typically include four separate controls: a slider,
++    scroll arrows, and a page control.
++
++    \list
++    \o a. The slider provides a way to quickly go to any part of the
++    document, but does not support accurate navigation within large
++    documents.
++    \o b. The scroll arrows are push buttons which can be used to accurately
++    navigate to a particular place in a document. For a vertical scroll bar
++    connected to a text editor, these typically move the current position one
++    "line" up or down, and adjust the position of the slider by a small
++    amount. In editors and list boxes a "line" might mean one line of text;
++    in an image viewer it might mean 20 pixels.
++    \o c. The page control is the area over which the slider is dragged (the
++    scroll bar's background). Clicking here moves the scroll bar towards
++    the click by one "page". This value is usually the same as the length of
++    the slider.
++    \endlist
++    \endtable
++
++    Each scroll bar has a value that indicates how far the slider is from
++    the start of the scroll bar; this is obtained with value() and set
++    with setValue(). This value always lies within the range of values
++    defined for the scroll bar, from \l{QAbstractSlider64::minimum()}{minimum()}
++    to \l{QAbstractSlider64::minimum()}{maximum()} inclusive. The range of
++    acceptable values can be set with setMinimum() and setMaximum().
++    At the minimum value, the top edge of the slider (for a vertical scroll
++    bar) or left edge (for a horizontal scroll bar) will be at the top (or
++    left) end of the scroll bar. At the maximum value, the bottom (or right)
++    edge of the slider will be at the bottom (or right) end of the scroll bar.
++
++    The length of the slider is usually related to the value of the page step,
++    and typically represents the proportion of the document area shown in a
++    scrolling view. The page step is the amount that the value changes by
++    when the user presses the \key{Page Up} and \key{Page Down} keys, and is
++    set with setPageStep(). Smaller changes to the value defined by the
++    line step are made using the cursor keys, and this quantity is set with
++    \l{QAbstractSlider64::}{setSingleStep()}.
++
++    Note that the range of values used is independent of the actual size
++    of the scroll bar widget. You do not need to take this into account when
++    you choose values for the range and the page step.
++
++    The range of values specified for the scroll bar are often determined
++    differently to those for a QSlider because the length of the slider
++    needs to be taken into account. If we have a document with 100 lines,
++    and we can only show 20 lines in a widget, we may wish to construct a
++    scroll bar with a page step of 20, a minimum value of 0, and a maximum
++    value of 80. This would give us a scroll bar with five "pages".
++
++    \table
++    \row \o \inlineimage qscrollbar-values.png
++    \o The relationship between a document length, the range of values used
++    in a scroll bar, and the page step is simple in many common situations.
++    The scroll bar's range of values is determined by subtracting a
++    chosen page step from some value representing the length of the document.
++    In such cases, the following equation is useful:
++    \e{document length} = maximum() - minimum() + pageStep().
++    \endtable
++
++    QScrollBar64 only provides integer ranges. Note that although
++    QScrollBar64 handles very large numbers, scroll bars on current
++    screens cannot usefully represent ranges above about 100,000 pixels.
++    Beyond that, it becomes difficult for the user to control the
++    slider using either the keyboard or the mouse, and the scroll
++    arrows will have limited use.
++
++    ScrollBar inherits a comprehensive set of signals from QAbstractSlider64:
++    \list
++    \o \l{QAbstractSlider64::valueChanged()}{valueChanged()} is emitted when the
++       scroll bar's value has changed. The tracking() determines whether this
++       signal is emitted during user interaction.
++    \o \l{QAbstractSlider64::rangeChanged()}{rangeChanged()} is emitted when the
++       scroll bar's range of values has changed.
++    \o \l{QAbstractSlider64::sliderPressed()}{sliderPressed()} is emitted when
++       the user starts to drag the slider.
++    \o \l{QAbstractSlider64::sliderMoved()}{sliderMoved()} is emitted when the user
++       drags the slider.
++    \o \l{QAbstractSlider64::sliderReleased()}{sliderReleased()} is emitted when
++       the user releases the slider.
++    \o \l{QAbstractSlider64::actionTriggered()}{actionTriggered()} is emitted
++       when the scroll bar is changed by user interaction or via the
++       \l{QAbstractSlider64::triggerAction()}{triggerAction()} function.
++    \endlist
++
++    A scroll bar can be controlled by the keyboard, but it has a
++    default focusPolicy() of Qt::NoFocus. Use setFocusPolicy() to
++    enable keyboard interaction with the scroll bar:
++    \list
++         \o Left/Right move a horizontal scroll bar by one single step.
++         \o Up/Down move a vertical scroll bar by one single step.
++         \o PageUp moves up one page.
++         \o PageDown moves down one page.
++         \o Home moves to the start (mininum).
++         \o End moves to the end (maximum).
++     \endlist
++
++    The slider itself can be controlled by using the
++    \l{QAbstractSlider64::triggerAction()}{triggerAction()} function to simulate
++    user interaction with the scroll bar controls. This is useful if you have
++    many different widgets that use a common range of values.
++
++    Most GUI styles use the pageStep() value to calculate the size of the
++    slider.
++
++    \table 100%
++    \row \o \inlineimage macintosh-horizontalscrollbar.png Screenshot of a Macintosh style scroll bar
++         \o A scroll bar shown in the \l{Macintosh Style Widget Gallery}{Macintosh widget style}.
++    \row \o \inlineimage windowsxp-horizontalscrollbar.png Screenshot of a Windows XP style scroll bar
++         \o A scroll bar shown in the \l{Windows XP Style Widget Gallery}{Windows XP widget style}.
++    \row \o \inlineimage plastique-horizontalscrollbar.png Screenshot of a Plastique style scroll bar
++         \o A scroll bar shown in the \l{Plastique Style Widget Gallery}{Plastique widget style}.
++    \endtable
++
++    \sa QScrollArea, QSlider, QDial, QSpinBox, {fowler}{GUI Design Handbook: Scroll Bar}, {Sliders Example}
++*/
++
++class QScrollBar64Private : public QAbstractSlider64Private
++{
++    Q_DECLARE_PUBLIC(QScrollBar64)
++public:
++    QStyle::SubControl pressedControl;
++    bool pointerOutsidePressedControl;
++
++    qint64 clickOffset, snapBackPosition;
++
++    void activateControl(uint control, int threshold = 500);
++    void stopRepeatAction();
++    qint64 pixelPosToRangeValue(int pos) const;
++    void init();
++    bool updateHoverControl(const QPoint &pos);
++    QStyle::SubControl newHoverControl(const QPoint &pos);
++
++    QStyle::SubControl hoverControl;
++    QRect hoverRect;
++};
++
++bool QScrollBar64Private::updateHoverControl(const QPoint &pos)
++{
++    Q_Q(QScrollBar64);
++    QRect lastHoverRect = hoverRect;
++    QStyle::SubControl lastHoverControl = hoverControl;
++    bool doesHover = q->testAttribute(Qt::WA_Hover);
++    if (lastHoverControl != newHoverControl(pos) && doesHover) {
++        q->update(lastHoverRect);
++        q->update(hoverRect);
++        return true;
++    }
++    return !doesHover;
++}
++
++QStyle::SubControl QScrollBar64Private::newHoverControl(const QPoint &pos)
++{
++    Q_Q(QScrollBar64);
++    QStyleOptionSlider64 opt;
++    q->initStyleOption(&opt);
++    opt.subControls = QStyle::SC_All;
++    hoverControl = q->style()->hitTestComplexControl(QStyle::CC_ScrollBar64, &opt, pos, q);
++    if (hoverControl == QStyle::SC_None)
++        hoverRect = QRect();
++    else
++        hoverRect = q->style()->subControlRect(QStyle::CC_ScrollBar64, &opt, hoverControl, q);
++    return hoverControl;
++}
++
++void QScrollBar64Private::activateControl(uint control, int threshold)
++{
++    QAbstractSlider64::SliderAction action = QAbstractSlider64::SliderNoAction;
++    switch (control) {
++    case QStyle::SC_ScrollBarAddPage:
++        action = QAbstractSlider64::SliderPageStepAdd;
++        break;
++    case QStyle::SC_ScrollBarSubPage:
++        action = QAbstractSlider64::SliderPageStepSub;
++        break;
++    case QStyle::SC_ScrollBarAddLine:
++        action = QAbstractSlider64::SliderSingleStepAdd;
++        break;
++    case QStyle::SC_ScrollBarSubLine:
++        action = QAbstractSlider64::SliderSingleStepSub;
++        break;
++    case QStyle::SC_ScrollBarFirst:
++        action = QAbstractSlider64::SliderToMinimum;
++        break;
++    case QStyle::SC_ScrollBarLast:
++        action = QAbstractSlider64::SliderToMaximum;
++        break;
++    default:
++        break;
++    }
++
++    if (action) {
++        q_func()->setRepeatAction(action, threshold);
++        q_func()->triggerAction(action);
++    }
++}
++
++void QScrollBar64Private::stopRepeatAction()
++{
++    Q_Q(QScrollBar64);
++    QStyle::SubControl tmp = pressedControl;
++    q->setRepeatAction(QAbstractSlider64::SliderNoAction);
++    pressedControl = QStyle::SC_None;
++
++    if (tmp == QStyle::SC_ScrollBarSlider)
++        q->setSliderDown(false);
++
++    QStyleOptionSlider64 opt;
++    q->initStyleOption(&opt);
++    q->repaint(q->style()->subControlRect(QStyle::CC_ScrollBar64, &opt, tmp, q));
++}
++
++/*!
++    Initialize \a option with the values from this QScrollBar64. This method
++    is useful for subclasses when they need a QStyleOptionSlider64, but don't want
++    to fill in all the information themselves.
++
++    \sa QStyleOption::initFrom()
++*/
++void QScrollBar64::initStyleOption(QStyleOptionSlider64 *option) const
++{
++    if (!option)
++        return;
++
++    Q_D(const QScrollBar64);
++    option->initFrom(this);
++    option->subControls = QStyle::SC_None;
++    option->activeSubControls = QStyle::SC_None;
++    option->orientation = d->orientation;
++    option->minimum = d->minimum;
++    option->maximum = d->maximum;
++    option->sliderPosition = d->position;
++    option->sliderValue = d->value;
++    option->singleStep = d->singleStep;
++    option->pageStep = d->pageStep;
++    option->upsideDown = d->invertedAppearance;
++    if (d->orientation == Qt::Horizontal)
++        option->state |= QStyle::State_Horizontal;
++}
++
++
++#define HORIZONTAL (d_func()->orientation == Qt::Horizontal)
++#define VERTICAL !HORIZONTAL
++
++/*!
++    Constructs a vertical scroll bar.
++
++    The \a parent argument is sent to the QWidget constructor.
++
++    The \l {QAbstractSlider64::minimum} {minimum} defaults to 0, the
++    \l {QAbstractSlider64::maximum} {maximum} to 99, with a
++    \l {QAbstractSlider64::singleStep} {singleStep} size of 1 and a
++    \l {QAbstractSlider64::pageStep} {pageStep} size of 10, and an
++    initial \l {QAbstractSlider64::value} {value} of 0.
++*/
++QScrollBar64::QScrollBar64(QWidget *parent)
++    : QAbstractSlider64(*new QScrollBar64Private, parent)
++{
++    d_func()->orientation = Qt::Vertical;
++    d_func()->init();
++}
++
++/*!
++    Constructs a scroll bar with the given \a orientation.
++
++    The \a parent argument is passed to the QWidget constructor.
++
++    The \l {QAbstractSlider64::minimum} {minimum} defaults to 0, the
++    \l {QAbstractSlider64::maximum} {maximum} to 99, with a
++    \l {QAbstractSlider64::singleStep} {singleStep} size of 1 and a
++    \l {QAbstractSlider64::pageStep} {pageStep} size of 10, and an
++    initial \l {QAbstractSlider64::value} {value} of 0.
++*/
++QScrollBar64::QScrollBar64(Qt::Orientation orientation, QWidget *parent)
++    : QAbstractSlider64(*new QScrollBar64Private, parent)
++{
++    d_func()->orientation = orientation;
++    d_func()->init();
++}
++
++
++#ifdef QT3_SUPPORT
++/*!
++    Use one of the constructors that doesn't take the \a name
++    argument and then use setObjectName() instead.
++*/
++QScrollBar64::QScrollBar64(QWidget *parent, const char *name)
++    : QAbstractSlider64(*new QScrollBar64Private, parent)
++{
++    setObjectName(QString::fromAscii(name));
++    d_func()->orientation = Qt::Vertical;
++    d_func()->init();
++}
++
++/*!
++    Use one of the constructors that doesn't take the \a name
++    argument and then use setObjectName() instead.
++*/
++QScrollBar64::QScrollBar64(Qt::Orientation orientation, QWidget *parent, const char *name)
++    : QAbstractSlider64(*new QScrollBar64Private, parent)
++{
++    setObjectName(QString::fromAscii(name));
++    d_func()->orientation = orientation;
++    d_func()->init();
++}
++
++/*!
++    Use one of the constructors that doesn't take the \a name
++    argument and then use setObjectName() instead.
++*/
++QScrollBar64::QScrollBar64(qint64 minimum, qint64 maximum, qint64 lineStep, qint64 pageStep,
++                        qint64 value, Qt::Orientation orientation,
++                        QWidget *parent, const char *name)
++    : QAbstractSlider64(*new QScrollBar64Private, parent)
++{
++    Q_D(QScrollBar64);
++    setObjectName(QString::fromAscii(name));
++    d->minimum = minimum;
++    d->maximum = maximum;
++    d->singleStep = lineStep;
++    d->pageStep = pageStep;
++    d->value = value;
++    d->orientation = orientation;
++    d->init();
++}
++#endif // QT3_SUPPORT
++
++/*!
++    Destroys the scroll bar.
++*/
++QScrollBar64::~QScrollBar64()
++{
++}
++
++void QScrollBar64Private::init()
++{
++    Q_Q(QScrollBar64);
++    invertedControls = true;
++    pressedControl = hoverControl = QStyle::SC_None;
++    pointerOutsidePressedControl = false;
++    q->setFocusPolicy(Qt::NoFocus);
++    QSizePolicy sp(QSizePolicy::Minimum, QSizePolicy::Fixed, QSizePolicy::Slider);
++    if (orientation == Qt::Vertical)
++        sp.transpose();
++    q->setSizePolicy(sp);
++    q->setAttribute(Qt::WA_WState_OwnSizePolicy, false);
++    q->setAttribute(Qt::WA_OpaquePaintEvent);
++
++#if !defined(QT_NO_CONTEXTMENU) && defined(Q_WS_WINCE)
++    if (!q->style()->styleHint(QStyle::SH_ScrollBar_ContextMenu, 0, q)) {
++        q->setContextMenuPolicy(Qt::PreventContextMenu);
++    }
++#endif
++}
++
++#ifndef QT_NO_CONTEXTMENU
++/*! \reimp */
++void QScrollBar64::contextMenuEvent(QContextMenuEvent *event)
++{
++    if (!style()->styleHint(QStyle::SH_ScrollBar_ContextMenu, 0, this)) {
++        QAbstractSlider64::contextMenuEvent(event);
++        return ;
++    }
++
++#ifndef QT_NO_MENU
++    bool horiz = HORIZONTAL;
++    QPointer<QMenu> menu = new QMenu(this);
++    QAction *actScrollHere = menu->addAction(tr("Scroll here"));
++    menu->addSeparator();
++    QAction *actScrollTop =  menu->addAction(horiz ? tr("Left edge") : tr("Top"));
++    QAction *actScrollBottom = menu->addAction(horiz ? tr("Right edge") : tr("Bottom"));
++    menu->addSeparator();
++    QAction *actPageUp = menu->addAction(horiz ? tr("Page left") : tr("Page up"));
++    QAction *actPageDn = menu->addAction(horiz ? tr("Page right") : tr("Page down"));
++    menu->addSeparator();
++    QAction *actScrollUp = menu->addAction(horiz ? tr("Scroll left") : tr("Scroll up"));
++    QAction *actScrollDn = menu->addAction(horiz ? tr("Scroll right") : tr("Scroll down"));
++    QAction *actionSelected = menu->exec(event->globalPos());
++    delete menu;
++    if (actionSelected == 0)
++        /* do nothing */ ;
++    else if (actionSelected == actScrollHere)
++        setValue(d_func()->pixelPosToRangeValue(horiz ? event->pos().x() : event->pos().y()));
++    else if (actionSelected == actScrollTop)
++        triggerAction(QAbstractSlider64::SliderToMinimum);
++    else if (actionSelected == actScrollBottom)
++        triggerAction(QAbstractSlider64::SliderToMaximum);
++    else if (actionSelected == actPageUp)
++        triggerAction(QAbstractSlider64::SliderPageStepSub);
++    else if (actionSelected == actPageDn)
++        triggerAction(QAbstractSlider64::SliderPageStepAdd);
++    else if (actionSelected == actScrollUp)
++        triggerAction(QAbstractSlider64::SliderSingleStepSub);
++    else if (actionSelected == actScrollDn)
++        triggerAction(QAbstractSlider64::SliderSingleStepAdd);
++#endif // QT_NO_MENU
++}
++#endif // QT_NO_CONTEXTMENU
++
++
++/*! \reimp */
++QSize QScrollBar64::sizeHint() const
++{
++    ensurePolished();
++    QStyleOptionSlider64 opt;
++    initStyleOption(&opt);
++
++    int scrollBarExtent = style()->pixelMetric(QStyle::PM_ScrollBarExtent, &opt, this);
++    int scrollBarSliderMin = style()->pixelMetric(QStyle::PM_ScrollBarSliderMin, &opt, this);
++    QSize size;
++    if (opt.orientation == Qt::Horizontal)
++        size = QSize(scrollBarExtent * 2 + scrollBarSliderMin, scrollBarExtent);
++    else
++        size = QSize(scrollBarExtent, scrollBarExtent * 2 + scrollBarSliderMin);
++
++    return style()->sizeFromContents(QStyle::CT_ScrollBar, &opt, size, this)
++        .expandedTo(QApplication::globalStrut());
++ }
++
++/*!\reimp */
++void QScrollBar64::sliderChange(SliderChange change)
++{
++    QAbstractSlider64::sliderChange(change);
++}
++
++/*!
++    \reimp
++*/
++bool QScrollBar64::event(QEvent *event)
++{
++    switch(event->type()) {
++    case QEvent::HoverEnter:
++    case QEvent::HoverLeave:
++    case QEvent::HoverMove:
++    if (const QHoverEvent *he = static_cast<const QHoverEvent *>(event))
++        d_func()->updateHoverControl(he->pos());
++        break;
++#ifndef QT_NO_WHEELEVENT
++    case QEvent::Wheel: {
++        event->ignore();
++        // override wheel event without adding virtual function override
++        QWheelEvent *ev = static_cast<QWheelEvent *>(event);
++        int delta = ev->delta();
++        // scrollbar is a special case - in vertical mode it reaches minimum
++        // value in the upper position, however QSlider's minimum value is on
++        // the bottom. So we need to invert a value, but since the scrollbar is
++        // inverted by default, we need to inverse the delta value for the
++        // horizontal orientation.
++        if (ev->orientation() == Qt::Horizontal)
++            delta = -delta;
++        Q_D(QScrollBar64);
++        if (d->scrollByDelta(ev->orientation(), ev->modifiers(), delta))
++            event->accept();
++        return true;
++    }
++#endif
++    default:
++        break;
++    }
++    return QAbstractSlider64::event(event);
++}
++
++/*!
++    \reimp
++*/
++void QScrollBar64::paintEvent(QPaintEvent *)
++{
++    Q_D(QScrollBar64);
++    QPainter p(this);
++    QStyleOptionSlider64 opt;
++    initStyleOption(&opt);
++    opt.subControls = QStyle::SC_All;
++    if (d->pressedControl) {
++        opt.activeSubControls = (QStyle::SubControl)d->pressedControl;
++        if (!d->pointerOutsidePressedControl)
++            opt.state |= QStyle::State_Sunken;
++    } else {
++        opt.activeSubControls = (QStyle::SubControl)d->hoverControl;
++    }
++    style()->drawComplexControl(QStyle::CC_ScrollBar64, &opt, &p, this);
++}
++
++/*!
++    \reimp
++*/
++void QScrollBar64::mousePressEvent(QMouseEvent *e)
++{
++    Q_D(QScrollBar64);
++
++    if (d->repeatActionTimer.isActive())
++        d->stopRepeatAction();
++
++    bool midButtonAbsPos = style()->styleHint(QStyle::SH_ScrollBar_MiddleClickAbsolutePosition,
++                                             0, this);
++    QStyleOptionSlider64 opt;
++    initStyleOption(&opt);
++
++    if (d->maximum == d->minimum // no range
++        || (e->buttons() & (~e->button())) // another button was clicked before
++        || !(e->button() == Qt::LeftButton || (midButtonAbsPos && e->button() == Qt::MidButton)))
++        return;
++
++    d->pressedControl = style()->hitTestComplexControl(QStyle::CC_ScrollBar64, &opt, e->pos(), this);
++    d->pointerOutsidePressedControl = false;
++
++    QRect sr = style()->subControlRect(QStyle::CC_ScrollBar64, &opt,
++                                       QStyle::SC_ScrollBarSlider, this);
++    QPoint click = e->pos();
++    QPoint pressValue = click - sr.center() + sr.topLeft();
++    d->pressValue = d->orientation == Qt::Horizontal ? d->pixelPosToRangeValue(pressValue.x()) :
++        d->pixelPosToRangeValue(pressValue.y());
++    if (d->pressedControl == QStyle::SC_ScrollBarSlider) {
++        d->clickOffset = HORIZONTAL ? (click.x()-sr.x()) : (click.y()-sr.y());
++        d->snapBackPosition = d->position;
++    }
++
++    if ((d->pressedControl == QStyle::SC_ScrollBarAddPage
++          || d->pressedControl == QStyle::SC_ScrollBarSubPage)
++        && ((midButtonAbsPos && e->button() == Qt::MidButton)
++            || (style()->styleHint(QStyle::SH_ScrollBar_LeftClickAbsolutePosition, &opt, this)
++                && e->button() == Qt::LeftButton))) {
++        qint64 sliderLength = HORIZONTAL ? sr.width() : sr.height();
++        setSliderPosition(d->pixelPosToRangeValue((HORIZONTAL ? e->pos().x()
++                                                              : e->pos().y()) - sliderLength / 2));
++        d->pressedControl = QStyle::SC_ScrollBarSlider;
++        d->clickOffset = sliderLength / 2;
++    }
++    const int initialDelay = 500; // default threshold
++    d->activateControl(d->pressedControl, initialDelay);
++    QElapsedTimer time;
++    time.start();
++    repaint(style()->subControlRect(QStyle::CC_ScrollBar64, &opt, d->pressedControl, this));
++    if (time.elapsed() >= initialDelay && d->repeatActionTimer.isActive()) {
++        // It took more than 500ms (the initial timer delay) to process the repaint(), we
++        // therefore need to restart the timer in case we have a pending mouse release event;
++        // otherwise we'll get a timer event right before the release event,
++        // causing the repeat action to be invoked twice on a single mouse click.
++        // 50ms is the default repeat time (see activateControl/setRepeatAction).
++        d->repeatActionTimer.start(50, this);
++    }
++    if (d->pressedControl == QStyle::SC_ScrollBarSlider)
++        setSliderDown(true);
++}
++
++
++/*!
++    \reimp
++*/
++void QScrollBar64::mouseReleaseEvent(QMouseEvent *e)
++{
++    Q_D(QScrollBar64);
++    if (!d->pressedControl)
++        return;
++
++    if (e->buttons() & (~e->button())) // some other button is still pressed
++        return;
++
++    d->stopRepeatAction();
++}
++
++
++/*!
++    \reimp
++*/
++void QScrollBar64::mouseMoveEvent(QMouseEvent *e)
++{
++    Q_D(QScrollBar64);
++    if (!d->pressedControl)
++        return;
++
++    QStyleOptionSlider64 opt;
++    initStyleOption(&opt);
++    if (!(e->buttons() & Qt::LeftButton
++          ||  ((e->buttons() & Qt::MidButton)
++               && style()->styleHint(QStyle::SH_ScrollBar_MiddleClickAbsolutePosition, &opt, this))))
++        return;
++
++    if (d->pressedControl == QStyle::SC_ScrollBarSlider) {
++        QPoint click = e->pos();
++        qint64 newPosition = d->pixelPosToRangeValue((HORIZONTAL ? click.x() : click.y()) -d->clickOffset);
++        int m = style()->pixelMetric(QStyle::PM_MaximumDragDistance, &opt, this);
++        if (m >= 0) {
++            QRect r = rect();
++            r.adjust(-m, -m, m, m);
++            if (! r.contains(e->pos()))
++                newPosition = d->snapBackPosition;
++        }
++        setSliderPosition(newPosition);
++    } else if (!style()->styleHint(QStyle::SH_ScrollBar_ScrollWhenPointerLeavesControl, &opt, this)) {
++
++        if (style()->styleHint(QStyle::SH_ScrollBar_RollBetweenButtons, &opt, this)
++                && d->pressedControl & (QStyle::SC_ScrollBarAddLine | QStyle::SC_ScrollBarSubLine)) {
++            QStyle::SubControl newSc = style()->hitTestComplexControl(QStyle::CC_ScrollBar64, &opt, e->pos(), this);
++            if (newSc == d->pressedControl && !d->pointerOutsidePressedControl)
++                return; // nothing to do
++            if (newSc & (QStyle::SC_ScrollBarAddLine | QStyle::SC_ScrollBarSubLine)) {
++                d->pointerOutsidePressedControl = false;
++                QRect scRect = style()->subControlRect(QStyle::CC_ScrollBar64, &opt, newSc, this);
++                scRect |= style()->subControlRect(QStyle::CC_ScrollBar64, &opt, d->pressedControl, this);
++                d->pressedControl = newSc;
++                d->activateControl(d->pressedControl, 0);
++                update(scRect);
++                return;
++            }
++        }
++
++        // stop scrolling when the mouse pointer leaves a control
++        // similar to push buttons
++        QRect pr = style()->subControlRect(QStyle::CC_ScrollBar64, &opt, d->pressedControl, this);
++        if (pr.contains(e->pos()) == d->pointerOutsidePressedControl) {
++            if ((d->pointerOutsidePressedControl = !d->pointerOutsidePressedControl)) {
++                d->pointerOutsidePressedControl = true;
++                setRepeatAction(SliderNoAction);
++                repaint(pr);
++            } else  {
++                d->activateControl(d->pressedControl);
++            }
++        }
++    }
++}
++
++
++qint64 QScrollBar64Private::pixelPosToRangeValue(int pos) const
++{
++    Q_Q(const QScrollBar64);
++    QStyleOptionSlider64 opt;
++    q->initStyleOption(&opt);
++    QRect gr = q->style()->subControlRect(QStyle::CC_ScrollBar64, &opt,
++                                          QStyle::SC_ScrollBarGroove, q);
++    QRect sr = q->style()->subControlRect(QStyle::CC_ScrollBar64, &opt,
++                                          QStyle::SC_ScrollBarSlider, q);
++    qint64 sliderMin, sliderMax, sliderLength;
++
++    if (orientation == Qt::Horizontal) {
++        sliderLength = sr.width();
++        sliderMin = gr.x();
++        sliderMax = gr.right() - sliderLength + 1;
++        if (q->layoutDirection() == Qt::RightToLeft)
++            opt.upsideDown = !opt.upsideDown;
++    } else {
++        sliderLength = sr.height();
++        sliderMin = gr.y();
++        sliderMax = gr.bottom() - sliderLength + 1;
++    }
++
++    return  QStyle::sliderValueFromPosition(minimum, maximum, pos - sliderMin,
++                                            sliderMax - sliderMin, opt.upsideDown);
++}
++
++/*! \reimp
++*/
++void QScrollBar64::hideEvent(QHideEvent *)
++{
++    Q_D(QScrollBar64);
++    if (d->pressedControl) {
++        d->pressedControl = QStyle::SC_None;
++        setRepeatAction(SliderNoAction);
++    }
++}
++
++/*!
++    \fn bool QScrollBar64::draggingSlider()
++
++    Use isSliderDown() instead.
++*/
++
++/*! \internal
++    Returns the style option for scroll bar.
++*/
++Q_GUI_EXPORT QStyleOptionSlider64 qt_qscrollbarStyleOption(QScrollBar64 *scrollbar)
++{
++    QStyleOptionSlider64 opt;
++    scrollbar->initStyleOption(&opt);
++    return opt;
++}
++
++QT_END_NAMESPACE
++
++#endif // QT_NO_SCROLLBAR
+--- /dev/null
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/widgets/qscrollbar64.h
+@@ -0,0 +1,63 @@
++#ifndef QSCROLLBAR64_H
++#define QSCROLLBAR64_H
++
++#include <QtWidgets/qwidget.h>
++#include <QtWidgets/qabstractslider64.h>
++
++QT_BEGIN_HEADER
++
++QT_BEGIN_NAMESPACE
++
++QT_MODULE(Gui)
++
++#ifndef QT_NO_SCROLLBAR
++
++class QScrollBar64Private;
++class QStyleOptionSlider64;
++
++class Q_GUI_EXPORT QScrollBar64 : public QAbstractSlider64
++{
++    Q_OBJECT
++public:
++    explicit QScrollBar64(QWidget *parent=0);
++    explicit QScrollBar64(Qt::Orientation, QWidget *parent=0);
++    ~QScrollBar64();
++
++    QSize sizeHint() const;
++    bool event(QEvent *event);
++
++protected:
++    void paintEvent(QPaintEvent *);
++    void mousePressEvent(QMouseEvent *);
++    void mouseReleaseEvent(QMouseEvent *);
++    void mouseMoveEvent(QMouseEvent *);
++    void hideEvent(QHideEvent*);
++    void sliderChange(SliderChange change);
++#ifndef QT_NO_CONTEXTMENU
++    void contextMenuEvent(QContextMenuEvent *);
++#endif
++    void initStyleOption(QStyleOptionSlider64 *option) const;
++
++#ifdef QT3_SUPPORT
++public:
++    QT3_SUPPORT_CONSTRUCTOR QScrollBar64(QWidget *parent, const char* name);
++    QT3_SUPPORT_CONSTRUCTOR QScrollBar64(Qt::Orientation, QWidget *parent, const char* name);
++    QT3_SUPPORT_CONSTRUCTOR QScrollBar64(qint64 minValue, qint64 maxValue, qint64 lineStep, qint64 pageStep,
++                qint64 value, Qt::Orientation, QWidget *parent=0, const char* name = 0);
++    inline QT3_SUPPORT bool draggingSlider() { return isSliderDown(); }
++#endif
++
++private:
++    friend Q_GUI_EXPORT QStyleOptionSlider64 qt_qscrollbarStyleOption(QScrollBar64 *scrollBar);
++
++    Q_DISABLE_COPY(QScrollBar64)
++    Q_DECLARE_PRIVATE(QScrollBar64)
++};
++
++#endif // QT_NO_SCROLLBAR
++
++QT_END_NAMESPACE
++
++QT_END_HEADER
++
++#endif // QSCROLLBAR64_H
+--- qtbase-opensource-src-5.3.2+dfsg.orig/src/widgets/widgets/widgets.pri
++++ qtbase-opensource-src-5.3.2+dfsg/src/widgets/widgets/widgets.pri
+@@ -6,6 +6,8 @@ HEADERS += \
+         widgets/qabstractbutton_p.h \
+         widgets/qabstractslider.h \
+         widgets/qabstractslider_p.h \
++        widgets/qabstractslider64.h \
++        widgets/qabstractslider64_p.h \
+         widgets/qabstractspinbox.h \
+         widgets/qabstractspinbox_p.h \
+         widgets/qcalendartextnavigator_p.h \
+@@ -48,6 +50,7 @@ HEADERS += \
+         widgets/qradiobutton.h \
+         widgets/qrubberband.h \
+         widgets/qscrollbar.h \
++        widgets/qscrollbar64.h \
+         widgets/qscrollbar_p.h \
+         widgets/qscrollarea_p.h \
+         widgets/qsizegrip.h \
+@@ -87,6 +90,7 @@ HEADERS += \
+ SOURCES += \
+         widgets/qabstractbutton.cpp \
+         widgets/qabstractslider.cpp \
++        widgets/qabstractslider64.cpp \
+         widgets/qabstractspinbox.cpp \
+         widgets/qcalendarwidget.cpp \
+         widgets/qcheckbox.cpp \
+@@ -117,6 +121,7 @@ SOURCES += \
+         widgets/qradiobutton.cpp \
+         widgets/qrubberband.cpp \
+         widgets/qscrollbar.cpp \
++        widgets/qscrollbar64.cpp \
+         widgets/qsizegrip.cpp \
+         widgets/qslider.cpp \
+         widgets/qspinbox.cpp \
diff --git a/debian/patches/series b/debian/patches/series
index a628eef..32763bb 100644
--- a/debian/patches/series
+++ b/debian/patches/series
@@ -11,3 +11,4 @@ fix_sparc_atomics.patch
 # Debian specific.
 remove_google_adsense.patch
 revert_upstream_bsymbolic_change.patch
+inendi.patch
-- 
2.5.1

