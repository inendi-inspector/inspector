#
# @file
#
# @copyright (C) Picviz Labs 2010-March 2015
# @copyright (C) ESI Group INENDI April 2015-2015

###############################################################################
# Define the Qt Core package
###############################################################################
ADD_DEFINITIONS(-DQT_SHARED)
FIND_PACKAGE(Qt5Core REQUIRED)
message(STATUS "QtCore include dirs: " ${Qt5Core_INCLUDE_DIR})
include_directories(${Qt5Core_INCLUDE_DIRS})

###############################################################################
# Define the Intel TBB Library
###############################################################################

set(TBB_ROOT_DIR /opt/tbb-latest)
find_package(TBB 4.4 REQUIRED)

message(STATUS "TBB include dirs: " ${TBB_INCLUDE_DIRS})
include_directories(AFTER ${TBB_INCLUDE_DIRS})

if(CMAKE_BUILD_TYPE_LOWER MATCHES "debug")
	set(TBB_USE_DEBUG "1")
endif()

###############################################################################
# Define the Cuda runtime
###############################################################################
if (${CMAKE_VERSION} STRLESS 2.8.12.1)
	# cmake support CUDA 5.5 since 2.8.12.1 because this CUDA version
	# splitted libnpp.so into 3 sub-librairies
	find_package(CUDA 5.0 EXACT)
else()
	find_package(CUDA 5.0)
endif()

message(STATUS "CUDA found: " ${CUDA_FOUND})
if(CUDA_FOUND)
	message(STATUS "CUDA version: " ${CUDA_VERSION_STRING})
  	message(STATUS "CUDA toolkit root dir: " ${CUDA_TOOLKIT_ROOT_DIR})
  	message(STATUS "CUDA 64bit device: " ${CUDA_64_BIT_DEVICE_CODE})
  	message(STATUS "CUDA runtime libraries: " ${CUDA_LIBRARIES})
  	message(STATUS "CUDA npp libraries: " ${CUDA_npp_LIBRARY})
	add_definitions(-DCUDA)

	# As NVCC can generate fat object files which support more than one
	# GPU at a time, we will ask him to support the largest number of
	# GPU it can.
	#
	# As there is no way to detect at CMake time the supported set of
	# arch/code for a given CUDA toolkit version, we have to write it by
	# hand. The information come from each version of the document named
	# "CUDA Compiler Driver NVCC".
	#
	# For supported GPUs, we generate an optimized kernel and for not
	# yet supported GPUs because our CUDA toolkit version does not, we
	# use CUDA JIT functionality.
	#
	# For 'arch' parameter, compute_XY means the GPU architecture to
	# consider at intermediate representation generation stage. X stands
	# for a GPU family (like Fermi of Kepler) and Y stands for a GPU
	# revision family (like GK100? or GK110/GK208) which extend an
	# architecture with new functionalities.
	#
	# For 'code' parameter, 2 forms are supported:
	# - sm_XY means the instruction set to use to generate the shader
	#   binary. X and Y have the same meaning than for 'arch'.
	# - compute_XY means that the final fat binary file will embbed the
	#   shader under an intermediate representation and that the Nvidia
	#   driver will do JIT.

	# As Inspector starts with compute capability 2.0, we use it as
	# lowest supported major version
	set(CUDA_COMP_CAP_MIN_VERSION 2)

        # making sure it is not defined
	unset(NVCC_GENCODE_FLAGS)

	if (CUDA_VERSION_MAJOR EQUAL 5)
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_20,code=sm_20")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_20,code=sm_21")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_30,code=sm_30")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_32,code=sm_32")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_35,code=sm_35")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_35,code=compute_35")
	elseif (CUDA_VERSION_MAJOR EQUAL 6)
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_20,code=sm_20")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_20,code=sm_21")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_30,code=sm_30")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_32,code=sm_32")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_35,code=sm_35")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_50,code=sm_50")
		if (CUDA_VERSION_MINOR EQUAL 0)
			list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_50,code=compute_50")
		else()
			# version 6.5
			list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_52,code=sm_52")
			list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_52,code=compute_52")
		endif()
	elseif(CUDA_VERSION_MAJOR EQUAL 7)
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_20,code=sm_20")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_20,code=sm_21")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_30,code=sm_30")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_32,code=sm_32")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_35,code=sm_35")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_50,code=sm_50")
		list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_52,code=sm_52")
		if (CUDA_VERSION_MINOR EQUAL 0)
			list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_52,code=compute_52")
		else()
			# version 7.5
			list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_53,code=sm_53")
			list(APPEND NVCC_GENCODE_FLAGS "-gencode arch=compute_53,code=compute_53")
		endif()
	else()
		message(FATAL_ERROR "unsupported CUDA version: ${CUDA_VERSION_STRING}")
	endif()

	add_definitions(-DCUDA_COMP_CAP_MIN_VERSION=${CUDA_COMP_CAP_MIN_VERSION})

	message(STATUS "CUDA nvcc gencode options: ${NVCC_GENCODE_FLAGS}")
else()
	message(FATAL_ERROR "CUDA not found")
endif(CUDA_FOUND)


###############################################################################
# Define variables for Boost library
###############################################################################

#set(Boost_DEBUG TRUE)
set(Boost_USE_STATIC_LIBS       OFF)
set(Boost_USE_MULTITHREADED      ON)
set(Boost_USE_STATIC_RUNTIME    OFF)
add_definitions(-DBOOST_PROGRAM_OPTIONS_DYN_LINK)

# as we want to separate Boost's Python library path to others Boost libraries,
# we do the detection in 2 steps : one for all needed modules except python, one other for python
find_package(Boost 1.49 COMPONENTS date_time system thread program_options)
# a little backup of $Boost_LIBRARIES because the second detection will overwrite it
set(Boost_LIBRARIES_SAVE ${Boost_LIBRARIES})

find_package(Boost 1.49 COMPONENTS python-py27)
set(Boost_LIBRARIES_PYTHON ${Boost_LIBRARIES})

# and a little restoration
set(Boost_LIBRARIES ${Boost_LIBRARIES_SAVE})

message(STATUS "Boost include dirs: " ${BOOST_INCLUDEDIR})
include_directories(AFTER ${BOOST_INCLUDEDIR})

###############################################################################
# Check for OpenMP
###############################################################################
find_package(OpenMP REQUIRED)
# This package does not declare the library used by GCC
set(OpenMP_LIBRARIES ${OpenMP_CXX_FLAGS})
add_definitions(${OpenMP_CXX_FLAGS})

message(STATUS "OpenMP Libraries: ${OpenMP_LIBRARIES}")
message(STATUS "OpenMP C FLAGS: ${OpenMP_C_FLAGS}")
message(STATUS "OpenMP CXX FLAGS: ${OpenMP_CXX_FLAGS}")

###############################################################################
# Check for libnuma
###############################################################################
find_package(LibNUMA REQUIRED)
if (LIBNUMA_FOUND)
  set(LibNUMA_LIBRARIES "-lnuma")
  message(STATUS "NUMA Libraries: ${LibNUMA_LIBRARIES}")
else()
  message(ERROR "libNUMA not found!")
endif()

###############################################################################
# Check for rapidjson
###############################################################################
find_package(rapidjson REQUIRED)
if (RAPIDJSON_FOUND)
  message(STATUS " rapidjson include directory: ${RAPIDJSON_INCLUDE_DIRS}")
else()
  message(ERROR " rapidjson not found!")
endif()

########################
# Needed for libpvrush #
########################

###############################################################################
# Check for PCAP library
###############################################################################
find_package(PCAP REQUIRED)

###############################################################################
# Check for Archive library
###############################################################################
pkg_check_modules(ARCHIVE REQUIRED libarchive)

###############################################################################
# Google Breakpad
###############################################################################
pkg_check_modules(BREAKPAD REQUIRED breakpad-client)

message(STATUS "Google Breakpad libraries: ${BREAKPAD_LIBRARIES}")
message(STATUS "Google Breakpad include: ${BREAKPAD_INCLUDE_DIRS}")

###############################################################################
# Check for libpcre++
# This is a library to handle perl regex
###############################################################################
find_package(PCRE REQUIRED)

###############################################################################
# OpenGL
# TODO : Check result and deduce OpenGL Support in Qt?
###############################################################################
find_package(OpenGL REQUIRED)

###############################################################################
# IBM ICU
###############################################################################
find_package(ICU REQUIRED) 

message(STATUS "ICU found: " ${ICU_FOUND})
if(ICU_FOUND)
	message(STATUS "ICU include: ${ICU_INCLUDE}")
  	message(STATUS "ICU libraries: ${ICU_LIBRARY}")
endif(ICU_FOUND)

###############################################################################
# Check for CURL
###############################################################################
find_package(CURL "7.38.0" REQUIRED)

###############################################################################
# Check for Perl support
###############################################################################
find_package(PerlLibs REQUIRED)

###############################################################################
# Check for Python support
# TODO : Check if it is found?
###############################################################################
# TODO: check that the good python version is found (the 3.2)
# We also need to check that these packages are installed:
#  * python3.2-dev
#  * libpython3.2
set(Python_ADDITIONAL_VERSIONS 2.7)
find_package(PythonLibs)
if(PYTHONLIBS_FOUND)
	add_definitions(-DENABLE_PYTHON_SUPPORT)
endif(PYTHONLIBS_FOUND)

################################################################################
## Check for Hwloc installation
################################################################################
# TODO : Should be replace by PVHwloc
pkg_check_modules(HWLOC REQUIRED hwloc)

###############################################################################
# Check for Furl installation
###############################################################################

set(FURL_STATIC_LIB /usr/local/lib/libfurll.a)
if(EXISTS ${FURL_STATIC_LIB})
  add_definitions(-DFURL_UTF16_CHAR)
else()
  message( FATAL_ERROR "FURL Can't be found" )
endif ()

###############################################################################
# Check for Arcsight installation
###############################################################################

pkg_check_modules(GSOAPPP REQUIRED gsoap++)
set(ARCSIGHT_STATIC_LIB /usr/local/lib/libarcsight.a)
if(NOT EXISTS ${ARCSIGHT_STATIC_LIB})
  message( FATAL_ERROR "Arcsight Can't be found" )
endif ()

set(ARCSIGHT_LIBRARIES ${ARCSIGHT_STATIC_LIB} ${GSOAPPP_LIBRARIES})

###############################################################################
# Check for PVCOP installation
###############################################################################      

find_package(PVCOP REQUIRED)

###############################################################################
# Check for License installation
###############################################################################      

find_package(PVLicense REQUIRED)
